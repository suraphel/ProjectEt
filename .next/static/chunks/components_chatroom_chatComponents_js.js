(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_chatroom_chatComponents_js"],{

/***/ "./components/chatroom/AblyReactEffect.js":
/*!************************************************!*\
  !*** ./components/chatroom/AblyReactEffect.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useChannel": function() { return /* binding */ useChannel; }
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();

//offer company name and logo
// textarea for his offer
// hidden and appear
// states for rendering the page
//WebSocket connections
//Ably
//add and Id
//add message storage and retrival
//


var ably = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime.Promise)({
  authUrl: "/api/createTokenRequest"
}); // console.log(ably);

function useChannel(channelName, callbackOnMessage) {
  _s();

  var channel = ably.channels.get(channelName);

  var onMount = function onMount() {
    channel.subscribe(function (msg) {
      callbackOnMessage(msg);
    });
  };

  var onUnMount = function onUnMount() {
    channel.unsubscribe();
  };

  var useEffectHook = function useEffectHook() {
    onMount();
    return function () {
      onUnMount();
    };
  };

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(useEffectHook);
  return [channel, ably];
}

_s(useChannel, "OD7bBpZva5O2jO+Puf00hKivP7c=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./components/chatroom/chatComponents.js":
/*!***********************************************!*\
  !*** ./components/chatroom/chatComponents.js ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AblyReactEffect */ "./components/chatroom/AblyReactEffect.js");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chatroom/chatComponents.module.css */ "./components/chatroom/chatComponents.module.css");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__);
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "A:\\Projects\\NextJs\\Balemoja_Next\\Balemoja\\components\\chatroom\\chatComponents.js",
    _this = undefined,
    _s = $RefreshSig$();






var ChatComponent = function ChatComponent() {
  _s();

  var inputBox = null;
  var messageEnd = null;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(""),
      messageText = _useState[0],
      setMessageText = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]),
      receivedMessages = _useState2[0],
      setMessages = _useState2[1];

  var messageTextIsEmpty = messageText.trim().length === 0;

  var _useChannel = (0,_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel)("chat-demo", function (message) {
    var history = receivedMessages.slice(-199);
    setMessages([].concat((0,A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(history), [message]));
  }),
      _useChannel2 = (0,A_Projects_NextJs_Balemoja_Next_Balemoja_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(_useChannel, 2),
      channel = _useChannel2[0],
      ably = _useChannel2[1];

  var sendChatMessage = function sendChatMessage(messageText) {
    channel.publish({
      name: "chat-message",
      data: messageText
    });
    setMessageText("");
    inputBox.focus();
  };

  var handleFormSubmission = function handleFormSubmission(event) {
    event.preventDefault();
    sendChatMessage(messageText);
  };

  var handleKeyPress = function handleKeyPress(event) {
    if (event.charCode !== 13 || messageTextIsEmpty) {
      return;
    }

    sendChatMessage(messageText);
    event.preventDefault();
  };

  var messages = receivedMessages.map(function (message, index) {
    var author = message.connectionId === ably.connection.id ? "me" : "other";
    var milliseconds = new Date();
    var timeStamp = milliseconds.toDateString(); // function parseMillisecondsIntoReadableTime(milliseconds) {
    //   //Get hours from milliseconds
    //   var hours = milliseconds / (1000 * 60 * 60);
    //   var absoluteHours = Math.floor(hours);
    //   var h = absoluteHours > 9 ? absoluteHours : "0" + absoluteHours;
    //   //Get remainder from hours and convert to minutes
    //   var minutes = (hours - absoluteHours) * 60;
    //   var absoluteMinutes = Math.floor(minutes);
    //   var m = absoluteMinutes > 9 ? absoluteMinutes : "0" + absoluteMinutes;
    //   //Get remainder from minutes and convert to seconds
    //   var seconds = (minutes - absoluteMinutes) * 60;
    //   var absoluteSeconds = Math.floor(seconds);
    //   var s = absoluteSeconds > 9 ? absoluteSeconds : "0" + absoluteSeconds;
    //   return h + ":" + m + ":" + s;
    // }
    // var time = parseMillisecondsIntoReadableTime(milliseconds);
    // alert(time);
    // console.log(time);

    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().message) // time={new Date().toString()}
      ,
      "data-author": author,
      children: message.data
    }, index, false, {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 7
    }, _this);
  });
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {
    messageEnd.scrollIntoView({
      behaviour: "smooth"
    });
  });
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
    className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatHolder),
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatText),
      children: [messages, new Date().toDateString(), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        ref: function ref(element) {
          messageEnd = element;
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 88,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 7
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("form", {
      onSubmit: handleFormSubmission,
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().form),
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("textarea", {
        ref: function ref(element) {
          inputBox = element;
        },
        value: messageText,
        placeholder: "Type a message..." // time={new Date().toString()}
        ,
        onChange: function onChange(e) {
          return setMessageText(e.target.value);
        },
        onKeyPress: handleKeyPress,
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().textarea)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 95,
        columnNumber: 9
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
        type: "submit",
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().button),
        disabled: messageTextIsEmpty,
        children: "Send"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 106,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 84,
    columnNumber: 5
  }, _this);
};

_s(ChatComponent, "UHCFF9ns1jrEPUyCddaISRIBzu0=", false, function () {
  return [_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel];
});

_c = ChatComponent;
/* harmony default export */ __webpack_exports__["default"] = (ChatComponent);

var _c;

$RefreshReg$(_c, "ChatComponent");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/ably/browser/static/ably-commonjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/ably/browser/static/ably-commonjs.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*!
 * @license Copyright 2021, Ably
 * 
 * Ably JavaScript Library v1.2.13
 * https://github.com/ably/ably-js
 * 
 * Ably Realtime Messaging
 * https://www.ably.com
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_749__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_749__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_749__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_749__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_749__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_749__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_749__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_749__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_749__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_749__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_749__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_749__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_749__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_749__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_749__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_749__(__nested_webpack_require_749__.s = 50);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_4226__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4226__(3);


var Logger = (function() {
	var consoleLogger, errorLogger;

	/* Can't just check for console && console.log; fails in IE <=9 */
	if((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
		 (global.console && global.console.log && (typeof global.console.log.apply === 'function')) /* sensible browsers */) {
		consoleLogger = function() { console.log.apply(console, arguments); };
		errorLogger = console.warn ? function() { console.warn.apply(console, arguments); } : consoleLogger;
	} else if(global.console && global.console.log) {
		/* IE <= 9 with the console open -- console.log does not
		 * inherit from Function, so has no apply method */
		consoleLogger = errorLogger = function() { Function.prototype.apply.call(console.log, console, arguments); };
	} else {
		/* IE <= 9 when dev tools are closed - window.console not even defined */
		consoleLogger = errorLogger = function() {};
	}

	function pad(str, three) {
		return ('000' + str).slice(-2-(three || 0));
	}

	var LOG_NONE  = 0,
	LOG_ERROR = 1,
	LOG_MAJOR = 2,
	LOG_MINOR = 3,
	LOG_MICRO = 4;

	var LOG_DEFAULT = LOG_ERROR,
	LOG_DEBUG   = LOG_MICRO;

	var logLevel = LOG_DEFAULT;

	function getHandler(logger) {
		return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logTimestamps ?
			function(msg) {
				var time = new Date();
				logger(pad(time.getHours()) + ':' + pad(time.getMinutes()) + ':' + pad(time.getSeconds()) + '.' + pad(time.getMilliseconds(), true) + ' ' + msg);
			} : logger;
	}

	var logHandler = getHandler(consoleLogger),
		logErrorHandler = getHandler(errorLogger);

	/* public constructor */
	function Logger(args) {}

	/* public constants */
	Logger.LOG_NONE    = LOG_NONE,
	Logger.LOG_ERROR   = LOG_ERROR,
	Logger.LOG_MAJOR   = LOG_MAJOR,
	Logger.LOG_MINOR   = LOG_MINOR,
	Logger.LOG_MICRO   = LOG_MICRO;

	Logger.LOG_DEFAULT = LOG_DEFAULT,
	Logger.LOG_DEBUG   = LOG_DEBUG;

	/* public static functions */
	Logger.logAction = function(level, action, message) {
		if (Logger.shouldLog(level)) {
			(level === LOG_ERROR ? logErrorHandler : logHandler)('Ably: ' + action + ': ' + message);
		}
	};

	Logger.deprecated = function(original, replacement) {
		Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
	}

	Logger.deprecatedWithMsg = function(funcName, msg) {
		if (Logger.shouldLog(LOG_ERROR)) {
			logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
		}
	}

	/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
	   the object being serialised if the log level will not output the message */
	Logger.shouldLog = function(level) {
		return level <= logLevel;
	};

	Logger.setLog = function(level, handler) {
		if(level !== undefined) logLevel = level;
		if(handler !== undefined) logHandler = logErrorHandler = handler;
	};

	return Logger;
})();

/* harmony default export */ __webpack_exports__["a"] = (Logger);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_4226__(17)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_7545__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_7545__(3);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_7545__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_7545__(5);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var Utils = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function Utils() {}

	function randomPosn(arrOrStr) {
		return Math.floor(Math.random() * arrOrStr.length);
	}

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.mixin = function(target) {
		for(var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			if(!source) { break; }
			for(var key in source) {
				if(hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}
		return target;
	};

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.copy = function(src) {
		return Utils.mixin({}, src);
	};

	/*
	 * Determine whether or not a given object is
	 * an array.
	 */
	Utils.isArray = Array.isArray || function(ob) {
		return Object.prototype.toString.call(ob) == '[object Array]';
	};

	/*
	 * Ensures that an Array object is always returned
	 * returning the original Array of obj is an Array
	 * else wrapping the obj in a single element Array
	 */
	Utils.ensureArray = function(obj) {
		if(Utils.isEmptyArg(obj)) {
			return [];
		}
		if(Utils.isArray(obj)) {
			return obj;
		}
		return [obj];
	}

	/* ...Or an Object (in the narrow sense) */
	Utils.isObject = function(ob) {
		return Object.prototype.toString.call(ob) == '[object Object]';
	};

	/*
	 * Determine whether or not an object contains
	 * any enumerable properties.
	 * ob: the object
	 */
	Utils.isEmpty = function(ob) {
		for(var prop in ob)
			return false;
		return true;
	};

	Utils.isOnlyPropIn = function(ob, property) {
		for(var prop in ob) {
			if(prop !== property) {
				return false;
			}
		}
		return true;
	};

	/*
	 * Determine whether or not an argument to an overloaded function is
	 * undefined (missing) or null.
	 * This method is useful when constructing functions such as (WebIDL terminology):
	 *   off([TreatUndefinedAs=Null] DOMString? event)
	 * as you can then confirm the argument using:
	 *   Utils.isEmptyArg(event)
	 */

	Utils.isEmptyArg = function(arg) {
		return arg === null || arg === undefined;
	}

	/*
	 * Perform a simple shallow clone of an object.
	 * Result is an object irrespective of whether
	 * the input is an object or array. All
	 * enumerable properties are copied.
	 * ob: the object
	 */
	Utils.shallowClone = function(ob) {
		var result = new Object();
		for(var prop in ob)
			result[prop] = ob[prop];
		return result;
	};

	/*
	 * Clone an object by creating a new object with the
	 * given object as its prototype. Optionally
	 * a set of additional own properties can be
	 * supplied to be added to the newly created clone.
	 * ob:            the object to be cloned
	 * ownProperties: optional object with additional
	 *                properties to add
	 */
	Utils.prototypicalClone = function(ob, ownProperties) {
		function F() {}
		F.prototype = ob;
		var result = new F();
		if(ownProperties)
			Utils.mixin(result, ownProperties);
		return result;
	};

	/*
	 * Declare a constructor to represent a subclass
	 * of another constructor
	 * If platform has a built-in version we use that from Platform, else we
	 * define here (so can make use of other Utils fns)
	 * See node.js util.inherits
	 */
	Utils.inherits = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits || function(ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
	};

	/*
	 * Determine whether or not an object has an enumerable
	 * property whose value equals a given value.
	 * ob:  the object
	 * val: the value to find
	 */
	Utils.containsValue = function(ob, val) {
		for(var i in ob) {
			if(ob[i] == val)
				return true;
		}
		return false;
	};

	Utils.intersect = function(arr, ob) { return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob); };

	Utils.arrIntersect = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var member = arr1[i];
			if(Utils.arrIndexOf(arr2, member) != -1)
				result.push(member);
		}
		return result;
	};

	Utils.arrIntersectOb = function(arr, ob) {
		var result = [];
		for(var i = 0; i < arr.length; i++) {
			var member = arr[i];
			if(member in ob)
				result.push(member);
		}
		return result;
	};

	Utils.arrSubtract = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var element = arr1[i];
			if(Utils.arrIndexOf(arr2, element) == -1)
				result.push(element);
		}
		return result;
	};

	Utils.arrIndexOf = Array.prototype.indexOf
		? function(arr, elem, fromIndex) {
			return arr.indexOf(elem,  fromIndex);
		}
		: function(arr, elem, fromIndex) {
			fromIndex = fromIndex || 0;
			var len = arr.length;
			for(;fromIndex < len; fromIndex++) {
				if(arr[fromIndex] === elem) {
					return fromIndex;
				}
			}
			return -1;
		};

	Utils.arrIn = function(arr, val) {
		return Utils.arrIndexOf(arr, val) !== -1;
	};

	Utils.arrDeleteValue = function(arr, val) {
		var idx = Utils.arrIndexOf(arr, val);
		var res = (idx != -1);
		if(res)
			arr.splice(idx, 1);
		return res;
	};

	Utils.arrWithoutValue = function(arr, val) {
		var newArr = arr.slice();
		Utils.arrDeleteValue(newArr, val);
		return newArr;
	};

	/*
	 * Construct an array of the keys of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.keysArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(prop);
		}
		return result;
	};

	/*
	 * Construct an array of the values of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(ob[prop]);
		}
		return result;
	};

	Utils.forInOwnNonNullProps = function(ob, fn) {
		for (var prop in ob) {
			if (hasOwnProperty.call(ob, prop) && ob[prop]) {
				fn(prop);
			}
		}
	};

	Utils.arrForEach = Array.prototype.forEach ?
		function(arr, fn) {
			arr.forEach(fn);
		} :
		function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				fn(arr[i], i, arr);
			}
		};

	/* Useful when the function may mutate the array */
	Utils.safeArrForEach = function(arr, fn) {
		return Utils.arrForEach(arr.slice(), fn);
	};

	Utils.arrMap = Array.prototype.map ?
		function(arr, fn) {
			return arr.map(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				result.push(fn(arr[i], i, arr));
			}
			return result;
		};

	Utils.arrFilter = Array.prototype.filter ?
		function(arr, fn) {
			return arr.filter(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				if(fn(arr[i])) {
					result.push(arr[i]);
				}
			}
			return result;
		};

	Utils.arrEvery = Array.prototype.every ?
		function(arr, fn) {
			return arr.every(fn);
		} : function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				if(!fn(arr[i], i, arr)) {
					return false;
				};
			}
			return true;
		};

	Utils.allSame = function(arr, prop) {
		if(arr.length === 0) {
			return true;
		}
		var first = arr[0][prop];
		return Utils.arrEvery(arr, function(item) {
			return item[prop] === first;
		});
	};

	Utils.nextTick = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick;

	var contentTypes = {
		json:   'application/json',
		jsonp:  'application/javascript',
		xml:    'application/xml',
		html:   'text/html',
		msgpack: 'application/x-msgpack'
	};

	Utils.defaultGetHeaders = function(format) {
		var accept = contentTypes[format || 'json'];
		return {
			accept: accept,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.defaultPostHeaders = function(format) {
		var accept, contentType;
		accept = contentType = contentTypes[format || 'json'];

		return {
			accept: accept,
			'content-type': contentType,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.arrPopRandomElement = function(arr) {
		return arr.splice(randomPosn(arr), 1)[0];
	};

	Utils.toQueryString = function(params) {
		var parts = [];
		if(params) {
			for(var key in params)
				parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
		}
		return parts.length ? '?' + parts.join('&') : '';
	};

	Utils.parseQueryString = function(query) {
		var match,
			search = /([^?&=]+)=?([^&]*)/g,
			result = {};

		while (match = search.exec(query))
			result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);

 		return result;
	};

	Utils.now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	Utils.inspect = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect;

	Utils.isErrorInfo = function(err) {
		return err.constructor.name == 'ErrorInfo'
	};

	Utils.inspectError = function(x) {
		/* redundant, but node vmcontext issue makes instanceof unreliable, and
		 * can't use just constructor test as could be a TypeError constructor etc. */
		return (x && (Utils.isErrorInfo(x) ||
			x.constructor.name == 'Error' ||
			x instanceof Error)) ?
			x.toString() :
			Utils.inspect(x);
	};

	Utils.inspectBody = function(body) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(body)) {
			return body.toString();
		} else if(typeof body === 'string') {
			return body;
		} else {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(body);
		}
	};

	/* Data is assumed to be either a string or a buffer. */
	Utils.dataSizeBytes = function(data) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].byteLength(data);
		}
		if(typeof data === 'string') {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringByteSize(data);
		}
		throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + (typeof data));
	};

	Utils.cheapRandStr = function() {
		return String(Math.random()).substr(2);
	};

	/* Takes param the minimum number of bytes of entropy the string must
	 * include, not the length of the string. String length produced is not
	 * guaranteed. */
	Utils.randomString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(uIntArr);
		} : function(numBytes) {
			/* Old browser; fall back to Math.random. Could just use a
			 * CryptoJS version of the above, but want this to still work in nocrypto
			 * versions of the library */
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64CharSet;
			/* base64 has 33% overhead; round length up */
			var length = Math.round(numBytes * 4/3);
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	Utils.randomHexString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexEncode(uIntArr);
		} : function(numBytes) {
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexCharSet;
			var length = numBytes * 2;
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	/* Pick n elements at random without replacement from an array */
	Utils.arrChooseN = function(arr, n) {
		var numItems = Math.min(n, arr.length),
			mutableArr = arr.slice(),
			result = [];
		for(var i = 0; i < numItems; i++) {
			result.push(Utils.arrPopRandomElement(mutableArr));
		}
		return result;
	};

	Utils.trim = String.prototype.trim ? function(str) {
		return str.trim();
	} : function(str) {
		return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};

	Utils.promisify = function(ob, fnName, args) {
		return new Promise(function(resolve, reject) {
			ob[fnName].apply(ob, Array.prototype.slice.call(args).concat(function(err, res) {
				err ? reject(err) : resolve(res);
			}));
		});
	};

	Utils.decodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(String(body));
	};

	Utils.encodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.encode(body, true) : JSON.stringify(body);
	};

	Utils.allToLowerCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toLowerCase();
		});
	};

	Utils.allToUpperCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toUpperCase();
		});
	};

	return Utils;
})();

/* harmony default export */ __webpack_exports__["a"] = (Utils);


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_21941__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_21941__(1);


var ErrorInfo = (function() {

	function ErrorInfo(message, code, statusCode, cause) {
		this.message = message;
		this.code = code;
		this.statusCode = statusCode;
		this.cause = cause;
		this.href = undefined;
	}

	ErrorInfo.prototype.toString = function() {
		var result = '[' + this.constructor.name;
		if(this.message) result += ': ' + this.message;
		if(this.statusCode) result += '; statusCode=' + this.statusCode;
		if(this.code) result += '; code=' + this.code;
		if(this.cause) result += '; cause=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(this.cause);
		if(this.href && !(this.message && this.message.indexOf('help.ably.io') > -1)) result += '; see ' + this.href + ' ';
		result += ']';
		return result;
	};

	ErrorInfo.fromValues = function(values) {
		var result = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ErrorInfo(), values);
		if (values instanceof Error) {
			/* Error.message is not enumerable, so mixin loses the message */
			result.message = values.message;
		}
		if(result.code && !result.href) {
			result.href = 'https://help.ably.io/error/' + result.code;
		}
		return result;
	};

	return ErrorInfo;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorInfo);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_23403__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/* harmony import */ var _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_23403__(24);


if(typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
	console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}

function allowComet() {
	/* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
	 * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
	 * So if websockets are supported, then just forget about comet transports and use that */
	var loc = global.location;
	return (!global.WebSocket || !loc || !loc.origin || loc.origin.indexOf("http") > -1);
}

var userAgent = global.navigator && global.navigator.userAgent.toString();
var currentUrl = global.location && global.location.href;

var Platform = {
        agent: 'browser',
	logTimestamps: true,
	userAgent: userAgent,
	currentUrl: currentUrl,
	noUpgrade: userAgent && userAgent.match(/MSIE\s8\.0/),
	binaryType: 'arraybuffer',
	WebSocket: global.WebSocket || global.MozWebSocket,
	xhrSupported: global.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
	jsonpSupported: typeof(document) !== 'undefined',
	allowComet: allowComet(),
	streamingSupported: true,
	useProtocolHeartbeats: true,
	createHmac: null,
	msgpack: _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
	supportsBinary: !!global.TextDecoder,
	preferBinary: false,
	ArrayBuffer: global.ArrayBuffer,
	atob: global.atob,
	nextTick: typeof setImmediate !== 'undefined' ? global.setImmediate.bind(global) : function(f) { setTimeout(f, 0); },
	addEventListener: global.addEventListener,
	inspect: JSON.stringify,
	stringByteSize: function(str) {
		/* str.length will be an underestimate for non-ascii strings. But if we're
		 * in a browser too old to support TextDecoder, not much we can do. Better
		 * to underestimate, so if we do go over-size, the server will reject the
		 * message */
		return global.TextDecoder &&
			(new global.TextEncoder().encode(str)).length ||
			str.length;
	},
	TextEncoder: global.TextEncoder,
	TextDecoder: global.TextDecoder,
	Promise: global.Promise,
	getRandomValues: (function(crypto) {
		if (crypto === undefined) {
			return undefined;
		}
		return function(arr, callback) {
			crypto.getRandomValues(arr);
			if(callback) {
				callback(null);
			}
		};
	})(global.crypto || global.msCrypto) // mscrypto for IE11
};

/* harmony default export */ __webpack_exports__["a"] = (Platform);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_23403__(17), __nested_webpack_require_23403__(42).setImmediate))

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_26250__) {

"use strict";

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_26250__(3);

// CONCATENATED MODULE: ./browser/lib/util/defaults.js


var Defaults = {
	internetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
	jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
	/* Order matters here: the base transport is the leftmost one in the
	 * intersection of baseTransportOrder and the transports clientOption that's
	 * supported.  This is not quite the same as the preference order -- e.g.
	 * xhr_polling is preferred to jsonp, but for browsers that support it we want
	 * the base transport to be xhr_polling, not jsonp */
	defaultTransports: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	baseTransportOrder: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	transportPreferenceOrder: ['jsonp', 'xhr_polling', 'xhr_streaming', 'web_socket'],
	upgradeTransports: ['xhr_streaming', 'web_socket']
};

/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
* while it can do streaming, the low max http-connections-per-host limit means
* that the polling transport is crippled during the upgrade process. So just
* leave it at the base transport */
if(platform_browser["a" /* default */].noUpgrade) {
	Defaults.upgradeTransports = [];
}

/* harmony default export */ var defaults = (Defaults);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_26250__(1);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_26250__(5);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_26250__(0);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_26250__(2);

// CONCATENATED MODULE: ./common/lib/util/defaults.js







defaults.ENVIRONMENT              = '';
defaults.REST_HOST                = 'rest.ably.io';
defaults.REALTIME_HOST            = 'realtime.ably.io';
defaults.FALLBACK_HOSTS           = ['A.ably-realtime.com', 'B.ably-realtime.com', 'C.ably-realtime.com', 'D.ably-realtime.com', 'E.ably-realtime.com'];
defaults.PORT                     = 80;
defaults.TLS_PORT                 = 443;
defaults.TIMEOUTS = {
	/* Documented as options params: */
	disconnectedRetryTimeout   : 15000,
	suspendedRetryTimeout      : 30000,
	/* Undocumented, but part of the api and can be used by customers: */
	httpRequestTimeout         : 15000,
	channelRetryTimeout        : 15000,
	fallbackRetryTimeout       : 600000,
	/* For internal / test use only: */
	connectionStateTtl         : 120000,
	realtimeRequestTimeout     : 10000,
	recvTimeout                : 90000,
	preferenceConnectTimeout   : 6000,
	parallelUpgradeDelay       : 6000
};
defaults.httpMaxRetryCount = 3;
defaults.maxMessageSize    = 65536;

defaults.errorReportingUrl = 'https://errors.ably.io/api/15/store/';
defaults.errorReportingHeaders = {
	"X-Sentry-Auth": "Sentry sentry_version=7, sentry_key=a04e33c8674c451f8a310fbec029acf5, sentry_client=ably-js/0.1",
	"Content-Type": "application/json"
};

defaults.version          = '1.2.13';
defaults.apiVersion       = '1.2';

var agent = 'ably-js/' + defaults.version;
if (platform_browser["a" /* default */].agent) {
	agent += ' ' + platform_browser["a" /* default */].agent;
} 
defaults.agent = agent;

defaults.getHost = function(options, host, ws) {
	if(ws)
		host = ((host == options.restHost) && options.realtimeHost) || host || options.realtimeHost;
	else
		host = host || options.restHost;

	return host;
};

defaults.getPort = function(options, tls) {
	return (tls || options.tls) ? options.tlsPort : options.port;
};

defaults.getHttpScheme = function(options) {
	return options.tls ? 'https://' : 'http://';
};

// construct environment fallback hosts as per RSC15i
defaults.environmentFallbackHosts = function(environment) {
	return [
		environment + '-a-fallback.ably-realtime.com',
		environment + '-b-fallback.ably-realtime.com',
		environment + '-c-fallback.ably-realtime.com',
		environment + '-d-fallback.ably-realtime.com',
		environment + '-e-fallback.ably-realtime.com'
	];
};

defaults.getFallbackHosts = function(options) {
	var fallbackHosts = options.fallbackHosts,
		httpMaxRetryCount = typeof(options.httpMaxRetryCount) !== 'undefined' ? options.httpMaxRetryCount : defaults.httpMaxRetryCount;

	return fallbackHosts ? utils["a" /* default */].arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
};

defaults.getHosts = function(options) {
	return [options.restHost].concat(defaults.getFallbackHosts(options));
};

function checkHost(host) {
	if(typeof host !== 'string') {
		throw new errorinfo["a" /* default */]('host must be a string; was a ' + typeof host, 40000, 400);
	};
	if(!host.length) {
		throw new errorinfo["a" /* default */]('host must not be zero-length', 40000, 400);
	};
}

defaults.objectifyOptions = function(options) {
	if(typeof options == 'string') {
		return (options.indexOf(':') == -1) ? {token: options} : {key: options};
	}
	return options;
};

defaults.normaliseOptions = function(options) {
	/* Deprecated options */
	if(options.host) {
		logger["a" /* default */].deprecated('host', 'restHost');
		options.restHost = options.host;
	}
	if(options.wsHost) {
		logger["a" /* default */].deprecated('wsHost', 'realtimeHost');
		options.realtimeHost = options.wsHost;
	}
	if(options.queueEvents) {
		logger["a" /* default */].deprecated('queueEvents', 'queueMessages');
		options.queueMessages = options.queueEvents;
	}

	if(options.fallbackHostsUseDefault) {
		/* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
		if(options.fallbackHosts) {
			var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* default fallbacks can't be used with custom ports */
		if(options.port || options.tlsPort) {
			var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* emit an appropriate deprecation warning */
		if(options.environment) {
			logger["a" /* default */].deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
		} else {
			logger["a" /* default */].deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
		}

		/* use the default fallback hosts as requested */
		options.fallbackHosts = defaults.FALLBACK_HOSTS;
	}

	if(options.recover === true) {
		logger["a" /* default */].deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
		options.recover = function(lastConnectionDetails, cb) { cb(true); };
	}

	if(typeof options.recover === 'function' && options.closeOnUnload === true) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
		options.recover = null;
	}

	if(!('closeOnUnload' in options)) {
		/* Have closeOnUnload default to true unless we have any indication that
		 * the user may want to recover the connection */
		options.closeOnUnload = !options.recover;
	}

	if(options.transports && utils["a" /* default */].arrIn(options.transports, 'xhr')) {
		logger["a" /* default */].deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
		utils["a" /* default */].arrDeleteValue(options.transports, 'xhr');
		options.transports.push('xhr_streaming');
	}

	if(!('queueMessages' in options))
		options.queueMessages = true;

	/* infer hosts and fallbacks based on the configured environment */
	var environment = (options.environment && String(options.environment).toLowerCase()) || defaults.ENVIRONMENT;
	var production = !environment || (environment === 'production');

	if(!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
		options.fallbackHosts = production ? defaults.FALLBACK_HOSTS : defaults.environmentFallbackHosts(environment);
	}

	if(!options.realtimeHost) {
		/* prefer setting realtimeHost to restHost as a custom restHost typically indicates
		 * a development environment is being used that can't be inferred by the library */
		if(options.restHost) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_WARN, 'Defaults.normaliseOptions', 'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.');
			options.realtimeHost = options.restHost
		} else {
			options.realtimeHost = production ? defaults.REALTIME_HOST : environment + '-' + defaults.REALTIME_HOST;
		}
	}

	if(!options.restHost) {
		options.restHost = production ? defaults.REST_HOST : environment + '-' + defaults.REST_HOST;
	}

	utils["a" /* default */].arrForEach((options.fallbackHosts || []).concat(options.restHost, options.realtimeHost), checkHost);

	options.port = options.port || defaults.PORT;
	options.tlsPort = options.tlsPort || defaults.TLS_PORT;
	options.maxMessageSize = options.maxMessageSize || defaults.maxMessageSize;
	if(!('tls' in options)) options.tls = true;

	/* Allow values passed in options to override default timeouts */
	options.timeouts = {};
	for(var prop in defaults.TIMEOUTS) {
		options.timeouts[prop] = options[prop] || defaults.TIMEOUTS[prop];
	};

	if('useBinaryProtocol' in options) {
		options.useBinaryProtocol = platform_browser["a" /* default */].supportsBinary && options.useBinaryProtocol;
	} else {
		options.useBinaryProtocol = platform_browser["a" /* default */].preferBinary;
	}

	if(options.clientId) {
		var headers = options.headers = options.headers || {};
		headers['X-Ably-ClientId'] = bufferutils["a" /* default */].base64Encode(bufferutils["a" /* default */].utf8Encode(options.clientId));
	}

	if(!('idempotentRestPublishing' in options)) {
		options.idempotentRestPublishing = true;
	}

	if(options.promises && !platform_browser["a" /* default */].Promise) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
		options.promises = false;
	}

        if(options.agents) {
          for(var key in options.agents) {
            defaults.agent += ' ' + key + '/' + options.agents[key];
          }
        }

	return options;
};

/* harmony default export */ var util_defaults = __webpack_exports__["a"] = (defaults);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_37334__) {

"use strict";
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_37334__(32);
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_37334__(33);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_37334__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_37334__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_37334__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_37334__(3);






var BufferUtils = (function() {
	var ArrayBuffer = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].ArrayBuffer;
	var atob = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].atob;
	var TextEncoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextEncoder;
	var TextDecoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextDecoder;
	var base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	var hexCharSet = '0123456789abcdef';

	function isWordArray(ob) { return ob !== null && ob !== undefined && ob.sigBytes !== undefined; }
	function isArrayBuffer(ob) { return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer; }
	function isTypedArray(ob) { return ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob); }

	// https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
	function uint8ViewToBase64(bytes) {
		var base64    = ''
		var encodings = base64CharSet;

		var byteLength    = bytes.byteLength
		var byteRemainder = byteLength % 3
		var mainLength    = byteLength - byteRemainder

		var a, b, c, d
		var chunk

		// Main loop deals with bytes in chunks of 3
		for (var i = 0; i < mainLength; i = i + 3) {
			// Combine the three bytes into a single integer
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

			// Use bitmasks to extract 6-bit segments from the triplet
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
			d = chunk & 63               // 63       = 2^6 - 1

			// Convert the raw binary segments to the appropriate ASCII encoding
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
		}

		// Deal with the remaining bytes and padding
		if (byteRemainder == 1) {
			chunk = bytes[mainLength]

			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

			// Set the 4 least significant bits to zero
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1

			base64 += encodings[a] + encodings[b] + '=='
		} else if (byteRemainder == 2) {
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

			// Set the 2 least significant bits to zero
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

			base64 += encodings[a] + encodings[b] + encodings[c] + '='
		}

		return base64
	}

	function base64ToArrayBuffer(base64) {
		var binary_string =  atob(base64);
		var len = binary_string.length;
		var bytes = new Uint8Array( len );
		for (var i = 0; i < len; i++)        {
			var ascii = binary_string.charCodeAt(i);
			bytes[i] = ascii;
		}
		return bytes.buffer;
	}

	/* Most BufferUtils methods that return a binary object return an ArrayBuffer
	 * if supported, else a CryptoJS WordArray. The exception is toBuffer, which
	 * returns a Uint8Array (and won't work on browsers too old to support it) */
	function BufferUtils() {}

	BufferUtils.base64CharSet = base64CharSet;
	BufferUtils.hexCharSet = hexCharSet;

	var isBuffer = BufferUtils.isBuffer = function(buf) { return isArrayBuffer(buf) || isWordArray(buf) || isTypedArray(buf); };

	/* In browsers, returns a Uint8Array */
	var toBuffer = BufferUtils.toBuffer = function(buf) {
		if(!ArrayBuffer) {
			throw new Error("Can't convert to Buffer: browser does not support the necessary types");
		}

		if(isArrayBuffer(buf)) {
			return new Uint8Array(buf);
		}

		if(isTypedArray(buf)) {
			return new Uint8Array(buf.buffer);
		}

		if(isWordArray(buf)) {
			/* Backported from unreleased CryptoJS
			* https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
			var arrayBuffer = new ArrayBuffer(buf.sigBytes);
			var uint8View = new Uint8Array(arrayBuffer);

			for (var i = 0; i < buf.sigBytes; i++) {
				uint8View[i] = (buf.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			}

			return uint8View;
		};

		throw new Error("BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray");
	};

	BufferUtils.toArrayBuffer = function(buf) {
		if(isArrayBuffer(buf)) {
			return buf;
		}
		return toBuffer(buf).buffer;
	};

	BufferUtils.toWordArray = function(buf) {
		if(isTypedArray(buf)) {
			buf = buf.buffer;
		}
		return isWordArray(buf) ? buf : crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default.a.create(buf);
	};

	BufferUtils.base64Encode = function(buf) {
		if(isWordArray(buf)) {
			return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["stringify"])(buf);
		}
		return uint8ViewToBase64(toBuffer(buf));
	};

	BufferUtils.base64Decode = function(str) {
		if(ArrayBuffer && atob) {
			return base64ToArrayBuffer(str);
		}
		return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["parse"])(str);
	};

	BufferUtils.hexEncode = function(buf) {
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["stringify"])(buf);
	};

	BufferUtils.hexDecode = function(string) {
		var wordArray = Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["parse"])(string);
		return ArrayBuffer ? BufferUtils.toArrayBuffer(wordArray) : wordArray;
	};

	BufferUtils.utf8Encode = function(string) {
		if(TextEncoder) {
			return (new TextEncoder()).encode(string).buffer;
		}
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["parse"])(string);
	};

	/* For utf8 decoding we apply slightly stricter input validation than to
	 * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
	 * can take (in particular allowing strings, which are just interpreted as
	 * binary); here we ensure that the input is actually a buffer since trying
	 * to utf8-decode a string to another string is almost certainly a mistake */
	BufferUtils.utf8Decode = function(buf) {
		if(!isBuffer(buf)) {
			throw new Error("Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray");
		}
		if(TextDecoder && !isWordArray(buf)) {
			return (new TextDecoder()).decode(buf);
		}
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["stringify"])(buf);
	};

	BufferUtils.bufferCompare = function(buf1, buf2) {
		if(!buf1) return -1;
		if(!buf2) return 1;
		buf1 = BufferUtils.toWordArray(buf1);
		buf2 = BufferUtils.toWordArray(buf2);
		buf1.clamp(); buf2.clamp();

		var cmp = buf1.sigBytes - buf2.sigBytes;
		if(cmp != 0) return cmp;
		buf1 = buf1.words; buf2 = buf2.words;
		for(var i = 0; i < buf1.length; i++) {
			cmp = buf1[i] - buf2[i];
			if(cmp != 0) return cmp;
		}
		return 0;
	};

	BufferUtils.byteLength = function(buf) {
		if(isArrayBuffer(buf) || isTypedArray(buf)) {
			return buf.byteLength
		} else if(isWordArray(buf)) {
			return buf.sigBytes;
		}
	};

	/* Returns ArrayBuffer on browser and Buffer on Node.js */
	BufferUtils.typedArrayToBuffer = function(typedArray) {
		return typedArray.buffer;
	};

	return BufferUtils;
})();

/* harmony default export */ __webpack_exports__["a"] = (BufferUtils);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_45867__) {

"use strict";
/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_45867__(1);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_45867__(4);



var Http = (function() {
	var noop = function() {};

	function Http() {}

	var now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	function shouldFallback(err) {
		var statusCode = err.statusCode;
		/* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
		 * detail to know whether it's fallback-fixable, but it may be (eg if a
		 * network issue), so try just in case */
		return (statusCode === 408 && !err.code) ||
			(statusCode === 400 && !err.code)      ||
			(statusCode >= 500 && statusCode <= 504);
	}

	function getHosts(client) {
		/* If we're a connected realtime client, try the endpoint we're connected
		 * to first -- but still have fallbacks, being connected is not an absolute
		 * guarantee that a datacenter has free capacity to service REST requests. */
		var connection = client.connection,
			connectionHost = connection && connection.connectionManager.host;

		if(connectionHost) {
			return [connectionHost].concat(_common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getFallbackHosts(client.options));
		}

		return _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getHosts(client.options);
	}
	Http._getHosts = getHosts;

	Http.methods = ['get', 'delete', 'post', 'put', 'patch'];
	Http.methodsWithoutBody = ['get', 'delete'];
	Http.methodsWithBody = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrSubtract(Http.methods, Http.methodsWithoutBody);

	/* - Http.get, Http.post, Http.put, ...
	 * Perform an HTTP request for a given path against prime and fallback Ably hosts
	 * @param rest
	 * @param path the full path
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 *
	 * - Http.getUri, Http.postUri, Http.putUri, ...
	 * Perform an HTTP request for a given full URI
	 * @param rest
	 * @param uri the full URI
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithoutBody, function(method) {
		Http[method] = function(rest, path, headers, params, callback) {
			Http['do'](method, rest, path, headers, null, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, params, callback) {
			Http.doUri(method, rest, uri, headers, null, params, callback);
		};
	});

	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithBody, function(method) {
		Http[method] = function(rest, path, headers, body, params, callback) {
			Http['do'](method, rest, path, headers, body, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, body, params, callback) {
			Http.doUri(method, rest, uri, headers, body, params, callback);
		};
	});

	/* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
	Http['do'] = function(method, rest, path, headers, body, params, callback) {
		callback = callback || noop;
		var uriFromHost = (typeof(path) == 'function') ? path : function(host) { return rest.baseUri(host) + path; };
		var binary = (headers && headers.accept != 'application/json');
		var doArgs = arguments;

		var currentFallback = rest._currentFallback;
		if(currentFallback) {
			if(currentFallback.validUntil > now()) {
				/* Use stored fallback */
				Http.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function(err) {
					if(err && shouldFallback(err)) {
						/* unstore the fallback and start from the top with the default sequence */
						rest._currentFallback = null;
						Http['do'].apply(Http, doArgs);
						return;
					}
					callback.apply(null, arguments);
				});
				return;
			} else {
				/* Fallback expired; remove it and fallthrough to normal sequence */
				rest._currentFallback = null;
			}
		}

		var hosts = getHosts(rest);

		/* if there is only one host do it */
		if(hosts.length == 1) {
			Http.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
			return;
		}

		/* hosts is an array with preferred host plus at least one fallback */
		var tryAHost = function(candidateHosts, persistOnSuccess) {
			var host = candidateHosts.shift();
			Http.doUri(method, rest, uriFromHost(host), headers, body, params, function(err) {
				if(err && shouldFallback(err) && candidateHosts.length) {
					tryAHost(candidateHosts, true);
					return;
				}
				if(persistOnSuccess) {
					/* RSC15f */
					rest._currentFallback = {
						host: host,
						validUntil: now() + rest.options.timeouts.fallbackRetryTimeout
					};
				}
				callback.apply(null, arguments);
			});
		};
		tryAHost(hosts);
	};

	Http.doUri = function(method, rest, uri, headers, body, params, callback) {
		Http.Request(method, rest, uri, headers, params, body, callback);
	};

	Http.supportsAuthHeaders = false;
	Http.supportsLinkHeaders = false;
	return Http;
})();

/* harmony default export */ __webpack_exports__["a"] = (Http);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_51456__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_51456__(1);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_51456__(0);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_51456__(3);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var EventEmitter = (function() {

	/* public constructor */
	function EventEmitter() {
		this.any = [];
		this.events = Object.create(null);
		this.anyOnce = [];
		this.eventsOnce = Object.create(null);
	}

	/* Call the listener, catch any exceptions and log, but continue operation*/
	function callListener(eventThis, listener, args) {
		try {
			listener.apply(eventThis, args);
		} catch(e) {
			_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
		}
	}

	/**
	 * Remove listeners that match listener
	 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
	 * @param listener the listener callback to remove
	 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
	 */
	function removeListener(targetListeners, listener, eventFilter) {
		var listeners, idx, eventName, targetListenersIndex;

		for (targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
			listeners = targetListeners[targetListenersIndex];
			if (eventFilter) { listeners = listeners[eventFilter]; }

			if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners)) {
				while ((idx = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIndexOf(listeners, listener)) !== -1) {
					listeners.splice(idx, 1);
				}
				/* If events object has an event name key with no listeners then
				   remove the key to stop the list growing indefinitely */
				if (eventFilter && (listeners.length === 0)) {
					delete targetListeners[targetListenersIndex][eventFilter];
				}
			} else if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isObject(listeners)) {
				/* events */
				for (eventName in listeners) {
					if (hasOwnProperty.call(listeners, eventName) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners[eventName])) {
						removeListener([listeners], listener, eventName);
					}
				}
			}
		}
	}

	/**
	 * Add an event listener
	 * @param event (optional) the name of the event to listen to
	 *        if not supplied, all events trigger a call to the listener
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.on = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.any.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.any.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listener);
			});
		} else {
			var listeners = (this.events[event] || (this.events[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Remove one or more event listeners
	 * @param event (optional) the name of the event whose listener
	 *        is to be removed. If not supplied, the listener is
	 *        treated as an 'any' listener
	 * @param listener (optional) the listener to remove. If not
	 *        supplied, all listeners are removed.
	 */
	EventEmitter.prototype.off = function(event, listener) {
		if(arguments.length == 0 || (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(listener))) {
			this.any = [];
			this.events = Object.create(null);
			this.anyOnce = [];
			this.eventsOnce = Object.create(null);
			return;
		}
		if(arguments.length == 1) {
			if(typeof(event) == 'function') {
				/* we take this to be the listener and treat the event as "any" .. */
				listener = event;
				event = null;
			}
			/* ... or we take event to be the actual event name and listener to be all */
		}

		if(listener && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
			return;
		}

		if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.off(ev, listener);
			});
		}

		/* "normal" case where event is an actual event */
		if(listener) {
			removeListener([this.events, this.eventsOnce], listener, event);
		} else {
			delete this.events[event];
			delete this.eventsOnce[event];
		}
	};

	/**
	 * Get the array of listeners for a given event; excludes once events
	 * @param event (optional) the name of the event, or none for 'any'
	 * @return array of events, or null if none
	 */
	EventEmitter.prototype.listeners = function(event) {
		if(event) {
			var listeners = (this.events[event] || []);
			if(this.eventsOnce[event])
				Array.prototype.push.apply(listeners, this.eventsOnce[event]);
			return listeners.length ? listeners : null;
		}
		return this.any.length ? this.any : null;
	};

	/**
	 * Emit an event
	 * @param event the event name
	 * @param args the arguments to pass to the listener
	 */
	EventEmitter.prototype.emit = function(event  /* , args... */) {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventThis = {event:event};
		var listeners = [];

		if(this.anyOnce.length) {
			Array.prototype.push.apply(listeners, this.anyOnce);
			this.anyOnce = [];
		}
		if(this.any.length) {
			Array.prototype.push.apply(listeners, this.any);
		}
		var eventsOnceListeners = this.eventsOnce[event];
		if(eventsOnceListeners) {
			Array.prototype.push.apply(listeners, eventsOnceListeners);
			delete this.eventsOnce[event];
		}
		var eventsListeners = this.events[event];
		if(eventsListeners) {
			Array.prototype.push.apply(listeners, eventsListeners);
		}

		_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(listeners, function(listener) {
			callListener(eventThis, listener, args);
		});
	};

	/**
	 * Listen for a single occurrence of an event
	 * @param event the name of the event to listen to
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.once = function(event, listener) {
		var argCount = arguments.length, self = this;
		if((argCount === 0 || (argCount === 1 && typeof event !== 'function')) && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				self.once(event, resolve);
			});
		}
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.anyOnce.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.anyOnce.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)){
			var listenerWrapper = function() {
				var args = Array.prototype.slice.call(arguments);
				_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
					self.off(ev, listenerWrapper);
				});
				listener.apply(this, args);
			};
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listenerWrapper);
			});
		} else {
			var listeners = (this.eventsOnce[event] || (this.eventsOnce[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Private API
	 *
	 * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
	 * @param targetState the name of the state event to listen to
	 * @param currentState the name of the current state of this object
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.whenState = function(targetState, currentState, listener /* ...listenerArgs */) {
		var eventThis = {event:targetState},
			self = this,
			listenerArgs = Array.prototype.slice.call(arguments, 3);

		if((typeof(targetState) !== 'string') || (typeof(currentState) !== 'string')) {
			throw("whenState requires a valid event String argument");
		}
		if(typeof listener !== 'function' && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				EventEmitter.prototype.whenState.apply(self, [targetState, currentState, resolve].concat(listenerArgs));
			});
		}
		if(targetState === currentState) {
			callListener(eventThis, listener, listenerArgs);
		} else {
			this.once(targetState, listener);
		}
	}

	return EventEmitter;
})();

/* harmony default export */ __webpack_exports__["a"] = (EventEmitter);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_60569__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_60569__(1);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_60569__(2);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_60569__(9);
/* harmony import */ var _presencemessage__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_60569__(11);





var ProtocolMessage = (function() {

	function ProtocolMessage() {
		this.action = undefined;
		this.flags = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.count = undefined;
		this.error = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.connectionSerial = undefined;
		this.channel = undefined;
		this.channelSerial = undefined;
		this.msgSerial = undefined;
		this.messages = undefined;
		this.presence = undefined;
		this.auth = undefined;
		this.params = undefined;
	}

	var actions = ProtocolMessage.Action = {
		'HEARTBEAT' : 0,
		'ACK' : 1,
		'NACK' : 2,
		'CONNECT' : 3,
		'CONNECTED' : 4,
		'DISCONNECT' : 5,
		'DISCONNECTED' : 6,
		'CLOSE' : 7,
		'CLOSED' : 8,
		'ERROR' : 9,
		'ATTACH' : 10,
		'ATTACHED' : 11,
		'DETACH' : 12,
		'DETACHED' : 13,
		'PRESENCE' : 14,
		'MESSAGE' : 15,
		'SYNC' : 16,
		'AUTH' : 17
	};

	ProtocolMessage.channelModes = [ 'PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE' ];

	ProtocolMessage.ActionName = [];
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(ProtocolMessage.Action, true), function(name) {
		ProtocolMessage.ActionName[actions[name]] = name;
	});

	var flags = {
		/* Channel attach state flags */
		'HAS_PRESENCE':       1 << 0,
		'HAS_BACKLOG':        1 << 1,
		'RESUMED':            1 << 2,
		'TRANSIENT':          1 << 4,
		'ATTACH_RESUME':      1 << 5,
		/* Channel mode flags */
		'PRESENCE':           1 << 16,
		'PUBLISH':            1 << 17,
		'SUBSCRIBE':          1 << 18,
		'PRESENCE_SUBSCRIBE': 1 << 19
	};
	var flagNames = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(flags);
	flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;

	ProtocolMessage.prototype.hasFlag = function(flag) {
		return ((this.flags & flags[flag]) > 0);
	};

	ProtocolMessage.prototype.setFlag = function(flag) {
		return this.flags = this.flags | flags[flag];
	};

	ProtocolMessage.prototype.getMode = function() {
		return this.flags && (this.flags & flags.MODE_ALL);
	};

	ProtocolMessage.prototype.encodeModesToFlags = function(modes) {
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(modes, function(mode) {
			self.setFlag(mode);
		});
	};

	ProtocolMessage.prototype.decodeModesFromFlags = function() {
		var modes = [],
			self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(ProtocolMessage.channelModes, function(mode) {
			if(self.hasFlag(mode)) {
				modes.push(mode);
			}
		});
		return modes.length > 0 ? modes : undefined;
	};

	ProtocolMessage.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].encodeBody;

	ProtocolMessage.deserialize = function(serialized, format) {
		var deserialized = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].decodeBody(serialized, format);
		return ProtocolMessage.fromDeserialized(deserialized);
	};

	ProtocolMessage.fromDeserialized = function(deserialized) {
		var error = deserialized.error;
		if(error) deserialized.error = _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(error);
		var messages = deserialized.messages;
		if(messages) for(var i = 0; i < messages.length; i++) messages[i] = _message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValues(messages[i]);
		var presence = deserialized.presence;
		if(presence) for(var i = 0; i < presence.length; i++) presence[i] = _presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(presence[i], true);
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), deserialized);
	};

	ProtocolMessage.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), values);
	};

	function toStringArray(array) {
		var result = [];
		if (array) {
			for (var i = 0; i < array.length; i++) {
				result.push(array[i].toString());
			}
		}
		return '[ ' + result.join(', ') + ' ]';
	}

	var simpleAttributes = 'id channel channelSerial connectionId connectionKey connectionSerial count msgSerial timestamp'.split(' ');

	ProtocolMessage.stringify = function(msg) {
		var result = '[ProtocolMessage';
		if(msg.action !== undefined)
			result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;

		var attribute;
		for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
			attribute = simpleAttributes[attribIndex];
			if(msg[attribute] !== undefined)
				result += '; ' + attribute + '=' + msg[attribute];
		}

		if(msg.messages)
			result += '; messages=' + toStringArray(_message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValuesArray(msg.messages));
		if(msg.presence)
			result += '; presence=' + toStringArray(_presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValuesArray(msg.presence));
		if(msg.error)
			result += '; error=' + _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(msg.error).toString();
		if(msg.auth && msg.auth.accessToken)
			result += '; token=' + msg.auth.accessToken;
		if(msg.flags)
			result += '; flags=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrFilter(flagNames, function(flag) {
				return msg.hasFlag(flag);
			}).join(',');
		if(msg.params) {
			var stringifiedParams = '';
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].forInOwnNonNullProps(msg.params, function(prop) {
				if (stringifiedParams.length > 0) {
					stringifiedParams += '; ';
				}
				stringifiedParams += prop + '=' + msg.params[prop];
			});
			if (stringifiedParams.length > 0) {
				result += '; params=[' + stringifiedParams + ']';
			}
		}
		result += ']';
		return result;
	};

	/* Only valid for channel messages */
	ProtocolMessage.isDuplicate = function(a, b) {
		if (a && b) {
			if ((a.action === actions.MESSAGE || a.action === actions.PRESENCE) &&
				(a.action === b.action) &&
				(a.channel === b.channel) &&
				(a.id === b.id)) {
				if (a.action === actions.PRESENCE) {
					return true;
				} else if (a.messages.length === b.messages.length) {
					for (var i = 0; i < a.messages.length; i++) {
						var aMessage = a.messages[i];
						var bMessage = b.messages[i];
						if ((aMessage.extras && aMessage.extras.delta && aMessage.extras.delta.format) !==
							(bMessage.extras && bMessage.extras.delta && bMessage.extras.delta.format)) {
							return false;
						}
					}

					return true;
				}
			}
		}

		return false;
	};

	return ProtocolMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (ProtocolMessage);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_67773__) {

"use strict";
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_67773__(5);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_67773__(1);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_67773__(0);
/* harmony import */ var platform_crypto__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_67773__(19);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_67773__(2);






var Message = (function() {

	function Message() {
		this.name = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.extras = undefined;
		this.size = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	Message.prototype.toJSON = function() {
		var result = {
			name: this.name,
			id: this.id,
			clientId: this.clientId,
			connectionId: this.connectionId,
			connectionKey: this.connectionKey,
			encoding: this.encoding,
			extras: this.extras
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	Message.prototype.toString = function() {
		var result = '[Message';
		if(this.name)
			result += '; name=' + this.name;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.extras)
			result += '; extras =' + JSON.stringify(this.extras);
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		if(this.extras)
			result += '; extras=' + JSON.stringify(this.extras);
		result += ']';
		return result;
	};

	Message.encrypt = function(msg, options, callback) {
		var data = msg.data,
			encoding = msg.encoding,
			cipher = options.channelCipher;

		encoding = encoding ? (encoding + '/') : '';
		if(!platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(String(data));
			encoding = encoding + 'utf-8/';
		}
		cipher.encrypt(data, function(err, data) {
			if (err) {
				callback(err);
				return;
			}
			msg.data = data;
			msg.encoding = encoding + 'cipher+' + cipher.algorithm;
			callback(null, msg);
		});
	};

	Message.encode = function(msg, options, callback) {
		var data = msg.data, encoding,
			nativeDataType = typeof(data) == 'string' || platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data) || data === null || data === undefined;

		if (!nativeDataType) {
			if (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isObject(data) || _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isArray(data)) {
				msg.data = JSON.stringify(data);
				msg.encoding = (encoding = msg.encoding) ? (encoding + '/json') : 'json';
			} else {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Data type is unsupported', 40013, 400);
			}
		}

		if(options != null && options.cipher) {
			Message.encrypt(msg, options, callback);
		} else {
			callback(null, msg);
		}
	};

	Message.encodeArray = function(messages, options, callback) {
		var processed = 0;
		for (var i = 0; i < messages.length; i++) {
			Message.encode(messages[i], options, function(err, msg) {
				if (err) {
					callback(err);
					return;
				}
				processed++;
				if (processed == messages.length) {
					callback(null, messages);
				}
			});
		}
	};

	Message.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].encodeBody;

	Message.decode = function(message, context) {
		/* The second argument could be either EncodingDecodingContext that contains ChannelOptions or ChannelOptions */
		if(!context || !context.channelOptions) {
			var channelOptions = context;
			context = {
				channelOptions: channelOptions,
				plugins: { },
				baseEncodedPreviousPayload: undefined
			};
		}

		var lastPayload = message.data;
		var encoding = message.encoding;
		if(encoding) {
			var xforms = encoding.split('/'),
				lastProcessedEncodingIndex, encodingsToProcess = xforms.length,
				data = message.data;

			try {
				while((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
					var match = xforms[--encodingsToProcess].match(/([\-\w]+)(\+([\w\-]+))?/);
					if(!match) break;
					var xform = match[1];
					switch(xform) {
						case 'base64':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Decode(String(data));
							if(lastProcessedEncodingIndex == xforms.length) {
								lastPayload = data;
							}
							continue;
						case 'utf-8':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Decode(data);
							continue;
						case 'json':
							data = JSON.parse(data);
							continue;
						case 'cipher':
							if(context.channelOptions != null && context.channelOptions.cipher) {
								var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
								/* don't attempt to decrypt unless the cipher params are compatible */
								if(xformAlgorithm != cipher.algorithm) {
									throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
								}
								data = cipher.decrypt(data);
								continue;
							} else {
								throw new Error('Unable to decrypt message; not an encrypted channel');
							}
						case 'vcdiff':
							if(!context.plugins || !context.plugins.vcdiff) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
							}
							if(typeof Uint8Array === 'undefined') {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
							}
							try {
								var deltaBase = context.baseEncodedPreviousPayload;
								if(typeof deltaBase === 'string') {
									deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(deltaBase);
								}

								/* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
								 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
								 * to process it into a buffer anyway) */
								deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(deltaBase);
								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);

								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
								lastPayload = data;
							} catch(e) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Vcdiff delta decode failed with ' + e, 40018, 400);
							}
							continue;
						default:
							throw new Error("Unknown encoding");
					}
					break;
				}
			} catch(e) {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Error processing the ' + xform + ' encoding, decoder returned ‘' + e.message + '’', e.code || 40013, 400);
			} finally {
				message.encoding = (lastProcessedEncodingIndex <= 0) ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
				message.data = data;
			}
		}
		context.baseEncodedPreviousPayload = lastPayload;
	};

	Message.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = Message.fromValues(body[i]);
			try {
				Message.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	Message.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(new Message(), values);
	};

	Message.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = Message.fromValues(values[i]);
		return result;
	};

	function normalizeCipherOptions(options) {
		if(options && options.cipher && !options.cipher.channelCipher) {
			if(!platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		}
	}

	Message.fromEncoded = function(encoded, options) {
		var msg = Message.fromValues(encoded);
		normalizeCipherOptions(options);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			Message.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromEncoded()', e.toString());
		}
		return msg;
	};

	Message.fromEncodedArray = function(encodedArray, options) {
		normalizeCipherOptions(options);
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return Message.fromEncoded(encoded, options);
		});
	};

	function getMessageSize(msg) {
		var size = 0;
		if(msg.name) {
			size += msg.name.length;
		}
		if(msg.clientId) {
			size += msg.clientId.length;
		}
		if(msg.extras) {
			size += JSON.stringify(msg.extras).length;
		}
		if(msg.data) {
			size += _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].dataSizeBytes(msg.data);
		}
		return size;
	};

	/* This should be called on encode()d (and encrypt()d) Messages (as it
	 * assumes the data is a string or buffer) */
	Message.getMessagesSize = function(messages) {
		var msg, total = 0;
		for(var i=0; i<messages.length; i++) {
			msg = messages[i];
			total += (msg.size || (msg.size = getMessageSize(msg)))
		}
		return total;
	};

	return Message;
})();

/* harmony default export */ __webpack_exports__["a"] = (Message);


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_79596__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_79596__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_81748__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_81748__(3);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_81748__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_81748__(5);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_81748__(9);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_81748__(1);






var PresenceMessage = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function toActionValue(actionString) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrIndexOf(PresenceMessage.Actions, actionString)
	}

	function PresenceMessage() {
		this.action = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.size = undefined;
	}

	PresenceMessage.Actions = [
		'absent',
		'present',
		'enter',
		'leave',
		'update'
	];

	/* Returns whether this presenceMessage is synthesized, i.e. was not actually
	 * sent by the connection (usually means a leave event sent 15s after a
	 * disconnection). This is useful because synthesized messages cannot be
	 * compared for newness by id lexicographically - RTP2b1
	 */
	PresenceMessage.prototype.isSynthesized = function() {
		return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
	};

	/* RTP2b2 */
	PresenceMessage.prototype.parseId = function() {
		var parts = this.id.split(':');
		return {
			connectionId: parts[0],
			msgSerial: parseInt(parts[1], 10),
			index: parseInt(parts[2], 10)
		};
	};

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PresenceMessage.prototype.toJSON = function() {
		var result = {
			clientId: this.clientId,
			/* Convert presence action back to an int for sending to Ably */
			action: toActionValue(this.action),
			encoding: this.encoding
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	PresenceMessage.prototype.toString = function() {
		var result = '[PresenceMessage';
		result += '; action=' + this.action;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		result += ']';
		return result;
	};
	PresenceMessage.encode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].encode;
	PresenceMessage.decode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].decode;

	PresenceMessage.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = PresenceMessage.fromValues(body[i], true);
			try {
				PresenceMessage.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	/* Creates a PresenceMessage from specified values, with a string presence action */
	PresenceMessage.fromValues = function(values, stringifyAction) {
		if(stringifyAction) {
			values.action = PresenceMessage.Actions[values.action]
		}
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].mixin(new PresenceMessage(), values);
	};

	PresenceMessage.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PresenceMessage.fromValues(values[i]);
		return result;
	};

	PresenceMessage.fromEncoded = function(encoded, options) {
		var msg = PresenceMessage.fromValues(encoded, true);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			PresenceMessage.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
		}
		return msg;
	};

	PresenceMessage.fromEncodedArray = function(encodedArray, options) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return PresenceMessage.fromEncoded(encoded, options);
		});
	};

	PresenceMessage.getMessagesSize = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getMessagesSize;

	return PresenceMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (PresenceMessage);


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_87981__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_87981__(45);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_87981__(17)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_111360__) {

"use strict";
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_111360__(2);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_111360__(1);



var ConnectionError = {
	disconnected: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80003,
		message: 'Connection to server temporarily unavailable'
	}),
	suspended: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80002,
		message: 'Connection to server unavailable'
	}),
	failed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80000,
		message: 'Connection failed or disconnected by server'
	}),
	closing: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closing'
	}),
	closed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closed'
	}),
	unknownConnectionErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50002,
		message: 'Internal connection error'
	}),
	unknownChannelErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50001,
		message: 'Internal channel error'
	})
};

ConnectionError.isRetriable = function(err) {
	if (!err.statusCode || !err.code || err.statusCode >= 500) {
		return true;
	}
	var retriable = false;
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].valuesArray(ConnectionError).forEach(function(connErr) {
		if (connErr.code && connErr.code == err.code) {
			retriable = true;
		}
	});
	return retriable;
};

/* harmony default export */ __webpack_exports__["a"] = (ConnectionError);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_113345__) {

"use strict";

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_113345__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_113345__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_113345__(1);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_113345__(6);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var multicaster = __nested_webpack_require_113345__(22);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_113345__(5);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_113345__(2);

// CONCATENATED MODULE: ./browser/lib/util/base64.js
/*
 Copyright (c) 2008 Fred Palmer fred.palmer_at_gmail.com

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */
var Base64 = (function() {
	function StringBuffer()
	{
		this.buffer = [];
	}

	StringBuffer.prototype.append = function append(string)
	{
		this.buffer.push(string);
		return this;
	};

	StringBuffer.prototype.toString = function toString()
	{
		return this.buffer.join("");
	};

	var Base64 =
	{
		codex : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

		encode : function (input)
		{
			var output = new StringBuffer();
			var codex = Base64.codex;

			var enumerator = new Utf8EncodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var chr1 = enumerator.current;

				enumerator.moveNext();
				var chr2 = enumerator.current;

				enumerator.moveNext();
				var chr3 = enumerator.current;

				var enc1 = chr1 >> 2;
				var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
				var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
				var enc4 = chr3 & 63;

				if (isNaN(chr2))
				{
					enc3 = enc4 = 64;
				}
				else if (isNaN(chr3))
				{
					enc4 = 64;
				}

				output.append(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
			}

			return output.toString();
		},

		decode : function (input)
		{
			var output = new StringBuffer();

			var enumerator = new Base64DecodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var charCode = enumerator.current;

				if (charCode < 128)
					output.append(String.fromCharCode(charCode));
				else if ((charCode > 191) && (charCode < 224))
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 31) << 6) | (charCode2 & 63)));
				}
				else
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					enumerator.moveNext();
					var charCode3 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 15) << 12) | ((charCode2 & 63) << 6) | (charCode3 & 63)));
				}
			}

			return output.toString();
		}
	};

	function Utf8EncodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Utf8EncodeEnumerator.prototype =
	{
		current: Number.NaN,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = Number.NaN;
				return false;
			}
			else
			{
				var charCode = this._input.charCodeAt(++this._index);

				// "\r\n" -> "\n"
				//
				if ((charCode == 13) && (this._input.charCodeAt(this._index + 1) == 10))
				{
					charCode = 10;
					this._index += 2;
				}

				if (charCode < 128)
				{
					this.current = charCode;
				}
				else if ((charCode > 127) && (charCode < 2048))
				{
					this.current = (charCode >> 6) | 192;
					this._buffer.push((charCode & 63) | 128);
				}
				else
				{
					this.current = (charCode >> 12) | 224;
					this._buffer.push(((charCode >> 6) & 63) | 128);
					this._buffer.push((charCode & 63) | 128);
				}

				return true;
			}
		}
	};

	function Base64DecodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Base64DecodeEnumerator.prototype =
	{
		current: 64,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = 64;
				return false;
			}
			else
			{
				var enc1 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc2 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc3 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc4 = Base64.codex.indexOf(this._input.charAt(++this._index));

				var chr1 = (enc1 << 2) | (enc2 >> 4);
				var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
				var chr3 = ((enc3 & 3) << 6) | enc4;

				this.current = chr1;

				if (enc3 != 64)
					this._buffer.push(chr2);

				if (enc4 != 64)
					this._buffer.push(chr3);

				return true;
			}
		}
	};

	return Base64;
})();

/* harmony default export */ var base64 = (Base64);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/hmac-sha256.js
var hmac_sha256 = __nested_webpack_require_113345__(38);
var hmac_sha256_default = /*#__PURE__*/__nested_webpack_require_113345__.n(hmac_sha256);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/enc-base64.js
var enc_base64 = __nested_webpack_require_113345__(18);

// CONCATENATED MODULE: ./common/lib/client/auth.js











var auth_Auth = (function() {
	var MAX_TOKEN_LENGTH = Math.pow(2, 17);
	function noop() {}
	function random() { return ('000000' + Math.floor(Math.random() * 1E16)).slice(-16); }
	function normaliseAuthcallbackError(err) {
		/* A client auth callback may give errors in any number of formats; normalise to an errorinfo */
		if(!utils["a" /* default */].isErrorInfo(err)) {
			return new errorinfo["a" /* default */](utils["a" /* default */].inspectError(err), err.code || 40170, err.statusCode || 401);
		}
		/* network errors will not have an inherent error code */
		if(!err.code) {
			if(err.statusCode === 403) {
				err.code = 40300;
			} else {
				err.code = 40170;
				/* normalise statusCode to 401 per RSA4e */
				err.statusCode = 401;
			}
		}
		return err;
	}

	var hmac, toBase64;
	if(platform_browser["a" /* default */].createHmac) {
		toBase64 = function(str) { return (Buffer.from(str, 'ascii')).toString('base64'); };
		hmac = function(text, key) {
			var inst = platform_browser["a" /* default */].createHmac('SHA256', key);
			inst.update(text);
			return inst.digest('base64');
		};
	} else {
		toBase64 = base64.encode;
		hmac = function(text, key) {
			return Object(enc_base64["stringify"])(hmac_sha256_default()(text, key));
		};
	}

	function c14n(capability) {
		if(!capability)
			return '';

		if(typeof(capability) == 'string')
			capability = JSON.parse(capability);

		var c14nCapability = Object.create(null);
		var keys = utils["a" /* default */].keysArray(capability, true);
		if(!keys)
			return '';
		keys.sort();
		for(var i = 0; i < keys.length; i++) {
			c14nCapability[keys[i]] = capability[keys[i]].sort();
		}
		return JSON.stringify(c14nCapability);
	}

	function logAndValidateTokenAuthMethod(authOptions) {
		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authCallback');
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authUrl');
		} else if(authOptions.key) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
		} else if(authOptions.tokenDetails) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
		} else {
			var msg = 'authOptions must include valid authentication parameters';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
			throw new Error(msg);
		}
	}

	function basicAuthForced(options) {
		return 'useTokenAuth' in options && !options.useTokenAuth;
	}

	/* RSA4 */
	function useTokenAuth(options) {
		return options.useTokenAuth ||
			(!basicAuthForced(options) &&
			 (options.authCallback ||
			  options.authUrl      ||
			  options.token        ||
			  options.tokenDetails))
	}

	/* RSA4a */
	function noWayToRenew(options) {
		return !options.key &&
			!options.authCallback &&
			!options.authUrl;
	}

	var trId = 0;
	function getTokenRequestId() {
		return trId++;
	}

	function Auth(client, options) {
		this.client = client;
		this.tokenParams = options.defaultTokenParams || {};
		/* The id of the current token request if one is in progress, else null */
		this.currentTokenRequestId = null;
		this.waitingForTokenRequest = null;

		if(useTokenAuth(options)) {
			/* Token auth */
			if(options.key && !hmac) {
				var msg = 'client-side token request signing not supported';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new Error(msg);
			}
			if(noWayToRenew(options)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			}
			this._saveTokenOptions(options.defaultTokenParams, options);
			logAndValidateTokenAuthMethod(this.authOptions);
		} else {
			/* Basic auth */
			if(!options.key) {
				var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new errorinfo["a" /* default */](msg, 40160, 401);
			}
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
			this._saveBasicOptions(options);
		}
	}

	/**
	 * Instructs the library to get a token immediately and ensures Token Auth
	 * is used for all future requests, storing the tokenParams and authOptions
	 * given as the new defaults for subsequent use.
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 *
	 * - ttl:        (optional) the requested life of any new token in ms. If none
	 *               is specified a default of 1 hour is provided. The maximum lifetime
	 *               is 24hours; any request exceeeding that lifetime will be rejected
	 *               with an error.
	 *
	 * - capability: (optional) the capability to associate with the access token.
	 *               If none is specified, a token will be requested with all of the
	 *               capabilities of the specified key.
	 *
	 * - clientId:   (optional) a client Id to associate with the token
	 *
	 * - timestamp:  (optional) the time in ms since the epoch. If none is specified,
	 *               the system will be queried for a time value to use.
	 *
	 * @param authOptions
	 * an object containing auth options relevant to token auth:
	 *
	 * - queryTime   (optional) boolean indicating that the Ably system should be
	 *               queried for the current time when none is specified explicitly.
	 *
	 * - tokenDetails: (optional) object: An authenticated TokenDetails object.
	 *
	 * - token:        (optional) string: the `token` property of a tokenDetails object
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.authorize = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback) {
			if(this.client.options.promises) {
				return utils["a" /* default */].promisify(this, 'authorize', arguments);
			}
			callback = noop;
		}
		var self = this;

		/* RSA10a: authorize() call implies token auth. If a key is passed it, we
		 * just check if it doesn't clash and assume we're generating a token from it */
		if(authOptions && authOptions.key && (this.authOptions.key !== authOptions.key)) {
			throw new errorinfo["a" /* default */]('Unable to update auth options with incompatible key', 40102, 401);
		}

		if(authOptions && ('force' in authOptions)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
			/* Emulate the old behaviour: if 'force' was the only member of authOptions,
			 * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
			if(utils["a" /* default */].isOnlyPropIn(authOptions, 'force')) {
				authOptions = null;
			}
		}

		this._forceNewToken(tokenParams, authOptions, function(err, tokenDetails) {
			if(err) {
				if(self.client.connection) {
					/* We interpret RSA4d as including requests made by a client lib to
					 * authenticate triggered by an explicit authorize() or an AUTH received from
					 * ably, not just connect-sequence-triggered token fetches */
					self.client.connection.connectionManager.actOnErrorFromAuthorize(err);
				}
				callback(err);
				return;
			}

			/* RTC8
			 * - When authorize called by an end user and have a realtime connection,
			 * don't call back till new token has taken effect.
			 * - Use self.client.connection as a proxy for (self.client instanceof Realtime),
			 * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
			if(self.client.connection) {
				self.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback);
			} else {
				callback(null, tokenDetails);
			}
		})
	};

	Auth.prototype.authorise = function() {
		logger["a" /* default */].deprecated('Auth.authorise', 'Auth.authorize');
		this.authorize.apply(this, arguments);
	};

	/* For internal use, eg by connectionManager - useful when want to call back
	 * as soon as we have the new token, rather than waiting for it to take
	 * effect on the connection as #authorize does */
	Auth.prototype._forceNewToken = function(tokenParams, authOptions, callback) {
		var self = this;

		/* get rid of current token even if still valid */
		this.tokenDetails = null;

		/* _save normalises the tokenParams and authOptions and updates the auth
		 * object. All subsequent operations should use the values on `this`,
		 * not the passed in ones. */
		this._saveTokenOptions(tokenParams, authOptions);

		logAndValidateTokenAuthMethod(this.authOptions);

		this._ensureValidAuthCredentials(true, function(err, tokenDetails) {
			/* RSA10g */
			delete self.tokenParams.timestamp;
			delete self.authOptions.queryTime;
			callback(err, tokenDetails);
		});
	}

	/**
	 * Request an access token
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use.
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.requestToken = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		}
		else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'requestToken', arguments);
		}

		/* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);
		callback = callback || noop;

		/* first set up whatever callback will be used to get signed
		 * token requests */
		var tokenRequestCallback, client = this.client;

		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
			tokenRequestCallback = authOptions.authCallback;
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
			tokenRequestCallback = function(params, cb) {
				var authHeaders = utils["a" /* default */].mixin({accept: 'application/json, text/plain'}, authOptions.authHeaders),
					usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
				if(!usePost) {
					/* Combine authParams with any qs params given in the authUrl */
					var queryIdx = authOptions.authUrl.indexOf('?');
					if(queryIdx > -1) {
						var providedQsParams = utils["a" /* default */].parseQueryString(authOptions.authUrl.slice(queryIdx));
						authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
						/* In case of conflict, authParams take precedence over qs params in the authUrl */
						authOptions.authParams = utils["a" /* default */].mixin(providedQsParams, authOptions.authParams);
					}
				}
				/* RSA8c2 */
				var authParams = utils["a" /* default */].mixin({}, authOptions.authParams || {}, params);
				var authUrlRequestCallback = function(err, body, headers, unpacked) {
					var contentType;
					if (err) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + utils["a" /* default */].inspectError(err));
					} else {
						contentType = headers['content-type'];
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + utils["a" /* default */].inspectBody(body));
					}
					if(err || unpacked) return cb(err, body);
					if(bufferutils["a" /* default */].isBuffer(body)) body = body.toString();
					if(!contentType) {
						cb(new errorinfo["a" /* default */]('authUrl response is missing a content-type header', 40170, 401));
						return;
					}
					var json = contentType.indexOf('application/json') > -1,
						text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
					if(!json && !text) {
						cb(new errorinfo["a" /* default */]('authUrl responded with unacceptable content-type ' + contentType + ', should be either text/plain, application/jwt or application/json', 40170, 401));
						return;
					}
					if(json) {
						if(body.length > MAX_TOKEN_LENGTH) {
							cb(new errorinfo["a" /* default */]('authUrl response exceeded max permitted length', 40170, 401));
							return;
						}
						try {
							body = JSON.parse(body);
						} catch(e) {
							cb(new errorinfo["a" /* default */]('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
							return;
						}
					}
					cb(null, body, contentType);
				};
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' + authOptions.authUrl + '; Params: ' + JSON.stringify(authParams) + '; method: ' + (usePost ? 'POST' : 'GET'));
				if(usePost) {
					/* send body form-encoded */
					var headers = authHeaders || {};
					headers['content-type'] = 'application/x-www-form-urlencoded';
					var body = utils["a" /* default */].toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
					http["a" /* default */].postUri(client, authOptions.authUrl, headers, body, {}, authUrlRequestCallback);
				} else {
					http["a" /* default */].getUri(client, authOptions.authUrl, authHeaders || {}, authParams, authUrlRequestCallback);
				}
			};
		} else if(authOptions.key) {
			var self = this;
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
			tokenRequestCallback = function(params, cb) { self.createTokenRequest(params, authOptions, cb); };
		} else {
			var msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			callback(new errorinfo["a" /* default */](msg, 40171, 403));
			return;
		}

		/* normalise token params */
		if('capability' in tokenParams)
			tokenParams.capability = c14n(tokenParams.capability);

		var tokenRequest = function(signedTokenParams, tokenCb) {
			var keyName = signedTokenParams.keyName,
				path = '/keys/' + keyName + '/requestToken',
				tokenUri = function(host) { return client.baseUri(host) + path; };

			var requestHeaders = utils["a" /* default */].defaultPostHeaders();
			if(authOptions.requestHeaders) utils["a" /* default */].mixin(requestHeaders, authOptions.requestHeaders);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
			signedTokenParams = JSON.stringify(signedTokenParams);
			http["a" /* default */].post(client, tokenUri, requestHeaders, signedTokenParams, null, tokenCb);
		};

		var tokenRequestCallbackTimeoutExpired = false,
			timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,
			tokenRequestCallbackTimeout = setTimeout(function() {
				tokenRequestCallbackTimeoutExpired = true;
				var msg = 'Token request callback timed out after ' + (timeoutLength / 1000) + ' seconds';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
			}, timeoutLength);

		tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
			if(tokenRequestCallbackTimeoutExpired) return;
			clearTimeout(tokenRequestCallbackTimeout);

			if(err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + utils["a" /* default */].inspectError(err));
				callback(normaliseAuthcallbackError(err));
				return;
			}
			/* the response from the callback might be a token string, a signed request or a token details */
			if(typeof(tokenRequestOrDetails) === 'string') {
				if(tokenRequestOrDetails.length === 0) {
					callback(new errorinfo["a" /* default */]('Token string is empty', 40170, 401));
				} else if(tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
					callback(new errorinfo["a" /* default */]('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
				} else if(tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
					/* common failure mode with poorly-implemented authCallbacks */
					callback(new errorinfo["a" /* default */]('Token string was literal null/undefined', 40170, 401));
				} else if((tokenRequestOrDetails[0] === '{') && !(contentType && contentType.indexOf('application/jwt') > -1)) {
					callback(new errorinfo["a" /* default */]('Token was double-encoded; make sure you\'re not JSON-encoding an already encoded token request or details', 40170, 401));
				} else {
					callback(null, {token: tokenRequestOrDetails});
				}
				return;
			}
			if(typeof(tokenRequestOrDetails) !== 'object') {
				var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' + typeof(tokenRequestOrDetails);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			var objectSize = JSON.stringify(tokenRequestOrDetails).length;
			if(objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
				callback(new errorinfo["a" /* default */]('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
				return;
			}
			if('issued' in tokenRequestOrDetails) {
				/* a tokenDetails object */
				callback(null, tokenRequestOrDetails);
				return;
			}
			if(!('keyName' in tokenRequestOrDetails)) {
				var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			/* it's a token request, so make the request */
			tokenRequest(tokenRequestOrDetails, function(err, tokenResponse, headers, unpacked) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + utils["a" /* default */].inspectError(err));
					callback(normaliseAuthcallbackError(err));
					return;
				}
				if(!unpacked) tokenResponse = JSON.parse(tokenResponse);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'token received');
				callback(null, tokenResponse);
			});
		});
	};

	/**
	 * Create and sign a token request based on the given options.
	 * NOTE this can only be used when the key value is available locally.
	 * Otherwise, signed token requests must be obtained from the key
	 * owner (either using the token request callback or url).
	 *
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use. If not specified, a key passed in constructing
	 *                  the Rest interface will be used
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:       (optional) the requested life of the token in ms. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 */
	Auth.prototype.createTokenRequest = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'createTokenRequest', arguments);
		}

		/* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);

		var key = authOptions.key;
		if(!key) {
			callback(new errorinfo["a" /* default */]('No key specified', 40101, 403));
			return;
		}
		var keyParts = key.split(':'),
			keyName = keyParts[0],
			keySecret = keyParts[1];

		if(!keySecret) {
			callback(new errorinfo["a" /* default */]('Invalid key specified', 40101, 403));
			return;
		}

		if(tokenParams.clientId === '') {
			callback(new errorinfo["a" /* default */]('clientId can’t be an empty string', 40012, 400));
			return;
		}

		if('capability' in tokenParams) {
			tokenParams.capability = c14n(tokenParams.capability);
		}

		var request = utils["a" /* default */].mixin({ keyName: keyName }, tokenParams),
			clientId = tokenParams.clientId || '',
			ttl = tokenParams.ttl || '',
			capability = tokenParams.capability || '',
			self = this;

		(function(authoriseCb) {
			if(request.timestamp) {
				authoriseCb();
				return;
			};
			self.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
				if(err) {callback(err); return;}
				request.timestamp = time;
				authoriseCb();
			});
		})(function() {
			/* nonce */
			/* NOTE: there is no expectation that the client
			 * specifies the nonce; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			var nonce = request.nonce || (request.nonce = random()),
				timestamp = request.timestamp;

			var signText
			=	request.keyName + '\n'
			+	ttl + '\n'
			+	capability + '\n'
			+	clientId + '\n'
			+	timestamp + '\n'
			+	nonce + '\n';

			/* mac */
			/* NOTE: there is no expectation that the client
			 * specifies the mac; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			request.mac = request.mac || hmac(signText, keySecret);

			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
			callback(null, request);
		});
	};

	/**
	 * Get the auth query params to use for a websocket connection,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthParams = function(callback) {
		if(this.method == 'basic')
			callback(null, {key: this.key});
		else
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {access_token: tokenDetails.token});
			});
	};

	/**
	 * Get the authorization header to use for a REST or comet request,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthHeaders = function(callback) {
		if(this.method == 'basic') {
			callback(null, {authorization: 'Basic ' + this.basicKey});
		} else {
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {authorization: 'Bearer ' + toBase64(tokenDetails.token)});
			});
		}
	};

	/**
	 * Get the current time based on the local clock,
	 * or if the option queryTime is true, return the server time.
	 * The server time offset from the local time is stored so that
	 * only one request to the server to get the time is ever needed
	 */
	Auth.prototype.getTimestamp = function(queryTime, callback) {
		if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
			this.client.time(callback);
		} else {
			callback(null, this.getTimestampUsingOffset());
		}
	};

	Auth.prototype.getTimestampUsingOffset = function() {
		return utils["a" /* default */].now() + (this.client.serverTimeOffset || 0);
	};

	Auth.prototype.isTimeOffsetSet = function() {
		return this.client.serverTimeOffset !== null;
	};

	Auth.prototype._saveBasicOptions = function(authOptions) {
		this.method = 'basic';
		this.key = authOptions.key;
		this.basicKey = toBase64(authOptions.key);
		this.authOptions = authOptions || {};
		if('clientId' in authOptions) {
			this._userSetClientId(authOptions.clientId);
		}
	}

	Auth.prototype._saveTokenOptions = function(tokenParams, authOptions) {
		this.method = 'token';

		if(tokenParams) {
			/* We temporarily persist tokenParams.timestamp in case a new token needs
			 * to be requested, then null it out in the callback of
			 * _ensureValidAuthCredentials for RSA10g compliance */
			this.tokenParams = tokenParams;
		}

		if(authOptions) {
			/* normalise */
			if(authOptions.token) {
				/* options.token may contain a token string or, for convenience, a TokenDetails */
				authOptions.tokenDetails = (typeof(authOptions.token) === 'string') ? {token: authOptions.token} : authOptions.token;
			}

			if(authOptions.tokenDetails) {
				this.tokenDetails = authOptions.tokenDetails;
			}

			if('clientId' in authOptions) {
				this._userSetClientId(authOptions.clientId);
			}

			this.authOptions = authOptions;
		}
	};

	/* @param forceSupersede: force a new token request even if there's one in
	 * progress, making all pending callbacks wait for the new one */
	Auth.prototype._ensureValidAuthCredentials = function(forceSupersede, callback) {
		var self = this,
			token = this.tokenDetails;

		if(token) {
			if(this._tokenClientIdMismatch(token.clientId)) {
				/* 403 to trigger a permanently failed client - RSA15c */
				callback(new errorinfo["a" /* default */]('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
				return;
			}
			/* RSA4b1 -- if we have a server time offset set already, we can
			 * autoremove expired tokens. Else just use the cached token. If it is
			 * expired Ably will tell us and we'll discard it then. */
			if(!this.isTimeOffsetSet() || !token.expires || (token.expires >= this.getTimestampUsingOffset())) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
				callback(null, token);
				return;
			}
			/* expired, so remove and fallthrough to getting a new one */
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
			this.tokenDetails = null;
		}

		(this.waitingForTokenRequest || (this.waitingForTokenRequest = Object(multicaster["a" /* default */])())).push(callback);
		if(this.currentTokenRequestId !== null && !forceSupersede) {
			return;
		}

		/* Request a new token */
		var tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
		this.requestToken(this.tokenParams, this.authOptions, function(err, tokenResponse) {
			if(self.currentTokenRequestId > tokenRequestId) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
				return;
			}
			self.currentTokenRequestId = null;
			var callbacks = self.waitingForTokenRequest || noop;
			self.waitingForTokenRequest = null;
			if(err) {
				callbacks(err);
				return;
			}
			callbacks(null, (self.tokenDetails = tokenResponse));
		});
	};


	/* User-set: check types, '*' is disallowed, throw any errors */
	Auth.prototype._userSetClientId = function(clientId) {
		if(!(typeof(clientId) === 'string' || clientId === null)) {
			throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
		} else if(clientId === '*') {
			throw new errorinfo["a" /* default */]('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
		} else {
			var err = this._uncheckedSetClientId(clientId);
			if(err) throw err;
		}
	};

	/* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
	Auth.prototype._uncheckedSetClientId = function(clientId) {
		if(this._tokenClientIdMismatch(clientId)) {
			/* Should never happen in normal circumstances as realtime should
			 * recognise mismatch and return an error */
			var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
			var err = new errorinfo["a" /* default */](msg, 40102, 401);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
			return err;
		} else {
			/* RSA7a4: if options.clientId is provided and is not
			 * null, it overrides defaultTokenParams.clientId */
			this.clientId = this.tokenParams.clientId = clientId;
			return null;
		}
	};

	Auth.prototype._tokenClientIdMismatch = function(tokenClientId) {
		return this.clientId &&
			(this.clientId !== '*') &&
			tokenClientId &&
			(tokenClientId !== '*') &&
			(this.clientId !== tokenClientId);
	};

	Auth.isTokenErr = function(error) {
		return error.code && (error.code >= 40140) && (error.code < 40150);
	};

	return Auth;
})();

/* harmony default export */ var auth = __webpack_exports__["a"] = (auth_Auth);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_154733__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_154733__(1);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_154733__(8);
/* harmony import */ var _transport_transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_154733__(20);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_154733__(0);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_154733__(4);
/* harmony import */ var _connectionerror__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_154733__(13);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_154733__(14);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_154733__(2);









var CometTransport = (function() {

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	/* TODO: can remove once realtime sends protocol message responses for comet errors */
	function shouldBeErrorAction(err) {
		var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
		if(err.code) {
			if(_client_auth__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].isTokenErr(err)) return false;
			if(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIn(UNRESOLVABLE_ERROR_CODES, err.code)) return true;
			return (err.code >= 40000 && err.code < 50000);
		} else {
			/* Likely a network or transport error of some kind. Certainly not fatal to the connection */
			return false;
		}
	}

	function protocolMessageFromRawError(err) {
		/* err will be either a legacy (non-protocolmessage) comet error response
		 * (which will have an err.code), or a xhr/network error (which won't). */
		if(shouldBeErrorAction(err)) {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.ERROR, error: err})];
		} else {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.DISCONNECTED, error: err})];
		}
	}

	/*
	 * A base comet transport class
	 */
	function CometTransport(connectionManager, auth, params) {
		/* binary not supported for comet, so just fall back to default */
		params.format = undefined;
		params.heartbeats = true;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		/* streaming defaults to true */
		this.stream = ('stream' in params) ? params.stream : true;
		this.sendRequest = null;
		this.recvRequest = null;
		this.pendingCallback = null;
		this.pendingItems = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(CometTransport, _transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	CometTransport.REQ_SEND = REQ_SEND;
	CometTransport.REQ_RECV = REQ_RECV;
	CometTransport.REQ_RECV_POLL = REQ_RECV_POLL;
	CometTransport.REQ_RECV_STREAM = REQ_RECV_STREAM;

	/* public instance methods */
	CometTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'starting');
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var host = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getHost(options, params.host);
		var port = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getPort(options);
		var cometScheme = options.tls ? 'https://' : 'http://';

		this.baseUri = cometScheme + host + ':' + port + '/comet/';
		var connectUri = this.baseUri + 'connect';
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(err) {
				self.disconnect(err);
				return;
			}
			if(self.isDisposed) {
				return;
			}
			self.authParams = authParams;
			var connectParams = self.params.getConnectParams(authParams);
			if('stream' in connectParams) self.stream = connectParams.stream;
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(connectParams));

			/* this will be the 'recvRequest' so this connection can stream messages */
			var preconnected = false,
				connectRequest = self.recvRequest = self.createRequest(connectUri, null, connectParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV));

			connectRequest.on('data', function(data) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					return;
				}
				if(!preconnected) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onData(data);
			});
			connectRequest.on('complete', function(err, _body, headers) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					err = err || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]('Request cancelled', 80003, 400);
				}
				self.recvRequest = null;
				/* Connect request may complete without a emitting 'data' event since that is not
				 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
				if(!preconnected && !err) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onActivity();
				if(err) {
					if(err.code) {
						/* A protocol error received from realtime. TODO: once realtime
						 * consistendly sends errors wrapped in protocol messages, should be
						 * able to remove this */
						self.onData(protocolMessageFromRawError(err));
					} else {
						/* A network/xhr error. Don't bother wrapping in a protocol message,
						 * just disconnect the transport */
						self.disconnect(err);
					}
					return;
				}
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					self.recv();
				});
			});
			connectRequest.exec();
		});
	};

	CometTransport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestClose()');
		this._requestCloseOrDisconnect(true);
	};

	CometTransport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestDisconnect()');
		this._requestCloseOrDisconnect(false);
	};

	CometTransport.prototype._requestCloseOrDisconnect = function(closing) {
		var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
		if(closeOrDisconnectUri) {
			var self = this,
				request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, REQ_SEND);

			request.on('complete', function (err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
					self.finish('disconnected', err);
				}
			});
			request.exec();
		}
	};

	CometTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', '');
		if(!this.isDisposed) {
			this.isDisposed = true;
			if(this.recvRequest) {
				_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
				this.recvRequest.abort();
				this.recvRequest = null;
			}
			/* In almost all cases the transport will be finished before it's
			 * disposed. Finish here just to make sure. */
			this.finish('disconnected', _connectionerror__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].disconnected);
			var self = this;
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.emit('disposed');
			});
		}
	};

	CometTransport.prototype.onConnect = function(message) {
		/* if this transport has been disposed whilst awaiting connection, do nothing */
		if(this.isDisposed) {
			return;
		}

		/* the connectionKey in a comet connected response is really
		 * <instId>-<connectionKey> */
		var connectionStr = message.connectionKey;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.onConnect.call(this, message);

		var baseConnectionUri =  this.baseUri + connectionStr;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri + '; connectionKey = ' + message.connectionKey);
		this.sendUri = baseConnectionUri + '/send';
		this.recvUri = baseConnectionUri + '/recv';
		this.closeUri = baseConnectionUri + '/close';
		this.disconnectUri = baseConnectionUri + '/disconnect';
	};

	CometTransport.prototype.send = function(message) {
		if(this.sendRequest) {
			/* there is a pending send, so queue this message */
			this.pendingItems = this.pendingItems || [];
			this.pendingItems.push(message);
			return;
		}
		/* send this, plus any pending, now */
		var pendingItems = this.pendingItems || [];
		pendingItems.push(message);
		this.pendingItems = null;

		this.sendItems(pendingItems);
	};

	CometTransport.prototype.sendAnyPending = function() {
		var pendingItems = this.pendingItems;

		if(!pendingItems) {
			return;
		}

		this.pendingItems = null;
		this.sendItems(pendingItems);
	}

	CometTransport.prototype.sendItems = function(items) {
		var self = this,
			sendRequest = this.sendRequest = self.createRequest(self.sendUri, null, self.authParams, this.encodeRequest(items), REQ_SEND);

		sendRequest.on('complete', function(err, data) {
			if(err) _util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
			self.sendRequest = null;

			/* the result of the request, even if a nack, is usually a protocol response
			 * contained in the data. An err is anomolous, and indicates some issue with the
			 * network,transport, or connection */
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}

			if(data) {
				self.onData(data);
			}

			if(self.pendingItems) {
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					/* If there's a new send request by now, any pending items will have
					 * been picked up by that; any new ones added since then will be
					 * picked up after that one completes */
					if(!self.sendRequest) {
						self.sendAnyPending();
					}
				});
			}
		});
		sendRequest.exec();
	};

	CometTransport.prototype.recv = function() {
		/* do nothing if there is an active request, which might be streaming */
		if(this.recvRequest)
			return;

		/* If we're no longer connected, do nothing */
		if(!this.isConnected)
			return;

		var self = this,
			recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV_POLL));

		recvRequest.on('data', function(data) {
			self.onData(data);
		});
		recvRequest.on('complete', function(err) {
			self.recvRequest = null;
			/* A request completing must be considered activity, as realtime sends
			 * heartbeats every 15s since a request began, not every 15s absolutely */
			self.onActivity();
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.recv();
			});
		});
		recvRequest.exec();
	};

	CometTransport.prototype.onData = function(responseData) {
		try {
			var items = this.decodeResponse(responseData);
			if(items && items.length)
				for(var i = 0; i < items.length; i++)
					this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromDeserialized(items[i]));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
		}
	};

	CometTransport.prototype.encodeRequest = function(requestItems) {
		return JSON.stringify(requestItems);
	};

	CometTransport.prototype.decodeResponse = function(responseData) {
		if(typeof(responseData) == 'string')
			responseData = JSON.parse(responseData);
		return responseData;
	};

	/* For comet, we could do the auth update by aborting the current recv and
	 * starting a new one with the new token, that'd be sufficient for realtime.
	 * Problem is JSONP - you can't cancel truly abort a recv once started. So
	 * we need to send an AUTH for jsonp. In which case it's simpler to keep all
	 * comet transports the same and do it for all of them. So we send the AUTH
	 * instead, and don't need to abort the recv */
	CometTransport.prototype.onAuthUpdated = function(tokenDetails) {
		this.authParams = {access_token: tokenDetails.token};
	};

	return CometTransport;
})();

/* harmony default export */ __webpack_exports__["a"] = (CometTransport);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_169550__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_169550__(1);


var WebStorage = (function() {
	var sessionSupported,
		localSupported,
		test = 'ablyjs-storage-test';

	/* Even just accessing the session/localStorage object can throw a
	 * security exception in some circumstances with some browsers. In
	 * others, calling setItem will throw. So have to check in this
	 * somewhat roundabout way. (If unsupported or no global object,
	 * will throw on accessing a property of undefined) */
	try {
		global.sessionStorage.setItem(test, test);
		global.sessionStorage.removeItem(test);
		sessionSupported = true;
	} catch(e) {
		sessionSupported = false;
	}

	try {
		global.localStorage.setItem(test, test);
		global.localStorage.removeItem(test);
		localSupported = true;
	} catch(e) {
		localSupported = false;
	}

	function WebStorage() {}

	function storageInterface(session) {
		return session ? global.sessionStorage : global.localStorage;
	}

	function set(name, value, ttl, session) {
		var wrappedValue = {value: value};
		if(ttl) {
			wrappedValue.expires = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now() + ttl;
		}
		return storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
	}

	function get(name, session) {
		var rawItem = storageInterface(session).getItem(name);
		if(!rawItem) return null;
		var wrappedValue = JSON.parse(rawItem);
		if(wrappedValue.expires && (wrappedValue.expires < _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now())) {
			storageInterface(session).removeItem(name);
			return null;
		}
		return wrappedValue.value;
	}

	function remove(name, session) {
		return storageInterface(session).removeItem(name);
	}

	if(localSupported) {
		WebStorage.set    = function(name, value, ttl) { return set(name, value, ttl, false); };
		WebStorage.get    = function(name) { return get(name, false); };
		WebStorage.remove = function(name) { return remove(name, false); };
	}

	if(sessionSupported) {
		WebStorage.setSession    = function(name, value, ttl) { return set(name, value, ttl, true); };
		WebStorage.getSession    = function(name) { return get(name, true); };
		WebStorage.removeSession = function(name) { return remove(name, true); };
	}

	return WebStorage;
})();

/* harmony default export */ __webpack_exports__["a"] = (WebStorage);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_169550__(17)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_172673__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_172673__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_176709__) {

"use strict";
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_176709__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_176709__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_176709__(28);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_176709__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_176709__(3);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_176709__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_176709__(5);







var Crypto = (function() {
	var DEFAULT_ALGORITHM = 'aes';
	var DEFAULT_KEYLENGTH = 256; // bits
	var DEFAULT_MODE = 'cbc';
	var DEFAULT_BLOCKLENGTH = 16; // bytes
	var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
	var UINT32_SUP = 0x100000000;
	var INT32_SUP = 0x80000000;

	/**
	 * Internal: generate an array of secure random words corresponding to the given length of bytes
	 * @param bytes
	 * @param callback
	 */
	var generateRandom;
	if(platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray) {
		generateRandom = platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray;
	} else if(typeof Uint32Array !== 'undefined' && platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues) {
		var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
		generateRandom = function(bytes, callback) {
			var words = bytes / 4, nativeArray = (words == DEFAULT_BLOCKLENGTH_WORDS) ? blockRandomArray : new Uint32Array(words);
			platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues(nativeArray, function(err) {
				callback(err, platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(nativeArray))
			});
		};
	} else {
		generateRandom = function(bytes, callback) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MAJOR, 'Ably.Crypto.generateRandom()', 'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()');
			var words = bytes / 4, array = new Array(words);
			for(var i = 0; i < words; i++) {
				/* cryptojs wordarrays use signed ints. When WordArray.create is fed a
				* Uint32Array unsigned are converted to signed automatically, but when
				* fed a normal array they aren't, so need to do so ourselves by
				* subtracting INT32_SUP */
				array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
			}

			callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
		};
	}

	/**
	 * Internal: calculate the padded length of a given plaintext
	 * using PKCS5.
	 * @param plaintextLength
	 * @return
	 */
	function getPaddedLength(plaintextLength) {
		return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
	}

	/**
	 * Internal: checks that the cipherParams are a valid combination. Currently
	 * just checks that the calculated keyLength is a valid one for aes-cbc
	 */
	function validateCipherParams(params) {
		if(params.algorithm === 'aes' && params.mode === 'cbc') {
			if(params.keyLength === 128 || params.keyLength === 256) {
				return;
			}
			throw new Error('Unsupported key length ' + params.keyLength + ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)');
		}
	}

	function normaliseBase64(string) {
		/* url-safe base64 strings use _ and - instread of / and + */
		return string.replace('_', '/').replace('-', '+');
	}

	/**
	 * Internal: a block containing zeros
	 */
	var emptyBlock = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0,0,0,0]);

	/**
	 * Internal: obtain the pkcs5 padding string for a given padded length;
	 */
	var pkcs5Padding = [
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505,0x05000000], 5),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606,0x06060000], 6),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707,0x07070700], 7),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808,0x08080808], 8),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909,0x09090909,0x09000000], 9),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a,0x0a0a0a0a,0x0a0a0000], 10),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b,0x0b0b0b0b,0x0b0b0b00], 11),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c,0x0c0c0c0c,0x0c0c0c0c], 12),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d,0x0d0d0d0d,0x0d0d0d0d,0x0d000000], 13),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e,0x0e0e0e0e,0x0e0e0e0e,0x0e0e0000], 14),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f], 15),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16)
	];

	/**
	 * Utility classes and interfaces for message payload encryption.
	 *
	 * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
	 * but supporting other keylengths. Other algorithms and chaining modes are
	 * not supported directly, but supportable by extending/implementing the base
	 * classes and interfaces here.
	 *
	 * Secure random data for creation of Initialization Vectors (IVs) and keys
	 * is obtained from window.crypto.getRandomValues if available, or from
	 * Math.random() if not. Clients who do not want to depend on Math.random()
	 * should polyfill window.crypto.getRandomValues with a library that seeds
	 * a PRNG with real entropy.
	 *
	 * Each message payload is encrypted with an IV in CBC mode, and the IV is
	 * concatenated with the resulting raw ciphertext to construct the "ciphertext"
	 * data passed to the recipient.
	 */
	function Crypto() {}

	/**
	 * A class encapsulating the client-specifiable parameters for
	 * the cipher.
	 *
	 * algorithm is the name of the algorithm in the default system provider,
	 * or the lower-cased version of it; eg "aes" or "AES".
	 *
	 * Clients are recommended to not call this directly, but instead to use the
	 * Crypto.getDefaultParams helper, which will fill in any fields not supplied
	 * with default values and validation the result.
	 */
	function CipherParams() {
		this.algorithm = null;
		this.keyLength = null;
		this.mode = null;
		this.key = null;
	}
	Crypto.CipherParams = CipherParams;

	/**
	 * Obtain a complete CipherParams instance from the provided params, filling
	 * in any not provided with default values, calculating a keyLength from
	 * the supplied key, and validating the result.
	 * @param params an object containing at a minimum a `key` key with value the
	 * key, as either a binary (ArrayBuffer, Array, WordArray) or a
	 * base64-encoded string. May optionally also contain: algorithm (defaults to
	 * AES), mode (defaults to 'cbc')
	 */
	Crypto.getDefaultParams = function(params) {
		var key;
		/* Backward compatibility */
		if((typeof(params) === 'function') || (typeof(params) === 'string')) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
			if(typeof(params) === 'function') {
				Crypto.generateRandomKey(function(key) {
					params(null, Crypto.getDefaultParams({key: key}));
				})
			} else if(typeof arguments[1] === 'function') {
				arguments[1](null, Crypto.getDefaultParams({key: params}));
			} else {
				throw new Error('Invalid arguments for Crypto.getDefaultParams');
			}
			return;
		}

		if(!params.key) {
			throw new Error('Crypto.getDefaultParams: a key is required');
		}

		if (typeof(params.key) === 'string') {
			key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
		} else {
			key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
		}

		var cipherParams = new CipherParams();
		cipherParams.key = key;
		cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
		cipherParams.keyLength = key.words.length * (4 * 8);
		cipherParams.mode = params.mode || DEFAULT_MODE;

		if(params.keyLength && params.keyLength !== cipherParams.keyLength) {
			throw new Error('Crypto.getDefaultParams: a keyLength of ' + params.keyLength + ' was specified, but the key actually has length ' + cipherParams.keyLength);
		}

		validateCipherParams(cipherParams);
		return cipherParams;
	};

	/**
	 * Generate a random encryption key from the supplied keylength (or the
	 * default keyLength if none supplied) as a CryptoJS WordArray
	 * @param keyLength (optional) the required keyLength in bits
	 * @param callback (err, key)
	 */
	Crypto.generateRandomKey = function(keyLength, callback) {
		if(arguments.length == 1 && typeof(keyLength) == 'function') {
			callback = keyLength;
			keyLength = undefined;
		}
		generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, callback);
	};

	/**
	 * Internal; get a ChannelCipher instance based on the given cipherParams
	 * @param params either a CipherParams instance or some subset of its
	 * fields that includes a key
	 */
	Crypto.getCipher = function(params) {
		var cipherParams = (params instanceof CipherParams) ?
		                   params :
		                   Crypto.getDefaultParams(params);

		return {cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv)};
	};

	function CBCCipher(params, blockLengthWords, iv) {
		this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
		this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
		this.key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key);
		if(iv) {
			this.iv = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(iv).clone();
		}
		this.blockLengthWords = blockLengthWords;
	}

	CBCCipher.prototype.encrypt = function(plaintext, callback) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.encrypt()', '');
		plaintext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(plaintext);
		var plaintextLength = plaintext.sigBytes,
			paddedLength = getPaddedLength(plaintextLength),
			self = this;

		var then = function() {
			self.getIv(function(err, iv) {
				if (err) {
					callback(err);
					return;
				}
				var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
				var ciphertext = iv.concat(cipherOut);
				callback(null, ciphertext);
			});
		};

		if (!this.encryptCipher) {
			if(this.iv) {
				this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
				then();
			} else {
				generateRandom(DEFAULT_BLOCKLENGTH, function(err, iv) {
					if (err) {
						callback(err);
						return;
					}
					self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
					self.iv = iv;
					then();
				});
			}
		} else {
			then();
		}
	};

	CBCCipher.prototype.decrypt = function(ciphertext) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.decrypt()', '');
		ciphertext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(ciphertext);
		var blockLengthWords = this.blockLengthWords,
			ciphertextWords = ciphertext.words,
			iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
			ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

		var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
		var plaintext = decryptCipher.process(ciphertextBody);
		var epilogue = decryptCipher.finalize();
		decryptCipher.reset();
		if(epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
		return plaintext;
	};

	CBCCipher.prototype.getIv = function(callback) {
		if(this.iv) {
			var iv = this.iv;
			this.iv = null;
			callback(null, iv);
			return;
		}

		/* Since the iv for a new block is the ciphertext of the last, this
		* sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
		* returning it */
		var self = this;
		generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
			if (err) {
				callback(err);
				return;
			} 
			callback(null, self.encryptCipher.process(randomBlock));
		});
	};

	return Crypto;
})();

/* harmony default export */ __webpack_exports__["a"] = (Crypto);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_191402__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_191402__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_191402__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_191402__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_191402__(0);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_191402__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_191402__(2);







var Transport = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var closeMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.CLOSE});
	var disconnectMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.DISCONNECT});
	var noop = function() {};

	/*
	 * EventEmitter, generates the following events:
	 *
	 * event name       data
	 * closed           error
	 * failed           error
	 * disposed
	 * connected        null error, connectionSerial, connectionId, connectionDetails
	 * sync             connectionSerial, connectionId
	 * event            channel message object
	 */

	/* public constructor */
	function Transport(connectionManager, auth, params) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.connectionManager = connectionManager;
		connectionManager.registerProposedTransport(this);
		this.auth = auth;
		this.params = params;
		this.timeouts = params.options.timeouts;
		this.format = params.format;
		this.isConnected = false;
		this.isFinished = false;
		this.isDisposed = false;
		this.maxIdleInterval = null;
		this.idleTimer = null;
		this.lastActivity = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Transport, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Transport.prototype.connect = function() {};

	Transport.prototype.close = function() {
		if(this.isConnected) {
			this.requestClose();
		}
		this.finish('closed', _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].closed);
	};

	Transport.prototype.disconnect = function(err) {
		/* Used for network/transport issues that need to result in the transport
		 * being disconnected, but should not affect the connection */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('disconnected', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].disconnected);
	};

	Transport.prototype.fail = function(err) {
		/* Used for client-side-detected fatal connection issues */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('failed', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].failed);
	};

	Transport.prototype.finish = function(event, err) {
		if(this.isFinished) {
			return;
		}

		this.isFinished = true;
		this.isConnected = false;
		this.maxIdleInterval = null;
		clearTimeout(this.idleTimer);
		this.idleTimer = null;
		this.emit(event, err);
		this.dispose();
	};

	Transport.prototype.onProtocolMessage = function(message) {
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' + this.shortName + ': ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(message) + '; connectionId = ' + this.connectionManager.connectionId);
		}
		this.onActivity();

		switch(message.action) {
		case actions.HEARTBEAT:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
			this.emit('heartbeat', message.id);
			break;
		case actions.CONNECTED:
			this.onConnect(message);
			this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
			break;
		case actions.CLOSED:
			this.onClose(message);
			break;
		case actions.DISCONNECTED:
			this.onDisconnect(message);
			break;
		case actions.ACK:
			this.emit('ack', message.msgSerial, message.count);
			break;
		case actions.NACK:
			this.emit('nack', message.msgSerial, message.count, message.error);
			break;
		case actions.SYNC:
			if(message.connectionId !== undefined) {
				/* a transport SYNC */
				this.emit('sync', message.connectionId, message);
				break;
			}
			/* otherwise it's a channel SYNC, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		case actions.AUTH:
			this.auth.authorize(function(err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
				}
			});
			break;
		case actions.ERROR:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' + this.connectionManager.connectionId + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(message.error) + (message.channel ? (', channel: ' +  message.channel) : ''));
			if(message.channel === undefined) {
				this.onFatalError(message);
				break;
			}
			/* otherwise it's a channel-specific error, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		default:
			/* all other actions are channel-specific */
			this.connectionManager.onChannelMessage(message, this);
		}
	};

	Transport.prototype.onConnect = function(message) {
		this.isConnected = true;
		var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
		if(maxPromisedIdle) {
			this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
			this.onActivity();
		}
		/* else Realtime declines to guarantee any maximum idle interval - CD2h */
	};

	Transport.prototype.onDisconnect = function(message) {
		/* Used for when the server has disconnected the client (usually with a
		 * DISCONNECTED action) */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('disconnected', err);
	};

	Transport.prototype.onFatalError = function(message) {
		/* On receipt of a fatal connection error, we can assume that the server
		 * will close the connection and the transport, and do not need to request
		 * a disconnection - RTN15i */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onFatalError()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('failed', err);
	};

	Transport.prototype.onClose = function(message) {
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onClose()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('closed', err);
	};

	Transport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestClose()', '');
		this.send(closeMessage);
	};

	Transport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestDisconnect()', '');
		this.send(disconnectMessage);
	};

	Transport.prototype.ping = function(id) {
		var msg = {action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action.HEARTBEAT};
		if(id) msg.id = id;
		this.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues(msg));
	};

	Transport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.dispose()', '');
		this.isDisposed = true;
		this.off();
	};

	Transport.prototype.onActivity = function() {
		if(!this.maxIdleInterval) { return; }
		this.lastActivity = this.connectionManager.lastActivity = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
		this.setIdleTimer(this.maxIdleInterval + 100);
	};

	Transport.prototype.setIdleTimer = function(timeout) {
		var self = this;
		if(!this.idleTimer) {
			this.idleTimer = setTimeout(function() {
				self.onIdleTimerExpire();
			}, timeout);
		}
	};

	Transport.prototype.onIdleTimerExpire = function() {
		this.idleTimer = null;
		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity,
			timeRemaining = this.maxIdleInterval - sinceLast;
		if(timeRemaining <= 0) {
			var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
			this.disconnect(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"](msg, 80003, 408));
		} else {
			this.setIdleTimer(timeRemaining + 100);
		}
	};

	Transport.prototype.onAuthUpdated = function() {};

	return Transport;
})();

/* harmony default export */ __webpack_exports__["a"] = (Transport);


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var ConnectionStateChange = (function() {

	/* public constructor */
	function ConnectionStateChange(previous, current, retryIn, reason) {
		this.previous = previous;
		this.current = current;
		if(retryIn) this.retryIn = retryIn;
		if(reason) this.reason = reason;
	}

	return ConnectionStateChange;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionStateChange);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_202483__) {

"use strict";
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_202483__(0);


var Multicaster = (function() {

	function Multicaster(members) {
		members = members || [];

		var handler = function() {
			for(var i = 0; i < members.length; i++) {
				var member = members[i];
				if(member) {
					try {
						member.apply(null, arguments);
					} catch(e){
						_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
					}
				}
			}
		};

		handler.push = function() {
			Array.prototype.push.apply(members, arguments);
		};
		return handler;
	}

	return Multicaster;
})();

/* harmony default export */ __webpack_exports__["a"] = (Multicaster);


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_203423__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_203423__(1);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_203423__(3);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_203423__(4);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_203423__(0);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_203423__(6);






var ErrorReporter = (function() {
	function ErrorReporter() {}

	var levels = ErrorReporter.levels = [
		'fatal',
		'error',
		'warning',
		'info',
		'debug'
	];

	/* (level: typeof ErrorReporter.levels[number], message: string, fingerprint?: string, tags?: {[key: string]: string}): void */
	ErrorReporter.report = function(level, message, fingerprint, tags) {
		var eventId = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].randomHexString(16);

		var event = {
			event_id: eventId,
			tags: _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin({
				ablyAgent: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].agent
			}, tags),
			platform: 'javascript',
			level: level,
			release: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].version,
			fingerprint: fingerprint && [ fingerprint ],
			message: message,
			request: {
				headers: {
					'User-Agent': platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].userAgent
				},
				url: platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].currentUrl
			}
		};

		_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter: ' + message);
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].postUri(null, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingUrl, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingHeaders, JSON.stringify(event), {}, function(err, res) {
			_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter resulted in: ' +
				(err ? _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err) : _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectBody(res))
			);
		});
	};

	return ErrorReporter;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorReporter);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var msgpack = (function() {
	"use strict";

	var exports = {};

	exports.inspect = inspect;
	function inspect(buffer) {
		if (buffer === undefined)
			return "undefined";
		var view;
		var type;
		if ( buffer instanceof ArrayBuffer) {
			type = "ArrayBuffer";
			view = new DataView(buffer);
		} else if ( buffer instanceof DataView) {
			type = "DataView";
			view = buffer;
		}
		if (!view)
			return JSON.stringify(buffer);
		var bytes = [];
		for (var i = 0; i < buffer.byteLength; i++) {
			if (i > 20) {
				bytes.push("...");
				break;
			}
			var byte_ = view.getUint8(i).toString(16);
			if (byte_.length === 1)
				byte_ = "0" + byte_;
			bytes.push(byte_);
		}
		return "<" + type + " " + bytes.join(" ") + ">";
	}

	// Encode string as utf8 into dataview at offset
	exports.utf8Write = utf8Write;
	function utf8Write(view, offset, string) {
		var byteLength = view.byteLength;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);

			// One byte of UTF-8
			if (codePoint < 0x80) {
				view.setUint8(offset++, codePoint >>> 0 & 0x7f | 0x00);
				continue;
			}

			// Two bytes of UTF-8
			if (codePoint < 0x800) {
				view.setUint8(offset++, codePoint >>> 6 & 0x1f | 0xc0);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Three bytes of UTF-8.
			if (codePoint < 0x10000) {
				view.setUint8(offset++, codePoint >>> 12 & 0x0f | 0xe0);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Four bytes of UTF-8
			if (codePoint < 0x110000) {
				view.setUint8(offset++, codePoint >>> 18 & 0x07 | 0xf0);
				view.setUint8(offset++, codePoint >>> 12 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
	}


	exports.utf8Read = utf8Read;
	function utf8Read(view, offset, length) {
		var string = "";
		for (var i = offset, end = offset + length; i < end; i++) {
			var byte_ = view.getUint8(i);
			// One byte character
			if ((byte_ & 0x80) === 0x00) {
				string += String.fromCharCode(byte_);
				continue;
			}
			// Two byte character
			if ((byte_ & 0xe0) === 0xc0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
				continue;
			}
			// Three byte character
			if ((byte_ & 0xf0) === 0xe0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			// Four byte character
			if ((byte_ & 0xf8) === 0xf0) {
				string += String.fromCharCode(((byte_ & 0x07) << 18) | ((view.getUint8(++i) & 0x3f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			throw new Error("Invalid byte " + byte_.toString(16));
		}
		return string;
	}


	exports.utf8ByteCount = utf8ByteCount;
	function utf8ByteCount(string) {
		var count = 0;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);
			if (codePoint < 0x80) {
				count += 1;
				continue;
			}
			if (codePoint < 0x800) {
				count += 2;
				continue;
			}
			if (codePoint < 0x10000) {
				count += 3;
				continue;
			}
			if (codePoint < 0x110000) {
				count += 4;
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
		return count;
	}


	exports.encode = function(value, sparse) {
		var size = sizeof(value, sparse);
		if(size == 0)
			return undefined;
		var buffer = new ArrayBuffer(size);
		var view = new DataView(buffer);
		encode(value, view, 0, sparse);
		return buffer;
	};

	exports.decode = decode;

	var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
	function getInt64(view, offset) {
		offset = offset || 0;
		return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function getUint64(view, offset) {
		offset = offset || 0;
		return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function setInt64(view, offset, val) {
		if (val < 0x8000000000000000) {
			view.setInt32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0x7fffffff);
			view.setUint32(offset + 4, 0x7fffffff);
		}
	}

	function setUint64(view, offset, val) {
		if (val < 0x10000000000000000) {
			view.setUint32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0xffffffff);
			view.setUint32(offset + 4, 0xffffffff);
		}
	}

// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//

	function Decoder(view, offset) {
		this.offset = offset || 0;
		this.view = view;
	}


	Decoder.prototype.map = function(length) {
		var value = {};
		for (var i = 0; i < length; i++) {
			var key = this.parse();
			value[key] = this.parse();
		}
		return value;
	};

	Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
		var value = new ArrayBuffer(length);
		(new Uint8Array(value)).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
		this.offset += length;
		return value;
	};

	Decoder.prototype.str = function(length) {
		var value = utf8Read(this.view, this.offset, length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.array = function(length) {
		var value = new Array(length);
		for (var i = 0; i < length; i++) {
			value[i] = this.parse();
		}
		return value;
	};

	Decoder.prototype.ext = function(length) {
		var value = {};
		// Get the type byte
		value['type'] = this.view.getInt8(this.offset);
		this.offset++;
		// Get the data array (length)
		value['data'] = this.buf(length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.parse = function() {
		var type = this.view.getUint8(this.offset);
		var value, length;

		// Positive FixInt - 0xxxxxxx
		if ((type & 0x80) === 0x00) {
			this.offset++;
			return type;
		}

		// FixMap - 1000xxxx
		if ((type & 0xf0) === 0x80) {
			length = type & 0x0f;
			this.offset++;
			return this.map(length);
		}

		// FixArray - 1001xxxx
		if ((type & 0xf0) === 0x90) {
			length = type & 0x0f;
			this.offset++;
			return this.array(length);
		}

		// FixStr - 101xxxxx
		if ((type & 0xe0) === 0xa0) {
			length = type & 0x1f;
			this.offset++;
			return this.str(length);
		}

		// Negative FixInt - 111xxxxx
		if ((type & 0xe0) === 0xe0) {
			value = this.view.getInt8(this.offset);
			this.offset++;
			return value;
		}

		switch (type) {

			// nil
			case 0xc0:
				this.offset++;
				return null;

			// 0xc1 never used - use for undefined (NON-STANDARD)
			case 0xc1:
				this.offset++;
				return undefined;

			// false
			case 0xc2:
				this.offset++;
				return false;

			// true
			case 0xc3:
				this.offset++;
				return true;

			// bin 8
			case 0xc4:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.bin(length);

			// bin 16
			case 0xc5:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.bin(length);

			// bin 32
			case 0xc6:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.bin(length);

			// ext 8
			case 0xc7:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.ext(length);

			// ext 16
			case 0xc8:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.ext(length);

			// ext 32
			case 0xc9:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.ext(length);

			// float 32
			case 0xca:
				value = this.view.getFloat32(this.offset + 1);
				this.offset += 5;
				return value;

			// float 64
			case 0xcb:
				value = this.view.getFloat64(this.offset + 1);
				this.offset += 9;
				return value;

			// uint8
			case 0xcc:
				value = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return value;

			// uint 16
			case 0xcd:
				value = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return value;

			// uint 32
			case 0xce:
				value = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return value;

			// uint 64
			case 0xcf:
				value = getUint64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// int 8
			case 0xd0:
				value = this.view.getInt8(this.offset + 1);
				this.offset += 2;
				return value;

			// int 16
			case 0xd1:
				value = this.view.getInt16(this.offset + 1);
				this.offset += 3;
				return value;

			// int 32
			case 0xd2:
				value = this.view.getInt32(this.offset + 1);
				this.offset += 5;
				return value;

			// int 64
			case 0xd3:
				value = getInt64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// fixext 1
			case 0xd4:
				length = 1;
				this.offset++;
				return this.ext(length);

			// fixext 2
			case 0xd5:
				length = 2;
				this.offset++;
				return this.ext(length);

			// fixext 4
			case 0xd6:
				length = 4;
				this.offset++;
				return this.ext(length);

			// fixext 8
			case 0xd7:
				length = 8;
				this.offset++;
				return this.ext(length);

			// fixext 16
			case 0xd8:
				length = 16;
				this.offset++;
				return this.ext(length);

			// str8
			case 0xd9:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.str(length);

			// str 16
			case 0xda:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.str(length);

			// str 32
			case 0xdb:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.str(length);

			// array 16
			case 0xdc:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.array(length);

			// array 32
			case 0xdd:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.array(length);

			// map 16
			case 0xde:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.map(length);

			// map 32
			case 0xdf:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.map(length);
		}
		throw new Error("Unknown type 0x" + type.toString(16));
	};

	function decode(buffer) {
		var view = new DataView(buffer);
		var decoder = new Decoder(view);
		var value = decoder.parse();
		if (decoder.offset !== buffer.byteLength)
			throw new Error((buffer.byteLength - decoder.offset) + " trailing bytes");
		return value;
	}

	function encodeableKeys(value, sparse) {
		var keys = []; // TODO: use Object.keys when we are able to transpile to ES3
		for (var key in value) {
			if (!value.hasOwnProperty(key)) continue;
			keys.push(key);
		}
		return keys.filter(function (e) {
			var val = value[e], type = typeof(val);
			return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
		})
	}

	function encode(value, view, offset, sparse) {
		var type = typeof value;

		// Strings Bytes
		// There are four string types: fixstr/str8/str16/str32
		if (type === "string") {
			var length = utf8ByteCount(value);

			// fixstr
			if (length < 0x20) {
				view.setUint8(offset, length | 0xa0);
				utf8Write(view, offset + 1, value);
				return 1 + length;
			}

			// str8
			if (length < 0x100) {
				view.setUint8(offset, 0xd9);
				view.setUint8(offset + 1, length);
				utf8Write(view, offset + 2, value);
				return 2 + length;
			}

			// str16
			if (length < 0x10000) {
				view.setUint8(offset, 0xda);
				view.setUint16(offset + 1, length);
				utf8Write(view, offset + 3, value);
				return 3 + length;
			}
			// str32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xdb);
				view.setUint32(offset + 1, length);
				utf8Write(view, offset + 5, value);
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// There are three bin types: bin8/bin16/bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;

			// bin8
			if (length < 0x100) {
				view.setUint8(offset, 0xc4);
				view.setUint8(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 2);
				return 2 + length;
			}

			// bin16
			if (length < 0x10000) {
				view.setUint8(offset, 0xc5);
				view.setUint16(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 3);
				return 3 + length;
			}

			// bin 32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xc6);
				view.setUint32(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 5);
				return 5 + length;
			}
		}

		if (type === "number") {

			// Floating Point
			// NOTE: We're always using float64
			if (Math.floor(value) !== value) {
				view.setUint8(offset, 0xcb);
				view.setFloat64(offset + 1, value);
				return 9;
			}

			// Integers
			if (value >= 0) {
				// positive fixnum
				if (value < 0x80) {
					view.setUint8(offset, value);
					return 1;
				}
				// uint 8
				if (value < 0x100) {
					view.setUint8(offset, 0xcc);
					view.setUint8(offset + 1, value);
					return 2;
				}
				// uint 16
				if (value < 0x10000) {
					view.setUint8(offset, 0xcd);
					view.setUint16(offset + 1, value);
					return 3;
				}
				// uint 32
				if (value < 0x100000000) {
					view.setUint8(offset, 0xce);
					view.setUint32(offset + 1, value);
					return 5;
				}
				// uint 64
				if (value < 0x10000000000000000) {
					view.setUint8(offset, 0xcf);
					setUint64(view, offset + 1, value);
					return 9;
				}
				throw new Error("Number too big 0x" + value.toString(16));
			}

			// negative fixnum
			if (value >= -0x20) {
				view.setInt8(offset, value);
				return 1;
			}
			// int 8
			if (value >= -0x80) {
				view.setUint8(offset, 0xd0);
				view.setInt8(offset + 1, value);
				return 2;
			}
			// int 16
			if (value >= -0x8000) {
				view.setUint8(offset, 0xd1);
				view.setInt16(offset + 1, value);
				return 3;
			}
			// int 32
			if (value >= -0x80000000) {
				view.setUint8(offset, 0xd2);
				view.setInt32(offset + 1, value);
				return 5;
			}
			// int 64
			if (value >= -0x8000000000000000) {
				view.setUint8(offset, 0xd3);
				setInt64(view, offset + 1, value);
				return 9;
			}
			throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
		}

		// undefined - use d4 (NON-STANDARD)
		if (type === "undefined") {
			if(sparse) return 0;
			view.setUint8(offset, 0xd4);
			view.setUint8(offset + 1, 0x00);
			view.setUint8(offset + 2, 0x00);
			return 3;
		}

		// null
		if (value === null) {
			if(sparse) return 0;
			view.setUint8(offset, 0xc0);
			return 1;
		}

		// Boolean
		if (type === "boolean") {
			view.setUint8(offset, value ? 0xc3 : 0xc2);
			return 1;
		}

		if('function' === typeof value.toJSON)
			return encode(value.toJSON(), view, offset, sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			var isArray = Array.isArray(value);

			if (isArray) {
				length = value.length;
			} else {
				var keys = encodeableKeys(value, sparse);
				length = keys.length;
			}

			var size;
			if (length < 0x10) {
				view.setUint8(offset, length | ( isArray ? 0x90 : 0x80));
				size = 1;
			} else if (length < 0x10000) {
				view.setUint8(offset, isArray ? 0xdc : 0xde);
				view.setUint16(offset + 1, length);
				size = 3;
			} else if (length < 0x100000000) {
				view.setUint8(offset, isArray ? 0xdd : 0xdf);
				view.setUint32(offset + 1, length);
				size = 5;
			}

			if (isArray) {
				for (var i = 0; i < length; i++) {
					size += encode(value[i], view, offset + size, sparse);
				}
			} else {
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += encode(key, view, offset + size);
					size += encode(value[key], view, offset + size, sparse);
				}
			}

			return size;
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	function sizeof(value, sparse) {
		var type = typeof value;

		// fixstr or str8 or str16 or str32
		if (type === "string") {
			var length = utf8ByteCount(value);
			if (length < 0x20) {
				return 1 + length;
			}
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// bin8 or bin16 or bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if (type === "number") {
			// Floating Point (32 bits)
			// double
			if (Math.floor(value) !== value)
				return 9;

			// Integers
			if (value >= 0) {
				// positive fixint
				if (value < 0x80)
					return 1;
				// uint 8
				if (value < 0x100)
					return 2;
				// uint 16
				if (value < 0x10000)
					return 3;
				// uint 32
				if (value < 0x100000000)
					return 5;
				// uint 64
				if (value < 0x10000000000000000)
					return 9;
				// Too big
				throw new Error("Number too big 0x" + value.toString(16));
			}
			// negative fixint
			if (value >= -0x20)
				return 1;
			// int 8
			if (value >= -0x80)
				return 2;
			// int 16
			if (value >= -0x8000)
				return 3;
			// int 32
			if (value >= -0x80000000)
				return 5;
			// int 64
			if (value >= -0x8000000000000000)
				return 9;
			// Too small
			throw new Error("Number too small -0x" + value.toString(16).substr(1));
		}

		// Boolean
		if (type === "boolean") return 1;

		// undefined, null
		if (value === null) return sparse ? 0 : 1;
		if (value === undefined) return sparse ? 0 : 3;

		if('function' === typeof value.toJSON)
			return sizeof(value.toJSON(), sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			if (Array.isArray(value)) {
				length = value.length;
				for (var i = 0; i < length; i++) {
					size += sizeof(value[i], sparse);
				}
			} else {
				var keys = encodeableKeys(value, sparse)
				length = keys.length;
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += sizeof(key) + sizeof(value[key], sparse);
				}
			}
			if (length < 0x10) {
				return 1 + size;
			}
			if (length < 0x10000) {
				return 3 + size;
			}
			if (length < 0x100000000) {
				return 5 + size;
			}
			throw new Error("Array or object too long 0x" + length.toString(16));
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	return exports;
})();

/* harmony default export */ __webpack_exports__["a"] = (msgpack);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_225303__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_225303__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_225303__(1);
/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_225303__(34);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_225303__(4);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_225303__(3);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_225303__(7);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_225303__(26);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_225303__(0);
/* harmony import */ var _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_225303__(21);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_225303__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_225303__(2);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_225303__(14);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_225303__(6);
/* harmony import */ var _types_message__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_225303__(9);
/* harmony import */ var _util_multicaster__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_225303__(22);
/* harmony import */ var _util_errorreporter__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_225303__(23);
/* harmony import */ var platform_webstorage__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_225303__(16);
/* harmony import */ var platform_transports__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_225303__(41);
/* harmony import */ var _websockettransport__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_225303__(40);




















var ConnectionManager = (function() {
	var haveWebStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get);
	var haveSessionStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession);
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var PendingMessage = _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].PendingMessage;
	var noop = function() {};
	var transportPreferenceOrder = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].transportPreferenceOrder;
	var optimalTransport = transportPreferenceOrder[transportPreferenceOrder.length - 1];
	var transportPreferenceName = 'ably-transport-preference';

	var sessionRecoveryName = 'ably-connection-recovery';
	function getSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession(sessionRecoveryName);
	}
	function setSessionRecoverData(value) {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].setSession(sessionRecoveryName, value);
	}
	function clearSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].removeSession(sessionRecoveryName);
	}

	function betterTransportThan(a, b) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, a.shortName) >
		   _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, b.shortName);
	}

	function TransportParams(options, host, mode, connectionKey) {
		this.options = options;
		this.host = host;
		this.mode = mode;
		this.connectionKey = connectionKey;
		this.format = options.useBinaryProtocol ? 'msgpack' : 'json';

		this.connectionSerial = undefined;
		this.timeSerial = undefined;
	}

	TransportParams.prototype.getConnectParams = function(authParams) {
		var params = authParams ? _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].copy(authParams) : {};
		var options = this.options;
		switch(this.mode) {
			case 'upgrade':
				params.upgrade = this.connectionKey;
				break;
			case 'resume':
				params.resume = this.connectionKey;
				if(this.timeSerial !== undefined) {
					params.timeSerial = this.timeSerial;
				} else if(this.connectionSerial !== undefined) {
					params.connectionSerial = this.connectionSerial;
				}
				break;
			case 'recover':
				var match = options.recover.split(':');
				if(match) {
					params.recover = match[0];
					var recoverSerial = match[1];
					if(isNaN(recoverSerial)) {
						params.timeSerial = recoverSerial;
					} else {
						params.connectionSerial = recoverSerial;
					}
				}
				break;
			default:
		}
		if(options.clientId !== undefined) {
			params.clientId = options.clientId;
		}
		if(options.echoMessages === false) {
			params.echo = 'false';
		}
		if(this.format !== undefined) {
			params.format = this.format;
		}
		if(this.stream !== undefined) {
			params.stream = this.stream;
		}
		if(this.heartbeats !== undefined) {
			params.heartbeats = this.heartbeats;
		}
		params.v = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].apiVersion;
		params.agent = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].agent;
		if(options.transportParams !== undefined) {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(params, options.transportParams);
		}
		return params;
	};

	TransportParams.prototype.toString = function() {
		var result = '[mode=' + this.mode;
		if(this.host) { result += (',host=' + this.host); }
		if(this.connectionKey) { result += (',connectionKey=' + this.connectionKey); }
		if(this.connectionSerial !== undefined) { result += (',connectionSerial=' + this.connectionSerial); }
		if(this.timeSerial) { result += (',timeSerial=' + this.timeSerial); }
		if(this.format) { result += (',format=' + this.format); }
		result += ']';

		return result;
	};

	/* public constructor */
	function ConnectionManager(realtime, options) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].call(this);
		this.realtime = realtime;
		this.options = options;
		var timeouts = options.timeouts;
		var self = this;
		/* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
		 * preference transport, then realtimeRequestTimeout (~10s) to establish
		 * the base transport in case that fails */
		var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
		this.states = {
			initialized:   {state: 'initialized',   terminal: false, queueEvents: true,  sendEvents: false, failState: 'disconnected'},
			connecting:    {state: 'connecting',    terminal: false, queueEvents: true,  sendEvents: false, retryDelay: connectingTimeout, failState: 'disconnected'},
			connected:     {state: 'connected',     terminal: false, queueEvents: false, sendEvents: true,  failState: 'disconnected'},
			synchronizing: {state: 'connected',     terminal: false, queueEvents: true,  sendEvents: false, forceQueueEvents: true, failState: 'disconnected'},
			disconnected:  {state: 'disconnected',  terminal: false, queueEvents: true,  sendEvents: false, retryDelay: timeouts.disconnectedRetryTimeout, failState: 'disconnected'},
			suspended:     {state: 'suspended',     terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.suspendedRetryTimeout, failState: 'suspended'},
			closing:       {state: 'closing',       terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.realtimeRequestTimeout, failState: 'closed'},
			closed:        {state: 'closed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'closed'},
			failed:        {state: 'failed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'failed'}
		};
		this.state = this.states.initialized;
		this.errorReason = null;

		this.queuedMessages = new _messagequeue__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]();
		this.msgSerial = 0;
		this.connectionDetails = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.timeSerial = undefined;
		this.connectionSerial = undefined;
		this.connectionStateTtl = timeouts.connectionStateTtl;
		this.maxIdleInterval = null;

		this.transports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect((options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports), ConnectionManager.supportedTransports);
		/* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
		* that's both requested and supported. Normally this will be xhr_polling;
		* if xhr isn't supported it will be jsonp. If the user has forced a
		* transport, it'll just be that one. */
		this.baseTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].baseTransportOrder, this.transports)[0];
		this.upgradeTransports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(this.transports, _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports);
		this.transportPreference = null;

		this.httpHosts = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHosts(options);
		this.activeProtocol = null;
		this.proposedTransports = [];
		this.pendingTransports = [];
		this.host = null;
		this.lastAutoReconnectAttempt = null;
		this.lastActivity = null;
		this.mostRecentMsg = null;
		this.forceFallbackHost = false;
		this.connectCounter = 0;

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports) + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + this.transports + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');

		if(!this.transports.length) {
			var msg = 'no requested transports available';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'realtime.ConnectionManager()', msg);
			throw new Error(msg);
		}

		var addEventListener = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].addEventListener;
		if(addEventListener) {
			/* intercept close event in browser to persist connection id if requested */
			if(haveSessionStorage && typeof options.recover === 'function') {
				/* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
				addEventListener('beforeunload', this.persistConnection.bind(this));
			}

			if(options.closeOnUnload === true) {
				addEventListener('beforeunload', function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
					self.requestState({state: 'closing'});
				});
			}

			/* Listen for online and offline events */
			addEventListener('online', function() {
				if(self.state == self.states.disconnected || self.state == self.states.suspended) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser ‘online’ event', 'reattempting connection');
					self.requestState({state: 'connecting'});
				}
			});
			addEventListener('offline', function() {
				if(self.state == self.states.connected) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser ‘offline’ event', 'disconnecting active transport');
					// Not sufficient to just go to the 'disconnected' state, want to
					// force all transports to reattempt the connection. Will immediately
					// retry.
					self.disconnectAllTransports();
				}
			});
		}
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(ConnectionManager, _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);

	/*********************
	 * transport management
	 *********************/

	ConnectionManager.supportedTransports = {};

	Object(_websockettransport__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(ConnectionManager);
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(platform_transports__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"], function (initFn) {
		initFn(ConnectionManager);
	});

	ConnectionManager.prototype.createTransportParams = function(host, mode) {
		var params = new TransportParams(this.options, host, mode, this.connectionKey);
		if(this.timeSerial) {
			params.timeSerial = this.timeSerial;
		} else if(this.connectionSerial !== undefined) {
			params.connectionSerial = this.connectionSerial;
		}
		return params;
	};

	ConnectionManager.prototype.getTransportParams = function(callback) {
		var self = this;

		function decideMode(modeCb) {
			if(self.connectionKey) {
				modeCb('resume');
				return;
			}

			if(typeof self.options.recover === 'string') {
				modeCb('recover');
				return;
			}

			var recoverFn = self.options.recover,
				lastSessionData = getSessionRecoverData();
			if(lastSessionData && typeof(recoverFn) === 'function') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
				recoverFn(lastSessionData, function(shouldRecover) {
					if(shouldRecover) {
						self.options.recover = lastSessionData.recoveryKey;
						modeCb('recover');
					} else {
						modeCb('clean');
					}
				});
				return;
			}
			modeCb('clean');
		}

		decideMode(function(mode) {
			var transportParams = self.createTransportParams(null, mode);
			if(mode === 'recover') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + self.options.recover);
				var match = self.options.recover.split(':');
				if(match && match[2]) {
					self.msgSerial = match[2];
				}
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
			}
			callback(transportParams);
		});
	};

	/**
	 * Attempt to connect using a given transport
	 * @param transportParams
	 * @param candidate, the transport to try
	 * @param callback
	 */
	ConnectionManager.prototype.tryATransport = function(transportParams, candidate, callback) {
		var self = this, host = transportParams.host;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
		(ConnectionManager.supportedTransports[candidate]).tryConnect(this, this.realtime.auth, transportParams, function(wrappedErr, transport) {
			var state = self.state;
			if(state == self.states.closing || state == self.states.closed || state == self.states.failed) {
				if(transport) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
					transport.close();
				}
				callback(true);
				return;
			}

			if(wrappedErr) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());

				/* Comet transport onconnect token errors can be dealt with here.
				* Websocket ones only happen after the transport claims to be viable,
				* so are dealt with as non-onconnect token errors */
				if(_client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(wrappedErr.error) && !(self.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(self.errorReason))) {
					self.errorReason = wrappedErr.error;
					/* re-get a token and try again */
					self.realtime.auth._forceNewToken(null, null, function(err) {
						if(err) {
							self.actOnErrorFromAuthorize(err);
							return;
						}
						self.tryATransport(transportParams, candidate, callback);
					});
				} else if(wrappedErr.event === 'failed') {
					/* Error that's fatal to the connection */
					self.notifyState({state: 'failed', error: wrappedErr.error});
					callback(true);
				} else if(wrappedErr.event === 'disconnected') {
					if(!_transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].isRetriable(wrappedErr.error)) {
						/* Error received from the server that does not call for trying a fallback host, eg a rate limit */
						self.notifyState({state: self.states.connecting.failState, error: wrappedErr.error});
						callback(true);
					} else {
						/* Error with that transport only; continue trying other fallback hosts */
						callback(false);
					}
				}
				return;
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
			self.setTransportPending(transport, transportParams);
			callback(null, transport);
		});
	};


	/**
	 * Called when a transport is indicated to be viable, and the connectionmanager
	 * expects to activate this transport as soon as it is connected.
	 * @param host
	 * @param transportParams
	 */
	ConnectionManager.prototype.setTransportPending = function(transport, transportParams) {
		var mode = transportParams.mode;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport);
		this.pendingTransports.push(transport);

		var self = this;
		transport.once('connected', function(error, connectionId, connectionDetails, connectionPosition) {
			if(mode == 'upgrade' && self.activeProtocol) {
				/*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
				if(transport.shortName !== optimalTransport && _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(self.getUpgradePossibilities(), optimalTransport)) {
					setTimeout(function() {
						self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
					}, self.options.timeouts.parallelUpgradeDelay);
				} else {
					self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
				}
			} else {
				self.activateTransport(error, transport, connectionId, connectionDetails, connectionPosition);

				/* allow connectImpl to start the upgrade process if needed, but allow
				 * other event handlers, including activating the transport, to run first */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.connectImpl(transportParams);
				});
			}

			if(mode === 'recover' && self.options.recover) {
				/* After a successful recovery, we unpersist, as a recovery key cannot
				* be used more than once */
				self.options.recover = null;
				self.unpersistConnection();
			}
		});

		transport.on(['disconnected', 'closed', 'failed'], function(error) {
			self.deactivateTransport(transport, this.event, error);
		});

		this.emit('transport.pending', transport);
	};

	/**
	 * Called when an upgrade transport is connected,
	 * to schedule the activation of that transport.
	 * @param error
	 * @param transport
	 * @param connectionId
	 * @param connectionDetails
	 * @param connectedMessage
	 */
	ConnectionManager.prototype.scheduleTransportActivation = function(error, transport, connectionId, connectionDetails, upgradeConnectionPosition) {
		var self = this,
			currentTransport = this.activeProtocol && this.activeProtocol.getTransport(),
			abandon = function() {
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			};

		if(this.state !== this.states.connected && this.state !== this.states.connecting) {
			/* This is most likely to happen for the delayed xhrs, when xhrs and ws are scheduled in parallel*/
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + this.state.state + (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
			abandon();
			return;
		}

		if(currentTransport && !betterTransportThan(transport, currentTransport)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + ' is no better than current active transport ' + currentTransport.shortName + ' - abandoning upgrade');
			abandon();
			return;
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);

		this.realtime.channels.onceNopending(function(err) {
			var oldProtocol;
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unable to activate transport; transport = ' + transport + '; err = ' + err);
				return;
			}

			if(!transport.isConnected) {
				/* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
				abandon();
				return;
			}

			if(self.state === self.states.connected) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
				self.state = self.states.synchronizing;
				oldProtocol = self.activeProtocol;
			} else if(self.state !== self.states.connecting) {
				/* Note: upgrading from the connecting state is valid if the old active
				* transport was deactivated after the upgrade transport first connected;
				* see logic in deactivateTransport */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + self.state.state + (self.state === self.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
				abandon();
				return;
			}

			/* If the connectionId has changed, the upgrade hasn't worked. But as
			* it's still an upgrade, realtime still expects a sync - it just needs to
			* be a sync with the new connection position. (And it
			* needs to be set in the library, which is done by activateTransport). */
			var connectionReset = connectionId !== self.connectionId,
				syncPosition = connectionReset ? upgradeConnectionPosition : self;

			if(connectionReset) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Upgrade resulted in new connectionId; resetting library connection position from ' + (self.timeSerial || self.connectionSerial) + ' to ' + (syncPosition.timeSerial || syncPosition.connectionSerial) + '; upgrade error was ' + error);
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
			self.sync(transport, syncPosition, function(syncErr, connectionId, postSyncPosition) {
				/* If there's been some problem with syncing (and the connection hasn't
				 * closed or something in the meantime), we have a problem -- we can't
				 * just fall back on the old transport, as we don't know whether
				 * realtime got the sync -- if it did, the old transport is no longer
				 * valid. To be safe, we disconnect both and start again from scratch. */
				if(syncErr) {
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unexpected error attempting to sync transport; transport = ' + transport + '; err = ' + syncErr);
						self.disconnectAllTransports();
					}
					return;
				}
				var finishUpgrade = function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
					self.activateTransport(error, transport, connectionId, connectionDetails, postSyncPosition);
					/* Restore pre-sync state. If state has changed in the meantime,
					 * don't touch it -- since the websocket transport waits a tick before
					 * disposing itself, it's possible for it to have happily synced
					 * without err while, unknown to it, the connection has closed in the
					 * meantime and the ws transport is scheduled for death */
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
						self.state = self.states.connected;
					} else {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + self.state.state + ', so leaving unchanged');
					}
					if(self.state.sendEvents) {
						self.sendQueuedMessages();
					}
				};

				/* Wait until sync is done and old transport is idle before activating new transport. This
				 * guarantees that messages arrive at realtime in the same order they are sent.
				 *
				 * If a message times out on the old transport, since it's still the active transport the
				 * message will be requeued. deactivateTransport will see the pending transport and notify
				 * the `connecting` state without starting a new connection, so the new transport can take
				 * over once deactivateTransport clears the old protocol's queue.
				 *
				 * If there is no old protocol, that meant that we weren't in the connected state at the
				 * beginning of the sync - likely the base transport died just before the sync. So can just
				 * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
				 * fine, activatetransport will deal with that. */
				if(oldProtocol) {
				 /* Most of the time this will be already true: the new-transport sync will have given
				 * enough time for in-flight messages on the old transport to complete. */
					oldProtocol.onceIdle(finishUpgrade);
				} else {
					finishUpgrade();
				}
			});
		});
	};

	/**
	 * Called when a transport is connected, and the connectionmanager decides that
	 * it will now be the active transport. Returns whether or not it activated
	 * the transport (if the connection is closing/closed it will choose not to).
	 * @param transport the transport instance
	 * @param connectionId the id of the new active connection
	 * @param connectionDetails the details of the new active connection
	 * @param connectionPosition the position at the point activation; either {connectionSerial: <serial>} or {timeSerial: <serial>}
	 */
	ConnectionManager.prototype.activateTransport = function(error, transport, connectionId, connectionDetails, connectionPosition) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
		if(error) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
		}
		if(connectionId) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
		}
		if(connectionDetails) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
		}
		if(connectionPosition) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'serial =  ' + (connectionPosition.timeSerial || connectionPosition.connectionSerial));
		}

		this.persistTransportPreference(transport);

		/* if the connectionmanager moved to the closing/closed state before this
		 * connection event, then we won't activate this transport */
		var existingState = this.state,
			connectedState = this.states.connected.state;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
		if(existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
			transport.disconnect();
			return false;
		}

		/* remove this transport from pending transports */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);

		/* if the transport is not connected (eg because it failed during a
		 * scheduleTransportActivation#onceNoPending wait) then don't activate it */
		if(!transport.isConnected) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
			return false;
		}

		/* the given transport is connected; this will immediately
		 * take over as the active transport */
		var existingActiveProtocol = this.activeProtocol;
		this.activeProtocol = new _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](transport);
		this.host = transport.params.host;

		var connectionKey = connectionDetails.connectionKey;
		if(connectionKey && this.connectionKey != connectionKey)  {
			this.setConnection(connectionId, connectionDetails, connectionPosition, !!error);
		}

		/* Rebroadcast any new connectionDetails from the active transport, which
		 * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
		 * event. (Listener added on nextTick because we're in a transport.on('connected')
		 * callback at the moment; if we add it now we'll be adding it to the end
		 * of the listeners array and it'll be called immediately) */
		this.onConnectionDetailsUpdate(connectionDetails, transport);
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			transport.on('connected', function(connectedErr, _connectionId, connectionDetails) {
				self.onConnectionDetailsUpdate(connectionDetails, transport);
				self.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, connectedErr));
			});
		})

		/* If previously not connected, notify the state change (including any
		 * error). */
		if(existingState.state === this.states.connected.state) {
			if(error) {
				/* if upgrading without error, leave any existing errorReason alone */
				this.errorReason = this.realtime.connection.errorReason = error;
				/* Only bother emitting an upgrade if there's an error; otherwise it's
				 * just a transport upgrade, so auth details won't have changed */
				this.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, error));
			}
		} else {
			this.notifyState({state: 'connected', error: error});
			this.errorReason = this.realtime.connection.errorReason = error || null;
		}

		/* Send after the connection state update, as Channels hooks into this to
		 * resend attaches on a new transport if necessary */
		this.emit('transport.active', transport);

		/* Gracefully terminate existing protocol */
		if(existingActiveProtocol) {
			if(existingActiveProtocol.messageQueue.count() > 0) {
				/* We could just requeue pending messages on the new transport, but
				 * actually this should never happen: transports should only take over
				 * from other active transports when upgrading, and upgrading waits for
				 * the old transport to be idle. So log an error. */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' + existingActiveProtocol.transport.shortName + ', new one is ' + transport.shortName + ') finishing with ' + existingActiveProtocol.messageQueue.count() + ' messages still pending');
			}
			if(existingActiveProtocol.transport === transport) {
				var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-previously-active');
			} else {
				existingActiveProtocol.finish();
			}
		}

		/* Terminate any other pending transport(s), and
		 * abort any not-yet-pending transport attempts */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(pendingTransport) {
			if(pendingTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-pending');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			} else {
				pendingTransport.disconnect();
			}
		});
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(proposedTransport) {
			if(proposedTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-proposed');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.proposedTransports, transport);
			} else {
				proposedTransport.dispose();
			}
		});

		return true;
	};

	/**
	 * Called when a transport is no longer the active transport. This can occur
	 * in any transport connection state.
	 * @param transport
	 */
	ConnectionManager.prototype.deactivateTransport = function(transport, state, error) {
		var currentProtocol = this.activeProtocol,
			wasActive = currentProtocol && currentProtocol.getTransport() === transport,
			wasPending = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport),
			wasProposed = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport),
			noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' + state + (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') + (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
		if(error && error.message)
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);

		if(wasActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' + this.activeProtocol.messageQueue.count() + ' pending messages');
			this.queuePendingMessages(currentProtocol.getPendingMessages());
			/* Clear any messages we requeue to allow the protocol to become idle.
			 * In case of an upgrade, this will trigger an immediate activation of
			 * the upgrade transport, so delay a tick so this transport can finish
			 * deactivating */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				currentProtocol.clearPendingMessages();
			});
			this.activeProtocol = this.host = null;
			clearTimeout(this.channelResumeCheckTimer);
		}

		this.emit('transport.inactive', transport);

		/* this transport state change is a state change for the connectionmanager if
		 * - the transport was the active transport and there are no transports
		 *   which are connected and scheduled for activation, just waiting for the
		 *   active transport to finish what its doing; or
		 * - the transport was the active transport and the error was fatal (so
		 *   unhealable by another transport); or
		 * - there is no active transport, and this is the last remaining
		 *   pending transport (so we were in the connecting state)
		 */
		if((wasActive && noTransportsScheduledForActivation) ||
			(wasActive && (state === 'failed') || (state === 'closed')) ||
			(currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {

			/* If we're disconnected with a 5xx we need to try fallback hosts
			 * (RTN14d), but (a) due to how the upgrade sequence works, the
			 * host/transport selection sequence only cares about getting to
			 * `preconnect` (eg establishing a websocket) getting a `disconnected`
			 * protocol message afterwards is too late; and (b) host retry only
			 * applies to connectBase unless the stored preference transport doesn't
			 * work. We solve this by unpersisting the transport preference and
			 * setting an instance variable to force fallback hosts to be used (if
			 * any) here. Bit of a kludge, but no real better alternatives without
			 * rewriting the entire thing */
			if(state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
				this.unpersistTransportPreference();
				this.forceFallbackHost = true;
				/* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
				this.notifyState({state: state, error: error, retryImmediately: true});
				return;
			}

			/* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
			var newConnectionState = (state === 'failed' && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(error)) ? 'disconnected' : state;
			this.notifyState({state: newConnectionState, error: error});
			return;
		}

		if(wasActive && (state === 'disconnected') && (this.state !== this.states.synchronizing)) {
			/* If we were active but there is another transport scheduled for
			* activation, go into to the connecting state until that transport
			* activates and sets us back to connected. (manually starting the
			* transition timers in case that never happens). (If we were in the
			* synchronizing state, then that's fine, the old transport just got its
			* disconnected before the new one got the sync -- ignore it and keep
			* waiting for the sync. If it fails we have a separate sync timer that
			* will expire). */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
			this.startSuspendTimer();
			this.startTransitionTimer(this.states.connecting);
			this.notifyState({state: 'connecting', error: error});
		}
	};

	/* Helper that returns true if there are no transports which are pending,
	* have been connected, and are just waiting for onceNoPending to fire before
	* being activated */
	ConnectionManager.prototype.noTransportsScheduledForActivation = function() {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isEmpty(this.pendingTransports) ||
			this.pendingTransports.every(function(transport) {
				return !transport.isConnected;
			});
	};

	/**
	 * Called when activating a new transport, to ensure message delivery
	 * on the new transport synchronises with the messages already received
	 */
	ConnectionManager.prototype.sync = function(transport, requestedSyncPosition, callback) {
		var timeout = setTimeout(function () {
			transport.off('sync');
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for sync response', 50000, 500));
		}, this.options.timeouts.realtimeRequestTimeout);

		/* send sync request */
		var syncMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
			action: actions.SYNC,
			connectionKey: this.connectionKey
		});

		if(requestedSyncPosition.timeSerial) {
			syncMessage.timeSerial = requestedSyncPosition.timeSerial;
		} else if(requestedSyncPosition.connectionSerial !== undefined) {
			syncMessage.connectionSerial = requestedSyncPosition.connectionSerial;
		}
		transport.send(syncMessage);

		transport.once('sync', function(connectionId, syncPosition) {
			clearTimeout(timeout);
			callback(null, connectionId, syncPosition);
		});
	};

	ConnectionManager.prototype.setConnection = function(connectionId, connectionDetails, connectionPosition, hasConnectionError) {
		/* if connectionKey changes but connectionId stays the same, then just a
		 * transport change on the same connection. If connectionId changes, we're
		 * on a new connection, with implications for msgSerial and channel state,
		 * and resetting the connectionSerial position */
		var self = this;
		/* If no previous connectionId, don't reset the msgSerial as it may have
		 * been set by recover data (unless the recover failed) */
		var prevConnId = this.connectionid,
			connIdChanged = prevConnId && (prevConnId !== connectionId),
			recoverFailure = !prevConnId && hasConnectionError;
		if(connIdChanged || recoverFailure)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
			this.msgSerial = 0;
		}
		/* but do need to reattach channels, for channels that were previously in
		 * the attached state even though the connection mode was 'clean' due to a
		 * freshness check - see https://github.com/ably/ably-js/issues/394 */
		if(this.connectionId !== connectionId)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
			/* Wait till next tick before reattaching channels, so that connection
			 * state will be updated and so that it will be applied after
			 * Channels#onTransportUpdate, else channels will not have an ATTACHED
			 * sent twice (once from this and once from that). */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				self.realtime.channels.reattach();
			});
		} else if(this.options.checkChannelsOnResume) {
			/* For attached channels, set the attached msg indicator variable to false,
			 * wait 30s, and check we got an attached for each one.
			 * 30s was chosen to be 5s longer than the transport idle timeout expire
			 * time, in an attempt to avoid false positives due to a transport
			 * silently failing immediately after a resume */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Same connectionId; checkChannelsOnResume is enabled');
			clearTimeout(this.channelResumeCheckTimer);
			this.realtime.channels.resetAttachedMsgIndicators();
			this.channelResumeCheckTimer = setTimeout(function() {
				self.realtime.channels.checkAttachedMsgIndicators(connectionId);
			}, 30000);
		}
		this.realtime.connection.id = this.connectionId = connectionId;
		this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
		var forceResetMessageSerial = connIdChanged || !prevConnId;
		this.setConnectionSerial(connectionPosition, forceResetMessageSerial);
	};

	ConnectionManager.prototype.clearConnection = function() {
		this.realtime.connection.id = this.connectionId = undefined;
		this.realtime.connection.key = this.connectionKey = undefined;
		this.clearConnectionSerial();
		this.msgSerial = 0;
		this.unpersistConnection();
	};

	/* force: set the connectionSerial even if it's less than the current
	 * connectionSerial. Used for new connections.
	 * Returns true iff the message was rejected as a duplicate. */
	ConnectionManager.prototype.setConnectionSerial = function(connectionPosition, force) {
		var timeSerial = connectionPosition.timeSerial,
			connectionSerial = connectionPosition.connectionSerial;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.setConnectionSerial()', 'Updating connection serial; serial = ' + connectionSerial + '; timeSerial = ' + timeSerial + '; force = ' + force + '; previous = ' + this.connectionSerial);
		if(timeSerial !== undefined) {
			if(timeSerial <= this.timeSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with timeSerial ' + timeSerial + ', but current timeSerial is ' + this.timeSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.timeSerial = this.timeSerial = timeSerial;
			this.setRecoveryKey();
			return;
		}
		if(connectionSerial !== undefined) {
			if(connectionSerial <= this.connectionSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with connectionSerial ' + connectionSerial + ', but current connectionSerial is ' + this.connectionSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.serial = this.connectionSerial = connectionSerial;
			this.setRecoveryKey();
		}
	};

	ConnectionManager.prototype.clearConnectionSerial = function() {
		this.realtime.connection.serial = this.connectionSerial = undefined;
		this.realtime.connection.timeSerial = this.timeSerial = undefined;
		this.clearRecoveryKey();
	};

	ConnectionManager.prototype.setRecoveryKey = function() {
		this.realtime.connection.recoveryKey = this.connectionKey + ':' + (this.timeSerial || this.connectionSerial) + ':' + this.msgSerial;
	};

	ConnectionManager.prototype.clearRecoveryKey = function() {
		this.realtime.connection.recoveryKey = null;
	};

	ConnectionManager.prototype.checkConnectionStateFreshness = function() {
		if(!this.lastActivity || !this.connectionId) { return; }

		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity;
		if(sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
			this.clearConnection();
			this.states.connecting.failState = 'suspended';
			this.states.connecting.queueEvents = false;
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.persistConnection = function() {
		if(haveSessionStorage) {
			var recoveryKey = this.realtime.connection.recoveryKey;
			if(recoveryKey) {
				setSessionRecoverData({
					recoveryKey: recoveryKey,
					disconnectedAt: _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
					location: global.location,
					clientId: this.realtime.auth.clientId
				}, this.connectionStateTtl);
			}
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.unpersistConnection = function() {
		clearSessionRecoverData();
	};

	/*********************
	 * state management
	 *********************/

	ConnectionManager.prototype.getError = function() {
		return this.errorReason || this.getStateError();
	};

	ConnectionManager.prototype.getStateError = function() {
		return _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][this.state.state];
	};

	ConnectionManager.prototype.activeState = function() {
		return this.state.queueEvents || this.state.sendEvents;
	};

	ConnectionManager.prototype.enactStateChange = function(stateChange) {
		var logLevel = stateChange.current === 'failed' ? _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR : _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? ('; reason: ' + stateChange.reason) : ''));
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' + stateChange.current + '; reason = ' + (stateChange.reason && stateChange.reason.message));
		var newState = this.state = this.states[stateChange.current];
		if(stateChange.reason) {
			this.errorReason = stateChange.reason;
			this.realtime.connection.errorReason = stateChange.reason;
		}
		if(newState.terminal || newState.state === 'suspended') {
			/* suspended is nonterminal, but once in the suspended state, realtime
			 * will have discarded our connection state, so futher connection
			 * attempts should start from scratch */
			this.clearConnection();
		}
		this.emit('connectionstate', stateChange);
	};

	/****************************************
	 * ConnectionManager connection lifecycle
	 ****************************************/

	ConnectionManager.prototype.startTransitionTimer = function(transitionState) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);

		if(this.transitionTimer) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
			clearTimeout(this.transitionTimer);
		}

		var self = this;
		this.transitionTimer = setTimeout(function() {
			if(self.transitionTimer) {
				self.transitionTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
				self.notifyState({state: transitionState.failState});
			}
		}, transitionState.retryDelay);
	};

	ConnectionManager.prototype.cancelTransitionTimer = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
		if(this.transitionTimer) {
			clearTimeout(this.transitionTimer);
			this.transitionTimer = null;
		}
	};

	ConnectionManager.prototype.startSuspendTimer = function() {
		var self = this;
		if(this.suspendTimer)
			return;
		this.suspendTimer = setTimeout(function() {
			if(self.suspendTimer) {
				self.suspendTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
				self.states.connecting.failState = 'suspended';
				self.states.connecting.queueEvents = false;
				self.notifyState({state: 'suspended'});
			}
		}, this.connectionStateTtl);
	};

	ConnectionManager.prototype.checkSuspendTimer = function(state) {
		if(state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
			this.cancelSuspendTimer();
	};

	ConnectionManager.prototype.cancelSuspendTimer = function() {
		this.states.connecting.failState = 'disconnected';
		this.states.connecting.queueEvents = true;
		if(this.suspendTimer) {
			clearTimeout(this.suspendTimer);
			this.suspendTimer = null;
		}
	};

	ConnectionManager.prototype.startRetryTimer = function(interval) {
		var self = this;
		this.retryTimer = setTimeout(function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
			self.retryTimer = null;
			self.requestState({state: 'connecting'});
		}, interval);
	};

	ConnectionManager.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.retryTimer = null;
		}
	};

	ConnectionManager.prototype.notifyState = function(indicated) {
		var state = indicated.state,
			self = this;

		/* We retry immediately if:
		 * - something disconnects us while we're connected, or
		 * - a viable (but not yet active) transport fails due to a token error (so
		 *   this.errorReason will be set, and startConnect will do a forced
		 *   authorize). If this.errorReason is already set (to a token error),
		 *   then there has been at least one previous attempt to connect that also
		 *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
		 *   before trying again */
		var retryImmediately = (state === 'disconnected' &&
			(this.state === this.states.connected     ||
			 this.state === this.states.synchronizing ||
			 indicated.retryImmediately               ||
				(this.state === this.states.connecting &&
					indicated.error && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(indicated.error) &&
					!(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)))));

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
		/* do nothing if we're already in the indicated state */
		if(state == this.state.state)
			return;

		/* kill timers (possibly excepting suspend timer depending on the notified
		* state), as these are superseded by this notification */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		this.checkSuspendTimer(indicated.state);

		/* do nothing if we're unable to move from the current state */
		if(this.state.terminal)
			return;

		/* process new state */
		var newState = this.states[indicated.state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, newState.retryDelay, (indicated.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		if(retryImmediately) {
			var autoReconnect = function() {
				if(self.state === self.states.disconnected) {
					self.lastAutoReconnectAttempt = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
					self.requestState({state: 'connecting'});
				}
			};
			var sinceLast = this.lastAutoReconnectAttempt && (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastAutoReconnectAttempt + 1);
			if(sinceLast && (sinceLast < 1000)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' + sinceLast + 'ms ago, waiting another ' + (1000 - sinceLast) + 'ms before trying again');
				setTimeout(autoReconnect, 1000 - sinceLast);
			} else {
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(autoReconnect);
			}
		} else if(state === 'disconnected' || state === 'suspended') {
			this.startRetryTimer(newState.retryDelay);
		}

		 /* If going into disconnect/suspended (and not retrying immediately), or a
			* terminal state, ensure there are no orphaned transports hanging around. */
		if((state === 'disconnected' && !retryImmediately) ||
			 (state === 'suspended') ||
			 newState.terminal) {
				 /* Wait till the next tick so the connection state change is enacted,
				 * so aborting transports doesn't trigger redundant state changes */
				 _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					 self.disconnectAllTransports();
				 });
		 }

		if(state == 'connected' && !this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
		}

		/* implement the change and notify */
		this.enactStateChange(change);
		if(this.state.sendEvents) {
			this.sendQueuedMessages();
		} else if(!this.state.queueEvents) {
			this.realtime.channels.propogateConnectionInterruption(state, change.reason);
			this.failQueuedMessages(change.reason); // RTN7c
		}
	};

	ConnectionManager.prototype.requestState = function(request) {
		var state = request.state, self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
		if(state == this.state.state)
			return; /* silently do nothing */

		/* kill running timers, as this request supersedes them */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		/* for suspend timer check rather than cancel -- eg requesting a connecting
		* state should not reset the suspend timer */
		this.checkSuspendTimer(state);

		if(state == 'connecting' && this.state.state == 'connected') return;
		if(state == 'closing' && this.state.state == 'closed') return;

		var newState = this.states[state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, null, (request.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		this.enactStateChange(change);

		if(state == 'connecting') {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() { self.startConnect(); });
		}
		if(state == 'closing') {
			this.closeImpl();
		}
	};


	ConnectionManager.prototype.startConnect = function() {
		if(this.state !== this.states.connecting) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
			return;
		}

		var auth = this.realtime.auth,
			self = this;

		/* The point of the connectCounter mechanism is to ensure that the
		 * connection procedure can be cancelled. We want disconnectAllTransports
		 * to be able to stop any in-progress connection, even before it gets to
		 * the stage of having a pending (or even a proposed) transport that it can
		 * dispose() of. So we check that it's still current after any async stage,
		 * up until the stage that is synchronous with instantiating a transport */
		var connectCount = ++this.connectCounter;

		var connect = function() {
			self.checkConnectionStateFreshness();
			self.getTransportParams(function(transportParams) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				self.connectImpl(transportParams, connectCount);
			});
		};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
		this.startSuspendTimer();
		this.startTransitionTimer(this.states.connecting);

		if(auth.method === 'basic') {
			connect();
		} else {
			var authCb = function(err) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(err) {
					self.actOnErrorFromAuthorize(err);
				} else {
					connect();
				}
			};
			if(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)) {
				/* Force a refetch of a new token */
				auth._forceNewToken(null, null, authCb);
			} else {
				auth._ensureValidAuthCredentials(false, authCb);
			}
		}
	};

	/**
	 * There are three stages in connecting:
	 * - preference: if there is a cached transport preference, we try to connect
	 *   on that. If that fails or times out we abort the attempt, remove the
	 *   preference and fall back to base. If it succeeds, we try upgrading it if
	 *   needed (will only be in the case where the preference is xhrs and the
	 *   browser supports ws).
	 * - base: we try to connect with the best transport that we think will
	 *   never fail for this browser (usually this is xhr_polling; for very old
	 *   browsers will be jsonp, for node will be comet). If it doesn't work, we
	 *   try fallback hosts.
	 * - upgrade: given a connected transport, we see if there are any better
	 *   ones, and if so, try to upgrade to them.
	 *
	 * connectImpl works out what stage you're at (which is purely a function of
	 * the current connection state and whether there are any stored preferences),
	 * and dispatches accordingly. After a transport has been set pending,
	 * tryATransport calls connectImpl to see if there's another stage to be done.
	 * */
	ConnectionManager.prototype.connectImpl = function(transportParams, connectCount) {
		var state = this.state.state;

		if(state !== this.states.connecting.state && state !== this.states.connected.state) {
			/* Only keep trying as long as in the 'connecting' state (or 'connected'
			 * for upgrading). Any operation can put us into 'disconnected' to cancel
			 * connection attempts and wait before retrying, or 'failed' to fail. */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
		} else if(this.pendingTransports.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
		} else if(state == this.states.connected.state) {
			this.upgradeIfNeeded(transportParams);
		} else if(this.transports.length > 1 && this.getTransportPreference()) {
			this.connectPreference(transportParams);
		} else {
			this.connectBase(transportParams, connectCount);
		}
	};


	ConnectionManager.prototype.connectPreference = function(transportParams) {
		var preference = this.getTransportPreference(),
			self = this,
			preferenceTimeoutExpired = false;

		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.transports, preference)) {
			this.unpersistTransportPreference();
			this.connectImpl(transportParams);
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);

		var preferenceTimeout = setTimeout(function() {
			preferenceTimeoutExpired = true;
			if(!(self.state.state === self.states.connected.state)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
				/* Abort all connection attempts. (This also disconnects the active
				 * protocol, but none exists if we're not in the connected state) */
				self.disconnectAllTransports();
				/* Be quite agressive about clearing the stored preference if ever it doesn't work */
				self.unpersistTransportPreference();
			}
			self.connectImpl(transportParams);
		}, this.options.timeouts.preferenceConnectTimeout);

		/* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
		 * The wstransport it will substitute the httphost for an appropriate wshost */
		transportParams.host = self.httpHosts[0];
		self.tryATransport(transportParams, preference, function(fatal, transport) {
			clearTimeout(preferenceTimeout);
			if(preferenceTimeoutExpired && transport) {
				/* Viable, but too late - connectImpl() will already be trying
				* connectBase, and we weren't in upgrade mode. Just remove the
				* onconnected listener and get rid of it */
				transport.off();
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);
			} else if(!transport && !fatal) {
				/* Preference failed in a transport-specific way. Try more */
				self.unpersistTransportPreference();
				self.connectImpl(transportParams);
			}
			/* If suceeded, or failed fatally, nothing to do */
		});
	};


	/**
	 * Try to establish a transport on the base transport (the best transport
	 * such that if it doesn't work, nothing will work) as determined through
	 * static feature detection, checking for network connectivity and trying
	 * fallback hosts if applicable.
	 * @param transportParams
	 */
	ConnectionManager.prototype.connectBase = function(transportParams, connectCount) {
		var self = this,
			giveUp = function(err) {
				self.notifyState({state: self.states.connecting.failState, error: err});
			},
			candidateHosts = this.httpHosts.slice(),
			hostAttemptCb = function(fatal, transport) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(!transport && !fatal) {
					tryFallbackHosts();
				}
			};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);

		/* first try to establish a connection with the priority host with http transport */
		var host = candidateHosts.shift();
		if(!host) {
			giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (no available host)', 80003, 404));
			return;
		}
		transportParams.host = host;

		/* this is what we'll be doing if the attempt for the main host fails */
		function tryFallbackHosts() {
			/* if there aren't any fallback hosts, fail */
			if(!candidateHosts.length) {
				giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (and no more fallback hosts to try)', 80003, 404));
				return;
			}
			/* before trying any fallback (or any remaining fallback) we decide if
			 * there is a problem with the ably host, or there is a general connectivity
			 * problem */
			platform_http__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"].checkConnectivity(function(err, connectivity) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				/* we know err won't happen but handle it here anyway */
				if(err) {
					giveUp(err);
					return;
				}
				if(!connectivity) {
					/* the internet isn't reachable, so don't try the fallback hosts */
					giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (network unreachable)', 80003, 404));
					return;
				}
				/* the network is there, so there's a problem with the main host, or
				 * its dns. Try the fallback hosts. We could try them simultaneously but
				 * that would potentially cause a huge spike in load on the load balancer */
				transportParams.host = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrPopRandomElement(candidateHosts);
				self.tryATransport(transportParams, self.baseTransport, hostAttemptCb);
			});
		}

		if(this.forceFallbackHost && candidateHosts.length) {
			this.forceFallbackHost = false;
			tryFallbackHosts();
			return;
		}

		this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
	};


	ConnectionManager.prototype.getUpgradePossibilities = function() {
		/* returns the subset of upgradeTransports to the right of the current
		 * transport in upgradeTransports (if it's in there - if not, currentPosition
		 * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
		var current = this.activeProtocol.getTransport().shortName;
		var currentPosition = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(this.upgradeTransports, current);
		return this.upgradeTransports.slice(currentPosition + 1);
	};


	ConnectionManager.prototype.upgradeIfNeeded = function(transportParams) {
		var upgradePossibilities = this.getUpgradePossibilities(),
			self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(upgradePossibilities));

		if(!upgradePossibilities.length) {
			return;
		}

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(upgradePossibilities, function(upgradeTransport) {
			/* Note: the transport may mutate the params, so give each transport a fresh one */
			var upgradeTransportParams = self.createTransportParams(transportParams.host, 'upgrade');
			self.tryATransport(upgradeTransportParams, upgradeTransport, noop);
		});
	};


	ConnectionManager.prototype.closeImpl = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
		this.cancelSuspendTimer();
		this.startTransitionTimer(this.states.closing);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
			if(transport) transport.close();
		});

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});

		if(this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().close();
		}

		/* If there was an active transport, this will probably be
		 * preempted by the notifyState call in deactivateTransport */
		this.notifyState({state: 'closed'});
	};

	ConnectionManager.prototype.onAuthUpdated = function(tokenDetails, callback) {
		var self = this;
		switch(this.state.state) {
			case 'connected':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
				/* If there are any proposed/pending transports (eg an upgrade that
				 * isn't yet scheduled for activation) that hasn't yet started syncing,
				 * just to get rid of them & restart the upgrade with the new token, to
				 * avoid a race condition. (If it has started syncing, the AUTH will be
				 * queued until the upgrade is complete, so everything's fine) */
				if((this.pendingTransports.length || this.proposedTransports.length) &&
					self.state !== self.states.synchronizing) {
					this.disconnectAllTransports(/* exceptActive: */true);
					var transportParams = this.activeProtocol.getTransport().params;
					_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
						if(self.state.state === 'connected') {
							self.upgradeIfNeeded(transportParams);
						}
					});
				}

				/* Do any transport-specific new-token action */
				this.activeProtocol.getTransport().onAuthUpdated(tokenDetails);

				var authMsg = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
					action: actions.AUTH,
					auth: {
						accessToken: tokenDetails.token
					}
				});
				this.send(authMsg);

				/* The answer will come back as either a connectiondetails event
				 * (realtime sends a CONNECTED to asknowledge the reauth) or a
				 * statechange to failed */
				var successListener = function() {
					self.off(failureListener);
					callback(null, tokenDetails);
				};
				var failureListener = function(stateChange) {
					if(stateChange.current === 'failed') {
						self.off(successListener);
						self.off(failureListener);
						callback(stateChange.reason || self.getStateError());
					}
				};
				this.once('connectiondetails', successListener);
				this.on('connectionstate', failureListener);
				break;

			case 'connecting':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Aborting current connection attempts in order to start again with the new auth details');
				this.disconnectAllTransports();
				/* fallthrough to add statechange listener */

			default:
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Connection state is ' + this.state.state + '; waiting until either connected or failed');
				var listener = function(stateChange) {
					switch(stateChange.current) {
						case 'connected':
							self.off(listener);
							callback(null, tokenDetails);
							break;
						case 'failed':
						case 'closed':
						case 'suspended':
							self.off(listener);
							callback(stateChange.reason || self.getStateError());
							break;
						default:
							/* ignore till we get either connected or failed */
							break;
					}
				};
				self.on('connectionstate', listener);
				if(this.state.state === 'connecting') {
					/* can happen if in the connecting state but no transport was pending
					 * yet, so disconnectAllTransports did not trigger a disconnected state */
					self.startConnect();
				} else {
					self.requestState({state: 'connecting'});
				}
		}
	};

	ConnectionManager.prototype.disconnectAllTransports = function(exceptActive) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));

		/* This will prevent any connection procedure in an async part of one of its early stages from continuing */
		this.connectCounter++;

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
			if(transport) transport.disconnect();
		});
		this.pendingTransports = [];

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});
		this.proposedTransports = [];

		if(this.activeProtocol && !exceptActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().disconnect();
		}
		/* No need to notify state disconnected; disconnecting the active transport
		 * will have that effect */
	};

	/******************
	 * event queueing
	 ******************/

	ConnectionManager.prototype.send = function(msg, queueEvent, callback) {
		callback = callback || noop;
		var state = this.state;

		if(state.sendEvents) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'sending event');
			this.sendImpl(new PendingMessage(msg, callback));
			return;
		}
		var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
		if(!shouldQueue) {
			var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', err);
			callback(this.errorReason || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](err, 90000, 400));
			return;
		}
		if(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(msg));
		}
		this.queue(msg, callback);
	};

	ConnectionManager.prototype.sendImpl = function(pendingMessage) {
		var msg = pendingMessage.message;
		/* If have already attempted to send this, resend with the same msgSerial,
		 * so Ably can dedup if the previous send succeeded */
		if(pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
			msg.msgSerial = this.msgSerial++;
			this.setRecoveryKey();
		}
		try {
			this.activeProtocol.send(pendingMessage);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
		}
	};

	function bundleWith(dest, src, maxSize) {
		var action;
		if(dest.channel !== src.channel) {
			/* RTL6d3 */
			return false;
		}
		if((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
			/* RTL6d - can only bundle messages or presence */
			return false;
		}
		if(action !== src.action) {
			/* RTL6d4 */
			return false;
		}
		var kind = (action === actions.PRESENCE) ? 'presence' : 'messages',
			proposed = dest[kind].concat(src[kind]),
			size = _types_message__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].getMessagesSize(proposed);
		if(size > maxSize) {
			/* RTL6d1 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].allSame(proposed, 'clientId')) {
			/* RTL6d2 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrEvery(proposed, function(msg) {
			return !msg.id;
		})) {
			/* RTL6d7 */
			return false;
		}
		/* we're good to go! */
		dest[kind] = proposed;
		return true;
	};

	ConnectionManager.prototype.queue = function(msg, callback) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
		var lastQueued = this.queuedMessages.last();
		var maxSize = this.options.maxMessageSize;
		/* If have already attempted to send a message, don't merge more messages
		 * into it, as if the previous send actually succeeded and realtime ignores
		 * the dup, they'll be lost */
		if(lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
			if(!lastQueued.merged) {
				lastQueued.callback = Object(_util_multicaster__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])([lastQueued.callback]);
				lastQueued.merged = true;
			}
			lastQueued.callback.push(callback);
		} else {
			this.queuedMessages.push(new PendingMessage(msg, callback));
		}
	};

	ConnectionManager.prototype.sendQueuedMessages = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
		var pendingMessage;
		while(pendingMessage = this.queuedMessages.shift())
			this.sendImpl(pendingMessage);
	};

	ConnectionManager.prototype.queuePendingMessages = function(pendingMessages) {
		if(pendingMessages && pendingMessages.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
			this.queuedMessages.prepend(pendingMessages);
		}
	};

	ConnectionManager.prototype.failQueuedMessages = function(err) {
		var numQueued = this.queuedMessages.count();
		if(numQueued > 0) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
			this.queuedMessages.completeAllMessages(err);
		}
	};

	ConnectionManager.prototype.onChannelMessage = function(message, transport) {
		var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(),
			onUpgradeTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing,
			notControlMsg = message.action === actions.MESSAGE || message.action === actions.PRESENCE;

		/* As the lib now has a period where the upgrade transport is synced but
		 * before it's become active (while waiting for the old one to become
		 * idle), message can validly arrive on it even though it isn't active */
		if(onActiveTransport || onUpgradeTransport) {
			if(notControlMsg) {
				var suppressed = this.setConnectionSerial(message);
				if(suppressed) {
					return;
				}
				if(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isDuplicate(message, this.mostRecentMsg)) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onChannelMessage()', 'received message with different connectionSerial, but same message id as a previous; discarding; id = ' + message.id);
					return;
				}
				this.mostRecentMsg = message;
			}
			this.realtime.channels.onChannelMessage(message);
		} else {
			// Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
			// messages,  no new messages (as sync has been sent on new transport so new messages will
			// be resent there, or connection has been closed so don't want new messages)
			if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
				this.realtime.channels.onChannelMessage(message);
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
			}
		}
	};

	ConnectionManager.prototype.ping = function(transport, callback) {
		/* if transport is specified, try that */
		if(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);

			var onTimeout = function () {
				transport.off('heartbeat', onHeartbeat);
				callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for heartbeat response', 50000, 500));
			};

			var pingStart = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
				id = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].cheapRandStr();

			var onHeartbeat = function (responseId) {
				if(responseId === id) {
					transport.off('heartbeat', onHeartbeat);
					clearTimeout(timer);
					var responseTime = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - pingStart;
					callback(null, responseTime);
				}
			};

			var timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);

			transport.on('heartbeat', onHeartbeat);
			transport.ping(id);
			return;
		}

		/* if we're not connected, don't attempt */
		if(this.state.state !== 'connected') {
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to ping service; not connected', 40000, 400));
			return;
		}

		/* no transport was specified, so use the current (connected) one
		 * but ensure that we retry if the transport is superseded before we complete */
		var completed = false, self = this;

		var onPingComplete = function(err, responseTime) {
			self.off('transport.active', onTransportActive);
			if(!completed) {
				completed = true;
				callback(err, responseTime);
			}
		};

		var onTransportActive = function() {
			if(!completed) {
				/* ensure that no callback happens for the currently outstanding operation */
				completed = true;
				/* repeat but picking up the new transport */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.ping(null, callback);
				});
			}
		};

		this.on('transport.active', onTransportActive);
		this.ping(this.activeProtocol.getTransport(), onPingComplete);
	};

	ConnectionManager.prototype.abort = function(error) {
		this.activeProtocol.getTransport().fail(error);
	};

	ConnectionManager.prototype.registerProposedTransport = function(transport) {
		this.proposedTransports.push(transport);
	};

	ConnectionManager.prototype.getTransportPreference = function() {
		return this.transportPreference || (haveWebStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get(transportPreferenceName));
	};

	ConnectionManager.prototype.persistTransportPreference = function(transport) {
		if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports, transport.shortName)) {
			this.transportPreference = transport.shortName;
			if(haveWebStorage) {
				platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].set(transportPreferenceName, transport.shortName);
			}
		}
	};

	ConnectionManager.prototype.unpersistTransportPreference = function() {
		this.transportPreference = null;
		if(haveWebStorage) {
			platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].remove(transportPreferenceName);
		}
	};

	/* This method is only used during connection attempts, so implements RSA4c1,
	 * RSA4c2, and RSA4d. In particular it is not invoked for
	 * serverside-triggered reauths or manual reauths, so RSA4c3 does not apply */
	ConnectionManager.prototype.actOnErrorFromAuthorize = function(err) {
		if(err.code === 40171) {
			/* No way to reauth */
			this.notifyState({state: 'failed', error: err});
		} else if(err.statusCode === 403) {
			var msg = 'Client configured authentication provider returned 403; failing the connection';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
			this.notifyState({state: 'failed', error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 403, err)});
		} else {
			var msg = 'Client configured authentication provider request failed';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
			this.notifyState({state: this.state.failState, error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 401, err)});
		}
	};

	ConnectionManager.prototype.onConnectionDetailsUpdate = function(connectionDetails, transport) {
		if(!connectionDetails) {
			return;
		}
		this.connectionDetails = connectionDetails;
		if(connectionDetails.maxMessageSize) {
			this.options.maxMessageSize = connectionDetails.maxMessageSize;
		}
		var clientId = connectionDetails.clientId;
		if(clientId) {
			var err = this.realtime.auth._uncheckedSetClientId(clientId);
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
				/* Errors setting the clientId are fatal to the connection */
				transport.fail(err);
				return;
			}
		}
		var connectionStateTtl = connectionDetails.connectionStateTtl;
		if(connectionStateTtl) {
			this.connectionStateTtl = connectionStateTtl;
		}
		this.maxIdleInterval = connectionDetails.maxIdleInterval;
		this.emit('connectiondetails', connectionDetails);
	};

	return ConnectionManager;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionManager);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_225303__(17)))

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_321878__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_321878__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_321878__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_321878__(0);




var MessageQueue = (function() {
	function MessageQueue() {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		this.messages = [];
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(MessageQueue, _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	MessageQueue.prototype.count = function() {
		return this.messages.length;
	};

	MessageQueue.prototype.push = function(message) {
		this.messages.push(message);
	};

	MessageQueue.prototype.shift = function() {
		return this.messages.shift();
	};

	MessageQueue.prototype.last = function() {
		return this.messages[this.messages.length - 1];
	};

	MessageQueue.prototype.copyAll = function() {
		return this.messages.slice();
	};

	MessageQueue.prototype.append = function(messages) {
		this.messages.push.apply(this.messages, messages);
	};

	MessageQueue.prototype.prepend = function(messages) {
		this.messages.unshift.apply(this.messages, messages);
	};

	MessageQueue.prototype.completeMessages = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
		err = err || null;
		var messages = this.messages;
		var first = messages[0];
		if(first) {
			var startSerial = first.message.msgSerial;
			var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
			if(endSerial > startSerial) {
				var completeMessages = messages.splice(0, (endSerial - startSerial));
				for(var i = 0; i < completeMessages.length; i++) {
					completeMessages[i].callback(err);
				}
			}
			if(messages.length == 0)
				this.emit('idle');
		}
	};

	MessageQueue.prototype.completeAllMessages = function(err) {
		this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
	};

	MessageQueue.prototype.clear = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
		this.messages = [];
		this.emit('idle');
	};

	return MessageQueue;
})();

/* harmony default export */ __webpack_exports__["a"] = (MessageQueue);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_324635__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_324635__(1);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_324635__(7);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_324635__(3);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_324635__(2);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_324635__(6);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_324635__(0);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_324635__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_324635__(5);
/* harmony import */ var _util_domevent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_324635__(35);










var XHRRequest = (function() {
	var noop = function() {};
	var idCounter = 0;
	var pendingRequests = {};

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function clearPendingRequests() {
		for(var id in pendingRequests)
			pendingRequests[id].dispose();
	}

	var isIE = typeof global !== 'undefined' && global.XDomainRequest;

	function ieVersion() {
		var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
		return match && Number(match[1]);
	}

	function needJsonEnvelope() {
		/* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
		var version;
		return isIE && (version = ieVersion()) && version === 10;
	}

	function getHeader(xhr, header) {
		return xhr.getResponseHeader && xhr.getResponseHeader(header);
	}

	/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
	 * it is 'chunked'. So instead, decide that it is chunked when
	 * transfer-encoding is present or content-length is absent.  ('or' because
	 * when using http2 streaming, there's no transfer-encoding header, but can
	 * still deduce streaming from lack of content-length) */
	function isEncodingChunked(xhr) {
		return xhr.getResponseHeader
			&& (xhr.getResponseHeader('transfer-encoding')
			|| !xhr.getResponseHeader('content-length'));
	}

	function getHeadersAsObject(xhr) {
		var headerPairs = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim(xhr.getAllResponseHeaders()).split('\r\n'),
			headers = {};
		for (var i = 0; i < headerPairs.length; i++) {
			var parts = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrMap(headerPairs[i].split(':'), _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim);
			headers[parts[0].toLowerCase()] = parts[1];
		}
		return headers;
	}

	function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		params = params || {};
		params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(needJsonEnvelope() && !params.envelope)
			params.envelope = 'json';
		this.uri = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		this.headers = headers || {};
		this.body = body;
		this.method = method ? method.toUpperCase() : (_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(body) ? 'GET' : 'POST');
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.timedOut = false;
		this.requestComplete = false;
		pendingRequests[this.id = String(++idCounter)] = this;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(XHRRequest, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	var createRequest = XHRRequest.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* XHR requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new XHRRequest(uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	XHRRequest.prototype.complete = function(err, body, headers, unpacked, statusCode) {
		if(!this.requestComplete) {
			this.requestComplete = true;
			if(!err && body) {
				this.emit('data', body);
			}
			this.emit('complete', err, body, headers, unpacked, statusCode);
			this.dispose();
		}
	};

	XHRRequest.prototype.abort = function() {
		this.dispose();
	};

	XHRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,
			self = this,
			timer = this.timer = setTimeout(function() {
				self.timedOut = true;
				xhr.abort();
			}, timeout),
			body = this.body,
			method = this.method,
			headers = this.headers,
			xhr = this.xhr = new XMLHttpRequest(),
			accept = headers['accept'],
			responseType = 'text';

		if(!accept) {
			headers['accept'] = 'application/json';
		} else if(accept.indexOf('application/x-msgpack') === 0) {
			responseType = 'arraybuffer';
		}

		if(body) {
			var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
			if(contentType.indexOf('application/json') > -1 && typeof(body) != 'string')
				body = JSON.stringify(body);
		}

		xhr.open(method, this.uri, true);
		xhr.responseType = responseType;

		if ('authorization' in headers) {
			xhr.withCredentials = true;
		}

		for(var h in headers)
			xhr.setRequestHeader(h, headers[h]);

		var errorHandler = function(errorEvent, message, code, statusCode) {
			var errorMessage = message + ' (event type: ' + errorEvent.type + ')' + (self.xhr.statusText ? ', current statusText is ' + self.xhr.statusText : '');
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](errorMessage, code, statusCode));
		};
		xhr.onerror = function(errorEvent) {
			errorHandler(errorEvent, 'XHR error occurred', null, 400);
		}
		xhr.onabort = function(errorEvent) {
			if(self.timedOut) {
				errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
			} else {
				errorHandler(errorEvent, 'Request cancelled', null, 400);
			}
		};
		xhr.ontimeout = function(errorEvent) {
			errorHandler(errorEvent, 'Request timed out', null, 408);
		};

		var streaming,
			statusCode,
			responseBody,
			contentType,
			successResponse,
			streamPos = 0,
			unpacked = false;

		function onResponse() {
			clearTimeout(timer);
			successResponse = (statusCode < 400);
			if(statusCode == 204) {
				self.complete(null, null, null, null, statusCode);
				return;
			}
			streaming = (self.requestMode == REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr));
		}

		function onEnd() {
			try {
				var contentType = getHeader(xhr, 'content-type'),
					headers,
					responseBody,
					/* Be liberal in what we accept; buggy auth servers may respond
					 * without the correct contenttype, but assume they're still
					 * responding with json */
					json = contentType ? (contentType.indexOf('application/json') >= 0) : (xhr.responseType == 'text');

				if(json) {
					/* If we requested msgpack but server responded with json, then since
					 * we set the responseType expecting msgpack, the response will be
					 * an ArrayBuffer containing json */
					responseBody = (xhr.responseType === 'arraybuffer') ? platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].utf8Decode(xhr.response) : String(xhr.responseText);
					if(responseBody.length) {
						responseBody = JSON.parse(responseBody);
					}
					unpacked = true;
				} else {
					responseBody = xhr.response;
				}

				if(responseBody.response !== undefined) {
					/* unwrap JSON envelope */
					statusCode = responseBody.statusCode;
					successResponse = (statusCode < 400);
					headers = responseBody.headers;
					responseBody = responseBody.response;
				} else {
					headers = getHeadersAsObject(xhr);
				}
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}

			/* If response is an array, it's an array of protocol messages -- even if
			 * is contains an error action (hence the nonsuccess statuscode), we can
			 * consider the request to have succeeded, just pass it on to
			 * onProtocolMessage to decide what to do */
			if(successResponse || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(responseBody)) {
				self.complete(null, responseBody, headers, unpacked, statusCode);
				return;
			}

			var err = responseBody.error && _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(responseBody.error);
			if(!err) {
				err = new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Error response received from server: ' + statusCode + ' body was: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(responseBody), null, statusCode);
			}
			self.complete(err, responseBody, headers, unpacked, statusCode);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.complete();
			});
		}

		xhr.onreadystatechange = function() {
			var readyState = xhr.readyState;
			if(readyState < 3) return;
			if(xhr.status !== 0) {
				if(statusCode === undefined) {
					statusCode = xhr.status;
					/* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
					if(statusCode === 1223) statusCode = 204;
					onResponse();
				}
				if(readyState == 3 && streaming) {
					onProgress();
				} else if(readyState == 4) {
					if(streaming)
						onStreamEnd();
					else
						onEnd();
				}
			}
		};
		xhr.send(body);
	};

	XHRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].xhrSupported) {
		if(typeof _util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"] === 'object') {
			_util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].addUnloadListener(clearPendingRequests);
		}
		if(typeof(platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]) !== 'undefined') {
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].supportsAuthHeaders = true;
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
				var req = createRequest(uri, headers, params, body, REQ_SEND, rest && rest.options.timeouts, method);
				req.once('complete', callback);
				req.exec();
				return req;
			};

			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
				var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].internetUpUrl;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + upUrl);
				platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getUri(null, upUrl, null, null, function(err, responseText) {
					var result = (!err && responseText.replace(/\n/, '') == 'yes');
					_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
					callback(null, result);
				});
			};
		}
	}

	return XHRRequest;
})();

/* harmony default export */ __webpack_exports__["a"] = (XHRRequest);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_324635__(17)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_338023__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_338023__(12), __nested_webpack_require_338023__(10), __nested_webpack_require_338023__(46), __nested_webpack_require_338023__(18), __nested_webpack_require_338023__(37), __nested_webpack_require_338023__(36), __nested_webpack_require_338023__(29), __nested_webpack_require_338023__(30), __nested_webpack_require_338023__(31), __nested_webpack_require_338023__(47), __nested_webpack_require_338023__(48));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_338536__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_338536__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_342432__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_342432__(12), __nested_webpack_require_342432__(37), __nested_webpack_require_342432__(29));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_346322__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_346322__(12), __nested_webpack_require_346322__(30));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_375869__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_375869__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_376140__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_376140__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_376424__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_376424__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_376424__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_376424__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_376424__(0);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_376424__(26);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_376424__(2);







var Protocol = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;

	function Protocol(transport) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.transport = transport;
		this.messageQueue = new _messagequeue__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]();
		var self = this;
		transport.on('ack', function(serial, count) { self.onAck(serial, count); });
		transport.on('nack', function(serial, count, err) { self.onNack(serial, count, err); });
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Protocol, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Protocol.prototype.onAck = function(serial, count) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
		this.messageQueue.completeMessages(serial, count);
	};

	Protocol.prototype.onNack = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		if(!err) {
			err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Unable to send message; channel not responding', 50001, 500);
		}
		this.messageQueue.completeMessages(serial, count, err);
	};

	Protocol.prototype.onceIdle = function(listener) {
		var messageQueue = this.messageQueue;
		if(messageQueue.count() === 0) {
			listener();
			return;
		}
		messageQueue.once('idle', listener);
	};

	Protocol.prototype.send = function(pendingMessage) {
		if(pendingMessage.ackRequired) {
			this.messageQueue.push(pendingMessage);
		}
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.send()', 'sending msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(pendingMessage.message));
		}
		pendingMessage.sendAttempted = true;
		this.transport.send(pendingMessage.message);
	};

	Protocol.prototype.getTransport = function() {
		return this.transport;
	};

	Protocol.prototype.getPendingMessages = function() {
		return this.messageQueue.copyAll();
	};

	Protocol.prototype.clearPendingMessages = function() {
		return this.messageQueue.clear();
	};

	Protocol.prototype.finish = function() {
		var transport = this.transport;
		this.onceIdle(function() {
			transport.disconnect();
		});
	};

	function PendingMessage(message, callback) {
		this.message = message;
		this.callback = callback;
		this.merged = false;
		var action = message.action;
		this.sendAttempted = false;
		this.ackRequired = (action == actions.MESSAGE || action == actions.PRESENCE);
	}
	Protocol.PendingMessage = PendingMessage;

	return Protocol;
})();

/* harmony default export */ __webpack_exports__["a"] = (Protocol);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_380416__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var DomEvent = (function() {
	function DomEvent() {}

	DomEvent.addListener = function(target, event, listener) {
		if(target.addEventListener) {
			target.addEventListener(event, listener, false);
		} else {
			target.attachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.removeListener = function(target, event, listener) {
		if(target.removeEventListener) {
			target.removeEventListener(event, listener, false);
		} else {
			target.detachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.addMessageListener = function(target, listener) {
		DomEvent.addListener(target, 'message', listener);
	};

	DomEvent.removeMessageListener = function(target, listener) {
		DomEvent.removeListener(target, 'message', listener);
	};

	DomEvent.addUnloadListener = function(listener) {
		DomEvent.addListener(global, 'unload', listener);
	};

	return DomEvent;
})();

/* harmony default export */ __webpack_exports__["a"] = (DomEvent);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_380416__(17)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_381626__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_381626__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_387076__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_387076__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_391051__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_391051__(12), __nested_webpack_require_391051__(36), __nested_webpack_require_391051__(29));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_391387__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_391387__(1);
/* harmony import */ var _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_391387__(15);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_391387__(3);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_391387__(7);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_391387__(6);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_391387__(2);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_391387__(4);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_391387__(0);









var JSONPTransport = function(connectionManager) {
	var noop = function() {};
	/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
	var _ = global._ablyjs_jsonp = {};

	/* express strips out parantheses from the callback!
	 * Kludge to still alow its responses to work, while not keeping the
	 * function form for normal use and not cluttering window.Ably
	 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
	 */
	_._ = function(id) { return _['_' + id] || noop; };
	var idCounter = 1;
	var head = null;
	var shortName = 'jsonp';

	/* public constructor */
	function JSONPTransport(connectionManager, auth, params) {
		params.stream = false;
		_common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(JSONPTransport, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	JSONPTransport.isAvailable = function() {
		return platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].allowComet;
	};
	if(JSONPTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = JSONPTransport;
	}
	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported) {
		head = document.getElementsByTagName('head')[0];
	}

	/* connectivity check; since this has a hard-coded callback id,
	 * we just make sure that we handle concurrent requests (but the
	 * connectionmanager should ensure this doesn't happen anyway */
	var checksInProgress = null;
	global.JSONPTransport = JSONPTransport

	JSONPTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new JSONPTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'JSONPTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	JSONPTransport.prototype.toString = function() {
		return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	var createRequest = JSONPTransport.prototype.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* JSONP requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = (this && this.timeouts) || timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new Request(undefined, uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].call(this);
		if(id === undefined) id = idCounter++;
		this.id = id;
		this.uri = uri;
		this.params = params || {};
		this.params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(headers) {
			/* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
			if(headers['X-Ably-Version']) this.params.v = headers['X-Ably-Version'];
			if(headers['Ably-Agent']) this.params.agent = headers['Ably-Agent'];
		}
		this.body = body;
		this.method = method;
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.requestComplete = false;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(Request, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]);

	Request.prototype.exec = function() {
		var id = this.id,
			body = this.body,
			method = this.method,
			uri = this.uri,
			params = this.params,
			self = this;

		params.callback = '_ablyjs_jsonp._(' + id + ')';

		params.envelope = 'jsonp';
		if(body) {
			params.body = body;
		}
		if(method && method !== 'get') {
			params.method = method;
		}

		var script = this.script = document.createElement('script');
		var src = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		script.src = src;
		if(script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
			/* The src has been truncated. Can't abort, but can at least emit an
			 * error so the user knows what's gone wrong. (Can't compare strings
			 * directly as src may have a port, script.src won't) */
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
		}
		script.async = true;
		script.type = 'text/javascript';
		script.charset = 'UTF-8';
		script.onerror = function(err) {
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('JSONP script error (event: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(err) + ')', null, 400));
		};

		_['_' + id] = function(message) {
			if(message.statusCode) {
				/* Handle as enveloped jsonp, as all jsonp transport uses should be */
				var response = message.response;
				if(message.statusCode == 204) {
					self.complete(null, null, null, message.statusCode);
				} else if(!response) {
					self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Invalid server response: no envelope detected', null, 500));
				} else if(message.statusCode < 400 || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(response)) {
					/* If response is an array, it's an array of protocol messages -- even if
					 * it contains an error action (hence the nonsuccess statuscode), we can
					 * consider the request to have succeeded, just pass it on to
					 * onProtocolMessage to decide what to do */
					self.complete(null, response, message.headers, message.statusCode);
				} else {
					var err = response.error || new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Error response received from server', null, message.statusCode);
					self.complete(err);
				}
			} else {
				/* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
				self.complete(null, message);
			}
		};

		var timeout = (this.requestMode == _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
		this.timer = setTimeout(function() { self.abort(); }, timeout);
		head.insertBefore(script, head.firstChild);
	};

	Request.prototype.complete = function(err, body, headers, statusCode) {
		headers = headers || {};
		if(!this.requestComplete) {
			this.requestComplete = true;
			var contentType;
			if(body) {
				contentType = (typeof(body) == 'string') ? 'text/plain' : 'application/json';
				headers['content-type'] = contentType;
				this.emit('data', body);
			}

			this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
			this.dispose();
		}
	};

	Request.prototype.abort = function() {
		this.dispose();
	};

	Request.prototype.dispose = function() {
		var timer = this.timer;
		if(timer) {
			clearTimeout(timer);
			this.timer = null;
		}
		var script = this.script;
		if(script.parentNode) script.parentNode.removeChild(script);
		delete _[this.id];
		this.emit('disposed');
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && !platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request) {
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
			var req = createRequest(uri, headers, params, body, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, rest && rest.options.timeouts, method);
			req.once('complete', callback);
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
			return req;
		};

		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
			var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].jsonpInternetUpUrl;

			if(checksInProgress) {
				checksInProgress.push(callback);
				return;
			}
			checksInProgress = [callback];
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);

			var req = new Request('isTheInternetUp', upUrl, null, null, null, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS);
			req.once('complete', function(err, response) {
				var result = !err && response;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
				for(var i = 0; i < checksInProgress.length; i++) checksInProgress[i](null, result);
				checksInProgress = null;
			});
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
		};
	}

	return JSONPTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (JSONPTransport);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_391387__(17)))

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_402742__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_402742__(3);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_402742__(1);
/* harmony import */ var _transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_402742__(20);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_402742__(4);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_402742__(0);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_402742__(8);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_402742__(2);








var WebSocketTransport = function(connectionManager) {
	var WebSocket = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].WebSocket;
	var shortName = 'web_socket';

	/* public constructor */
	function WebSocketTransport(connectionManager, auth, params) {
		this.shortName = shortName;
		/* If is a browser, can't detect pings, so request protocol heartbeats */
		params.heartbeats = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].useProtocolHeartbeats;
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.wsHost = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHost(params.options, params.host, true);
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(WebSocketTransport, _transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	WebSocketTransport.isAvailable = function() {
		return !!WebSocket;
	};

	if(WebSocketTransport.isAvailable())
		connectionManager.supportedTransports[shortName] = WebSocketTransport;

	WebSocketTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new WebSocketTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('wsopen', function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	WebSocketTransport.prototype.createWebSocket = function(uri, connectParams) {
		this.uri = uri + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].toQueryString(connectParams)
		return new WebSocket(this.uri);
	};

	WebSocketTransport.prototype.toString = function() {
		return 'WebSocketTransport; uri=' + this.uri;
	};

	WebSocketTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var wsScheme = options.tls ? 'wss://' : 'ws://';
		var wsUri = wsScheme + this.wsHost + ':' + _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getPort(options) + '/';
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(self.isDisposed) {
				return;
			}
			var paramStr = ''; for(var param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
			if(err) {
				self.disconnect(err);
				return;
			}
			var connectParams = params.getConnectParams(authParams);
			try {
				var wsConnection = self.wsConnection = self.createWebSocket(wsUri, connectParams);
				wsConnection.binaryType = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].binaryType;
				wsConnection.onopen = function() { self.onWsOpen(); };
				wsConnection.onclose = function(ev) { self.onWsClose(ev); };
				wsConnection.onmessage = function(ev) { self.onWsData(ev.data); };
				wsConnection.onerror = function(ev) { self.onWsError(ev); };
				if(wsConnection.on) {
					/* node; browsers currently don't have a general eventemitter and can't detect
					 * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
					wsConnection.on('ping', function() { self.onActivity(); });
				}
			} catch(e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
				self.disconnect(e);
			}
		});
	};

	WebSocketTransport.prototype.send = function(message) {
		var wsConnection = this.wsConnection;
		if(!wsConnection) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
			return;
		}
		try {
			wsConnection.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].serialize(message, this.params.format));
		} catch (e) {
			var msg = 'Exception from ws connection when trying to send: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(e);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', msg);
			/* Don't try to request a disconnect, that'll just involve sending data
			 * down the websocket again. Just finish the transport. */
			this.finish('disconnected', new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 50000, 500));
		}
	};

	WebSocketTransport.prototype.onWsData = function(data) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof(data));
		try {
			this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].deserialize(data, this.format));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
		}
	};

	WebSocketTransport.prototype.onWsOpen = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
		this.emit('wsopen');
	};

	WebSocketTransport.prototype.onWsClose = function(ev) {
		var wasClean, code, reason;
		if(typeof(ev) == 'object') {
			/* W3C spec-compatible */
			wasClean = ev.wasClean;
			code = ev.code;
		} else /*if(typeof(ev) == 'number')*/ {
			/* ws in node */
			code = ev;
			wasClean = (code == 1000);
		}
		delete this.wsConnection;
		if(wasClean) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
			var err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]('Websocket closed', 80003, 400);
			this.finish('disconnected', err);
		} else {
			var msg = 'Unclean disconnection of WebSocket ; code = ' + code,
				err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 80003, 400);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
			this.finish('disconnected', err);
		}
		this.emit('disposed');
	};

	WebSocketTransport.prototype.onWsError = function(err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
		/* Wait a tick before aborting: if the websocket was connected, this event
		 * will be immediately followed by an onclose event with a close code. Allow
		 * that to close it (so we see the close code) rather than anticipating it */
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			self.disconnect(err);
		});
	};

	WebSocketTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.dispose()', '');
		this.isDisposed = true;
		var wsConnection = this.wsConnection;
		if(wsConnection) {
			/* Ignore any messages that come through after dispose() is called but before
			 * websocket is actually closed. (mostly would be harmless, but if it's a
			 * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
			wsConnection.onmessage = function() {};
			delete this.wsConnection;
			/* defer until the next event loop cycle before closing the socket,
			 * giving some implementations the opportunity to send any outstanding close message */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
				wsConnection.close();
			});
		}
	};

	return WebSocketTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (WebSocketTransport);


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_413003__) {

"use strict";

// EXTERNAL MODULE: ./browser/lib/transport/jsonptransport.js
var jsonptransport = __nested_webpack_require_413003__(39);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_413003__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_413003__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_413003__(3);

// EXTERNAL MODULE: ./common/lib/transport/comettransport.js
var comettransport = __nested_webpack_require_413003__(15);

// EXTERNAL MODULE: ./browser/lib/transport/xhrrequest.js
var xhrrequest = __nested_webpack_require_413003__(27);

// CONCATENATED MODULE: ./browser/lib/transport/xhrpollingtransport.js






var xhrpollingtransport_XHRPollingTransport = function(connectionManager) {
	var shortName = 'xhr_polling';

	function XHRPollingTransport(connectionManager, auth, params) {
		params.stream = false;
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRPollingTransport, comettransport["a" /* default */]);

	XHRPollingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRPollingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRPollingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRPollingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRPollingTransport.prototype.toString = function() {
		return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRPollingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRPollingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRPollingTransport;
	}

	return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/xhrstreamingtransport.js






var xhrstreamingtransport_XHRStreamingTransport = function(connectionManager) {
	var shortName = 'xhr_streaming';

	/* public constructor */
	function XHRStreamingTransport(connectionManager, auth, params) {
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRStreamingTransport, comettransport["a" /* default */]);

	XHRStreamingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].streamingSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRStreamingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRStreamingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRStreamingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRStreamingTransport.prototype.toString = function() {
		return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRStreamingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRStreamingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
	}

	return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/index.js




/* harmony default export */ var lib_transport = __webpack_exports__["a"] = ([
  jsonptransport["a" /* default */],
  xhrpollingtransport,
  xhrstreamingtransport
]);


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_417833__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__nested_webpack_require_417833__(43);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_417833__(17)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_420045__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_420045__(17), __nested_webpack_require_420045__(44)))

/***/ }),
/* 44 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 45 */
/***/ (function(module, exports) {



/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_432274__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_432274__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_436272__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_436272__(12), __nested_webpack_require_436272__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_437981__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_437981__(12), __nested_webpack_require_437981__(18), __nested_webpack_require_437981__(49), __nested_webpack_require_437981__(30), __nested_webpack_require_437981__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_446491__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_446491__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_455833__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_455833__.r(__webpack_exports__);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_455833__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_455833__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_455833__(0);

// EXTERNAL MODULE: ./common/lib/util/defaults.js + 1 modules
var defaults = __nested_webpack_require_455833__(4);

// EXTERNAL MODULE: ./common/lib/client/auth.js + 1 modules
var auth = __nested_webpack_require_455833__(14);

// CONCATENATED MODULE: ./common/lib/types/devicedetails.js


var devicedetails_DeviceDetails = (function() {

	function DeviceDetails() {
		this.id = undefined;
		this.deviceSecret = undefined;
		this.platform = undefined;
		this.formFactor = undefined;
		this.clientId = undefined;
		this.metadata = undefined;
		this.deviceIdentityToken = undefined;
		this.push = {
			recipient: undefined,
			state: undefined,
			error: undefined
		};
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	DeviceDetails.prototype.toJSON = function() {
		return {
			id: this.id,
			deviceSecret: this.deviceSecret,
			platform: this.platform,
			formFactor: this.formFactor,
			clientId: this.clientId,
			metadata: this.metadata,
			deviceIdentityToken: this.deviceIdentityToken,
			push: {
				recipient: this.push.recipient,
				state: this.push.state,
				error: this.push.error
			}
		};
	};

	DeviceDetails.prototype.toString = function() {
		var result = '[DeviceDetails';
		if(this.id)
			result += '; id=' + this.id;
		if(this.platform)
			result += '; platform=' + this.platform;
		if(this.formFactor)
			result += '; formFactor=' + this.formFactor;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.metadata)
			result += '; metadata=' + this.metadata;
		if(this.deviceIdentityToken)
			result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
		if(this.push.recipient)
			result += '; push.recipient=' + JSON.stringify(this.push.recipient);
		if(this.push.state)
			result += '; push.state=' + this.push.state;
		if(this.push.error)
			result += '; push.error=' + JSON.stringify(this.push.error);
		if(this.push.metadata)
			result += '; push.metadata=' + this.push.metadata;
		result += ']';
		return result;
	};

	DeviceDetails.toRequestBody = utils["a" /* default */].encodeBody;

	DeviceDetails.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return DeviceDetails.fromValuesArray(body);
		} else {
			return DeviceDetails.fromValues(body);
		}
	};

	DeviceDetails.fromValues = function(values) {
		values.error = values.error && ErrorInfo.fromValues(values.error); 
		return utils["a" /* default */].mixin(new DeviceDetails(), values);
	};

	DeviceDetails.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);
		return result;
	};

	return DeviceDetails;
})();

/* harmony default export */ var devicedetails = (devicedetails_DeviceDetails);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_455833__(6);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_455833__(5);

// CONCATENATED MODULE: ./common/lib/client/resource.js







var resource_Resource = (function() {
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Resource() {}

	function withAuthDetails(rest, headers, params, errCallback, opCallback) {
		if (http["a" /* default */].supportsAuthHeaders) {
			rest.auth.getAuthHeaders(function(err, authHeaders) {
				if(err)
					errCallback(err);
				else
					opCallback(utils["a" /* default */].mixin(authHeaders, headers), params);
			});
		} else {
			rest.auth.getAuthParams(function(err, authParams) {
				if(err)
					errCallback(err);
				else
					opCallback(headers, utils["a" /* default */].mixin(authParams, params));
			});
		}
	}

	function unenvelope(callback, format) {
		return function(err, body, outerHeaders, unpacked, outerStatusCode) {
			if(err && !body) {
				callback(err);
				return;
			}

			if(!unpacked) {
				try {
					body = utils["a" /* default */].decodeBody(body, format);
				} catch(e) {
					callback(e);
					return;
				}
			}

			if(body.statusCode === undefined) {
				/* Envelope already unwrapped by the transport */
				callback(err, body, outerHeaders, true, outerStatusCode);
				return;
			}

			var wrappedStatusCode = body.statusCode,
				response = body.response,
				wrappedHeaders = body.headers;

			if(wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
				/* handle wrapped errors */
				var wrappedErr = (response && response.error) || err;
				if(!wrappedErr) {
					wrappedErr = new Error("Error in unenveloping " + body);
					wrappedErr.statusCode = wrappedStatusCode;
				}
				callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
				return;
			}

			callback(err, response, wrappedHeaders, true, wrappedStatusCode);
		};
	}

	function paramString(params) {
		var paramPairs = [];
		if (params) {
			for (var needle in params) {
				paramPairs.push(needle + '=' + params[needle]);
			}
		}
		return paramPairs.join('&');
	}

	function urlFromPathAndParams(path, params) {
		return path + (params ? '?' : '') + paramString(params);
	}

	function logResponseHandler(callback, method, path, params) {
		return function(err, body, headers, unpacked, statusCode) {
			if (err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + utils["a" /* default */].inspectError(err));
			} else {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()',
					'Received; ' + urlFromPathAndParams(path, params) + '; Headers: ' + paramString(headers) + '; StatusCode: ' + statusCode + '; Body: ' + (bufferutils["a" /* default */].isBuffer(body) ? body.toString() : body));
			}
			if (callback) { callback(err, body, headers, unpacked, statusCode); }
		}
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		Resource[method] = function(rest, path, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, null, origheaders, origparams, envelope, callback);
		};
	});

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		Resource[method] = function(rest, path, body, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, body, origheaders, origparams, envelope, callback);
		};
	});

	Resource['do'] = function(method, rest, path, body, origheaders, origparams, envelope, callback) {
		if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
			callback = logResponseHandler(callback, method, path, origparams);
		}

		if(envelope) {
			callback = (callback && unenvelope(callback, envelope));
			(origparams = (origparams || {}))['envelope'] = envelope;
		}

		function doRequest(headers, params) {
			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
			}

			var args = [rest, path, headers, body, params, function(err, res, headers, unpacked, statusCode) {
				if(err && auth["a" /* default */].isTokenErr(err)) {
					/* token has expired, so get a new one */
					rest.auth.authorize(null, null, function(err) {
						if(err) {
							callback(err);
							return;
						}
						/* retry ... */
						withAuthDetails(rest, origheaders, origparams, callback, doRequest);
					});
					return;
				}
				callback(err, res, headers, unpacked, statusCode);
			}];
			if (!body) {
				args.splice(3, 1);
			}

			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				var decodedBody = body;
				if ((headers['content-type'] || '').indexOf('msgpack') > 0) {
					try {
						decodedBody = msgpack.decode(body);
					} catch (decodeErr) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + utils["a" /* default */].inspectError(decodeErr));
					}
				}
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
			}
			http["a" /* default */][method].apply(this, args);
		}

		withAuthDetails(rest, origheaders, origparams, callback, doRequest);
	};

	return Resource;
})();

/* harmony default export */ var client_resource = (resource_Resource);

// CONCATENATED MODULE: ./common/lib/client/paginatedresource.js





var paginatedresource_PaginatedResource = (function() {

	function getRelParams(linkUrl) {
		var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
		return urlMatch && utils["a" /* default */].parseQueryString(urlMatch[2]);
	}

	function parseRelLinks(linkHeader) {
		if(typeof(linkHeader) == 'string')
			linkHeader = linkHeader.split(',');

		var relParams = {};
		for(var i = 0; i < linkHeader.length; i++) {
			var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
			if(linkMatch) {
				var params = getRelParams(linkMatch[1]);
				if(params)
					relParams[linkMatch[2]] = params;
			}
		}
		return relParams;
	}

	function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
		this.rest = rest;
		this.path = path;
		this.headers = headers;
		this.envelope = envelope;
		this.bodyHandler = bodyHandler;
		this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		PaginatedResource.prototype[method] = function(params, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, self.headers, params, self.envelope, function(err, body, headers, unpacked, statusCode) {
				self.handlePage(err, body, headers, unpacked, statusCode, callback);
			});
		};
	})

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		PaginatedResource.prototype[method] = function(params, body, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, body, self.headers, params, self.envelope, function(err, resbody, headers, unpacked, statusCode) {
				if(callback) {
					self.handlePage(err, resbody, headers, unpacked, statusCode, callback);
				}
			});
		};
	});

	function returnErrOnly(err, body, useHPR) {
		/* If using httpPaginatedResponse, errors from Ably are returned as part of
		 * the HPR, only do callback(err) for network errors etc. which don't
		 * return a body and/or have no ably-originated error code (non-numeric
		 * error codes originate from node) */
		return !(useHPR && (body || typeof err.code === 'number'));
	}

	PaginatedResource.prototype.handlePage = function(err, body, headers, unpacked, statusCode, callback) {
		if(err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + utils["a" /* default */].inspectError(err));
			callback(err);
			return;
		}
		var items, linkHeader, relParams;
		try {
			items = this.bodyHandler(body, headers, unpacked);
		} catch(e) {
			/* If we got an error, the failure to parse the body is almost certainly
			 * due to that, so cb with that in preference to the parse error */
			callback(err || e);
			return;
		}

		if(headers && (linkHeader = (headers['Link'] || headers['link']))) {
			relParams = parseRelLinks(linkHeader);
		}

		if(this.useHttpPaginatedResponse) {
			callback(null, new HttpPaginatedResponse(this, items, headers, statusCode, relParams, err));
		} else {
			callback(null, new PaginatedResult(this, items, relParams));
		}
	};

	function PaginatedResult(resource, items, relParams) {
		this.resource = resource;
		this.items = items;

		if(relParams) {
			var self = this;
			if('first' in relParams) {
				this.first = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'first', []);
					}
					self.get(relParams.first, cb);
				};
			}
			if('current' in relParams) {
				this.current = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'current', []);
					}
					self.get(relParams.current, cb);
				};
			}
			this.next = function(cb) {
				if(!cb && self.resource.rest.options.promises) {
					return utils["a" /* default */].promisify(self, 'next', []);
				}
				if('next' in relParams) {
					self.get(relParams.next, cb);
				} else {
					cb(null, null);
				}
			};

			this.hasNext = function() { return ('next' in relParams) };
			this.isLast = function() { return !this.hasNext(); }
		}
	}

	/* We assume that only the initial request can be a POST, and that accessing
	 * the rest of a multipage set of results can always be done with GET */
	PaginatedResult.prototype.get = function(params, callback) {
		var res = this.resource;
		client_resource.get(res.rest, res.path, res.headers, params, res.envelope, function(err, body, headers, unpacked, statusCode) {
			res.handlePage(err, body, headers, unpacked, statusCode, callback);
		});
	};

	function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
		PaginatedResult.call(this, resource, items, relParams);
		this.statusCode = statusCode;
		this.success = statusCode < 300 && statusCode >= 200;
		this.headers = headers;
		this.errorCode = err && err.code;
		this.errorMessage = err && err.message;
	}
	utils["a" /* default */].inherits(HttpPaginatedResponse, PaginatedResult);

	return PaginatedResource;
})();

/* harmony default export */ var paginatedresource = (paginatedresource_PaginatedResource);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_455833__(2);

// CONCATENATED MODULE: ./common/lib/types/pushchannelsubscription.js


var pushchannelsubscription_PushChannelSubscription = (function() {

	function PushChannelSubscription() {
		this.channel = undefined;
		this.deviceId = undefined;
		this.clientId = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PushChannelSubscription.prototype.toJSON = function() {
		return {
			channel: this.channel,
			deviceId: this.deviceId,
			clientId: this.clientId
		};
	};

	PushChannelSubscription.prototype.toString = function() {
		var result = '[PushChannelSubscription';
		if(this.channel)
			result += '; channel=' + this.channel;
		if(this.deviceId)
			result += '; deviceId=' + this.deviceId;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		result += ']';
		return result;
	};

	PushChannelSubscription.toRequestBody = utils["a" /* default */].encodeBody;

	PushChannelSubscription.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return PushChannelSubscription.fromValuesArray(body);
		} else {
			return PushChannelSubscription.fromValues(body);
		}
	};

	PushChannelSubscription.fromValues = function(values) {
		return utils["a" /* default */].mixin(new PushChannelSubscription(), values);
	};

	PushChannelSubscription.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);
		return result;
	};

	return PushChannelSubscription;
})();

/* harmony default export */ var pushchannelsubscription = (pushchannelsubscription_PushChannelSubscription);

// CONCATENATED MODULE: ./common/lib/client/push.js








var push_Push = (function() {
	var noop = function() {};

	function Push(rest) {
		this.rest = rest;
		this.admin = new Admin(rest);
	}

	function Admin(rest) {
		this.rest = rest;
		this.deviceRegistrations = new DeviceRegistrations(rest);
		this.channelSubscriptions = new ChannelSubscriptions(rest);
	}

	Admin.prototype.publish = function(recipient, payload, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = utils["a" /* default */].mixin({recipient: recipient}, payload),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/publish', requestBody, headers, params, false, function(err) { callback(err); });
	};

	function DeviceRegistrations(rest) {
		this.rest = rest;
	}

	DeviceRegistrations.prototype.save = function(device, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = devicedetails.fromValues(device),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.get = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		client_resource.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/deviceRegistrations', headers, envelope, function(body, headers, unpacked) {
			return devicedetails.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	DeviceRegistrations.prototype.remove = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			params = {},
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'remove', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, false, function(err) { callback(err); });
	};

	DeviceRegistrations.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations', headers, params, false, function(err) { callback(err); });
	};

	function ChannelSubscriptions(rest) {
		this.rest = rest;
	}

	ChannelSubscriptions.prototype.save = function(subscription, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = pushchannelsubscription.fromValues(subscription),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/channelSubscriptions', requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && pushchannelsubscription.fromResponseBody(body, !unpacked && format));
		});
	};

	ChannelSubscriptions.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/channelSubscriptions', headers, envelope, function(body, headers, unpacked) {
			return pushchannelsubscription.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	ChannelSubscriptions.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/channelSubscriptions', headers, params, false, function(err) { callback(err); });
	};

	/* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
	ChannelSubscriptions.prototype.remove = ChannelSubscriptions.prototype.removeWhere;

	ChannelSubscriptions.prototype.listChannels = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'listChannels', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		(new paginatedresource(rest, '/push/channels', headers, envelope, function(body, headers, unpacked) {
			var f = !unpacked && format;

			if(f) {
				body = utils["a" /* default */].decodeBody(body, format);
			}

			for(var i = 0; i < body.length; i++) {
				body[i] = String(body[i]);
			}
			return body;
		})).get(params, callback);
	};

	return Push;
})();

/* harmony default export */ var push = (push_Push);

// EXTERNAL MODULE: ./common/lib/util/eventemitter.js
var eventemitter = __nested_webpack_require_455833__(7);

// EXTERNAL MODULE: ./common/lib/types/presencemessage.js
var presencemessage = __nested_webpack_require_455833__(11);

// CONCATENATED MODULE: ./common/lib/client/presence.js







var presence_Presence = (function() {
	function noop() {}
	function Presence(channel) {
		this.channel = channel;
		this.basePath = channel.basePath + '/presence';
	}
	utils["a" /* default */].inherits(Presence, eventemitter["a" /* default */]);

	Presence.prototype.get = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'get', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath, headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	Presence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
		this._history(params, callback);
	};

	Presence.prototype._history = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, '_history', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this.channel;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath + '/history', headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	return Presence;
})();

/* harmony default export */ var client_presence = (presence_Presence);

// EXTERNAL MODULE: ./browser/lib/util/crypto.js
var util_crypto = __nested_webpack_require_455833__(19);

// EXTERNAL MODULE: ./common/lib/types/message.js
var types_message = __nested_webpack_require_455833__(9);

// CONCATENATED MODULE: ./common/lib/client/channel.js











var channel_Channel = (function() {
	function noop() {}
	var MSG_ID_ENTROPY_BYTES = 9;

	/* public constructor */
	function Channel(rest, name, channelOptions) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Channel()', 'started; name = ' + name);
		eventemitter["a" /* default */].call(this);
		this.rest = rest;
		this.name = name;
		this.basePath = '/channels/' + encodeURIComponent(name);
		this.presence = new client_presence(this);
		this.setOptions(channelOptions);
	}
	utils["a" /* default */].inherits(Channel, eventemitter["a" /* default */]);

	Channel.prototype.setOptions = function(options) {
		this.channelOptions = options = options || {};
		if(options.cipher) {
			if(!util_crypto["a" /* default */]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = util_crypto["a" /* default */].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		} else if('cipher' in options) {
			/* Don't deactivate an existing cipher unless options
			 * has a 'cipher' key that's falsey */
			options.cipher = null;
			options.channelCipher = null;
		}
	};

	Channel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		this._history(params, callback);
	};

	Channel.prototype._history = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channelOptions;
		(new paginatedresource(rest, this.basePath + '/messages', headers, envelope, function(body, headers, unpacked) {
			return types_message["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	function allEmptyIds(messages) {
		return utils["a" /* default */].arrEvery(messages, function(message) {
			return !message.id;
		});
	}

	Channel.prototype.publish = function() {
		var argCount = arguments.length,
			first = arguments[0],
			second = arguments[1],
			callback = arguments[argCount - 1],
			messages,
			params,
			self = this;

		if(typeof(callback) !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(typeof first === 'string' || first === null) {
			/* (name, data, ...) */
			messages = [types_message["a" /* default */].fromValues({name: first, data: second})];
			params = arguments[2];
		} else if(utils["a" /* default */].isObject(first)) {
			messages = [types_message["a" /* default */].fromValues(first)];
			params = arguments[1];
		} else if(utils["a" /* default */].isArray(first)) {
			messages = types_message["a" /* default */].fromValuesArray(first);
			params = arguments[1];
		} else {
			throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		}

		if(typeof params !== 'object' || !params) {
			/* No params supplied (so after-message argument is just the callback or undefined) */
			params = {};
		}

		var rest = this.rest,
			options = rest.options,
			format = options.useBinaryProtocol ? 'msgpack' : 'json',
			idempotentRestPublishing = rest.options.idempotentRestPublishing,
			headers = utils["a" /* default */].defaultPostHeaders(format);

		if(options.headers)
			utils["a" /* default */].mixin(headers, options.headers);

		if(idempotentRestPublishing && allEmptyIds(messages)) {
			var msgIdBase = utils["a" /* default */].randomString(MSG_ID_ENTROPY_BYTES);
			utils["a" /* default */].arrForEach(messages, function(message, index) {
				message.id = msgIdBase + ':' + index.toString();
			});
		}

		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if(err) {
				callback(err);
				return;
			}

			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages),
				maxMessageSize = options.maxMessageSize;
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}

			self._publish(types_message["a" /* default */].serialize(messages, format), headers, params, callback);
		});
	};

	Channel.prototype._publish = function(requestBody, headers, params, callback) {
		client_resource.post(this.rest, this.basePath + '/messages', requestBody, headers, params, false, callback);
	};

	return Channel;
})();

/* harmony default export */ var client_channel = (channel_Channel);

// CONCATENATED MODULE: ./common/lib/types/stats.js


var stats_Stats = (function() {

	function MessageCount(values) {
		this.count = (values && values.count) || 0;
		this.data = (values && values.data) || 0;
		this.uncompressedData = (values && values.uncompressedData) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function MessageCategory(values) {
		var self = this;
		MessageCount.call(this, values);
		this.category = undefined;
		if (values && values.category) {
			this.category = { };
			utils["a" /* default */].forInOwnNonNullProps(values.category, function(prop) {
				self.category[prop] = new MessageCount(values.category[prop]);
			});
		}
	}

	function ResourceCount(values) {
		this.peak = (values && values.peak) || 0;
		this.min = (values && values.min) || 0;
		this.mean = (values && values.mean) || 0;
		this.opened = (values && values.opened) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function RequestCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function ConnectionTypes(values) {
		this.plain = new ResourceCount(values && values.plain);
		this.tls = new ResourceCount(values && values.tls);
		this.all = new ResourceCount(values && values.all);
	}

	function MessageTypes(values) {
		this.messages = new MessageCategory(values && values.messages);
		this.presence = new MessageCategory(values && values.presence);
		this.all = new MessageCategory(values && values.all);
	}

	function MessageTraffic(values) {
		this.realtime = new MessageTypes(values && values.realtime);
		this.rest = new MessageTypes(values && values.rest);
		this.webhook = new MessageTypes(values && values.webhook);
		this.sharedQueue = new MessageTypes(values && values.sharedQueue);
		this.externalQueue = new MessageTypes(values && values.externalQueue);
		this.httpEvent = new MessageTypes(values && values.httpEvent);
		this.push = new MessageTypes(values && values.push);
		this.all = new MessageTypes(values && values.all);
	}

	function MessageDirections(values) {
		this.all           = new MessageTypes(values && values.all);
		this.inbound       = new MessageTraffic(values && values.inbound);
		this.outbound      = new MessageTraffic(values && values.outbound);
	}

	function XchgMessages(values) {
		this.all           = new MessageTypes(values && values.all);
		this.producerPaid  = new MessageDirections(values && values.producerPaid);
		this.consumerPaid  = new MessageDirections(values && values.consumerPaid);
	}

	function PushStats(values) {
		this.messages = (values && values.messages) || 0;
		var notifications = values && values.notifications;
		this.notifications = {
			invalid: notifications && notifications.invalid || 0,
			attempted: notifications && notifications.attempted || 0,
			successful: notifications && notifications.successful || 0,
			failed: notifications && notifications.failed || 0
		};
		this.directPublishes = (values && values.directPublishes) || 0;
	}

	function ProcessedCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.skipped = (values && values.skipped) || 0;
		this.failed = (values && values.failed) || 0;
	}

	function ProcessedMessages(values) {
		var self = this;
		this.delta = undefined;
		if (values && values.delta) {
			this.delta = { };
			utils["a" /* default */].forInOwnNonNullProps(values.delta, function(prop) {
				self.delta[prop] = new ProcessedCount(values.delta[prop]);
			});
		}
	}

	function Stats(values) {
		MessageDirections.call(this, values);
		this.persisted     = new MessageTypes(values && values.persisted);
		this.connections   = new ConnectionTypes(values && values.connections);
		this.channels      = new ResourceCount(values && values.channels);
		this.apiRequests   = new RequestCount(values && values.apiRequests);
		this.tokenRequests = new RequestCount(values && values.tokenRequests);
		this.xchgProducer  = new XchgMessages(values && values.xchgProducer);
		this.xchgConsumer  = new XchgMessages(values && values.xchgConsumer);
		this.push          = new PushStats(values && values.pushStats);
		this.processed     = new ProcessedMessages(values && values.processed);
		this.inProgress    = (values && values.inProgress) || undefined;
		this.unit          = (values && values.unit) || undefined;
		this.intervalId    = (values && values.intervalId) || undefined;
	}

	Stats.fromValues = function(values) {
		return new Stats(values);
	};

	return Stats;
})();

/* harmony default export */ var stats = (stats_Stats);

// CONCATENATED MODULE: ./common/lib/client/rest.js












var rest_Rest = (function() {
	var noop = function() {};
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Rest(options) {
		if(!(this instanceof Rest)){
			return new Rest(options);
		}

		/* normalise options */
		if(!options) {
			var msg = 'no options provided';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
			throw new Error(msg);
		}
		options = defaults["a" /* default */].objectifyOptions(options);

		if(options.log) {
			logger["a" /* default */].setLog(options.log.level, options.log.handler);
		}
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + utils["a" /* default */].inspect(options));

		this.options = defaults["a" /* default */].normaliseOptions(options);

		/* process options */
		if(options.key) {
			var keyMatch = options.key.match(/^([^:\s]+):([^:.\s]+)$/);
			if(!keyMatch) {
				var msg = 'invalid key parameter';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
				throw new Error(msg);
			}
			options.keyName = keyMatch[1];
			options.keySecret = keyMatch[2];
		}

		if('clientId' in options) {
			if(!(typeof(options.clientId) === 'string' || options.clientId === null))
				throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
			else if(options.clientId === '*')
				throw new errorinfo["a" /* default */]('Can’t use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Rest()', 'started; version = ' + defaults["a" /* default */].libstring);

		this.baseUri = this.authority = function(host) { return defaults["a" /* default */].getHttpScheme(options) + host + ':' + defaults["a" /* default */].getPort(options, false); };
		this._currentFallback = null;

		this.serverTimeOffset = null;
		this.auth = new auth["a" /* default */](this, options);
		this.channels = new Channels(this);
		this.push = new push(this);
	}

	Rest.prototype.stats = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'stats', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders(),
			format = this.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;

		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);

		(new paginatedresource(this, '/stats', headers, envelope, function(body, headers, unpacked) {
			var statsValues = (unpacked ? body : JSON.parse(body));
			for(var i = 0; i < statsValues.length; i++) statsValues[i] = stats.fromValues(statsValues[i]);
			return statsValues;
		})).get(params, callback);
	};

	Rest.prototype.time = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'time', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders();
		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);
		var self = this;
		var timeUri = function(host) { return self.authority(host) + '/time' };
		http["a" /* default */].get(this, timeUri, headers, params, function(err, res, headers, unpacked) {
			if(err) {
				callback(err);
				return;
			}
			if(!unpacked) res = JSON.parse(res);
			var time = res[0];
			if(!time) {
				err = new Error('Internal error (unexpected result type from GET /time)');
				err.statusCode = 500;
				callback(err);
				return;
			}
			/* calculate time offset only once for this device by adding to the prototype */
			self.serverTimeOffset = (time - utils["a" /* default */].now());
			callback(null, time);
		});
	};

	Rest.prototype.request = function(method, path, params, body, customHeaders, callback) {
		var useBinary = this.options.useBinaryProtocol,
			encoder = useBinary ? msgpack.encode: JSON.stringify,
			decoder = useBinary ? msgpack.decode : JSON.parse,
			format = useBinary ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;
		params = params || {};
		method = method.toLowerCase();
		var headers = method == 'get' ? utils["a" /* default */].defaultGetHeaders(format) : utils["a" /* default */].defaultPostHeaders(format);

		if(callback === undefined) {
			if(this.options.promises) {
				return utils["a" /* default */].promisify(this, 'request', [method, path, params, body, customHeaders]);
			}
			callback = noop;
		}

		if(typeof body !== 'string') {
			body = encoder(body);
		}
		if(this.options.headers) {
			utils["a" /* default */].mixin(headers, this.options.headers);
		}
		if(customHeaders) {
			utils["a" /* default */].mixin(headers, customHeaders);
		}
		var paginatedResource = new paginatedresource(this, path, headers, envelope, function(resbody, headers, unpacked) {
			return utils["a" /* default */].ensureArray(unpacked ? resbody : decoder(resbody));
		}, /* useHttpPaginatedResponse: */ true);

		if(!utils["a" /* default */].arrIn(http["a" /* default */].methods, method)) {
			throw new errorinfo["a" /* default */]('Unsupported method ' + method, 40500, 405);
		}

		if(utils["a" /* default */].arrIn(http["a" /* default */].methodsWithBody, method)) {
			paginatedResource[method](params, body, callback);
		} else {
			paginatedResource[method](params, callback);
		}
	};

	Rest.prototype.setLog = function(logOptions) {
		logger["a" /* default */].setLog(logOptions.level, logOptions.handler);
	};

	function Channels(rest) {
		this.rest = rest;
		this.all = Object.create(null);
	}

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			this.all[name] = channel = new client_channel(this.rest, name, channelOptions);
		} else if(channelOptions) {
			channel.setOptions(channelOptions);
		}

		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		delete this.all[String(name)];
	};

	return Rest;
})();

rest_Rest.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new rest_Rest(options);
};

rest_Rest.Callbacks = rest_Rest;

/* harmony default export */ var client_rest = (rest_Rest);

// EXTERNAL MODULE: ./common/lib/transport/connectionmanager.js
var connectionmanager = __nested_webpack_require_455833__(25);

// EXTERNAL MODULE: ./common/lib/client/connectionstatechange.js
var connectionstatechange = __nested_webpack_require_455833__(21);

// CONCATENATED MODULE: ./common/lib/client/connection.js






var connection_Connection = (function() {
	function noop() {}

	/* public constructor */
	function Connection(ably, options) {
		eventemitter["a" /* default */].call(this);
		this.ably = ably;
		this.connectionManager = new connectionmanager["a" /* default */](ably, options);
		this.state = this.connectionManager.state.state;
		this.key = undefined;
		this.id = undefined;
		this.serial = undefined;
		this.timeSerial = undefined;
		this.recoveryKey = undefined;
		this.errorReason = null;

		var self = this;
		this.connectionManager.on('connectionstate', function(stateChange) {
			var state = self.state = stateChange.current;
			utils["a" /* default */].nextTick(function() {
				self.emit(state, stateChange);
			});
		});
		this.connectionManager.on('update', function(stateChange) {
			utils["a" /* default */].nextTick(function() {
				self.emit('update', stateChange);
			});
		});
	}
	utils["a" /* default */].inherits(Connection, eventemitter["a" /* default */]);

	Connection.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener, new connectionstatechange["a" /* default */](undefined, state));
	}

	Connection.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.connect()', '');
		this.connectionManager.requestState({state: 'connecting'});
	};

	Connection.prototype.ping = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.ping()', '');
		if(!callback) {
			if(this.ably.options.promises) {
				return utils["a" /* default */].promisify(this, 'ping', arguments);
			}
			callback = noop;
		}
		this.connectionManager.ping(null, callback);
	};

	Connection.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
		this.connectionManager.requestState({state: 'closing'});
	};

	return Connection;
})();

/* harmony default export */ var connection = (connection_Connection);

// EXTERNAL MODULE: ./common/lib/types/protocolmessage.js
var protocolmessage = __nested_webpack_require_455833__(8);

// EXTERNAL MODULE: ./common/lib/transport/connectionerror.js
var connectionerror = __nested_webpack_require_455833__(13);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var util_multicaster = __nested_webpack_require_455833__(22);

// CONCATENATED MODULE: ./common/lib/client/channelstatechange.js
var ChannelStateChange = (function() {

	/* public constructor */
	function ChannelStateChange(previous, current, resumed, reason) {
		this.previous = previous;
		this.current = current;
		if(current === 'attached') this.resumed = resumed;
		if(reason) this.reason = reason;
	}

	return ChannelStateChange;
})();

/* harmony default export */ var channelstatechange = (ChannelStateChange);

// CONCATENATED MODULE: ./common/lib/client/realtimepresence.js











var realtimepresence_RealtimePresence = (function() {
	var noop = function() {};

	function memberKey(item) {
		return item.clientId + ':' + item.connectionId;
	}

	function getClientId(realtimePresence) {
		return realtimePresence.channel.realtime.auth.clientId;
	}

	function isAnonymousOrWildcard(realtimePresence) {
		var realtime = realtimePresence.channel.realtime;
		/* If not currently connected, we can't assume that we're an anonymous
		 * client, as realtime may inform us of our clientId in the CONNECTED
		 * message. So assume we're not anonymous and leave it to realtime to
		 * return an error if we are */
		var clientId = realtime.auth.clientId;
		return (!clientId || (clientId === '*')) && realtime.connection.state === 'connected';
	}

	/* Callback is called only in the event of an error */
	function waitAttached(channel, callback, action) {
		switch(channel.state) {
			case 'attached':
			case 'suspended':
				action();
				break;
			case 'initialized':
			case 'detached':
			case 'detaching':
			case 'attaching':
				channel.attach(function(err) {
					if(err) callback(err);
					else action();
				});
				break;
			default:
				callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError(channel.state)));
		}
	}

	function RealtimePresence(channel, options) {
		client_presence.call(this, channel);
		this.syncComplete = false;
		this.members = new PresenceMap(this);
		this._myMembers = new PresenceMap(this);
		this.subscriptions = new eventemitter["a" /* default */]();
		this.pendingPresence = [];
	}
	utils["a" /* default */].inherits(RealtimePresence, client_presence);

	RealtimePresence.prototype.enter = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to enter a presence channel', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'enter', callback);
	};

	RealtimePresence.prototype.update = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to update presence data', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'update', callback);
	};

	RealtimePresence.prototype.enterClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'enter', callback);
	};

	RealtimePresence.prototype.updateClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'update', callback);
	};

	RealtimePresence.prototype._enterOrUpdateClient = function(clientId, data, action, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, '_enterOrUpdateClient', [clientId, data, action]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.' + action + 'Client()',
		  'channel = ' + channel.name + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));

		var presence = presencemessage["a" /* default */].fromValues({
			action : action,
			data   : data
		});
		if (clientId) {
			presence.clientId = clientId;
		}

		var self = this;
		presencemessage["a" /* default */].encode(presence, channel.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			switch(channel.state) {
				case 'attached':
					channel.sendPresence(presence, callback);
					break;
				case 'initialized':
				case 'detached':
					channel.attach();
				case 'attaching':
					self.pendingPresence.push({
						presence : presence,
						callback : callback
					});
					break;
				default:
					err = new errorinfo["a" /* default */]('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
					err.code = 90001;
					callback(err);
			}
		});
	};

	RealtimePresence.prototype.leave = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must have been specified to enter or leave a presence channel', 40012, 400);
		}
		return this.leaveClient(undefined, data, callback);
	};

	RealtimePresence.prototype.leaveClient = function(clientId, data, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'leaveClient', [clientId, data]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
		var presence = presencemessage["a" /* default */].fromValues({
			action : 'leave',
			data   : data
		});
		if (clientId) { presence.clientId = clientId; }

		switch(channel.state) {
			case 'attached':
				channel.sendPresence(presence, callback);
				break;
			case 'attaching':
				this.pendingPresence.push({
					presence : presence,
					callback : callback
				});
				break;
			case 'initialized':
			case 'failed':
				/* we're not attached; therefore we let any entered status
				 * timeout by itself instead of attaching just in order to leave */
				var err = new errorinfo["a" /* default */]('Unable to leave presence channel (incompatible state)', 90001);
				callback(err);
				break;
			default:
				/* there is no connection; therefore we let
				 * any entered status timeout by itself */
				callback(connectionerror["a" /* default */].failed);
		}
	};

	RealtimePresence.prototype.get = function(/* params, callback */) {
		var args = Array.prototype.slice.call(arguments);
		if(args.length == 1 && typeof(args[0]) == 'function')
			args.unshift(null);

		var params = args[0],
			callback = args[1],
			waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', args);
			}
			callback = noop;
		}

		function returnMembers(members) {
			callback(null, params ? members.list(params) : members.values());
		}

		/* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
		if(this.channel.state === 'suspended') {
			if(waitForSync) {
				callback(errorinfo["a" /* default */].fromValues({
					statusCode: 400,
					code: 91005,
					message: 'Presence state is out of sync due to channel being in the SUSPENDED state'
				}));
			} else {
				returnMembers(this.members);
			}
			return;
		}

		var self = this;
		waitAttached(this.channel, callback, function() {
			var members = self.members;
			if(waitForSync) {
				members.waitSync(function() {
					returnMembers(members);
				});
			} else {
				returnMembers(members);
			}
		});
	};

	RealtimePresence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.channel.state === 'attached') {
				delete params.untilAttach;
				params.from_serial = this.channel.properties.attachSerial;
			} else {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached, was: " + this.channel.state, 40000, 400));
			}
		}

		client_presence.prototype._history.call(this, params, callback);
	};

	RealtimePresence.prototype.setPresence = function(presenceSet, isSync, syncChannelSerial) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
		var syncCursor, match, members = this.members, myMembers = this._myMembers,
			broadcastMessages = [], connId = this.channel.connectionManager.connectionId;

		if(isSync) {
			this.members.startSync();
			if(syncChannelSerial && (match = syncChannelSerial.match(/^[\w\-]+:(.*)$/))) {
				syncCursor = match[1];
			}
		}

		for(var i = 0; i < presenceSet.length; i++) {
			var presence = presencemessage["a" /* default */].fromValues(presenceSet[i]);
			switch(presence.action) {
				case 'leave':
					if(members.remove(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId && !presence.isSynthesized()) {
						myMembers.remove(presence);
					}
					break;
				case 'enter':
				case 'present':
				case 'update':
					if(members.put(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId) {
						myMembers.put(presence);
					}
					break;
			}
		}
		/* if this is the last (or only) message in a sequence of sync updates, end the sync */
		if(isSync && !syncCursor) {
			members.endSync();
			/* RTP5c2: re-enter our own members if they haven't shown up in the sync */
			this._ensureMyMembersPresent();
			this.channel.setInProgress(realtimechannel.progressOps.sync, false);
			this.channel.syncChannelSerial = null;
		}

		/* broadcast to listeners */
		for(var i = 0; i < broadcastMessages.length; i++) {
			var presence = broadcastMessages[i];
			this.subscriptions.emit(presence.action, presence);
		}
	};

	RealtimePresence.prototype.onAttached = function(hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);

		if(hasPresence) {
			this.members.startSync();
		} else {
			this._synthesizeLeaves(this.members.values());
			this.members.clear();
			this._ensureMyMembersPresent();
		}

		/* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
		var pendingPresence = this.pendingPresence,
			pendingPresCount = pendingPresence.length;

		if(pendingPresCount) {
			this.pendingPresence = [];
			var presenceArray = [];
			var multicaster = Object(util_multicaster["a" /* default */])();
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
			for(var i = 0; i < pendingPresCount; i++) {
				var event = pendingPresence[i];
				presenceArray.push(event.presence);
				multicaster.push(event.callback);
			}
			this.channel.sendPresence(presenceArray, multicaster);
		}
	};

	RealtimePresence.prototype.actOnChannelState = function(state, hasPresence, err) {
		switch(state) {
			case 'attached':
				this.onAttached(hasPresence);
				break;
			case 'detached':
			case 'failed':
				this._clearMyMembers();
				this.members.clear();
				/* falls through */
			case 'suspended':
				this.failPendingPresence(err);
				break;
		}
	};

	RealtimePresence.prototype.failPendingPresence = function(err) {
		if(this.pendingPresence.length) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + utils["a" /* default */].inspectError(err));
			for(var i = 0; i < this.pendingPresence.length; i++)
				try {
					this.pendingPresence[i].callback(err);
				} catch(e) {}
			this.pendingPresence = [];
		}
	};

	RealtimePresence.prototype._clearMyMembers = function() {
		this._myMembers.clear();
	};

	RealtimePresence.prototype._ensureMyMembersPresent = function() {
		var self = this, members = this.members, myMembers = this._myMembers,
			reenterCb = function(err) {
				if(err) {
					var msg = 'Presence auto-re-enter failed: ' + err.toString();
					var wrappedErr = new errorinfo["a" /* default */](msg, 91004, 400);
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
					var change = new channelstatechange(self.channel.state, self.channel.state, true, wrappedErr);
					self.channel.emit('update', change);
				}
			};

		for(var memberKey in myMembers.map) {
			if(!(memberKey in members.map)) {
				var entry = myMembers.map[memberKey];
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
				this._enterOrUpdateClient(entry.clientId, entry.data, 'enter', reenterCb);
				delete myMembers.map[memberKey];
			}
		}
	};

	RealtimePresence.prototype._synthesizeLeaves = function(items) {
		var subscriptions = this.subscriptions;
		utils["a" /* default */].arrForEach(items, function(item) {
			var presence = presencemessage["a" /* default */].fromValues({
				action: 'leave',
				connectionId: item.connectionId,
				clientId: item.clientId,
				data: item.data,
				encoding: item.encoding,
				timestamp: utils["a" /* default */].now()
			});
			subscriptions.emit('leave', presence);
		});
	};

	/* Deprecated */
	RealtimePresence.prototype.on = function() {
		logger["a" /* default */].deprecated('presence.on', 'presence.subscribe');
		this.subscribe.apply(this, arguments);
	};

	/* Deprecated */
	RealtimePresence.prototype.off = function() {
		logger["a" /* default */].deprecated('presence.off', 'presence.unsubscribe');
		this.unsubscribe.apply(this, arguments);
	};

	RealtimePresence.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var channel = this.channel;
		var self = this;

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(channel.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);
		channel.attach(callback);
	};

	RealtimePresence.prototype.unsubscribe = function(/* [event], listener */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	function PresenceMap(presence) {
		eventemitter["a" /* default */].call(this);
		this.presence = presence;
		this.map = Object.create(null);
		this.syncInProgress = false;
		this.residualMembers = null;
	}
	utils["a" /* default */].inherits(PresenceMap, eventemitter["a" /* default */]);

	PresenceMap.prototype.get = function(key) {
		return this.map[key];
	};

	PresenceMap.prototype.getClient = function(clientId) {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.clientId == clientId && item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.list = function(params) {
		var map = this.map,
			clientId = params && params.clientId,
			connectionId = params && params.connectionId,
			result = [];

		for(var key in map) {
			var item = map[key];
			if(item.action === 'absent') continue;
			if(clientId && clientId != item.clientId) continue;
			if(connectionId && connectionId != item.connectionId) continue;
			result.push(item);
		}
		return result;
	};

	function newerThan(item, existing) {
		/* RTP2b1: if either is synthesised, compare by timestamp */
		if(item.isSynthesized() || existing.isSynthesized()) {
			return item.timestamp > existing.timestamp;
		}

		/* RTP2b2 */
		var itemOrderings = item.parseId(),
			existingOrderings = existing.parseId();
		if(itemOrderings.msgSerial === existingOrderings.msgSerial) {
			return itemOrderings.index > existingOrderings.index;
		} else {
			return itemOrderings.msgSerial > existingOrderings.msgSerial;
		}
	}

	PresenceMap.prototype.put = function(item) {
		if(item.action === 'enter' || item.action === 'update') {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'present';
		}
		var map = this.map, key = memberKey(item);
		/* we've seen this member, so do not remove it at the end of sync */
		if(this.residualMembers)
			delete this.residualMembers[key];

		/* compare the timestamp of the new item with any existing member (or ABSENT witness) */
		var existingItem = map[key];
		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}
		map[key] = item;
		return true;

	};

	PresenceMap.prototype.values = function() {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.remove = function(item) {
		var map = this.map, key = memberKey(item);
		var existingItem = map[key];

		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}

		/* RTP2f */
		if(this.syncInProgress) {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'absent';
			map[key] = item;
		} else {
			delete map[key];
		}

		return true;
	};

	PresenceMap.prototype.startSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		/* we might be called multiple times while a sync is in progress */
		if(!this.syncInProgress) {
			this.residualMembers = utils["a" /* default */].copy(map);
			this.setInProgress(true);
		}
	};

	PresenceMap.prototype.endSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(syncInProgress) {
			/* we can now strip out the ABSENT members, as we have
			 * received all of the out-of-order sync messages */
			for(var memberKey in map) {
				var entry = map[memberKey];
				if(entry.action === 'absent') {
					delete map[memberKey];
				}
			}
			/* any members that were present at the start of the sync,
			 * and have not been seen in sync, can be removed, and leave events emitted */
			this.presence._synthesizeLeaves(utils["a" /* default */].valuesArray(this.residualMembers));
			for(var memberKey in this.residualMembers) {
				delete map[memberKey];
			}
			this.residualMembers = null;

			/* finish, notifying any waiters */
			this.setInProgress(false);
		}
		this.emit('sync');
	};

	PresenceMap.prototype.waitSync = function(callback) {
		var syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(!syncInProgress) {
			callback();
			return;
		}
		this.once('sync', callback);
	};

	PresenceMap.prototype.clear = function(callback) {
		this.map = {};
		this.setInProgress(false);
		this.residualMembers = null;
	};

	PresenceMap.prototype.setInProgress = function(inProgress) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
		this.syncInProgress = inProgress;
		this.presence.syncComplete = !inProgress;
	};

	return RealtimePresence;
})();

/* harmony default export */ var realtimepresence = (realtimepresence_RealtimePresence);

// CONCATENATED MODULE: ./common/lib/client/realtimechannel.js












var realtimechannel_RealtimeChannel = (function() {
	var actions = protocolmessage["a" /* default */].Action;
	var noop = function() {};
	var statechangeOp = 'statechange';
	var syncOp = 'sync';

	/* public constructor */
	function RealtimeChannel(realtime, name, options) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
		client_channel.call(this, realtime, name, options);
		this.realtime = realtime;
		this.presence = new realtimepresence(this, realtime.options);
		this.connectionManager = realtime.connection.connectionManager;
		this.state = 'initialized';
		this.subscriptions = new eventemitter["a" /* default */]();
		this.syncChannelSerial = undefined;
		this.properties = {
			attachSerial: undefined
		};
		this.setOptions(options);
		this.errorReason = null;
		this._requestedFlags = null;
		this._mode = null;
		/* Temporary; only used for the checkChannelsOnResume option */
		this._attachedMsgIndicator = false;
		this._attachResume = false;
		this._decodingContext = {
			channelOptions: this.channelOptions,
			plugins: realtime.options.plugins || { },
			baseEncodedPreviousPayload: undefined
		};
		this._lastPayload = {
			messageId: null,
			protocolMessageChannelSerial: null,
			decodeFailureRecoveryInProgress: null
		};
		/* Only differences between this and the public event emitter is that this emits an
		 * update event for all ATTACHEDs, whether resumed or not */
		this._allChannelChanges = new eventemitter["a" /* default */]();
	}
	utils["a" /* default */].inherits(RealtimeChannel, client_channel);

	RealtimeChannel.invalidStateError = function(state) {
		return {
			statusCode: 400,
			code: 90001,
			message: 'Channel operation failed as channel state is ' + state
		};
	};

	RealtimeChannel.progressOps = {
		statechange: statechangeOp,
		sync: syncOp
	};

	RealtimeChannel.processListenerArgs = function(args) {
		/* [event], listener, [callback] */
		args = Array.prototype.slice.call(args);
		if(typeof args[0] === 'function') {
			args.unshift(null);
		}
		if(args[args.length - 1] == undefined) {
			args.pop();
		}
		return args;
	};

	RealtimeChannel.prototype.setOptions = function(options, callback) {
		if(!callback) {
			if (this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'setOptions', arguments);
			}

			callback = function(err){
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
				}
			};
		}
		var err = validateChannelOptions(options);
		if(err) {
			callback(err);
			return;
		}
		client_channel.prototype.setOptions.call(this, options);
		if (this._decodingContext)
			this._decodingContext.channelOptions = this.channelOptions;
		if(this._shouldReattachToSetOptions(options)) {
			/* This does not just do _attach(true, null, callback) because that would put us
			 * into the 'attaching' state until we receive the new attached, which is
			 * conceptually incorrect: we are still attached, we just have a pending request to
			 * change some channel params. Per RTL17 going into the attaching state would mean
			 * rejecting messages until we have confirmation that the options have changed,
			 * which would unnecessarily lose message continuity. */
			this.attachImpl();
			this._allChannelChanges.once(function(stateChange) {
				switch(this.event) {
					case 'update':
					case 'attached':
						callback(null);
						return;
					default:
						callback(stateChange.reason);
						return;
				}
			});
		} else {
			callback();
		}
	};

	function validateChannelOptions(options) {
		if(options && 'params' in options && !utils["a" /* default */].isObject(options.params)) {
			return new errorinfo["a" /* default */]('options.params must be an object', 40000, 400);
		}
		if(options && 'modes' in options){
			if(!utils["a" /* default */].isArray(options.modes)){
				return new errorinfo["a" /* default */]('options.modes must be an array', 40000, 400);
			}
			for(var i = 0; i < options.modes.length; i++){
				var currentMode = options.modes[i];
				if(!currentMode || typeof currentMode !== 'string' || !utils["a" /* default */].arrIn(protocolmessage["a" /* default */].channelModes, String.prototype.toUpperCase.call(currentMode))){
					return new errorinfo["a" /* default */]('Invalid channel mode: ' + currentMode, 40000, 400);
				}
			}
		}
	}

	RealtimeChannel.prototype._shouldReattachToSetOptions = function(options) {
		return (this.state === 'attached' || this.state === 'attaching') && (options.params || options.modes);
	};

	RealtimeChannel.prototype.publish = function() {
		var argCount = arguments.length,
			messages = arguments[0],
			callback = arguments[argCount - 1];

		if(typeof(callback) !== 'function') {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
			++argCount;
		}
		if(!this.connectionManager.activeState()) {
			callback(this.connectionManager.getError());
			return;
		}
		if(argCount == 2) {
			if(utils["a" /* default */].isObject(messages))
				messages = [types_message["a" /* default */].fromValues(messages)];
			else if(utils["a" /* default */].isArray(messages))
				messages = types_message["a" /* default */].fromValuesArray(messages);
			else
				throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		} else {
			messages = [types_message["a" /* default */].fromValues({name: arguments[0], data: arguments[1]})];
		}
		var self = this,
			maxMessageSize = this.realtime.options.maxMessageSize;
		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages);
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}
			self._publish(messages, callback);
		});
	};

	RealtimeChannel.prototype._publish = function(messages, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
		var state = this.state;
		switch(state) {
			case 'failed':
			case 'suspended':
				callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError(state)));
				break;
			default:
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
				var msg = new protocolmessage["a" /* default */]();
				msg.action = actions.MESSAGE;
				msg.channel = this.name;
				msg.messages = messages;
				this.sendMessage(msg, callback);
				break;
		}
	};

	RealtimeChannel.prototype.onEvent = function(messages) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
		var subscriptions = this.subscriptions;
		for(var i = 0; i < messages.length; i++) {
			var message = messages[i];
			subscriptions.emit(message.name, message);
		}
	};

	RealtimeChannel.prototype.attach = function(flags, callback) {
		if(typeof(flags) === 'function') {
			callback = flags;
			flags = null;
		}
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'attach', arguments);
			}
			callback = function(err) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}
		if(flags) {
			logger["a" /* default */].deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
			/* If flags requested, always do a re-attach. TODO only do this if
			 * current mode differs from requested mode */
			this._requestedFlags = flags;
		} else if (this.state === 'attached') {
			callback();
			return;
		}

		this._attach(false, null, callback);
	};

	RealtimeChannel.prototype._attach = function(forceReattach, attachReason, callback) {
		if(!callback) {
			callback = function(err) {
				if (err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}

		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}

		if (this.state !== 'attaching' || forceReattach) {
			this.requestState('attaching', attachReason);
		}

		this.once(function(stateChange) {
			switch(this.event) {
				case 'attached':
					callback();
					break;
				case 'detached':
				case 'suspended':
				case 'failed':
					callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));
					break;
				case 'detaching':
					callback(new errorinfo["a" /* default */]('Attach request superseded by a subsequent detach request', 90000, 409));
					break;
			}
		});
	};

	RealtimeChannel.prototype.attachImpl = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
		this.setInProgress(statechangeOp, true);
		var attachMsg = protocolmessage["a" /* default */].fromValues({action: actions.ATTACH, channel: this.name, params: this.channelOptions.params});
		if(this._requestedFlags) {
			attachMsg.encodeModesToFlags(this._requestedFlags);
		} else if(this.channelOptions.modes) {
			attachMsg.encodeModesToFlags(utils["a" /* default */].allToUpperCase(this.channelOptions.modes));
		}
		if(this._attachResume) {
			attachMsg.setFlag('ATTACH_RESUME');
		}
		if(this._lastPayload.decodeFailureRecoveryInProgress) {
			attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
		}
		this.sendMessage(attachMsg, noop);
	};

	RealtimeChannel.prototype.detach = function(callback) {
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'detach', arguments);
			}
			callback = noop;
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}
		switch(this.state) {
                        case 'suspended':
                                this.notifyState('detached');
                                callback();
                                break;
			case 'detached':
				callback();
				break;
			case 'failed':
				callback(new errorinfo["a" /* default */]('Unable to detach; channel state = failed', 90001, 400));
				break;
			default:
				this.requestState('detaching');
			case 'detaching':
				this.once(function(stateChange) {
					switch(this.event) {
						case 'detached':
							callback();
							break;
						case 'attached':
						case 'suspended':
						case 'failed':
							callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));
							break;
						case 'attaching':
							callback(new errorinfo["a" /* default */]('Detach request superseded by a subsequent attach request', 90000, 409));
							break;
					}
				});
		}
	};

	RealtimeChannel.prototype.detachImpl = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
		this.setInProgress(statechangeOp, true);
		var msg = protocolmessage["a" /* default */].fromValues({action: actions.DETACH, channel: this.name});
		this.sendMessage(msg, (callback || noop));
	};

	RealtimeChannel.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];

		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(this.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);

		return this.attach(callback);
	};

	RealtimeChannel.prototype.unsubscribe = function(/* [event], listener */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	RealtimeChannel.prototype.sync = function() {
		/* check preconditions */
		switch(this.state) {
			case 'initialized':
			case 'detaching':
			case 'detached':
				throw new errorinfo["a" /* default */]("Unable to sync to channel; not attached", 40000);
			default:
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			throw connectionManager.getError();
		}

		/* send sync request */
		var syncMessage = protocolmessage["a" /* default */].fromValues({action: actions.SYNC, channel: this.name});
		if(this.syncChannelSerial) {
			syncMessage.channelSerial = this.syncChannelSerial;
		}
		connectionManager.send(syncMessage);
	};

	RealtimeChannel.prototype.sendMessage = function(msg, callback) {
		this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
	};

	RealtimeChannel.prototype.sendPresence = function(presence, callback) {
		var msg = protocolmessage["a" /* default */].fromValues({
			action: actions.PRESENCE,
			channel: this.name,
			presence: (utils["a" /* default */].isArray(presence) ?
				presencemessage["a" /* default */].fromValuesArray(presence) :
				[presencemessage["a" /* default */].fromValues(presence)])
		});
		this.sendMessage(msg, callback);
	};

	RealtimeChannel.prototype.onMessage = function(message) {
		var syncChannelSerial, isSync = false;
		switch(message.action) {
		case actions.ATTACHED:
			this._attachedMsgIndicator = true;
			this.properties.attachSerial = message.channelSerial;
			this._mode = message.getMode();
			this.params = message.params || {};
			var modesFromFlags = message.decodeModesFromFlags();
			this.modes = (modesFromFlags && utils["a" /* default */].allToLowerCase(modesFromFlags)) || undefined;
			var resumed = message.hasFlag('RESUMED');
			var hasPresence = message.hasFlag('HAS_PRESENCE');
			if(this.state === 'attached') {
				/* attached operations to change options set the inprogress mutex, but leave
				 * channel in the attached state */
				this.setInProgress(statechangeOp, false);
				if(!resumed) {
					/* On a loss of continuity, the presence set needs to be re-synced */
					this.presence.onAttached(hasPresence);
				}
				var change = new channelstatechange(this.state, this.state, resumed, message.error);
				this._allChannelChanges.emit('update', change);
				if(!resumed || this.channelOptions.updateOnAttached) {
					this.emit('update', change);
				}
			} else if(this.state === 'detaching') {
				/* RTL5i: re-send DETACH and remain in the 'detaching' state */
				this.checkPendingState();
			} else {
				this.notifyState('attached', message.error, resumed, hasPresence);
			}
			break;

		case actions.DETACHED:
			var err = message.error ? errorinfo["a" /* default */].fromValues(message.error) : new errorinfo["a" /* default */]('Channel detached', 90001, 404);
			if(this.state === 'detaching') {
				this.notifyState('detached', err);
			} else if(this.state === 'attaching') {
				/* Only retry immediately if we were previously attached. If we were
				 * attaching, go into suspended, fail messages, and wait a few seconds
				 * before retrying */
				this.notifyState('suspended', err);
			} else {
				this.requestState('attaching', err);
			}
			break;

		case actions.SYNC:
			/* syncs can have channelSerials, but might not if the sync is one page long */
			isSync = true;
			syncChannelSerial = this.syncChannelSerial = message.channelSerial;
			/* syncs can happen on channels with no presence data as part of connection
			 * resuming, in which case protocol message has no presence property */
			if(!message.presence) break;
		case actions.PRESENCE:
			var presence = message.presence,
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			var options = this.channelOptions;
			for(var i = 0; i < presence.length; i++) {
				try {
					var presenceMsg = presence[i];
					presencemessage["a" /* default */].decode(presenceMsg, options);
				} catch (e) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
				}
				if(!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;
				if(!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;
				if(!presenceMsg.id) presenceMsg.id = id + ':' + i;
			}
			this.presence.setPresence(presence, isSync, syncChannelSerial);
			break;

		case actions.MESSAGE:

			//RTL17
			if(this.state !== 'attached') {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' + message.id + '" skipped as this channel "' + this.name + '" state is not "attached" (state is "' + this.state + '").');
				return;
			}

			var messages = message.messages,
				firstMessage = messages[0],
				lastMessage = messages[messages.length - 1],
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			if(firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {
				var msg = 'Delta message decode failure - previous message not available for message "' + message.id + '" on this channel "' + this.name + '".';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
				this._startDecodeFailureRecovery(new errorinfo["a" /* default */](msg, 40018, 400));
				break;
			}

			for(var i = 0; i < messages.length; i++) {
				var msg = messages[i];
				try {
					types_message["a" /* default */].decode(msg, this._decodingContext);
				} catch (e) {
					/* decrypt failed .. the most likely cause is that we have the wrong key */
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
					switch(e.code) {
						case 40018:
							/* decode failure */
							this._startDecodeFailureRecovery(e);
							return;
						case 40019:
							/* No vcdiff plugin passed in - no point recovering, give up */
						case 40021:
							/* Browser does not support deltas, similarly no point recovering */
							this.notifyState('failed', e);
							return;
					}
				}
				if(!msg.connectionId) msg.connectionId = connectionId;
				if(!msg.timestamp) msg.timestamp = timestamp;
				if(!msg.id) msg.id = id + ':' + i;
			}
			this._lastPayload.messageId = lastMessage.id;
			this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
			this.onEvent(messages);
			break;

		case actions.ERROR:
			/* there was a channel-specific error */
			var err = message.error;
			if(err && err.code == 80016) {
				/* attach/detach operation attempted on superseded transport handle */
				this.checkPendingState();
			} else {
				this.notifyState('failed', errorinfo["a" /* default */].fromValues(err));
			}
			break;

		default:
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
			this.connectionManager.abort(connectionerror["a" /* default */].unknownChannelErr);
		}
	};

	RealtimeChannel.prototype._startDecodeFailureRecovery = function(reason) {
		var self = this;
		if(!this._lastPayload.decodeFailureRecoveryInProgress) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
			this._lastPayload.decodeFailureRecoveryInProgress = true;
			this._attach(true, reason, function() {
				self._lastPayload.decodeFailureRecoveryInProgress = false;
			});
		}
	};

	RealtimeChannel.prototype.onAttached = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
	};

	RealtimeChannel.prototype.notifyState = function(state, reason, resumed, hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
		this.clearStateTimer();

		if(state === this.state) {
			return;
		}
		this.presence.actOnChannelState(state, hasPresence, reason);
		if(state === 'suspended' && this.connectionManager.state.sendEvents) {
			this.startRetryTimer();
		} else {
			this.cancelRetryTimer();
		}
		if(reason) {
			this.errorReason = reason;
		}
		var change = new channelstatechange(this.state, state, resumed, reason);
		var logLevel = state === 'failed' ? logger["a" /* default */].LOG_ERROR : logger["a" /* default */].LOG_MAJOR;
		logger["a" /* default */].logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? ('; reason: ' + reason) : ''));

		/* Note: we don't set inProgress for pending states until the request is actually in progress */
		if(state === 'attached') {
			this.onAttached();
			this.setInProgress(syncOp, hasPresence);
			this.setInProgress(statechangeOp, false);
		} else if(state === 'detached' || state === 'failed' || state === 'suspended') {
			this.setInProgress(statechangeOp, false);
			this.setInProgress(syncOp, false);
		}

		if(state === 'attached') {
			this._attachResume = true;
		} else if(state === 'detaching' || state === 'failed') {
			this._attachResume = false;
		}

		this.state = state;
		this._allChannelChanges.emit(state, change);
		this.emit(state, change);
	};

	RealtimeChannel.prototype.requestState = function(state, reason) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
		this.notifyState(state, reason);
		/* send the event and await response */
		this.checkPendingState();
	};

	RealtimeChannel.prototype.checkPendingState = function() {
		/* if can't send events, do nothing */
		var cmState = this.connectionManager.state;
		/* Allow attach messages to queue up when synchronizing, since this will be
		 * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
		if(!(cmState.sendEvents || cmState.forceQueueEvents)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
		/* Only start the state timer running when actually sending the event */
		switch(this.state) {
			case 'attaching':
				this.startStateTimerIfNotRunning();
				this.attachImpl();
				break;
			case 'detaching':
				this.startStateTimerIfNotRunning();
				this.detachImpl();
				break;
			case 'attached':
				/* resume any sync operation that was in progress */
				this.sync();
			default:
				break;
		}
	};

	RealtimeChannel.prototype.timeoutPendingState = function() {
		switch(this.state) {
			case 'attaching':
				var err = new errorinfo["a" /* default */]('Channel attach timed out', 90007, 408);
				this.notifyState('suspended', err);
				break;
			case 'detaching':
				var err = new errorinfo["a" /* default */]('Channel detach timed out', 90007, 408);
				this.notifyState('attached', err);
				break;
			default:
				this.checkPendingState();
				break;
		}
	};

	RealtimeChannel.prototype.startStateTimerIfNotRunning = function() {
		var self = this;
		if(!this.stateTimer) {
			this.stateTimer = setTimeout(function() {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
				self.stateTimer = null;
				self.timeoutPendingState();
			}, this.realtime.options.timeouts.realtimeRequestTimeout);
		}
	};

	RealtimeChannel.prototype.clearStateTimer = function() {
		var stateTimer = this.stateTimer;
		if(stateTimer) {
			clearTimeout(stateTimer);
			this.stateTimer = null;
		}
	};

	RealtimeChannel.prototype.startRetryTimer = function() {
		var self = this;
		if(this.retryTimer) return;

		this.retryTimer = setTimeout(function() {
			/* If connection is not connected, just leave in suspended, a reattach
			 * will be triggered once it connects again */
			if(self.state === 'suspended' && self.connectionManager.state.sendEvents) {
				self.retryTimer = null;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
				self.requestState('attaching');
			}
		}, this.realtime.options.timeouts.channelRetryTimeout);
	};

	RealtimeChannel.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.suspendTimer = null;
		}
	};

	RealtimeChannel.prototype.setInProgress = function(operation, value) {
		this.rest.channels.setInProgress(this, operation, value);
	};

	RealtimeChannel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.state !== 'attached') {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached", 40000, 400));
				return;
			}
			if(!this.properties.attachSerial) {
				callback(new errorinfo["a" /* default */]("untilAttach was specified and channel is attached, but attachSerial is not defined", 40000, 400));
				return;
			}
			delete params.untilAttach;
			params.from_serial = this.properties.attachSerial;
		}

		client_channel.prototype._history.call(this, params, callback);
	};

	RealtimeChannel.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener);
	}

	/* @returns null (if can safely be released) | ErrorInfo (if cannot) */
	RealtimeChannel.prototype.getReleaseErr = function() {
		var s = this.state;
		if(s === 'initialized' || s === 'detached' || s === 'failed') {
			return null;
		}
		return new errorinfo["a" /* default */]('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' + s, 90001, 400);
	}

	return RealtimeChannel;
})();

/* harmony default export */ var realtimechannel = (realtimechannel_RealtimeChannel);

// EXTERNAL MODULE: ./common/lib/util/errorreporter.js
var errorreporter = __nested_webpack_require_455833__(23);

// CONCATENATED MODULE: ./common/lib/client/realtime.js










var realtime_Realtime = (function() {

	function Realtime(options) {
		if(!(this instanceof Realtime)){
			return new Realtime(options);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime()', '');
		client_rest.call(this, options);
		this.connection = new connection(this, this.options);
		this.channels = new Channels(this);
		if(options.autoConnect !== false)
			this.connect();
	}
	utils["a" /* default */].inherits(Realtime, client_rest);

	Realtime.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.connect()', '');
		this.connection.connect();
	};

	Realtime.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.close()', '');
		this.connection.close();
	};

	function Channels(realtime) {
		eventemitter["a" /* default */].call(this);
		this.realtime = realtime;
		this.all = Object.create(null);
		this.inProgress = Object.create(null);
		var self = this;
		realtime.connection.connectionManager.on('transport.active', function() {
			self.onTransportActive();
		});
	}
	utils["a" /* default */].inherits(Channels, eventemitter["a" /* default */]);

	Channels.prototype.onChannelMessage = function(msg) {
		var channelName = msg.channel;
		if(channelName === undefined) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
			return;
		}
		var channel = this.all[channelName];
		if(!channel) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
			return;
		}
		channel.onMessage(msg);
	};

	/* called when a transport becomes connected; reattempt attach/detach
	 * for channels that are attaching or detaching.
	 * Note that this does not use inProgress as inProgress is only channels which have already made
	* at least one attempt to attach/detach */
	Channels.prototype.onTransportActive = function() {
		for(var channelName in this.all) {
			var channel = this.all[channelName];
			if(channel.state === 'attaching' || channel.state === 'detaching') {
				channel.checkPendingState();
			} else if(channel.state === 'suspended') {
				channel.attach();
			}
		}
	};

	Channels.prototype.reattach = function(reason) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			/* NB this should not trigger for merely attaching channels, as they will
			 * be reattached anyway through the onTransportActive checkPendingState */
			if(channel.state === 'attached') {
				channel.requestState('attaching', reason);
			}
		}
	};

	Channels.prototype.resetAttachedMsgIndicators = function() {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached') {
			channel._attachedMsgIndicator = false;
			}
		}
	};

	Channels.prototype.checkAttachedMsgIndicators = function(connectionId) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached' && channel._attachedMsgIndicator === false) {
				var msg = '30s after a resume, found channel which has not received an attached; channelId = ' + channelId + '; connectionId = ' + connectionId;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.checkAttachedMsgIndicators()', msg);
				errorreporter["a" /* default */].report('error', msg, 'channel-no-attached-after-resume');
				channel.requestState('attaching');
			};
		}
	};

	/* Connection interruptions (ie when the connection will no longer queue
	 * events) imply connection state changes for any channel which is either
	 * attached, pending, or will attempt to become attached in the future */
	Channels.prototype.propogateConnectionInterruption = function(connectionState, reason) {
		var connectionStateToChannelState = {
			'closing'  : 'detached',
			'closed'   : 'detached',
			'failed'   : 'failed',
			'suspended': 'suspended'
		};
		var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
		var toChannelState = connectionStateToChannelState[connectionState];

		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(utils["a" /* default */].arrIn(fromChannelStates, channel.state)) {
				 channel.notifyState(toChannelState, reason);
			}
		}
	};

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			channel = this.all[name] = new realtimechannel(this.realtime, name, channelOptions);
		} else if(channelOptions) {
			if (channel._shouldReattachToSetOptions(channelOptions)) {
				throw new errorinfo["a" /* default */]("Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.", 40000, 400);
			}
			channel.setOptions(channelOptions);
		}
		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			return;
		}
		var releaseErr = channel.getReleaseErr();
		if(releaseErr) {
			throw releaseErr;
		}
		delete this.all[name];
		delete this.inProgress[name];
	};

	/* Records operations currently pending on a transport; used by connectionManager to decide when
	 * it's safe to upgrade. Note that a channel might be in the attaching state without any pending
	 * operations (eg if attached while the connection state is connecting) - such a channel must not
	 * hold up an upgrade, so is not considered inProgress.
	 * Operation is currently one of either 'statechange' or 'sync' */
	Channels.prototype.setInProgress = function(channel, operation, inProgress) {
		this.inProgress[channel.name] = this.inProgress[channel.name] || {};
		this.inProgress[channel.name][operation] = inProgress;
		if(!inProgress && this.hasNopending()) {
			this.emit('nopending');
		}
	};

	Channels.prototype.onceNopending = function(listener) {
		if(this.hasNopending()) {
			listener();
			return;
		}
		this.once('nopending', listener);
	};

	Channels.prototype.hasNopending = function() {
		return utils["a" /* default */].arrEvery(utils["a" /* default */].valuesArray(this.inProgress, true), function(operations) {
			return !utils["a" /* default */].containsValue(operations, true);
		});
	};

	return Realtime;
})();

realtime_Realtime.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new realtime_Realtime(options);
};

realtime_Realtime.Callbacks = realtime_Realtime;

/* harmony default export */ var client_realtime = (realtime_Realtime);

// EXTERNAL MODULE: ./browser/lib/util/msgpack.js
var util_msgpack = __nested_webpack_require_455833__(24);

// CONCATENATED MODULE: ./common/lib/index.js














client_rest.Utils = utils["a" /* default */];
client_rest.BufferUtils = bufferutils["a" /* default */];
client_rest.Crypto = util_crypto["a" /* default */];
client_rest.Defaults = defaults["a" /* default */];
client_rest.Http = http["a" /* default */];
client_rest.Resource = client_resource;
client_rest.Message = types_message["a" /* default */];
client_rest.PresenceMessage = presencemessage["a" /* default */];

client_realtime.Utils = utils["a" /* default */];
client_realtime.BufferUtils = bufferutils["a" /* default */];
client_realtime.Crypto = util_crypto["a" /* default */];
client_realtime.Defaults = defaults["a" /* default */];
client_realtime.Http = http["a" /* default */];
client_realtime.Message = types_message["a" /* default */];
client_realtime.PresenceMessage = presencemessage["a" /* default */];
client_realtime.ProtocolMessage = protocolmessage["a" /* default */];
client_realtime.ConnectionManager = connectionmanager["a" /* default */];

/* harmony default export */ var lib = __webpack_exports__["default"] = ({
  Rest: client_rest,
  Realtime: client_realtime,
  msgpack: util_msgpack["a" /* default */]
});


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

function promisifyOptions(options) {
  if(typeof options == 'string') {
    options = (options.indexOf(':') == -1) ? {token: options} : {key: options};
  }
  options.promises = true;
  return options;
}

/* Please note that the file imported below is only generated after running 
 * the build task. */
var Ably = __webpack_require__(/*! ./browser/static/ably-node */ "./node_modules/ably/browser/static/ably-commonjs.js");

var RestPromise = function(options) {
  return new Ably.Rest(promisifyOptions(options));
}
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function(options) {
  return new Ably.Realtime(promisifyOptions(options));
}
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./components/chatroom/chatComponents.module.css":
/*!*******************************************************!*\
  !*** ./components/chatroom/chatComponents.module.css ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = function(element) {
                // These elements should always exist. If they do not,
                // this code should fail.
                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');
                var parentNode = anchorElement.parentNode// Normally <head>
                ;
                // Each style tag should be placed right before our
                // anchor. By inserting before and not after, we do not
                // need to track the last inserted element.
                parentNode.insertBefore(element, anchorElement);
            };
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
    if (!a && b || a && !b) {
        return false;
    }
    let p;
    for(p in a){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (a[p] !== b[p]) {
            return false;
        }
    }
    for(p in b){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (!a[p]) {
            return false;
        }
    }
    return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css",
      function () {
        content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.id, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css":
/*!*********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css ***!
  \*********************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".chatComponents_chatHolder__2E1AX {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatComponents_chatText__3MREs {\r\n  display: -moz-box;\r\n  display: flex;\r\n  -moz-box-orient: vertical;\r\n  -moz-box-direction: normal;\r\n       flex-direction: column;\r\n  -moz-box-align: start;\r\n       align-items: flex-start;\r\n  grid-gap: 1em;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: -webkit-calc(100vh - 40px - 100px - 100px - 100px);\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.chatComponents_form__3rFIK {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.chatComponents_textarea__2UuLy {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.chatComponents_button__3eZyM {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: -webkit-linear-gradient(left, #363795, #005c97);\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.chatComponents_button__3eZyM:hover {\r\n  background: -webkit-gradient(\r\n    linear,\r\n    left top, right top,\r\n    from(rgba(54, 55, 149, 1)),\r\n    color-stop(62%, rgba(0, 92, 151, 1)),\r\n    to(rgba(0, 125, 205, 1))\r\n  );\r\n  background: -webkit-linear-gradient(\r\n    left,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.chatComponents_button__3eZyM:disabled,\r\n.chatComponents_button__3eZyM:hover:disabled {\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: -webkit-linear-gradient(left, #363795, #005c97);\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.chatComponents_message__1dnoB {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  -moz-box-flex: 0;\r\n       flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n", "",{"version":3,"sources":["webpack://components/chatroom/chatComponents.module.css"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,6BAA6B;AAC/B;;AAEA;EACE,iBAAa;EAAb,aAAa;EACb,yBAAsB;EAAtB,0BAAsB;OAAtB,sBAAsB;EACtB,qBAAuB;OAAvB,uBAAuB;EACvB,aAAQ;EAAR,QAAQ;EACR,YAAY;EACZ,0DAAkD;EAAlD,kDAAkD;EAClD,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,gCAAgC;EAChC,0BAA0B;AAC5B;;AAEA;EACE,YAAY;EACZ,SAAS;EACT;wEACsE;EACtE,gBAAgB;AAClB;;AAEA;EACE,SAAS;EACT,YAAY;EACZ,iBAAiB;EACjB,gBAAgB;EAChB,qFAAuD;EAAvD,2DAAuD;EAAvD,uDAAuD;AACzD;;AAEA;EACE;;;;;;GAKC;EALD;;;;;GAKC;EALD;;;;;GAKC;AACH;;AAEA;;EAEE,qFAAuD;EAAvD,2DAAuD;EAAvD,uDAAuD;EACvD,YAAY;AACd;;AAEA;EACE,yBAAyB;EACzB,YAAY;EACZ,mBAAmB;EACnB,gBAAY;OAAZ,YAAY;EACZ,4BAA4B;AAC9B","sourcesContent":[".chatHolder {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatText {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.form {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.textarea {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.button {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.button:hover {\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.button:disabled,\r\n.button:hover:disabled {\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.message {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"chatHolder": "chatComponents_chatHolder__2E1AX",
	"chatText": "chatComponents_chatText__3MREs",
	"form": "chatComponents_form__3rFIK",
	"textarea": "chatComponents_textarea__2UuLy",
	"button": "chatComponents_button__3eZyM",
	"message": "chatComponents_message__1dnoB"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithHoles; }
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArrayLimit; }
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableRest; }
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _slicedToArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2NodW5rcy9jb21wb25lbnRzX2NoYXRyb29tX2NoYXRDb21wb25lbnRzX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBLElBQU1FLElBQUksR0FBRyxJQUFJRix1RUFBSixDQUEwQjtBQUFFSyxFQUFBQSxPQUFPLEVBQUU7QUFBWCxDQUExQixDQUFiLEVBRUE7O0FBRU8sU0FBU0MsVUFBVCxDQUFvQkMsV0FBcEIsRUFBaUNDLGlCQUFqQyxFQUFvRDtBQUFBOztBQUN6RCxNQUFNQyxPQUFPLEdBQUdQLElBQUksQ0FBQ1EsUUFBTCxDQUFjQyxHQUFkLENBQWtCSixXQUFsQixDQUFoQjs7QUFFQSxNQUFNSyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFNO0FBQ3BCSCxJQUFBQSxPQUFPLENBQUNJLFNBQVIsQ0FBa0IsVUFBQ0MsR0FBRCxFQUFTO0FBQ3pCTixNQUFBQSxpQkFBaUIsQ0FBQ00sR0FBRCxDQUFqQjtBQUNELEtBRkQ7QUFHRCxHQUpEOztBQUtBLE1BQU1DLFNBQVMsR0FBRyxTQUFaQSxTQUFZLEdBQU07QUFDdEJOLElBQUFBLE9BQU8sQ0FBQ08sV0FBUjtBQUNELEdBRkQ7O0FBSUEsTUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFNO0FBQzFCTCxJQUFBQSxPQUFPO0FBQ1AsV0FBTyxZQUFNO0FBQ1hHLE1BQUFBLFNBQVM7QUFDVixLQUZEO0FBR0QsR0FMRDs7QUFPQWQsRUFBQUEsZ0RBQVMsQ0FBQ2dCLGFBQUQsQ0FBVDtBQUVBLFNBQU8sQ0FBQ1IsT0FBRCxFQUFVUCxJQUFWLENBQVA7QUFDRDs7R0F0QmVJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJoQjtBQUNBO0FBQ0E7OztBQUVBLElB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnSUFBZ0ksYUFBYTtBQUM3STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVB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O0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxTkFBcU47QUFDck47QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FB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QTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2TEFBNkw7QUFDN0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrUkFBa1IsWUFBWTtBQUM5UjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsa1FBQWtRO0FBQ2xRO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwyTkFBMk47QUFDM047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSw0QkFBNEIsWUFBWSxpQ0FBbUI7O0FBRTNELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUIsTUFBTSxpQ0FBbUI7QUFDbFQ7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDOztBQUVEOztBQUVBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsQ0FBQztBQUNELEtBQUssSUFBSTtBQUNUO0FBQ0EscUNBQXFDLGlDQUFtQjtBQUN4RDtBQUNBLE1BQU0sRUFBRTtBQUNSLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHFCQUFxQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxxQkFBcUIsTUFBTTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sRUFBRTs7O0FBR0YsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxDQUFDO0FBQ0QsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxxQ0FBcUMsaUNBQW1CLE1BQU0saUNBQW1CLE1BQU0saUNBQW1CO0FBQzFHO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQix1QkFBdUIsUUFBUTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxZQUFZO0FBQ3BFLHdEQUF3RCw4QkFBOEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQSxxQkFBcUIsV0FBVztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlDQUFpQyxnQkFBZ0I7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRSx3REFBd0QsOEJBQThCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxDQUFDO0FBQ0QsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxxQ0FBcUMsaUNBQW1CLE1BQU0saUNBQW1CO0FBQ2pGO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0IsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0Isb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsUUFBUTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGlCQUFpQjtBQUNoRztBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxpQkFBaUI7QUFDaEc7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsV0FBVztBQUMvQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQSx5R0FBeUcsaUJBQWlCO0FBQzFIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLGVBQWU7QUFDNUM7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixXQUFXO0FBQy9CLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkJBQTZCLG1CQUFtQjtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFdBQVc7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixNQUFNO0FBQzdCLHVCQUF1QixTQUFTO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixXQUFXO0FBQzlCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixNQUFNO0FBQ3pCLG1CQUFtQixTQUFTO0FBQzVCLG1CQUFtQixRQUFRO0FBQzNCLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0EscUJBQXFCLFFBQVE7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQSxxQkFBcUIsY0FBYztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQyxvQ0FBb0M7QUFDOUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixXQUFXO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsb0JBQW9CLGtCQUFrQjtBQUN0QyxvQkFBb0IsV0FBVztBQUMvQixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtIQUFrSCxRQUFRO0FBQzFILGtIQUFrSCx5Q0FBeUM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2QsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IscUJBQXFCO0FBQ3pDLG9CQUFvQixXQUFXO0FBQy9CLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0EscUJBQXFCLFdBQVc7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVIQUF1SCx5Q0FBeUM7QUFDaEssb0hBQW9ILHlDQUF5QztBQUM3SjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QyxvQkFBb0IsV0FBVztBQUMvQjtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0Isa0JBQWtCO0FBQ3RDO0FBQ0EscUJBQXFCLGNBQWM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx1Q0FBdUMsMkJBQTJCOztBQUVsRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEMsOEJBQThCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixLQUFLO0FBQzVCO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsb0JBQW9CLGtCQUFrQjtBQUN0QyxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixjQUFjO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSCxpQ0FBaUM7QUFDM0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsb0JBQW9CLHFCQUFxQjtBQUN6QyxvQkFBb0IsUUFBUTtBQUM1QixvQkFBb0IsUUFBUTtBQUM1QjtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0gsaUNBQWlDO0FBQ2hLLDRIQUE0SCxpQ0FBaUM7QUFDN0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEVBQUU7OztBQUdGLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsQ0FBQztBQUNELEtBQUssSUFBSTtBQUNUO0FBQ0EscUNBQXFDLGlDQUFtQjtBQUN4RDtBQUNBLE1BQU0sRUFBRTtBQUNSLENBQUM7O0FBRUQ7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxDQUFDO0FBQ0QsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxxQ0FBcUMsaUNBQW1CO0FBQ3hEO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsK0VBQStFLGlDQUFtQjtBQUNsRyxvRUFBb0UsaUNBQW1CO0FBQ3ZGLDJFQUEyRSxpQ0FBbUI7QUFDOUYscUVBQXFFLGlDQUFtQjtBQUN4RixzRUFBc0UsaUNBQW1CO0FBQ3pGLHlFQUF5RSxpQ0FBbUI7Ozs7Ozs7O0FBUTVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUUsc0RBQXNELGtDQUFrQztBQUN4RjtBQUNBOztBQUVBO0FBQ0EsK0xBQStMO0FBQy9MO0FBQ0E7O0FBRUE7QUFDQSxnTUFBZ00sdUJBQXVCO0FBQ3ZOO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtTEFBbUw7QUFDbkw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLCtDQUErQyxvQ0FBb0M7QUFDbkY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osK0NBQStDLG9DQUFvQztBQUNuRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQSw0QkFBNEIsWUFBWSxpQ0FBbUI7O0FBRTNELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxpQ0FBbUI7QUFDeEQ7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxpQkFBaUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0EsaUJBQWlCLFdBQVc7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjs7QUFFQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELENBQUM7QUFDRCxLQUFLLElBQUk7QUFDVDtBQUNBLHFDQUFxQyxpQ0FBbUI7QUFDeEQ7QUFDQSxNQUFNLEVBQUU7QUFDUixDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7O0FBR0Y7O0FBRUEsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRCxDQUFDO0FBQ0QsS0FBSyxJQUFJO0FBQ1Q7QUFDQSxxQ0FBcUMsaUNBQW1CLE1BQU0saUNBQW1CLE1BQU0saUNBQW1CO0FBQzFHO0FBQ0EsTUFBTSxFQUFFO0FBQ1IsQ0FBQzs7QUFFRDs7QUFFQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsOENBQThDLCtFQUErRSxpQ0FBbUI7QUFDaEosNkZBQTZGLGlDQUFtQjtBQUNoSCxpRUFBaUUsaUNBQW1CO0FBQ3BGLHNGQUFzRixpQ0FBbUI7QUFDekcsc0VBQXNFLGlDQUFtQjtBQUN6RixvRkFBb0YsaUNBQW1CO0FBQ3ZHLGtGQUFrRixpQ0FBbUI7QUFDckcsZ0ZBQWdGLGlDQUFtQjs7Ozs7Ozs7OztBQVVuRztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSw4QkFBOEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDLGVBQWU7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTkFBcU47O0FBRXJOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLDZCQUE2QjtBQUNoRDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEIsWUFBWSxpQ0FBbUI7O0FBRTNELE9BQU87QUFDUDtBQUNBLDZDQUE2QyxpQ0FBbUI7O0FBRWhFO0FBQ0EsaUVBQWlFLGlDQUFtQjtBQUNwRixvRUFBb0UsaUNBQW1CO0FBQ3ZGLG1FQUFtRSxpQ0FBbUI7QUFDdEYsdUVBQXVFLGlDQUFtQjtBQUMxRixxRUFBcUUsaUNBQW1CO0FBQ3hGLCtFQUErRSxpQ0FBbUI7QUFDbEcseUVBQXlFLGlDQUFtQjs7Ozs7Ozs7O0FBUzVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdDQUFnQyxVQUFVLDhCQUE4QjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7QUFDOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixvRkFBb0Y7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLDBDQUEwQztBQUMxQyw0Q0FBNEM7QUFDNUMsMENBQTBDO0FBQzFDO0FBQ0EsY0FBYztBQUNkO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtNQUFrTSw4QkFBOEI7QUFDaE87QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsNkNBQTZDLGlDQUFtQjs7QUFFaEU7O0FBRUE7QUFDQSxxQkFBcUIsaUNBQW1COztBQUV4QztBQUNBLFlBQVksaUNBQW1COztBQUUvQjtBQUNBLGFBQWEsaUNBQW1COztBQUVoQztBQUNBLHVCQUF1QixpQ0FBbUI7O0FBRTFDO0FBQ0EscUJBQXFCLGlDQUFtQjs7QUFFeEM7QUFDQSxpQkFBaUIsaUNBQW1COztBQUVwQzs7Ozs7OztBQU9BO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsOEJBQThCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBLCtCQUErQiwwQkFBMEI7QUFDekQ7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOzs7Ozs7O0FBT0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVSw4QkFBOEI7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLDBCQUEwQjtBQUMzRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsaUNBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0QkFBNEIsWUFBWSxpQ0FBbUI7O0FBRTNELE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBELHVEQUF1RDtBQUN2RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlCQUFpQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCw0QkFBNEIsWUFBWSxpQ0FBbUIsTUFBTSxpQ0FBbUI7O0FBRXBGLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsaUJBQWlCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7OztBQUdGOztBQUVBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0EsaUNBQWlDLGlDQUFtQjs7QUFFcEQsQ0FBQztBQUNELEtBQUssSUFBSTtBQUNUO0FBQ0EscUNBQXFDLGlDQUFtQjtBQUN4RDtBQUNBLE1BQU0sRUFBRTtBQUNSLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLFFBQVE7QUFDakM7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjtBQUNBO0FBQ0EsNkJBQTZCLFFBQVE7QUFDckM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNktBQTZLO0FBQzdLO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCLDhCQUE4QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isc0JBQXNCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdILGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFKQUFxSjtBQUNySjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1KQUFtSjtBQUNuSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvSkFBb0o7QUFDcEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7Ozs7Ozs7Ozs7Ozs7QUFhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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OztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsOEhBQThIO0FBQzlIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7O0FBRXZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFNQUFxTTtBQUNyTTs7QUFFQTtBQUNBLENBQUM7O0FB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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsRUFBRTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0Isa0JBQWtCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Iiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS9fTl9FLy4vY29tcG9uZW50cy9jaGF0cm9vbS9BYmx5UmVhY3RFZmZlY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS9fTl9FLy4vY29tcG9uZW50cy9jaGF0cm9vbS9jaGF0Q29tcG9uZW50cy5qcyIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9ub2RlX21vZHVsZXMvYWJseS9icm93c2VyL3N0YXRpYy9hYmx5LWNvbW1vbmpzLmpzIiwid2VicGFjazovL19OX0UvX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L3Byb21pc2VzLmpzIiwid2VicGFjazovL19OX0UvX05fRS8uL25vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vX05fRS9fTl9FLy4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9jb21wb25lbnRzL2NoYXRyb29tL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3M/MmVhMSIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9jb21wb25lbnRzL2NoYXRyb29tL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3MiLCJ3ZWJwYWNrOi8vX05fRS9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qcyIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vbm9uSXRlcmFibGVSZXN0LmpzIiwid2VicGFjazovL19OX0UvX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vc2xpY2VkVG9BcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vdG9Db25zdW1hYmxlQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vb2ZmZXIgY29tcGFueSBuYW1lIGFuZCBsb2dvXHJcbi8vIHRleHRhcmVhIGZvciBoaXMgb2ZmZXJcclxuLy8gaGlkZGVuIGFuZCBhcHBlYXJcclxuLy8gc3RhdGVzIGZvciByZW5kZXJpbmcgdGhlIHBhZ2VcclxuLy9XZWJTb2NrZXQgY29ubmVjdGlvbnNcclxuLy9BYmx5XHJcbi8vYWRkIGFuZCBJZFxyXG4vL2FkZCBtZXNzYWdlIHN0b3JhZ2UgYW5kIHJldHJpdmFsXHJcbi8vXHJcblxyXG5pbXBvcnQgQWJseSBmcm9tIFwiYWJseS9wcm9taXNlc1wiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmNvbnN0IGFibHkgPSBuZXcgQWJseS5SZWFsdGltZS5Qcm9taXNlKHsgYXV0aFVybDogXCIvYXBpL2NyZWF0ZVRva2VuUmVxdWVzdFwiIH0pO1xyXG5cclxuLy8gY29uc29sZS5sb2coYWJseSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhbm5lbChjaGFubmVsTmFtZSwgY2FsbGJhY2tPbk1lc3NhZ2UpIHtcclxuICBjb25zdCBjaGFubmVsID0gYWJseS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xyXG5cclxuICBjb25zdCBvbk1vdW50ID0gKCkgPT4ge1xyXG4gICAgY2hhbm5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xyXG4gICAgICBjYWxsYmFja09uTWVzc2FnZShtc2cpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICBjb25zdCBvblVuTW91bnQgPSAoKSA9PiB7XHJcbiAgICBjaGFubmVsLnVuc3Vic2NyaWJlKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdXNlRWZmZWN0SG9vayA9ICgpID0+IHtcclxuICAgIG9uTW91bnQoKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIG9uVW5Nb3VudCgpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QodXNlRWZmZWN0SG9vayk7XHJcblxyXG4gIHJldHVybiBbY2hhbm5lbCwgYWJseV07XHJcbn1cclxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2hhbm5lbCB9IGZyb20gXCIuL0FibHlSZWFjdEVmZmVjdFwiO1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuLi9jaGF0cm9vbS9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzXCI7XHJcblxyXG5jb25zdCBDaGF0Q29tcG9uZW50ID0gKCkgPT4ge1xyXG4gIGxldCBpbnB1dEJveCA9IG51bGw7XHJcbiAgbGV0IG1lc3NhZ2VFbmQgPSBudWxsO1xyXG5cclxuICBjb25zdCBbbWVzc2FnZVRleHQsIHNldE1lc3NhZ2VUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gIGNvbnN0IFtyZWNlaXZlZE1lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgY29uc3QgbWVzc2FnZVRleHRJc0VtcHR5ID0gbWVzc2FnZVRleHQudHJpbSgpLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgY29uc3QgW2NoYW5uZWwsIGFibHldID0gdXNlQ2hhbm5lbChcImNoYXQtZGVtb1wiLCAobWVzc2FnZSkgPT4ge1xyXG4gICAgY29uc3QgaGlzdG9yeSA9IHJlY2VpdmVkTWVzc2FnZXMuc2xpY2UoLTE5OSk7XHJcbiAgICBzZXRNZXNzYWdlcyhbLi4uaGlzdG9yeSwgbWVzc2FnZV0pO1xyXG4gIH0pO1xyXG5cclxuICBjb25zdCBzZW5kQ2hhdE1lc3NhZ2UgPSAobWVzc2FnZVRleHQpID0+IHtcclxuICAgIGNoYW5uZWwucHVibGlzaCh7IG5hbWU6IFwiY2hhdC1tZXNzYWdlXCIsIGRhdGE6IG1lc3NhZ2VUZXh0IH0pO1xyXG4gICAgc2V0TWVzc2FnZVRleHQoXCJcIik7XHJcbiAgICBpbnB1dEJveC5mb2N1cygpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUZvcm1TdWJtaXNzaW9uID0gKGV2ZW50KSA9PiB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgc2VuZENoYXRNZXNzYWdlKG1lc3NhZ2VUZXh0KTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVLZXlQcmVzcyA9IChldmVudCkgPT4ge1xyXG4gICAgaWYgKGV2ZW50LmNoYXJDb2RlICE9PSAxMyB8fCBtZXNzYWdlVGV4dElzRW1wdHkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2VuZENoYXRNZXNzYWdlKG1lc3NhZ2VUZXh0KTtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbWVzc2FnZXMgPSByZWNlaXZlZE1lc3NhZ2VzLm1hcCgobWVzc2FnZSwgaW5kZXgpID0+IHtcclxuICAgIGNvbnN0IGF1dGhvciA9IG1lc3NhZ2UuY29ubmVjdGlvbklkID09PSBhYmx5LmNvbm5lY3Rpb24uaWQgPyBcIm1lXCIgOiBcIm90aGVyXCI7XHJcblxyXG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gbmV3IERhdGUoKTtcclxuICAgIGNvbnN0IHRpbWVTdGFtcCA9IG1pbGxpc2Vjb25kcy50b0RhdGVTdHJpbmcoKTtcclxuXHJcbiAgICAvLyBmdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kc0ludG9SZWFkYWJsZVRpbWUobWlsbGlzZWNvbmRzKSB7XHJcbiAgICAvLyAgIC8vR2V0IGhvdXJzIGZyb20gbWlsbGlzZWNvbmRzXHJcbiAgICAvLyAgIHZhciBob3VycyA9IG1pbGxpc2Vjb25kcyAvICgxMDAwICogNjAgKiA2MCk7XHJcbiAgICAvLyAgIHZhciBhYnNvbHV0ZUhvdXJzID0gTWF0aC5mbG9vcihob3Vycyk7XHJcbiAgICAvLyAgIHZhciBoID0gYWJzb2x1dGVIb3VycyA+IDkgPyBhYnNvbHV0ZUhvdXJzIDogXCIwXCIgKyBhYnNvbHV0ZUhvdXJzO1xyXG5cclxuICAgIC8vICAgLy9HZXQgcmVtYWluZGVyIGZyb20gaG91cnMgYW5kIGNvbnZlcnQgdG8gbWludXRlc1xyXG4gICAgLy8gICB2YXIgbWludXRlcyA9IChob3VycyAtIGFic29sdXRlSG91cnMpICogNjA7XHJcbiAgICAvLyAgIHZhciBhYnNvbHV0ZU1pbnV0ZXMgPSBNYXRoLmZsb29yKG1pbnV0ZXMpO1xyXG4gICAgLy8gICB2YXIgbSA9IGFic29sdXRlTWludXRlcyA+IDkgPyBhYnNvbHV0ZU1pbnV0ZXMgOiBcIjBcIiArIGFic29sdXRlTWludXRlcztcclxuXHJcbiAgICAvLyAgIC8vR2V0IHJlbWFpbmRlciBmcm9tIG1pbnV0ZXMgYW5kIGNvbnZlcnQgdG8gc2Vjb25kc1xyXG4gICAgLy8gICB2YXIgc2Vjb25kcyA9IChtaW51dGVzIC0gYWJzb2x1dGVNaW51dGVzKSAqIDYwO1xyXG4gICAgLy8gICB2YXIgYWJzb2x1dGVTZWNvbmRzID0gTWF0aC5mbG9vcihzZWNvbmRzKTtcclxuICAgIC8vICAgdmFyIHMgPSBhYnNvbHV0ZVNlY29uZHMgPiA5ID8gYWJzb2x1dGVTZWNvbmRzIDogXCIwXCIgKyBhYnNvbHV0ZVNlY29uZHM7XHJcblxyXG4gICAgLy8gICByZXR1cm4gaCArIFwiOlwiICsgbSArIFwiOlwiICsgcztcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyB2YXIgdGltZSA9IHBhcnNlTWlsbGlzZWNvbmRzSW50b1JlYWRhYmxlVGltZShtaWxsaXNlY29uZHMpO1xyXG5cclxuICAgIC8vIGFsZXJ0KHRpbWUpO1xyXG4gICAgLy8gY29uc29sZS5sb2codGltZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPHNwYW5cclxuICAgICAgICBrZXk9e2luZGV4fVxyXG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm1lc3NhZ2V9XHJcbiAgICAgICAgLy8gdGltZT17bmV3IERhdGUoKS50b1N0cmluZygpfVxyXG4gICAgICAgIGRhdGEtYXV0aG9yPXthdXRob3J9XHJcbiAgICAgID5cclxuICAgICAgICB7bWVzc2FnZS5kYXRhfVxyXG4gICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgbWVzc2FnZUVuZC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW91cjogXCJzbW9vdGhcIiB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2hhdEhvbGRlcn0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2hhdFRleHR9PlxyXG4gICAgICAgIHttZXNzYWdlc31cclxuICAgICAgICB7bmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKX1cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICByZWY9eyhlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgfX1cclxuICAgICAgICA+PC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlRm9ybVN1Ym1pc3Npb259IGNsYXNzTmFtZT17c3R5bGVzLmZvcm19PlxyXG4gICAgICAgIDx0ZXh0YXJlYVxyXG4gICAgICAgICAgcmVmPXsoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBpbnB1dEJveCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICB9fVxyXG4gICAgICAgICAgdmFsdWU9e21lc3NhZ2VUZXh0fVxyXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIGEgbWVzc2FnZS4uLlwiXHJcbiAgICAgICAgICAvLyB0aW1lPXtuZXcgRGF0ZSgpLnRvU3RyaW5nKCl9XHJcbiAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldE1lc3NhZ2VUZXh0KGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgIG9uS2V5UHJlc3M9e2hhbmRsZUtleVByZXNzfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudGV4dGFyZWF9XHJcbiAgICAgICAgPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXHJcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5idXR0b259XHJcbiAgICAgICAgICBkaXNhYmxlZD17bWVzc2FnZVRleHRJc0VtcHR5fVxyXG4gICAgICAgID5cclxuICAgICAgICAgIFNlbmRcclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgPC9mb3JtPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoYXRDb21wb25lbnQ7XHJcbiIsIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMjEsIEFibHlcbiAqIFxuICogQWJseSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuMi4xM1xuICogaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qc1xuICogXG4gKiBBYmx5IFJlYWx0aW1lIE1lc3NhZ2luZ1xuICogaHR0cHM6Ly93d3cuYWJseS5jb21cbiAqIFxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIHYyLjBcbiAqL1xuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xuXHRlbHNlIGlmKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZClcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xuXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0Jylcblx0XHRleHBvcnRzW1wiQWJseVwiXSA9IGZhY3RvcnkoKTtcblx0ZWxzZVxuXHRcdHJvb3RbXCJBYmx5XCJdID0gZmFjdG9yeSgpO1xufSkod2luZG93LCBmdW5jdGlvbigpIHtcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXG4vKioqKioqLyBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdGk6IG1vZHVsZUlkLFxuLyoqKioqKi8gXHRcdFx0bDogZmFsc2UsXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4vKioqKioqLyBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuLyoqKioqKi8gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuLyoqKioqKi8gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuLyoqKioqKi8gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3Rcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbi8qKioqKiovIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4vKioqKioqLyBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbi8qKioqKiovIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG4vKioqKioqL1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4vKioqKioqLyBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IDUwKTtcbi8qKioqKiovIH0pXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gKFtcbi8qIDAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cbnZhciBMb2dnZXIgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBjb25zb2xlTG9nZ2VyLCBlcnJvckxvZ2dlcjtcblxuXHQvKiBDYW4ndCBqdXN0IGNoZWNrIGZvciBjb25zb2xlICYmIGNvbnNvbGUubG9nOyBmYWlscyBpbiBJRSA8PTkgKi9cblx0aWYoKHR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcpIC8qIG5vZGUgKi8gfHxcblx0XHQgKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmxvZyAmJiAodHlwZW9mIGdsb2JhbC5jb25zb2xlLmxvZy5hcHBseSA9PT0gJ2Z1bmN0aW9uJykpIC8qIHNlbnNpYmxlIGJyb3dzZXJzICovKSB7XG5cdFx0Y29uc29sZUxvZ2dlciA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpOyB9O1xuXHRcdGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuID8gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2Fybi5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpOyB9IDogY29uc29sZUxvZ2dlcjtcblx0fSBlbHNlIGlmKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmxvZykge1xuXHRcdC8qIElFIDw9IDkgd2l0aCB0aGUgY29uc29sZSBvcGVuIC0tIGNvbnNvbGUubG9nIGRvZXMgbm90XG5cdFx0ICogaW5oZXJpdCBmcm9tIEZ1bmN0aW9uLCBzbyBoYXMgbm8gYXBwbHkgbWV0aG9kICovXG5cdFx0Y29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24oKSB7IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpOyB9O1xuXHR9IGVsc2Uge1xuXHRcdC8qIElFIDw9IDkgd2hlbiBkZXYgdG9vbHMgYXJlIGNsb3NlZCAtIHdpbmRvdy5jb25zb2xlIG5vdCBldmVuIGRlZmluZWQgKi9cblx0XHRjb25zb2xlTG9nZ2VyID0gZXJyb3JMb2dnZXIgPSBmdW5jdGlvbigpIHt9O1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFkKHN0ciwgdGhyZWUpIHtcblx0XHRyZXR1cm4gKCcwMDAnICsgc3RyKS5zbGljZSgtMi0odGhyZWUgfHwgMCkpO1xuXHR9XG5cblx0dmFyIExPR19OT05FICA9IDAsXG5cdExPR19FUlJPUiA9IDEsXG5cdExPR19NQUpPUiA9IDIsXG5cdExPR19NSU5PUiA9IDMsXG5cdExPR19NSUNSTyA9IDQ7XG5cblx0dmFyIExPR19ERUZBVUxUID0gTE9HX0VSUk9SLFxuXHRMT0dfREVCVUcgICA9IExPR19NSUNSTztcblxuXHR2YXIgbG9nTGV2ZWwgPSBMT0dfREVGQVVMVDtcblxuXHRmdW5jdGlvbiBnZXRIYW5kbGVyKGxvZ2dlcikge1xuXHRcdHJldHVybiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ1RpbWVzdGFtcHMgP1xuXHRcdFx0ZnVuY3Rpb24obXNnKSB7XG5cdFx0XHRcdHZhciB0aW1lID0gbmV3IERhdGUoKTtcblx0XHRcdFx0bG9nZ2VyKHBhZCh0aW1lLmdldEhvdXJzKCkpICsgJzonICsgcGFkKHRpbWUuZ2V0TWludXRlcygpKSArICc6JyArIHBhZCh0aW1lLmdldFNlY29uZHMoKSkgKyAnLicgKyBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgdHJ1ZSkgKyAnICcgKyBtc2cpO1xuXHRcdFx0fSA6IGxvZ2dlcjtcblx0fVxuXG5cdHZhciBsb2dIYW5kbGVyID0gZ2V0SGFuZGxlcihjb25zb2xlTG9nZ2VyKSxcblx0XHRsb2dFcnJvckhhbmRsZXIgPSBnZXRIYW5kbGVyKGVycm9yTG9nZ2VyKTtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gTG9nZ2VyKGFyZ3MpIHt9XG5cblx0LyogcHVibGljIGNvbnN0YW50cyAqL1xuXHRMb2dnZXIuTE9HX05PTkUgICAgPSBMT0dfTk9ORSxcblx0TG9nZ2VyLkxPR19FUlJPUiAgID0gTE9HX0VSUk9SLFxuXHRMb2dnZXIuTE9HX01BSk9SICAgPSBMT0dfTUFKT1IsXG5cdExvZ2dlci5MT0dfTUlOT1IgICA9IExPR19NSU5PUixcblx0TG9nZ2VyLkxPR19NSUNSTyAgID0gTE9HX01JQ1JPO1xuXG5cdExvZ2dlci5MT0dfREVGQVVMVCA9IExPR19ERUZBVUxULFxuXHRMb2dnZXIuTE9HX0RFQlVHICAgPSBMT0dfREVCVUc7XG5cblx0LyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cblx0TG9nZ2VyLmxvZ0FjdGlvbiA9IGZ1bmN0aW9uKGxldmVsLCBhY3Rpb24sIG1lc3NhZ2UpIHtcblx0XHRpZiAoTG9nZ2VyLnNob3VsZExvZyhsZXZlbCkpIHtcblx0XHRcdChsZXZlbCA9PT0gTE9HX0VSUk9SID8gbG9nRXJyb3JIYW5kbGVyIDogbG9nSGFuZGxlcikoJ0FibHk6ICcgKyBhY3Rpb24gKyAnOiAnICsgbWVzc2FnZSk7XG5cdFx0fVxuXHR9O1xuXG5cdExvZ2dlci5kZXByZWNhdGVkID0gZnVuY3Rpb24ob3JpZ2luYWwsIHJlcGxhY2VtZW50KSB7XG5cdFx0TG9nZ2VyLmRlcHJlY2F0ZWRXaXRoTXNnKG9yaWdpbmFsLCBcIlBsZWFzZSB1c2UgJ1wiICsgcmVwbGFjZW1lbnQgKyBcIicgaW5zdGVhZC5cIik7XG5cdH1cblxuXHRMb2dnZXIuZGVwcmVjYXRlZFdpdGhNc2cgPSBmdW5jdGlvbihmdW5jTmFtZSwgbXNnKSB7XG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2coTE9HX0VSUk9SKSkge1xuXHRcdFx0bG9nRXJyb3JIYW5kbGVyKFwiQWJseTogRGVwcmVjYXRpb24gd2FybmluZyAtICdcIiArIGZ1bmNOYW1lICsgXCInIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIGEgZnV0dXJlIHZlcnNpb24uIFwiICsgbXNnKTtcblx0XHR9XG5cdH1cblxuXHQvKiBXaGVyZSBhIGxvZ2dpbmcgb3BlcmF0aW9uIGlzIGV4cGVuc2l2ZSwgc3VjaCBhcyBzZXJpYWxpc2F0aW9uIG9mIGRhdGEsIHVzZSBzaG91bGRMb2cgd2lsbCBwcmV2ZW50XG5cdCAgIHRoZSBvYmplY3QgYmVpbmcgc2VyaWFsaXNlZCBpZiB0aGUgbG9nIGxldmVsIHdpbGwgbm90IG91dHB1dCB0aGUgbWVzc2FnZSAqL1xuXHRMb2dnZXIuc2hvdWxkTG9nID0gZnVuY3Rpb24obGV2ZWwpIHtcblx0XHRyZXR1cm4gbGV2ZWwgPD0gbG9nTGV2ZWw7XG5cdH07XG5cblx0TG9nZ2VyLnNldExvZyA9IGZ1bmN0aW9uKGxldmVsLCBoYW5kbGVyKSB7XG5cdFx0aWYobGV2ZWwgIT09IHVuZGVmaW5lZCkgbG9nTGV2ZWwgPSBsZXZlbDtcblx0XHRpZihoYW5kbGVyICE9PSB1bmRlZmluZWQpIGxvZ0hhbmRsZXIgPSBsb2dFcnJvckhhbmRsZXIgPSBoYW5kbGVyO1xuXHR9O1xuXG5cdHJldHVybiBMb2dnZXI7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKExvZ2dlcik7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblxuXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBVdGlscyA9IChmdW5jdGlvbigpIHtcblx0dmFyIG1zZ3BhY2sgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1zZ3BhY2s7XG5cblx0ZnVuY3Rpb24gVXRpbHMoKSB7fVxuXG5cdGZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcblx0XHRyZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyT3JTdHIubGVuZ3RoKTtcblx0fVxuXG5cdC8qXG5cdCAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuXHQgKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XG5cdCAqIHByb3BzOiAgYW4gb2JqZWN0IHdob3NlIGVudW1lcmFibGUgcHJvcGVydGllcyBhcmVcblx0ICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcblx0ICovXG5cdFV0aWxzLm1peGluID0gZnVuY3Rpb24odGFyZ2V0KSB7XG5cdFx0Zm9yKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdGlmKCFzb3VyY2UpIHsgYnJlYWs7IH1cblx0XHRcdGZvcih2YXIga2V5IGluIHNvdXJjZSkge1xuXHRcdFx0XHRpZihoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuXHRcdFx0XHRcdHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRhcmdldDtcblx0fTtcblxuXHQvKlxuXHQgKiBBZGQgYSBzZXQgb2YgcHJvcGVydGllcyB0byBhIHRhcmdldCBvYmplY3Rcblx0ICogdGFyZ2V0OiB0aGUgdGFyZ2V0IG9iamVjdFxuXHQgKiBwcm9wczogIGFuIG9iamVjdCB3aG9zZSBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlXG5cdCAqICAgICAgICAgYWRkZWQsIGJ5IHJlZmVyZW5jZSBvbmx5XG5cdCAqL1xuXHRVdGlscy5jb3B5ID0gZnVuY3Rpb24oc3JjKSB7XG5cdFx0cmV0dXJuIFV0aWxzLm1peGluKHt9LCBzcmMpO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGdpdmVuIG9iamVjdCBpc1xuXHQgKiBhbiBhcnJheS5cblx0ICovXG5cdFV0aWxzLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iKSB7XG5cdFx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYikgPT0gJ1tvYmplY3QgQXJyYXldJztcblx0fTtcblxuXHQvKlxuXHQgKiBFbnN1cmVzIHRoYXQgYW4gQXJyYXkgb2JqZWN0IGlzIGFsd2F5cyByZXR1cm5lZFxuXHQgKiByZXR1cm5pbmcgdGhlIG9yaWdpbmFsIEFycmF5IG9mIG9iaiBpcyBhbiBBcnJheVxuXHQgKiBlbHNlIHdyYXBwaW5nIHRoZSBvYmogaW4gYSBzaW5nbGUgZWxlbWVudCBBcnJheVxuXHQgKi9cblx0VXRpbHMuZW5zdXJlQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcblx0XHRpZihVdGlscy5pc0VtcHR5QXJnKG9iaikpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cdFx0aWYoVXRpbHMuaXNBcnJheShvYmopKSB7XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH1cblx0XHRyZXR1cm4gW29ial07XG5cdH1cblxuXHQvKiAuLi5PciBhbiBPYmplY3QgKGluIHRoZSBuYXJyb3cgc2Vuc2UpICovXG5cdFV0aWxzLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2IpIHtcblx0XHRyZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iKSA9PSAnW29iamVjdCBPYmplY3RdJztcblx0fTtcblxuXHQvKlxuXHQgKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGNvbnRhaW5zXG5cdCAqIGFueSBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXG5cdCAqIG9iOiB0aGUgb2JqZWN0XG5cdCAqL1xuXHRVdGlscy5pc0VtcHR5ID0gZnVuY3Rpb24ob2IpIHtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0VXRpbHMuaXNPbmx5UHJvcEluID0gZnVuY3Rpb24ob2IsIHByb3BlcnR5KSB7XG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKSB7XG5cdFx0XHRpZihwcm9wICE9PSBwcm9wZXJ0eSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0cnVlO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBhcmd1bWVudCB0byBhbiBvdmVybG9hZGVkIGZ1bmN0aW9uIGlzXG5cdCAqIHVuZGVmaW5lZCAobWlzc2luZykgb3IgbnVsbC5cblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4gY29uc3RydWN0aW5nIGZ1bmN0aW9ucyBzdWNoIGFzIChXZWJJREwgdGVybWlub2xvZ3kpOlxuXHQgKiAgIG9mZihbVHJlYXRVbmRlZmluZWRBcz1OdWxsXSBET01TdHJpbmc/IGV2ZW50KVxuXHQgKiBhcyB5b3UgY2FuIHRoZW4gY29uZmlybSB0aGUgYXJndW1lbnQgdXNpbmc6XG5cdCAqICAgVXRpbHMuaXNFbXB0eUFyZyhldmVudClcblx0ICovXG5cblx0VXRpbHMuaXNFbXB0eUFyZyA9IGZ1bmN0aW9uKGFyZykge1xuXHRcdHJldHVybiBhcmcgPT09IG51bGwgfHwgYXJnID09PSB1bmRlZmluZWQ7XG5cdH1cblxuXHQvKlxuXHQgKiBQZXJmb3JtIGEgc2ltcGxlIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LlxuXHQgKiBSZXN1bHQgaXMgYW4gb2JqZWN0IGlycmVzcGVjdGl2ZSBvZiB3aGV0aGVyXG5cdCAqIHRoZSBpbnB1dCBpcyBhbiBvYmplY3Qgb3IgYXJyYXkuIEFsbFxuXHQgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvcGllZC5cblx0ICogb2I6IHRoZSBvYmplY3Rcblx0ICovXG5cdFV0aWxzLnNoYWxsb3dDbG9uZSA9IGZ1bmN0aW9uKG9iKSB7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBPYmplY3QoKTtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpXG5cdFx0XHRyZXN1bHRbcHJvcF0gPSBvYltwcm9wXTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qXG5cdCAqIENsb25lIGFuIG9iamVjdCBieSBjcmVhdGluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGVcblx0ICogZ2l2ZW4gb2JqZWN0IGFzIGl0cyBwcm90b3R5cGUuIE9wdGlvbmFsbHlcblx0ICogYSBzZXQgb2YgYWRkaXRpb25hbCBvd24gcHJvcGVydGllcyBjYW4gYmVcblx0ICogc3VwcGxpZWQgdG8gYmUgYWRkZWQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgY2xvbmUuXG5cdCAqIG9iOiAgICAgICAgICAgIHRoZSBvYmplY3QgdG8gYmUgY2xvbmVkXG5cdCAqIG93blByb3BlcnRpZXM6IG9wdGlvbmFsIG9iamVjdCB3aXRoIGFkZGl0aW9uYWxcblx0ICogICAgICAgICAgICAgICAgcHJvcGVydGllcyB0byBhZGRcblx0ICovXG5cdFV0aWxzLnByb3RvdHlwaWNhbENsb25lID0gZnVuY3Rpb24ob2IsIG93blByb3BlcnRpZXMpIHtcblx0XHRmdW5jdGlvbiBGKCkge31cblx0XHRGLnByb3RvdHlwZSA9IG9iO1xuXHRcdHZhciByZXN1bHQgPSBuZXcgRigpO1xuXHRcdGlmKG93blByb3BlcnRpZXMpXG5cdFx0XHRVdGlscy5taXhpbihyZXN1bHQsIG93blByb3BlcnRpZXMpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0Lypcblx0ICogRGVjbGFyZSBhIGNvbnN0cnVjdG9yIHRvIHJlcHJlc2VudCBhIHN1YmNsYXNzXG5cdCAqIG9mIGFub3RoZXIgY29uc3RydWN0b3Jcblx0ICogSWYgcGxhdGZvcm0gaGFzIGEgYnVpbHQtaW4gdmVyc2lvbiB3ZSB1c2UgdGhhdCBmcm9tIFBsYXRmb3JtLCBlbHNlIHdlXG5cdCAqIGRlZmluZSBoZXJlIChzbyBjYW4gbWFrZSB1c2Ugb2Ygb3RoZXIgVXRpbHMgZm5zKVxuXHQgKiBTZWUgbm9kZS5qcyB1dGlsLmluaGVyaXRzXG5cdCAqL1xuXHRVdGlscy5pbmhlcml0cyA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMgfHwgZnVuY3Rpb24oY3Rvciwgc3VwZXJDdG9yKSB7XG5cdFx0Y3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG5cdFx0Y3Rvci5wcm90b3R5cGUgPSBVdGlscy5wcm90b3R5cGljYWxDbG9uZShzdXBlckN0b3IucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiBjdG9yIH0pO1xuXHR9O1xuXG5cdC8qXG5cdCAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhbiBvYmplY3QgaGFzIGFuIGVudW1lcmFibGVcblx0ICogcHJvcGVydHkgd2hvc2UgdmFsdWUgZXF1YWxzIGEgZ2l2ZW4gdmFsdWUuXG5cdCAqIG9iOiAgdGhlIG9iamVjdFxuXHQgKiB2YWw6IHRoZSB2YWx1ZSB0byBmaW5kXG5cdCAqL1xuXHRVdGlscy5jb250YWluc1ZhbHVlID0gZnVuY3Rpb24ob2IsIHZhbCkge1xuXHRcdGZvcih2YXIgaSBpbiBvYikge1xuXHRcdFx0aWYob2JbaV0gPT0gdmFsKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xuXG5cdFV0aWxzLmludGVyc2VjdCA9IGZ1bmN0aW9uKGFyciwgb2IpIHsgcmV0dXJuIFV0aWxzLmlzQXJyYXkob2IpID8gVXRpbHMuYXJySW50ZXJzZWN0KGFyciwgb2IpIDogVXRpbHMuYXJySW50ZXJzZWN0T2IoYXJyLCBvYik7IH07XG5cblx0VXRpbHMuYXJySW50ZXJzZWN0ID0gZnVuY3Rpb24oYXJyMSwgYXJyMikge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1lbWJlciA9IGFycjFbaV07XG5cdFx0XHRpZihVdGlscy5hcnJJbmRleE9mKGFycjIsIG1lbWJlcikgIT0gLTEpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKG1lbWJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuYXJySW50ZXJzZWN0T2IgPSBmdW5jdGlvbihhcnIsIG9iKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtZW1iZXIgPSBhcnJbaV07XG5cdFx0XHRpZihtZW1iZXIgaW4gb2IpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKG1lbWJlcik7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0VXRpbHMuYXJyU3VidHJhY3QgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgZWxlbWVudCA9IGFycjFbaV07XG5cdFx0XHRpZihVdGlscy5hcnJJbmRleE9mKGFycjIsIGVsZW1lbnQpID09IC0xKVxuXHRcdFx0XHRyZXN1bHQucHVzaChlbGVtZW50KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5hcnJJbmRleE9mID0gQXJyYXkucHJvdG90eXBlLmluZGV4T2Zcblx0XHQ/IGZ1bmN0aW9uKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XG5cdFx0XHRyZXR1cm4gYXJyLmluZGV4T2YoZWxlbSwgIGZyb21JbmRleCk7XG5cdFx0fVxuXHRcdDogZnVuY3Rpb24oYXJyLCBlbGVtLCBmcm9tSW5kZXgpIHtcblx0XHRcdGZyb21JbmRleCA9IGZyb21JbmRleCB8fCAwO1xuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IoO2Zyb21JbmRleCA8IGxlbjsgZnJvbUluZGV4KyspIHtcblx0XHRcdFx0aWYoYXJyW2Zyb21JbmRleF0gPT09IGVsZW0pIHtcblx0XHRcdFx0XHRyZXR1cm4gZnJvbUluZGV4O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gLTE7XG5cdFx0fTtcblxuXHRVdGlscy5hcnJJbiA9IGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmFyckluZGV4T2YoYXJyLCB2YWwpICE9PSAtMTtcblx0fTtcblxuXHRVdGlscy5hcnJEZWxldGVWYWx1ZSA9IGZ1bmN0aW9uKGFyciwgdmFsKSB7XG5cdFx0dmFyIGlkeCA9IFV0aWxzLmFyckluZGV4T2YoYXJyLCB2YWwpO1xuXHRcdHZhciByZXMgPSAoaWR4ICE9IC0xKTtcblx0XHRpZihyZXMpXG5cdFx0XHRhcnIuc3BsaWNlKGlkeCwgMSk7XG5cdFx0cmV0dXJuIHJlcztcblx0fTtcblxuXHRVdGlscy5hcnJXaXRob3V0VmFsdWUgPSBmdW5jdGlvbihhcnIsIHZhbCkge1xuXHRcdHZhciBuZXdBcnIgPSBhcnIuc2xpY2UoKTtcblx0XHRVdGlscy5hcnJEZWxldGVWYWx1ZShuZXdBcnIsIHZhbCk7XG5cdFx0cmV0dXJuIG5ld0Fycjtcblx0fTtcblxuXHQvKlxuXHQgKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgdGhlIGtleXMgb2YgdGhlIGVudW1lcmFibGVcblx0ICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXG5cdCAqIHRvIG9ubHkgdGhlIG93biBwcm9wZXJ0aWVzLlxuXHQgKiBvYjogICAgICB0aGUgb2JqZWN0XG5cdCAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XG5cdCAqL1xuXHRVdGlscy5rZXlzQXJyYXkgPSBmdW5jdGlvbihvYiwgb3duT25seSkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpIHtcblx0XHRcdGlmKG93bk9ubHkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKSBjb250aW51ZTtcblx0XHRcdHJlc3VsdC5wdXNoKHByb3ApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdC8qXG5cdCAqIENvbnN0cnVjdCBhbiBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBlbnVtZXJhYmxlXG5cdCAqIHByb3BlcnRpZXMgb2YgYSBnaXZlbiBvYmplY3QsIG9wdGlvbmFsbHkgbGltaXRlZFxuXHQgKiB0byBvbmx5IHRoZSBvd24gcHJvcGVydGllcy5cblx0ICogb2I6ICAgICAgdGhlIG9iamVjdFxuXHQgKiBvd25Pbmx5OiBib29sZWFuLCBnZXQgb3duIHByb3BlcnRpZXMgb25seVxuXHQgKi9cblx0VXRpbHMudmFsdWVzQXJyYXkgPSBmdW5jdGlvbihvYiwgb3duT25seSkge1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpIHtcblx0XHRcdGlmKG93bk9ubHkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKSBjb250aW51ZTtcblx0XHRcdHJlc3VsdC5wdXNoKG9iW3Byb3BdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5mb3JJbk93bk5vbk51bGxQcm9wcyA9IGZ1bmN0aW9uKG9iLCBmbikge1xuXHRcdGZvciAodmFyIHByb3AgaW4gb2IpIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSAmJiBvYltwcm9wXSkge1xuXHRcdFx0XHRmbihwcm9wKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0VXRpbHMuYXJyRm9yRWFjaCA9IEFycmF5LnByb3RvdHlwZS5mb3JFYWNoID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRhcnIuZm9yRWFjaChmbik7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0Zm4oYXJyW2ldLCBpLCBhcnIpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0LyogVXNlZnVsIHdoZW4gdGhlIGZ1bmN0aW9uIG1heSBtdXRhdGUgdGhlIGFycmF5ICovXG5cdFV0aWxzLnNhZmVBcnJGb3JFYWNoID0gZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdHJldHVybiBVdGlscy5hcnJGb3JFYWNoKGFyci5zbGljZSgpLCBmbik7XG5cdH07XG5cblx0VXRpbHMuYXJyTWFwID0gQXJyYXkucHJvdG90eXBlLm1hcCA/XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0cmV0dXJuIGFyci5tYXAoZm4pO1xuXHRcdH0gOlxuXHRcdGZ1bmN0aW9uKGFyciwgZm4pXHR7XG5cdFx0XHR2YXIgcmVzdWx0ID0gW10sXG5cdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0LnB1c2goZm4oYXJyW2ldLCBpLCBhcnIpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fTtcblxuXHRVdGlscy5hcnJGaWx0ZXIgPSBBcnJheS5wcm90b3R5cGUuZmlsdGVyID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRyZXR1cm4gYXJyLmZpbHRlcihmbik7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oYXJyLCBmbilcdHtcblx0XHRcdHZhciByZXN1bHQgPSBbXSxcblx0XHRcdFx0bGVuID0gYXJyLmxlbmd0aDtcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0XHRpZihmbihhcnJbaV0pKSB7XG5cdFx0XHRcdFx0cmVzdWx0LnB1c2goYXJyW2ldKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9O1xuXG5cdFV0aWxzLmFyckV2ZXJ5ID0gQXJyYXkucHJvdG90eXBlLmV2ZXJ5ID9cblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XG5cdFx0XHRyZXR1cm4gYXJyLmV2ZXJ5KGZuKTtcblx0XHR9IDogZnVuY3Rpb24oYXJyLCBmbikge1xuXHRcdFx0dmFyIGxlbiA9IGFyci5sZW5ndGg7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdFx0aWYoIWZuKGFycltpXSwgaSwgYXJyKSkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH07XG5cblx0VXRpbHMuYWxsU2FtZSA9IGZ1bmN0aW9uKGFyciwgcHJvcCkge1xuXHRcdGlmKGFyci5sZW5ndGggPT09IDApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgZmlyc3QgPSBhcnJbMF1bcHJvcF07XG5cdFx0cmV0dXJuIFV0aWxzLmFyckV2ZXJ5KGFyciwgZnVuY3Rpb24oaXRlbSkge1xuXHRcdFx0cmV0dXJuIGl0ZW1bcHJvcF0gPT09IGZpcnN0O1xuXHRcdH0pO1xuXHR9O1xuXG5cdFV0aWxzLm5leHRUaWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljaztcblxuXHR2YXIgY29udGVudFR5cGVzID0ge1xuXHRcdGpzb246ICAgJ2FwcGxpY2F0aW9uL2pzb24nLFxuXHRcdGpzb25wOiAgJ2FwcGxpY2F0aW9uL2phdmFzY3JpcHQnLFxuXHRcdHhtbDogICAgJ2FwcGxpY2F0aW9uL3htbCcsXG5cdFx0aHRtbDogICAndGV4dC9odG1sJyxcblx0XHRtc2dwYWNrOiAnYXBwbGljYXRpb24veC1tc2dwYWNrJ1xuXHR9O1xuXG5cdFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzID0gZnVuY3Rpb24oZm9ybWF0KSB7XG5cdFx0dmFyIGFjY2VwdCA9IGNvbnRlbnRUeXBlc1tmb3JtYXQgfHwgJ2pzb24nXTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0YWNjZXB0OiBhY2NlcHQsXG5cdFx0XHQnWC1BYmx5LVZlcnNpb24nOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcGlWZXJzaW9uLFxuXHRcdFx0J0FibHktQWdlbnQnOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZ2VudFxuXHRcdH07XG5cdH07XG5cblx0VXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzID0gZnVuY3Rpb24oZm9ybWF0KSB7XG5cdFx0dmFyIGFjY2VwdCwgY29udGVudFR5cGU7XG5cdFx0YWNjZXB0ID0gY29udGVudFR5cGUgPSBjb250ZW50VHlwZXNbZm9ybWF0IHx8ICdqc29uJ107XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWNjZXB0OiBhY2NlcHQsXG5cdFx0XHQnY29udGVudC10eXBlJzogY29udGVudFR5cGUsXG5cdFx0XHQnWC1BYmx5LVZlcnNpb24nOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcGlWZXJzaW9uLFxuXHRcdFx0J0FibHktQWdlbnQnOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZ2VudFxuXHRcdH07XG5cdH07XG5cblx0VXRpbHMuYXJyUG9wUmFuZG9tRWxlbWVudCA9IGZ1bmN0aW9uKGFycikge1xuXHRcdHJldHVybiBhcnIuc3BsaWNlKHJhbmRvbVBvc24oYXJyKSwgMSlbMF07XG5cdH07XG5cblx0VXRpbHMudG9RdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHBhcmFtcykge1xuXHRcdHZhciBwYXJ0cyA9IFtdO1xuXHRcdGlmKHBhcmFtcykge1xuXHRcdFx0Zm9yKHZhciBrZXkgaW4gcGFyYW1zKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJ0cy5sZW5ndGggPyAnPycgKyBwYXJ0cy5qb2luKCcmJykgOiAnJztcblx0fTtcblxuXHRVdGlscy5wYXJzZVF1ZXJ5U3RyaW5nID0gZnVuY3Rpb24ocXVlcnkpIHtcblx0XHR2YXIgbWF0Y2gsXG5cdFx0XHRzZWFyY2ggPSAvKFtePyY9XSspPT8oW14mXSopL2csXG5cdFx0XHRyZXN1bHQgPSB7fTtcblxuXHRcdHdoaWxlIChtYXRjaCA9IHNlYXJjaC5leGVjKHF1ZXJ5KSlcblx0XHRcdHJlc3VsdFtkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMV0pXSA9IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFsyXSk7XG5cbiBcdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRVdGlscy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcblx0XHQvKiBJRSA4ICovXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXHR9O1xuXG5cdFV0aWxzLmluc3BlY3QgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3Q7XG5cblx0VXRpbHMuaXNFcnJvckluZm8gPSBmdW5jdGlvbihlcnIpIHtcblx0XHRyZXR1cm4gZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT0gJ0Vycm9ySW5mbydcblx0fTtcblxuXHRVdGlscy5pbnNwZWN0RXJyb3IgPSBmdW5jdGlvbih4KSB7XG5cdFx0LyogcmVkdW5kYW50LCBidXQgbm9kZSB2bWNvbnRleHQgaXNzdWUgbWFrZXMgaW5zdGFuY2VvZiB1bnJlbGlhYmxlLCBhbmRcblx0XHQgKiBjYW4ndCB1c2UganVzdCBjb25zdHJ1Y3RvciB0ZXN0IGFzIGNvdWxkIGJlIGEgVHlwZUVycm9yIGNvbnN0cnVjdG9yIGV0Yy4gKi9cblx0XHRyZXR1cm4gKHggJiYgKFV0aWxzLmlzRXJyb3JJbmZvKHgpIHx8XG5cdFx0XHR4LmNvbnN0cnVjdG9yLm5hbWUgPT0gJ0Vycm9yJyB8fFxuXHRcdFx0eCBpbnN0YW5jZW9mIEVycm9yKSkgP1xuXHRcdFx0eC50b1N0cmluZygpIDpcblx0XHRcdFV0aWxzLmluc3BlY3QoeCk7XG5cdH07XG5cblx0VXRpbHMuaW5zcGVjdEJvZHkgPSBmdW5jdGlvbihib2R5KSB7XG5cdFx0aWYocGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihib2R5KSkge1xuXHRcdFx0cmV0dXJuIGJvZHkudG9TdHJpbmcoKTtcblx0XHR9IGVsc2UgaWYodHlwZW9mIGJvZHkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRyZXR1cm4gYm9keTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdChib2R5KTtcblx0XHR9XG5cdH07XG5cblx0LyogRGF0YSBpcyBhc3N1bWVkIHRvIGJlIGVpdGhlciBhIHN0cmluZyBvciBhIGJ1ZmZlci4gKi9cblx0VXRpbHMuZGF0YVNpemVCeXRlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRpZihwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpKSB7XG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ieXRlTGVuZ3RoKGRhdGEpO1xuXHRcdH1cblx0XHRpZih0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdHJldHVybiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ0J5dGVTaXplKGRhdGEpO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBpbnB1dCBvZiBVdGlscy5kYXRhU2l6ZUJ5dGVzIHRvIGJlIGEgYnVmZmVyIG9yIHN0cmluZywgYnV0IHdhczogXCIgKyAodHlwZW9mIGRhdGEpKTtcblx0fTtcblxuXHRVdGlscy5jaGVhcFJhbmRTdHIgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gU3RyaW5nKE1hdGgucmFuZG9tKCkpLnN1YnN0cigyKTtcblx0fTtcblxuXHQvKiBUYWtlcyBwYXJhbSB0aGUgbWluaW11bSBudW1iZXIgb2YgYnl0ZXMgb2YgZW50cm9weSB0aGUgc3RyaW5nIG11c3Rcblx0ICogaW5jbHVkZSwgbm90IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy4gU3RyaW5nIGxlbmd0aCBwcm9kdWNlZCBpcyBub3Rcblx0ICogZ3VhcmFudGVlZC4gKi9cblx0VXRpbHMucmFuZG9tU3RyaW5nID0gKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgP1xuXHRcdGZ1bmN0aW9uKG51bUJ5dGVzKSB7XG5cdFx0XHR2YXIgdUludEFyciA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzKTtcblx0XHRcdHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzKHVJbnRBcnIpO1xuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKHVJbnRBcnIpO1xuXHRcdH0gOiBmdW5jdGlvbihudW1CeXRlcykge1xuXHRcdFx0LyogT2xkIGJyb3dzZXI7IGZhbGwgYmFjayB0byBNYXRoLnJhbmRvbS4gQ291bGQganVzdCB1c2UgYVxuXHRcdFx0ICogQ3J5cHRvSlMgdmVyc2lvbiBvZiB0aGUgYWJvdmUsIGJ1dCB3YW50IHRoaXMgdG8gc3RpbGwgd29yayBpbiBub2NyeXB0b1xuXHRcdFx0ICogdmVyc2lvbnMgb2YgdGhlIGxpYnJhcnkgKi9cblx0XHRcdHZhciBjaGFyc2V0ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRDaGFyU2V0O1xuXHRcdFx0LyogYmFzZTY0IGhhcyAzMyUgb3ZlcmhlYWQ7IHJvdW5kIGxlbmd0aCB1cCAqL1xuXHRcdFx0dmFyIGxlbmd0aCA9IE1hdGgucm91bmQobnVtQnl0ZXMgKiA0LzMpO1xuXHRcdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0ICs9IGNoYXJzZXRbcmFuZG9tUG9zbihjaGFyc2V0KV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0VXRpbHMucmFuZG9tSGV4U3RyaW5nID0gKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgP1xuXHRcdGZ1bmN0aW9uKG51bUJ5dGVzKSB7XG5cdFx0XHR2YXIgdUludEFyciA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzKTtcblx0XHRcdHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzKHVJbnRBcnIpO1xuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaGV4RW5jb2RlKHVJbnRBcnIpO1xuXHRcdH0gOiBmdW5jdGlvbihudW1CeXRlcykge1xuXHRcdFx0dmFyIGNoYXJzZXQgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmhleENoYXJTZXQ7XG5cdFx0XHR2YXIgbGVuZ3RoID0gbnVtQnl0ZXMgKiAyO1xuXHRcdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0cmVzdWx0ICs9IGNoYXJzZXRbcmFuZG9tUG9zbihjaGFyc2V0KV07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH07XG5cblx0LyogUGljayBuIGVsZW1lbnRzIGF0IHJhbmRvbSB3aXRob3V0IHJlcGxhY2VtZW50IGZyb20gYW4gYXJyYXkgKi9cblx0VXRpbHMuYXJyQ2hvb3NlTiA9IGZ1bmN0aW9uKGFyciwgbikge1xuXHRcdHZhciBudW1JdGVtcyA9IE1hdGgubWluKG4sIGFyci5sZW5ndGgpLFxuXHRcdFx0bXV0YWJsZUFyciA9IGFyci5zbGljZSgpLFxuXHRcdFx0cmVzdWx0ID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IG51bUl0ZW1zOyBpKyspIHtcblx0XHRcdHJlc3VsdC5wdXNoKFV0aWxzLmFyclBvcFJhbmRvbUVsZW1lbnQobXV0YWJsZUFycikpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFV0aWxzLnRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW0gPyBmdW5jdGlvbihzdHIpIHtcblx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcblx0fSA6IGZ1bmN0aW9uKHN0cikge1xuXHRcdHJldHVybiBzdHIucmVwbGFjZSgvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csICcnKTtcblx0fTtcblxuXHRVdGlscy5wcm9taXNpZnkgPSBmdW5jdGlvbihvYiwgZm5OYW1lLCBhcmdzKSB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHRcdFx0b2JbZm5OYW1lXS5hcHBseShvYiwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncykuY29uY2F0KGZ1bmN0aW9uKGVyciwgcmVzKSB7XG5cdFx0XHRcdGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShyZXMpO1xuXHRcdFx0fSkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFV0aWxzLmRlY29kZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcblx0XHRyZXR1cm4gKGZvcm1hdCA9PSAnbXNncGFjaycpID8gbXNncGFjay5kZWNvZGUoYm9keSkgOiBKU09OLnBhcnNlKFN0cmluZyhib2R5KSk7XG5cdH07XG5cblx0VXRpbHMuZW5jb2RlQm9keSA9IGZ1bmN0aW9uKGJvZHksIGZvcm1hdCkge1xuXHRcdHJldHVybiAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmVuY29kZShib2R5LCB0cnVlKSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuXHR9O1xuXG5cdFV0aWxzLmFsbFRvTG93ZXJDYXNlID0gZnVuY3Rpb24oYXJyKSB7XG5cdFx0cmV0dXJuIFV0aWxzLmFyck1hcChhcnIsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcblx0XHRcdHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9Mb3dlckNhc2UoKTtcblx0XHR9KTtcblx0fTtcblxuXHRVdGlscy5hbGxUb1VwcGVyQ2FzZSA9IGZ1bmN0aW9uKGFycikge1xuXHRcdHJldHVybiBVdGlscy5hcnJNYXAoYXJyLCBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0XHRyZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvVXBwZXJDYXNlKCk7XG5cdFx0fSk7XG5cdH07XG5cblx0cmV0dXJuIFV0aWxzO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChVdGlscyk7XG5cblxuLyoqKi8gfSksXG4vKiAyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbnZhciBFcnJvckluZm8gPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdFx0dGhpcy5jYXVzZSA9IGNhdXNlO1xuXHRcdHRoaXMuaHJlZiA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdEVycm9ySW5mby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1snICsgdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuXHRcdGlmKHRoaXMubWVzc2FnZSkgcmVzdWx0ICs9ICc6ICcgKyB0aGlzLm1lc3NhZ2U7XG5cdFx0aWYodGhpcy5zdGF0dXNDb2RlKSByZXN1bHQgKz0gJzsgc3RhdHVzQ29kZT0nICsgdGhpcy5zdGF0dXNDb2RlO1xuXHRcdGlmKHRoaXMuY29kZSkgcmVzdWx0ICs9ICc7IGNvZGU9JyArIHRoaXMuY29kZTtcblx0XHRpZih0aGlzLmNhdXNlKSByZXN1bHQgKz0gJzsgY2F1c2U9JyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKHRoaXMuY2F1c2UpO1xuXHRcdGlmKHRoaXMuaHJlZiAmJiAhKHRoaXMubWVzc2FnZSAmJiB0aGlzLm1lc3NhZ2UuaW5kZXhPZignaGVscC5hYmx5LmlvJykgPiAtMSkpIHJlc3VsdCArPSAnOyBzZWUgJyArIHRoaXMuaHJlZiArICcgJztcblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0RXJyb3JJbmZvLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YXIgcmVzdWx0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgRXJyb3JJbmZvKCksIHZhbHVlcyk7XG5cdFx0aWYgKHZhbHVlcyBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHQvKiBFcnJvci5tZXNzYWdlIGlzIG5vdCBlbnVtZXJhYmxlLCBzbyBtaXhpbiBsb3NlcyB0aGUgbWVzc2FnZSAqL1xuXHRcdFx0cmVzdWx0Lm1lc3NhZ2UgPSB2YWx1ZXMubWVzc2FnZTtcblx0XHR9XG5cdFx0aWYocmVzdWx0LmNvZGUgJiYgIXJlc3VsdC5ocmVmKSB7XG5cdFx0XHRyZXN1bHQuaHJlZiA9ICdodHRwczovL2hlbHAuYWJseS5pby9lcnJvci8nICsgcmVzdWx0LmNvZGU7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0cmV0dXJuIEVycm9ySW5mbztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRXJyb3JJbmZvKTtcblxuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsLCBzZXRJbW1lZGlhdGUpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xpYl91dGlsX21zZ3BhY2tfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG5cbmlmKHR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0Y29uc29sZS5sb2coXCJXYXJuaW5nOiB0aGlzIGRpc3RyaWJ1dGlvbiBvZiBBYmx5IGlzIGludGVuZGVkIGZvciBicm93c2Vycy4gT24gbm9kZWpzLCBwbGVhc2UgdXNlIHRoZSAnYWJseScgcGFja2FnZSBvbiBucG1cIik7XG59XG5cbmZ1bmN0aW9uIGFsbG93Q29tZXQoKSB7XG5cdC8qIHhociByZXF1ZXN0cyBmcm9tIGxvY2FsIGZpbGVzIGFyZSB1bnJlbGlhYmxlIGluIHNvbWUgYnJvd3NlcnMsIHN1Y2ggYXMgQ2hyb21lIDY1IGFuZCBoaWdoZXIgLS0gc2VlIGVnXG5cdCAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5MjU2NDI5L2Nocm9tZS02NS11bmFibGUtdG8tbWFrZS1wb3N0LXJlcXVlc3RzLWZyb20tbG9jYWwtZmlsZXMtdG8tZmxhc2tcblx0ICogU28gaWYgd2Vic29ja2V0cyBhcmUgc3VwcG9ydGVkLCB0aGVuIGp1c3QgZm9yZ2V0IGFib3V0IGNvbWV0IHRyYW5zcG9ydHMgYW5kIHVzZSB0aGF0ICovXG5cdHZhciBsb2MgPSBnbG9iYWwubG9jYXRpb247XG5cdHJldHVybiAoIWdsb2JhbC5XZWJTb2NrZXQgfHwgIWxvYyB8fCAhbG9jLm9yaWdpbiB8fCBsb2Mub3JpZ2luLmluZGV4T2YoXCJodHRwXCIpID4gLTEpO1xufVxuXG52YXIgdXNlckFnZW50ID0gZ2xvYmFsLm5hdmlnYXRvciAmJiBnbG9iYWwubmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpO1xudmFyIGN1cnJlbnRVcmwgPSBnbG9iYWwubG9jYXRpb24gJiYgZ2xvYmFsLmxvY2F0aW9uLmhyZWY7XG5cbnZhciBQbGF0Zm9ybSA9IHtcbiAgICAgICAgYWdlbnQ6ICdicm93c2VyJyxcblx0bG9nVGltZXN0YW1wczogdHJ1ZSxcblx0dXNlckFnZW50OiB1c2VyQWdlbnQsXG5cdGN1cnJlbnRVcmw6IGN1cnJlbnRVcmwsXG5cdG5vVXBncmFkZTogdXNlckFnZW50ICYmIHVzZXJBZ2VudC5tYXRjaCgvTVNJRVxcczhcXC4wLyksXG5cdGJpbmFyeVR5cGU6ICdhcnJheWJ1ZmZlcicsXG5cdFdlYlNvY2tldDogZ2xvYmFsLldlYlNvY2tldCB8fCBnbG9iYWwuTW96V2ViU29ja2V0LFxuXHR4aHJTdXBwb3J0ZWQ6IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcblx0anNvbnBTdXBwb3J0ZWQ6IHR5cGVvZihkb2N1bWVudCkgIT09ICd1bmRlZmluZWQnLFxuXHRhbGxvd0NvbWV0OiBhbGxvd0NvbWV0KCksXG5cdHN0cmVhbWluZ1N1cHBvcnRlZDogdHJ1ZSxcblx0dXNlUHJvdG9jb2xIZWFydGJlYXRzOiB0cnVlLFxuXHRjcmVhdGVIbWFjOiBudWxsLFxuXHRtc2dwYWNrOiBfbGliX3V0aWxfbXNncGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxuXHRzdXBwb3J0c0JpbmFyeTogISFnbG9iYWwuVGV4dERlY29kZXIsXG5cdHByZWZlckJpbmFyeTogZmFsc2UsXG5cdEFycmF5QnVmZmVyOiBnbG9iYWwuQXJyYXlCdWZmZXIsXG5cdGF0b2I6IGdsb2JhbC5hdG9iLFxuXHRuZXh0VGljazogdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWwuc2V0SW1tZWRpYXRlLmJpbmQoZ2xvYmFsKSA6IGZ1bmN0aW9uKGYpIHsgc2V0VGltZW91dChmLCAwKTsgfSxcblx0YWRkRXZlbnRMaXN0ZW5lcjogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIsXG5cdGluc3BlY3Q6IEpTT04uc3RyaW5naWZ5LFxuXHRzdHJpbmdCeXRlU2l6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0Lyogc3RyLmxlbmd0aCB3aWxsIGJlIGFuIHVuZGVyZXN0aW1hdGUgZm9yIG5vbi1hc2NpaSBzdHJpbmdzLiBCdXQgaWYgd2UncmVcblx0XHQgKiBpbiBhIGJyb3dzZXIgdG9vIG9sZCB0byBzdXBwb3J0IFRleHREZWNvZGVyLCBub3QgbXVjaCB3ZSBjYW4gZG8uIEJldHRlclxuXHRcdCAqIHRvIHVuZGVyZXN0aW1hdGUsIHNvIGlmIHdlIGRvIGdvIG92ZXItc2l6ZSwgdGhlIHNlcnZlciB3aWxsIHJlamVjdCB0aGVcblx0XHQgKiBtZXNzYWdlICovXG5cdFx0cmV0dXJuIGdsb2JhbC5UZXh0RGVjb2RlciAmJlxuXHRcdFx0KG5ldyBnbG9iYWwuVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyKSkubGVuZ3RoIHx8XG5cdFx0XHRzdHIubGVuZ3RoO1xuXHR9LFxuXHRUZXh0RW5jb2RlcjogZ2xvYmFsLlRleHRFbmNvZGVyLFxuXHRUZXh0RGVjb2RlcjogZ2xvYmFsLlRleHREZWNvZGVyLFxuXHRQcm9taXNlOiBnbG9iYWwuUHJvbWlzZSxcblx0Z2V0UmFuZG9tVmFsdWVzOiAoZnVuY3Rpb24oY3J5cHRvKSB7XG5cdFx0aWYgKGNyeXB0byA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRyZXR1cm4gZnVuY3Rpb24oYXJyLCBjYWxsYmFjaykge1xuXHRcdFx0Y3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuXHRcdFx0aWYoY2FsbGJhY2spIHtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0fSkoZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8pIC8vIG1zY3J5cHRvIGZvciBJRTExXG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFBsYXRmb3JtKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQyKS5zZXRJbW1lZGlhdGUpKVxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXG52YXIgcGxhdGZvcm1fYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9kZWZhdWx0cy5qc1xuXG5cbnZhciBEZWZhdWx0cyA9IHtcblx0aW50ZXJuZXRVcFVybDogJ2h0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLnR4dCcsXG5cdGpzb25wSW50ZXJuZXRVcFVybDogJ2h0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLTAtOS5qcycsXG5cdC8qIE9yZGVyIG1hdHRlcnMgaGVyZTogdGhlIGJhc2UgdHJhbnNwb3J0IGlzIHRoZSBsZWZ0bW9zdCBvbmUgaW4gdGhlXG5cdCAqIGludGVyc2VjdGlvbiBvZiBiYXNlVHJhbnNwb3J0T3JkZXIgYW5kIHRoZSB0cmFuc3BvcnRzIGNsaWVudE9wdGlvbiB0aGF0J3Ncblx0ICogc3VwcG9ydGVkLiAgVGhpcyBpcyBub3QgcXVpdGUgdGhlIHNhbWUgYXMgdGhlIHByZWZlcmVuY2Ugb3JkZXIgLS0gZS5nLlxuXHQgKiB4aHJfcG9sbGluZyBpcyBwcmVmZXJyZWQgdG8ganNvbnAsIGJ1dCBmb3IgYnJvd3NlcnMgdGhhdCBzdXBwb3J0IGl0IHdlIHdhbnRcblx0ICogdGhlIGJhc2UgdHJhbnNwb3J0IHRvIGJlIHhocl9wb2xsaW5nLCBub3QganNvbnAgKi9cblx0ZGVmYXVsdFRyYW5zcG9ydHM6IFsneGhyX3BvbGxpbmcnLCAneGhyX3N0cmVhbWluZycsICdqc29ucCcsICd3ZWJfc29ja2V0J10sXG5cdGJhc2VUcmFuc3BvcnRPcmRlcjogWyd4aHJfcG9sbGluZycsICd4aHJfc3RyZWFtaW5nJywgJ2pzb25wJywgJ3dlYl9zb2NrZXQnXSxcblx0dHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyOiBbJ2pzb25wJywgJ3hocl9wb2xsaW5nJywgJ3hocl9zdHJlYW1pbmcnLCAnd2ViX3NvY2tldCddLFxuXHR1cGdyYWRlVHJhbnNwb3J0czogWyd4aHJfc3RyZWFtaW5nJywgJ3dlYl9zb2NrZXQnXVxufTtcblxuLyogSWYgdXNpbmcgSUU4LCBkb24ndCBhdHRlbXB0IHRvIHVwZ3JhZGUgZnJvbSB4aHJfcG9sbGluZyB0byB4aHJfc3RyZWFtaW5nIC1cbiogd2hpbGUgaXQgY2FuIGRvIHN0cmVhbWluZywgdGhlIGxvdyBtYXggaHR0cC1jb25uZWN0aW9ucy1wZXItaG9zdCBsaW1pdCBtZWFuc1xuKiB0aGF0IHRoZSBwb2xsaW5nIHRyYW5zcG9ydCBpcyBjcmlwcGxlZCBkdXJpbmcgdGhlIHVwZ3JhZGUgcHJvY2Vzcy4gU28ganVzdFxuKiBsZWF2ZSBpdCBhdCB0aGUgYmFzZSB0cmFuc3BvcnQgKi9cbmlmKHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubm9VcGdyYWRlKSB7XG5cdERlZmF1bHRzLnVwZ3JhZGVUcmFuc3BvcnRzID0gW107XG59XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRlZmF1bHRzID0gKERlZmF1bHRzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC91dGlscy5qc1xudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvYnVmZmVydXRpbHMuanNcbnZhciBidWZmZXJ1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbG9nZ2VyLmpzXG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvZXJyb3JpbmZvLmpzXG52YXIgZXJyb3JpbmZvID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvZGVmYXVsdHMuanNcblxuXG5cblxuXG5cblxuZGVmYXVsdHMuRU5WSVJPTk1FTlQgICAgICAgICAgICAgID0gJyc7XG5kZWZhdWx0cy5SRVNUX0hPU1QgICAgICAgICAgICAgICAgPSAncmVzdC5hYmx5LmlvJztcbmRlZmF1bHRzLlJFQUxUSU1FX0hPU1QgICAgICAgICAgICA9ICdyZWFsdGltZS5hYmx5LmlvJztcbmRlZmF1bHRzLkZBTExCQUNLX0hPU1RTICAgICAgICAgICA9IFsnQS5hYmx5LXJlYWx0aW1lLmNvbScsICdCLmFibHktcmVhbHRpbWUuY29tJywgJ0MuYWJseS1yZWFsdGltZS5jb20nLCAnRC5hYmx5LXJlYWx0aW1lLmNvbScsICdFLmFibHktcmVhbHRpbWUuY29tJ107XG5kZWZhdWx0cy5QT1JUICAgICAgICAgICAgICAgICAgICAgPSA4MDtcbmRlZmF1bHRzLlRMU19QT1JUICAgICAgICAgICAgICAgICA9IDQ0MztcbmRlZmF1bHRzLlRJTUVPVVRTID0ge1xuXHQvKiBEb2N1bWVudGVkIGFzIG9wdGlvbnMgcGFyYW1zOiAqL1xuXHRkaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQgICA6IDE1MDAwLFxuXHRzdXNwZW5kZWRSZXRyeVRpbWVvdXQgICAgICA6IDMwMDAwLFxuXHQvKiBVbmRvY3VtZW50ZWQsIGJ1dCBwYXJ0IG9mIHRoZSBhcGkgYW5kIGNhbiBiZSB1c2VkIGJ5IGN1c3RvbWVyczogKi9cblx0aHR0cFJlcXVlc3RUaW1lb3V0ICAgICAgICAgOiAxNTAwMCxcblx0Y2hhbm5lbFJldHJ5VGltZW91dCAgICAgICAgOiAxNTAwMCxcblx0ZmFsbGJhY2tSZXRyeVRpbWVvdXQgICAgICAgOiA2MDAwMDAsXG5cdC8qIEZvciBpbnRlcm5hbCAvIHRlc3QgdXNlIG9ubHk6ICovXG5cdGNvbm5lY3Rpb25TdGF0ZVR0bCAgICAgICAgIDogMTIwMDAwLFxuXHRyZWFsdGltZVJlcXVlc3RUaW1lb3V0ICAgICA6IDEwMDAwLFxuXHRyZWN2VGltZW91dCAgICAgICAgICAgICAgICA6IDkwMDAwLFxuXHRwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgICA6IDYwMDAsXG5cdHBhcmFsbGVsVXBncmFkZURlbGF5ICAgICAgIDogNjAwMFxufTtcbmRlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50ID0gMztcbmRlZmF1bHRzLm1heE1lc3NhZ2VTaXplICAgID0gNjU1MzY7XG5cbmRlZmF1bHRzLmVycm9yUmVwb3J0aW5nVXJsID0gJ2h0dHBzOi8vZXJyb3JzLmFibHkuaW8vYXBpLzE1L3N0b3JlLyc7XG5kZWZhdWx0cy5lcnJvclJlcG9ydGluZ0hlYWRlcnMgPSB7XG5cdFwiWC1TZW50cnktQXV0aFwiOiBcIlNlbnRyeSBzZW50cnlfdmVyc2lvbj03LCBzZW50cnlfa2V5PWEwNGUzM2M4Njc0YzQ1MWY4YTMxMGZiZWMwMjlhY2Y1LCBzZW50cnlfY2xpZW50PWFibHktanMvMC4xXCIsXG5cdFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXG59O1xuXG5kZWZhdWx0cy52ZXJzaW9uICAgICAgICAgID0gJzEuMi4xMyc7XG5kZWZhdWx0cy5hcGlWZXJzaW9uICAgICAgID0gJzEuMic7XG5cbnZhciBhZ2VudCA9ICdhYmx5LWpzLycgKyBkZWZhdWx0cy52ZXJzaW9uO1xuaWYgKHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uYWdlbnQpIHtcblx0YWdlbnQgKz0gJyAnICsgcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5hZ2VudDtcbn0gXG5kZWZhdWx0cy5hZ2VudCA9IGFnZW50O1xuXG5kZWZhdWx0cy5nZXRIb3N0ID0gZnVuY3Rpb24ob3B0aW9ucywgaG9zdCwgd3MpIHtcblx0aWYod3MpXG5cdFx0aG9zdCA9ICgoaG9zdCA9PSBvcHRpb25zLnJlc3RIb3N0KSAmJiBvcHRpb25zLnJlYWx0aW1lSG9zdCkgfHwgaG9zdCB8fCBvcHRpb25zLnJlYWx0aW1lSG9zdDtcblx0ZWxzZVxuXHRcdGhvc3QgPSBob3N0IHx8IG9wdGlvbnMucmVzdEhvc3Q7XG5cblx0cmV0dXJuIGhvc3Q7XG59O1xuXG5kZWZhdWx0cy5nZXRQb3J0ID0gZnVuY3Rpb24ob3B0aW9ucywgdGxzKSB7XG5cdHJldHVybiAodGxzIHx8IG9wdGlvbnMudGxzKSA/IG9wdGlvbnMudGxzUG9ydCA6IG9wdGlvbnMucG9ydDtcbn07XG5cbmRlZmF1bHRzLmdldEh0dHBTY2hlbWUgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHJldHVybiBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG59O1xuXG4vLyBjb25zdHJ1Y3QgZW52aXJvbm1lbnQgZmFsbGJhY2sgaG9zdHMgYXMgcGVyIFJTQzE1aVxuZGVmYXVsdHMuZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzID0gZnVuY3Rpb24oZW52aXJvbm1lbnQpIHtcblx0cmV0dXJuIFtcblx0XHRlbnZpcm9ubWVudCArICctYS1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWItZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuXHRcdGVudmlyb25tZW50ICsgJy1jLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcblx0XHRlbnZpcm9ubWVudCArICctZC1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWUtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nXG5cdF07XG59O1xuXG5kZWZhdWx0cy5nZXRGYWxsYmFja0hvc3RzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHR2YXIgZmFsbGJhY2tIb3N0cyA9IG9wdGlvbnMuZmFsbGJhY2tIb3N0cyxcblx0XHRodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZihvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50IDogZGVmYXVsdHMuaHR0cE1heFJldHJ5Q291bnQ7XG5cblx0cmV0dXJuIGZhbGxiYWNrSG9zdHMgPyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJDaG9vc2VOKGZhbGxiYWNrSG9zdHMsIGh0dHBNYXhSZXRyeUNvdW50KSA6IFtdO1xufTtcblxuZGVmYXVsdHMuZ2V0SG9zdHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdHJldHVybiBbb3B0aW9ucy5yZXN0SG9zdF0uY29uY2F0KGRlZmF1bHRzLmdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykpO1xufTtcblxuZnVuY3Rpb24gY2hlY2tIb3N0KGhvc3QpIHtcblx0aWYodHlwZW9mIGhvc3QgIT09ICdzdHJpbmcnKSB7XG5cdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnaG9zdCBtdXN0IGJlIGEgc3RyaW5nOyB3YXMgYSAnICsgdHlwZW9mIGhvc3QsIDQwMDAwLCA0MDApO1xuXHR9O1xuXHRpZighaG9zdC5sZW5ndGgpIHtcblx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdob3N0IG11c3Qgbm90IGJlIHplcm8tbGVuZ3RoJywgNDAwMDAsIDQwMCk7XG5cdH07XG59XG5cbmRlZmF1bHRzLm9iamVjdGlmeU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdGlmKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG5cdFx0cmV0dXJuIChvcHRpb25zLmluZGV4T2YoJzonKSA9PSAtMSkgPyB7dG9rZW46IG9wdGlvbnN9IDoge2tleTogb3B0aW9uc307XG5cdH1cblx0cmV0dXJuIG9wdGlvbnM7XG59O1xuXG5kZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHQvKiBEZXByZWNhdGVkIG9wdGlvbnMgKi9cblx0aWYob3B0aW9ucy5ob3N0KSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ2hvc3QnLCAncmVzdEhvc3QnKTtcblx0XHRvcHRpb25zLnJlc3RIb3N0ID0gb3B0aW9ucy5ob3N0O1xuXHR9XG5cdGlmKG9wdGlvbnMud3NIb3N0KSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3dzSG9zdCcsICdyZWFsdGltZUhvc3QnKTtcblx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMud3NIb3N0O1xuXHR9XG5cdGlmKG9wdGlvbnMucXVldWVFdmVudHMpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgncXVldWVFdmVudHMnLCAncXVldWVNZXNzYWdlcycpO1xuXHRcdG9wdGlvbnMucXVldWVNZXNzYWdlcyA9IG9wdGlvbnMucXVldWVFdmVudHM7XG5cdH1cblxuXHRpZihvcHRpb25zLmZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0KSB7XG5cdFx0LyogZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgYW5kIGZhbGxiYWNrSG9zdHMgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBhcyBwZXIgVE8zazcgKi9cblx0XHRpZihvcHRpb25zLmZhbGxiYWNrSG9zdHMpIHtcblx0XHRcdHZhciBtc2cgPSAnZmFsbGJhY2tIb3N0cyBhbmQgZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgY2Fubm90IGJvdGggYmUgc2V0Jztcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCBtc2cpO1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMDAwLCA0MDApO1xuXHRcdH1cblxuXHRcdC8qIGRlZmF1bHQgZmFsbGJhY2tzIGNhbid0IGJlIHVzZWQgd2l0aCBjdXN0b20gcG9ydHMgKi9cblx0XHRpZihvcHRpb25zLnBvcnQgfHwgb3B0aW9ucy50bHNQb3J0KSB7XG5cdFx0XHR2YXIgbXNnID0gJ2ZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGNhbm5vdCBiZSBzZXQgd2hlbiBwb3J0IG9yIHRsc1BvcnQgYXJlIHNldCc7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDAwMCwgNDAwKTtcblx0XHR9XG5cblx0XHQvKiBlbWl0IGFuIGFwcHJvcHJpYXRlIGRlcHJlY2F0aW9uIHdhcm5pbmcgKi9cblx0XHRpZihvcHRpb25zLmVudmlyb25tZW50KSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZFdpdGhNc2coJ2ZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0JywgJ1RoZXJlIGlzIG5vIGxvbmdlciBhIG5lZWQgdG8gc2V0IHRoaXMgd2hlbiB0aGUgZW52aXJvbm1lbnQgb3B0aW9uIGlzIGFsc28gc2V0IHNpbmNlIHRoZSBsaWJyYXJ5IHdpbGwgbm93IGdlbmVyYXRlIHRoZSBjb3JyZWN0IGZhbGxiYWNrIGhvc3RzIHVzaW5nIHRoZSBlbnZpcm9ubWVudCBvcHRpb24uJyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCcsICdmYWxsYmFja0hvc3RzOiBBYmx5LkRlZmF1bHRzLkZBTExCQUNLX0hPU1RTJyk7XG5cdFx0fVxuXG5cdFx0LyogdXNlIHRoZSBkZWZhdWx0IGZhbGxiYWNrIGhvc3RzIGFzIHJlcXVlc3RlZCAqL1xuXHRcdG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IGRlZmF1bHRzLkZBTExCQUNLX0hPU1RTO1xuXHR9XG5cblx0aWYob3B0aW9ucy5yZWNvdmVyID09PSB0cnVlKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3tyZWNvdmVyOiB0cnVlfScsICd7cmVjb3ZlcjogZnVuY3Rpb24obGFzdENvbm5lY3Rpb25EZXRhaWxzLCBjYikgeyBjYih0cnVlKTsgfX0nKTtcblx0XHRvcHRpb25zLnJlY292ZXIgPSBmdW5jdGlvbihsYXN0Q29ubmVjdGlvbkRldGFpbHMsIGNiKSB7IGNiKHRydWUpOyB9O1xuXHR9XG5cblx0aWYodHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ2Nsb3NlT25VbmxvYWQgd2FzIHRydWUgYW5kIGEgc2Vzc2lvbiByZWNvdmVyeSBmdW5jdGlvbiB3YXMgc2V0IC0gdGhlc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gdW5zZXR0aW5nIHRoZSBsYXR0ZXInKTtcblx0XHRvcHRpb25zLnJlY292ZXIgPSBudWxsO1xuXHR9XG5cblx0aWYoISgnY2xvc2VPblVubG9hZCcgaW4gb3B0aW9ucykpIHtcblx0XHQvKiBIYXZlIGNsb3NlT25VbmxvYWQgZGVmYXVsdCB0byB0cnVlIHVubGVzcyB3ZSBoYXZlIGFueSBpbmRpY2F0aW9uIHRoYXRcblx0XHQgKiB0aGUgdXNlciBtYXkgd2FudCB0byByZWNvdmVyIHRoZSBjb25uZWN0aW9uICovXG5cdFx0b3B0aW9ucy5jbG9zZU9uVW5sb2FkID0gIW9wdGlvbnMucmVjb3Zlcjtcblx0fVxuXG5cdGlmKG9wdGlvbnMudHJhbnNwb3J0cyAmJiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihvcHRpb25zLnRyYW5zcG9ydHMsICd4aHInKSkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCd0cmFuc3BvcnRzOiBbXCJ4aHJcIl0nLCAndHJhbnNwb3J0czogW1wieGhyX3N0cmVhbWluZ1wiXScpO1xuXHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckRlbGV0ZVZhbHVlKG9wdGlvbnMudHJhbnNwb3J0cywgJ3hocicpO1xuXHRcdG9wdGlvbnMudHJhbnNwb3J0cy5wdXNoKCd4aHJfc3RyZWFtaW5nJyk7XG5cdH1cblxuXHRpZighKCdxdWV1ZU1lc3NhZ2VzJyBpbiBvcHRpb25zKSlcblx0XHRvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuXG5cdC8qIGluZmVyIGhvc3RzIGFuZCBmYWxsYmFja3MgYmFzZWQgb24gdGhlIGNvbmZpZ3VyZWQgZW52aXJvbm1lbnQgKi9cblx0dmFyIGVudmlyb25tZW50ID0gKG9wdGlvbnMuZW52aXJvbm1lbnQgJiYgU3RyaW5nKG9wdGlvbnMuZW52aXJvbm1lbnQpLnRvTG93ZXJDYXNlKCkpIHx8IGRlZmF1bHRzLkVOVklST05NRU5UO1xuXHR2YXIgcHJvZHVjdGlvbiA9ICFlbnZpcm9ubWVudCB8fCAoZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJyk7XG5cblx0aWYoIW9wdGlvbnMuZmFsbGJhY2tIb3N0cyAmJiAhb3B0aW9ucy5yZXN0SG9zdCAmJiAhb3B0aW9ucy5yZWFsdGltZUhvc3QgJiYgIW9wdGlvbnMucG9ydCAmJiAhb3B0aW9ucy50bHNQb3J0KSB7XG5cdFx0b3B0aW9ucy5mYWxsYmFja0hvc3RzID0gcHJvZHVjdGlvbiA/IGRlZmF1bHRzLkZBTExCQUNLX0hPU1RTIDogZGVmYXVsdHMuZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KTtcblx0fVxuXG5cdGlmKCFvcHRpb25zLnJlYWx0aW1lSG9zdCkge1xuXHRcdC8qIHByZWZlciBzZXR0aW5nIHJlYWx0aW1lSG9zdCB0byByZXN0SG9zdCBhcyBhIGN1c3RvbSByZXN0SG9zdCB0eXBpY2FsbHkgaW5kaWNhdGVzXG5cdFx0ICogYSBkZXZlbG9wbWVudCBlbnZpcm9ubWVudCBpcyBiZWluZyB1c2VkIHRoYXQgY2FuJ3QgYmUgaW5mZXJyZWQgYnkgdGhlIGxpYnJhcnkgKi9cblx0XHRpZihvcHRpb25zLnJlc3RIb3N0KSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfV0FSTiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAncmVzdEhvc3QgaXMgc2V0IHRvIFwiJyArIG9wdGlvbnMucmVzdEhvc3QgKyAnXCIgYnV0IHJlYWx0aW1lSG9zdCBpcyBub3Qgc2V0LCBzbyBzZXR0aW5nIHJlYWx0aW1lSG9zdCB0byBcIicgKyBvcHRpb25zLnJlc3RIb3N0ICsgJ1wiIHRvby4gSWYgdGhpcyBpcyBub3Qgd2hhdCB5b3Ugd2FudCwgcGxlYXNlIHNldCByZWFsdGltZUhvc3QgZXhwbGljaXRseS4nKTtcblx0XHRcdG9wdGlvbnMucmVhbHRpbWVIb3N0ID0gb3B0aW9ucy5yZXN0SG9zdFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IHByb2R1Y3Rpb24gPyBkZWZhdWx0cy5SRUFMVElNRV9IT1NUIDogZW52aXJvbm1lbnQgKyAnLScgKyBkZWZhdWx0cy5SRUFMVElNRV9IT1NUO1xuXHRcdH1cblx0fVxuXG5cdGlmKCFvcHRpb25zLnJlc3RIb3N0KSB7XG5cdFx0b3B0aW9ucy5yZXN0SG9zdCA9IHByb2R1Y3Rpb24gPyBkZWZhdWx0cy5SRVNUX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIGRlZmF1bHRzLlJFU1RfSE9TVDtcblx0fVxuXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goKG9wdGlvbnMuZmFsbGJhY2tIb3N0cyB8fCBbXSkuY29uY2F0KG9wdGlvbnMucmVzdEhvc3QsIG9wdGlvbnMucmVhbHRpbWVIb3N0KSwgY2hlY2tIb3N0KTtcblxuXHRvcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQgfHwgZGVmYXVsdHMuUE9SVDtcblx0b3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IGRlZmF1bHRzLlRMU19QT1JUO1xuXHRvcHRpb25zLm1heE1lc3NhZ2VTaXplID0gb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSB8fCBkZWZhdWx0cy5tYXhNZXNzYWdlU2l6ZTtcblx0aWYoISgndGxzJyBpbiBvcHRpb25zKSkgb3B0aW9ucy50bHMgPSB0cnVlO1xuXG5cdC8qIEFsbG93IHZhbHVlcyBwYXNzZWQgaW4gb3B0aW9ucyB0byBvdmVycmlkZSBkZWZhdWx0IHRpbWVvdXRzICovXG5cdG9wdGlvbnMudGltZW91dHMgPSB7fTtcblx0Zm9yKHZhciBwcm9wIGluIGRlZmF1bHRzLlRJTUVPVVRTKSB7XG5cdFx0b3B0aW9ucy50aW1lb3V0c1twcm9wXSA9IG9wdGlvbnNbcHJvcF0gfHwgZGVmYXVsdHMuVElNRU9VVFNbcHJvcF07XG5cdH07XG5cblx0aWYoJ3VzZUJpbmFyeVByb3RvY29sJyBpbiBvcHRpb25zKSB7XG5cdFx0b3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNCaW5hcnkgJiYgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbDtcblx0fSBlbHNlIHtcblx0XHRvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5wcmVmZXJCaW5hcnk7XG5cdH1cblxuXHRpZihvcHRpb25zLmNsaWVudElkKSB7XG5cdFx0dmFyIGhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge307XG5cdFx0aGVhZGVyc1snWC1BYmx5LUNsaWVudElkJ10gPSBidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5iYXNlNjRFbmNvZGUoYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udXRmOEVuY29kZShvcHRpb25zLmNsaWVudElkKSk7XG5cdH1cblxuXHRpZighKCdpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcnIGluIG9wdGlvbnMpKSB7XG5cdFx0b3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSB0cnVlO1xuXHR9XG5cblx0aWYob3B0aW9ucy5wcm9taXNlcyAmJiAhcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5Qcm9taXNlKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICd7cHJvbWlzZXM6IHRydWV9IHdhcyBzcGVjaWZpZWQsIGJ1dCBubyBQcm9taXNlIGNvbnN0cnVjdG9yIGZvdW5kOyBkaXNhYmxpbmcgcHJvbWlzZXMnKTtcblx0XHRvcHRpb25zLnByb21pc2VzID0gZmFsc2U7XG5cdH1cblxuICAgICAgICBpZihvcHRpb25zLmFnZW50cykge1xuICAgICAgICAgIGZvcih2YXIga2V5IGluIG9wdGlvbnMuYWdlbnRzKSB7XG4gICAgICAgICAgICBkZWZhdWx0cy5hZ2VudCArPSAnICcgKyBrZXkgKyAnLycgKyBvcHRpb25zLmFnZW50c1trZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG5cdHJldHVybiBvcHRpb25zO1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXRpbF9kZWZhdWx0cyA9IF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGRlZmF1bHRzKTtcblxuXG4vKioqLyB9KSxcbi8qIDUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cblxuXG5cblxuXG52YXIgQnVmZmVyVXRpbHMgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBBcnJheUJ1ZmZlciA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uQXJyYXlCdWZmZXI7XG5cdHZhciBhdG9iID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hdG9iO1xuXHR2YXIgVGV4dEVuY29kZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRleHRFbmNvZGVyO1xuXHR2YXIgVGV4dERlY29kZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRleHREZWNvZGVyO1xuXHR2YXIgYmFzZTY0Q2hhclNldCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJztcblx0dmFyIGhleENoYXJTZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZic7XG5cblx0ZnVuY3Rpb24gaXNXb3JkQXJyYXkob2IpIHsgcmV0dXJuIG9iICE9PSBudWxsICYmIG9iICE9PSB1bmRlZmluZWQgJiYgb2Iuc2lnQnl0ZXMgIT09IHVuZGVmaW5lZDsgfVxuXHRmdW5jdGlvbiBpc0FycmF5QnVmZmVyKG9iKSB7IHJldHVybiBvYiAhPT0gbnVsbCAmJiBvYiAhPT0gdW5kZWZpbmVkICYmIG9iLmNvbnN0cnVjdG9yID09PSBBcnJheUJ1ZmZlcjsgfVxuXHRmdW5jdGlvbiBpc1R5cGVkQXJyYXkob2IpIHsgcmV0dXJuIEFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2IpOyB9XG5cblx0Ly8gaHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qb25sZWlnaHRvbi85NTg4NDEvcmF3L2YyMDBlMzBkZmU5NTIxMmMwMTY1Y2NmMWFlMDAwY2E1MWU5ZGU4MDMvZ2lzdGZpbGUxLmpzXG5cdGZ1bmN0aW9uIHVpbnQ4Vmlld1RvQmFzZTY0KGJ5dGVzKSB7XG5cdFx0dmFyIGJhc2U2NCAgICA9ICcnXG5cdFx0dmFyIGVuY29kaW5ncyA9IGJhc2U2NENoYXJTZXQ7XG5cblx0XHR2YXIgYnl0ZUxlbmd0aCAgICA9IGJ5dGVzLmJ5dGVMZW5ndGhcblx0XHR2YXIgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzXG5cdFx0dmFyIG1haW5MZW5ndGggICAgPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlclxuXG5cdFx0dmFyIGEsIGIsIGMsIGRcblx0XHR2YXIgY2h1bmtcblxuXHRcdC8vIE1haW4gbG9vcCBkZWFscyB3aXRoIGJ5dGVzIGluIGNodW5rcyBvZiAzXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcblx0XHRcdC8vIENvbWJpbmUgdGhlIHRocmVlIGJ5dGVzIGludG8gYSBzaW5nbGUgaW50ZWdlclxuXHRcdFx0Y2h1bmsgPSAoYnl0ZXNbaV0gPDwgMTYpIHwgKGJ5dGVzW2kgKyAxXSA8PCA4KSB8IGJ5dGVzW2kgKyAyXVxuXG5cdFx0XHQvLyBVc2UgYml0bWFza3MgdG8gZXh0cmFjdCA2LWJpdCBzZWdtZW50cyBmcm9tIHRoZSB0cmlwbGV0XG5cdFx0XHRhID0gKGNodW5rICYgMTY1MTUwNzIpID4+IDE4IC8vIDE2NTE1MDcyID0gKDJeNiAtIDEpIDw8IDE4XG5cdFx0XHRiID0gKGNodW5rICYgMjU4MDQ4KSAgID4+IDEyIC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXG5cdFx0XHRjID0gKGNodW5rICYgNDAzMikgICAgID4+ICA2IC8vIDQwMzIgICAgID0gKDJeNiAtIDEpIDw8IDZcblx0XHRcdGQgPSBjaHVuayAmIDYzICAgICAgICAgICAgICAgLy8gNjMgICAgICAgPSAyXjYgLSAxXG5cblx0XHRcdC8vIENvbnZlcnQgdGhlIHJhdyBiaW5hcnkgc2VnbWVudHMgdG8gdGhlIGFwcHJvcHJpYXRlIEFTQ0lJIGVuY29kaW5nXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgZW5jb2RpbmdzW2RdXG5cdFx0fVxuXG5cdFx0Ly8gRGVhbCB3aXRoIHRoZSByZW1haW5pbmcgYnl0ZXMgYW5kIHBhZGRpbmdcblx0XHRpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XG5cdFx0XHRjaHVuayA9IGJ5dGVzW21haW5MZW5ndGhdXG5cblx0XHRcdGEgPSAoY2h1bmsgJiAyNTIpID4+IDIgLy8gMjUyID0gKDJeNiAtIDEpIDw8IDJcblxuXHRcdFx0Ly8gU2V0IHRoZSA0IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdG8gemVyb1xuXHRcdFx0YiA9IChjaHVuayAmIDMpICAgPDwgNCAvLyAzICAgPSAyXjIgLSAxXG5cblx0XHRcdGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyAnPT0nXG5cdFx0fSBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcblx0XHRcdGNodW5rID0gKGJ5dGVzW21haW5MZW5ndGhdIDw8IDgpIHwgYnl0ZXNbbWFpbkxlbmd0aCArIDFdXG5cblx0XHRcdGEgPSAoY2h1bmsgJiA2NDUxMikgPj4gMTAgLy8gNjQ1MTIgPSAoMl42IC0gMSkgPDwgMTBcblx0XHRcdGIgPSAoY2h1bmsgJiAxMDA4KSAgPj4gIDQgLy8gMTAwOCAgPSAoMl42IC0gMSkgPDwgNFxuXG5cdFx0XHQvLyBTZXQgdGhlIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXG5cdFx0XHRjID0gKGNodW5rICYgMTUpICAgIDw8ICAyIC8vIDE1ICAgID0gMl40IC0gMVxuXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJhc2U2NFxuXHR9XG5cblx0ZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQpIHtcblx0XHR2YXIgYmluYXJ5X3N0cmluZyA9ICBhdG9iKGJhc2U2NCk7XG5cdFx0dmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuXHRcdHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KCBsZW4gKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSAgICAgICAge1xuXHRcdFx0dmFyIGFzY2lpID0gYmluYXJ5X3N0cmluZy5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0Ynl0ZXNbaV0gPSBhc2NpaTtcblx0XHR9XG5cdFx0cmV0dXJuIGJ5dGVzLmJ1ZmZlcjtcblx0fVxuXG5cdC8qIE1vc3QgQnVmZmVyVXRpbHMgbWV0aG9kcyB0aGF0IHJldHVybiBhIGJpbmFyeSBvYmplY3QgcmV0dXJuIGFuIEFycmF5QnVmZmVyXG5cdCAqIGlmIHN1cHBvcnRlZCwgZWxzZSBhIENyeXB0b0pTIFdvcmRBcnJheS4gVGhlIGV4Y2VwdGlvbiBpcyB0b0J1ZmZlciwgd2hpY2hcblx0ICogcmV0dXJucyBhIFVpbnQ4QXJyYXkgKGFuZCB3b24ndCB3b3JrIG9uIGJyb3dzZXJzIHRvbyBvbGQgdG8gc3VwcG9ydCBpdCkgKi9cblx0ZnVuY3Rpb24gQnVmZmVyVXRpbHMoKSB7fVxuXG5cdEJ1ZmZlclV0aWxzLmJhc2U2NENoYXJTZXQgPSBiYXNlNjRDaGFyU2V0O1xuXHRCdWZmZXJVdGlscy5oZXhDaGFyU2V0ID0gaGV4Q2hhclNldDtcblxuXHR2YXIgaXNCdWZmZXIgPSBCdWZmZXJVdGlscy5pc0J1ZmZlciA9IGZ1bmN0aW9uKGJ1ZikgeyByZXR1cm4gaXNBcnJheUJ1ZmZlcihidWYpIHx8IGlzV29yZEFycmF5KGJ1ZikgfHwgaXNUeXBlZEFycmF5KGJ1Zik7IH07XG5cblx0LyogSW4gYnJvd3NlcnMsIHJldHVybnMgYSBVaW50OEFycmF5ICovXG5cdHZhciB0b0J1ZmZlciA9IEJ1ZmZlclV0aWxzLnRvQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoIUFycmF5QnVmZmVyKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRvIEJ1ZmZlcjogYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBuZWNlc3NhcnkgdHlwZXNcIik7XG5cdFx0fVxuXG5cdFx0aWYoaXNBcnJheUJ1ZmZlcihidWYpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYnVmKTtcblx0XHR9XG5cblx0XHRpZihpc1R5cGVkQXJyYXkoYnVmKSkge1xuXHRcdFx0cmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1Zi5idWZmZXIpO1xuXHRcdH1cblxuXHRcdGlmKGlzV29yZEFycmF5KGJ1ZikpIHtcblx0XHRcdC8qIEJhY2twb3J0ZWQgZnJvbSB1bnJlbGVhc2VkIENyeXB0b0pTXG5cdFx0XHQqIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY3J5cHRvLWpzL3NvdXJjZS9icm93c2UvYnJhbmNoZXMvMy54L3NyYy9saWItdHlwZWRhcnJheXMuanM/cj02NjEgKi9cblx0XHRcdHZhciBhcnJheUJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihidWYuc2lnQnl0ZXMpO1xuXHRcdFx0dmFyIHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidWYuc2lnQnl0ZXM7IGkrKykge1xuXHRcdFx0XHR1aW50OFZpZXdbaV0gPSAoYnVmLndvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVpbnQ4Vmlldztcblx0XHR9O1xuXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyVXRpbHMudG9CdWZmZXIgZXhwZWN0ZWQgYW4gYXJyYXlidWZmZXIsIHR5cGVkIGFycmF5LCBvciBDcnlwdG9KUyB3b3JkYXJyYXlcIik7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xuXHRcdGlmKGlzQXJyYXlCdWZmZXIoYnVmKSkge1xuXHRcdFx0cmV0dXJuIGJ1Zjtcblx0XHR9XG5cdFx0cmV0dXJuIHRvQnVmZmVyKGJ1ZikuYnVmZmVyO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5ID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoaXNUeXBlZEFycmF5KGJ1ZikpIHtcblx0XHRcdGJ1ZiA9IGJ1Zi5idWZmZXI7XG5cdFx0fVxuXHRcdHJldHVybiBpc1dvcmRBcnJheShidWYpID8gYnVmIDogY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5jcmVhdGUoYnVmKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZihpc1dvcmRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJzdHJpbmdpZnlcIl0pKGJ1Zik7XG5cdFx0fVxuXHRcdHJldHVybiB1aW50OFZpZXdUb0Jhc2U2NCh0b0J1ZmZlcihidWYpKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5iYXNlNjREZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcblx0XHRpZihBcnJheUJ1ZmZlciAmJiBhdG9iKSB7XG5cdFx0XHRyZXR1cm4gYmFzZTY0VG9BcnJheUJ1ZmZlcihzdHIpO1xuXHRcdH1cblx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXCJwYXJzZVwiXSkoc3RyKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5oZXhFbmNvZGUgPSBmdW5jdGlvbihidWYpIHtcblx0XHRidWYgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShidWYpO1xuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInN0cmluZ2lmeVwiXSkoYnVmKTtcblx0fTtcblxuXHRCdWZmZXJVdGlscy5oZXhEZWNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHR2YXIgd29yZEFycmF5ID0gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXCJwYXJzZVwiXSkoc3RyaW5nKTtcblx0XHRyZXR1cm4gQXJyYXlCdWZmZXIgPyBCdWZmZXJVdGlscy50b0FycmF5QnVmZmVyKHdvcmRBcnJheSkgOiB3b3JkQXJyYXk7XG5cdH07XG5cblx0QnVmZmVyVXRpbHMudXRmOEVuY29kZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdGlmKFRleHRFbmNvZGVyKSB7XG5cdFx0XHRyZXR1cm4gKG5ldyBUZXh0RW5jb2RlcigpKS5lbmNvZGUoc3RyaW5nKS5idWZmZXI7XG5cdFx0fVxuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVwiXSkoc3RyaW5nKTtcblx0fTtcblxuXHQvKiBGb3IgdXRmOCBkZWNvZGluZyB3ZSBhcHBseSBzbGlnaHRseSBzdHJpY3RlciBpbnB1dCB2YWxpZGF0aW9uIHRoYW4gdG9cblx0ICogaGV4RW5jb2RlL2Jhc2U2NEVuY29kZS9ldGM6IGluIHRob3NlIHdlIGFjY2VwdCBhbnl0aGluZyB0aGF0IEJ1ZmZlci5mcm9tXG5cdCAqIGNhbiB0YWtlIChpbiBwYXJ0aWN1bGFyIGFsbG93aW5nIHN0cmluZ3MsIHdoaWNoIGFyZSBqdXN0IGludGVycHJldGVkIGFzXG5cdCAqIGJpbmFyeSk7IGhlcmUgd2UgZW5zdXJlIHRoYXQgdGhlIGlucHV0IGlzIGFjdHVhbGx5IGEgYnVmZmVyIHNpbmNlIHRyeWluZ1xuXHQgKiB0byB1dGY4LWRlY29kZSBhIHN0cmluZyB0byBhbm90aGVyIHN0cmluZyBpcyBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSAqL1xuXHRCdWZmZXJVdGlscy51dGY4RGVjb2RlID0gZnVuY3Rpb24oYnVmKSB7XG5cdFx0aWYoIWlzQnVmZmVyKGJ1ZikpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIHV0ZjhkZWNvZGUgdG8gYmUgYW4gYXJyYXlidWZmZXIsIHR5cGVkIGFycmF5LCBvciBDcnlwdG9KUyB3b3JkYXJyYXlcIik7XG5cdFx0fVxuXHRcdGlmKFRleHREZWNvZGVyICYmICFpc1dvcmRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gKG5ldyBUZXh0RGVjb2RlcigpKS5kZWNvZGUoYnVmKTtcblx0XHR9XG5cdFx0YnVmID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmKTtcblx0XHRyZXR1cm4gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfdXRmOF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1wic3RyaW5naWZ5XCJdKShidWYpO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmJ1ZmZlckNvbXBhcmUgPSBmdW5jdGlvbihidWYxLCBidWYyKSB7XG5cdFx0aWYoIWJ1ZjEpIHJldHVybiAtMTtcblx0XHRpZighYnVmMikgcmV0dXJuIDE7XG5cdFx0YnVmMSA9IEJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KGJ1ZjEpO1xuXHRcdGJ1ZjIgPSBCdWZmZXJVdGlscy50b1dvcmRBcnJheShidWYyKTtcblx0XHRidWYxLmNsYW1wKCk7IGJ1ZjIuY2xhbXAoKTtcblxuXHRcdHZhciBjbXAgPSBidWYxLnNpZ0J5dGVzIC0gYnVmMi5zaWdCeXRlcztcblx0XHRpZihjbXAgIT0gMCkgcmV0dXJuIGNtcDtcblx0XHRidWYxID0gYnVmMS53b3JkczsgYnVmMiA9IGJ1ZjIud29yZHM7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJ1ZjEubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNtcCA9IGJ1ZjFbaV0gLSBidWYyW2ldO1xuXHRcdFx0aWYoY21wICE9IDApIHJldHVybiBjbXA7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9O1xuXG5cdEJ1ZmZlclV0aWxzLmJ5dGVMZW5ndGggPSBmdW5jdGlvbihidWYpIHtcblx0XHRpZihpc0FycmF5QnVmZmVyKGJ1ZikgfHwgaXNUeXBlZEFycmF5KGJ1ZikpIHtcblx0XHRcdHJldHVybiBidWYuYnl0ZUxlbmd0aFxuXHRcdH0gZWxzZSBpZihpc1dvcmRBcnJheShidWYpKSB7XG5cdFx0XHRyZXR1cm4gYnVmLnNpZ0J5dGVzO1xuXHRcdH1cblx0fTtcblxuXHQvKiBSZXR1cm5zIEFycmF5QnVmZmVyIG9uIGJyb3dzZXIgYW5kIEJ1ZmZlciBvbiBOb2RlLmpzICovXG5cdEJ1ZmZlclV0aWxzLnR5cGVkQXJyYXlUb0J1ZmZlciA9IGZ1bmN0aW9uKHR5cGVkQXJyYXkpIHtcblx0XHRyZXR1cm4gdHlwZWRBcnJheS5idWZmZXI7XG5cdH07XG5cblx0cmV0dXJuIEJ1ZmZlclV0aWxzO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChCdWZmZXJVdGlscyk7XG5cblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuXG5cbnZhciBIdHRwID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0ZnVuY3Rpb24gSHR0cCgpIHt9XG5cblx0dmFyIG5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuXHRcdC8qIElFIDggKi9cblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cdH07XG5cblx0ZnVuY3Rpb24gc2hvdWxkRmFsbGJhY2soZXJyKSB7XG5cdFx0dmFyIHN0YXR1c0NvZGUgPSBlcnIuc3RhdHVzQ29kZTtcblx0XHQvKiA0MDAgKyBubyBjb2RlID0gYSBnZW5lcmljIHhociBvbmVycm9yLiBCcm93c2VyIGRvZXNuJ3QgZ2l2ZSB1cyBlbm91Z2hcblx0XHQgKiBkZXRhaWwgdG8ga25vdyB3aGV0aGVyIGl0J3MgZmFsbGJhY2stZml4YWJsZSwgYnV0IGl0IG1heSBiZSAoZWcgaWYgYVxuXHRcdCAqIG5ldHdvcmsgaXNzdWUpLCBzbyB0cnkganVzdCBpbiBjYXNlICovXG5cdFx0cmV0dXJuIChzdGF0dXNDb2RlID09PSA0MDggJiYgIWVyci5jb2RlKSB8fFxuXHRcdFx0KHN0YXR1c0NvZGUgPT09IDQwMCAmJiAhZXJyLmNvZGUpICAgICAgfHxcblx0XHRcdChzdGF0dXNDb2RlID49IDUwMCAmJiBzdGF0dXNDb2RlIDw9IDUwNCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRIb3N0cyhjbGllbnQpIHtcblx0XHQvKiBJZiB3ZSdyZSBhIGNvbm5lY3RlZCByZWFsdGltZSBjbGllbnQsIHRyeSB0aGUgZW5kcG9pbnQgd2UncmUgY29ubmVjdGVkXG5cdFx0ICogdG8gZmlyc3QgLS0gYnV0IHN0aWxsIGhhdmUgZmFsbGJhY2tzLCBiZWluZyBjb25uZWN0ZWQgaXMgbm90IGFuIGFic29sdXRlXG5cdFx0ICogZ3VhcmFudGVlIHRoYXQgYSBkYXRhY2VudGVyIGhhcyBmcmVlIGNhcGFjaXR5IHRvIHNlcnZpY2UgUkVTVCByZXF1ZXN0cy4gKi9cblx0XHR2YXIgY29ubmVjdGlvbiA9IGNsaWVudC5jb25uZWN0aW9uLFxuXHRcdFx0Y29ubmVjdGlvbkhvc3QgPSBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuaG9zdDtcblxuXHRcdGlmKGNvbm5lY3Rpb25Ib3N0KSB7XG5cdFx0XHRyZXR1cm4gW2Nvbm5lY3Rpb25Ib3N0XS5jb25jYXQoX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEZhbGxiYWNrSG9zdHMoY2xpZW50Lm9wdGlvbnMpKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3RzKGNsaWVudC5vcHRpb25zKTtcblx0fVxuXHRIdHRwLl9nZXRIb3N0cyA9IGdldEhvc3RzO1xuXG5cdEh0dHAubWV0aG9kcyA9IFsnZ2V0JywgJ2RlbGV0ZScsICdwb3N0JywgJ3B1dCcsICdwYXRjaCddO1xuXHRIdHRwLm1ldGhvZHNXaXRob3V0Qm9keSA9IFsnZ2V0JywgJ2RlbGV0ZSddO1xuXHRIdHRwLm1ldGhvZHNXaXRoQm9keSA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJTdWJ0cmFjdChIdHRwLm1ldGhvZHMsIEh0dHAubWV0aG9kc1dpdGhvdXRCb2R5KTtcblxuXHQvKiAtIEh0dHAuZ2V0LCBIdHRwLnBvc3QsIEh0dHAucHV0LCAuLi5cblx0ICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gcGF0aCBhZ2FpbnN0IHByaW1lIGFuZCBmYWxsYmFjayBBYmx5IGhvc3RzXG5cdCAqIEBwYXJhbSByZXN0XG5cdCAqIEBwYXJhbSBwYXRoIHRoZSBmdWxsIHBhdGhcblx0ICogQHBhcmFtIGhlYWRlcnMgb3B0aW9uYWwgaGFzaCBvZiBoZWFkZXJzXG5cdCAqIFtvbmx5IGZvciBtZXRob2RzIHdpdGggYm9keTogQHBhcmFtIGJvZHkgb2JqZWN0IG9yIGJ1ZmZlciBjb250YWluaW5nIHJlcXVlc3QgYm9keV1cblx0ICogQHBhcmFtIHBhcmFtcyBvcHRpb25hbCBoYXNoIG9mIHBhcmFtc1xuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgcmVzcG9uc2UpXG5cdCAqXG5cdCAqIC0gSHR0cC5nZXRVcmksIEh0dHAucG9zdFVyaSwgSHR0cC5wdXRVcmksIC4uLlxuXHQgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBmb3IgYSBnaXZlbiBmdWxsIFVSSVxuXHQgKiBAcGFyYW0gcmVzdFxuXHQgKiBAcGFyYW0gdXJpIHRoZSBmdWxsIFVSSVxuXHQgKiBAcGFyYW0gaGVhZGVycyBvcHRpb25hbCBoYXNoIG9mIGhlYWRlcnNcblx0ICogW29ubHkgZm9yIG1ldGhvZHMgd2l0aCBib2R5OiBAcGFyYW0gYm9keSBvYmplY3Qgb3IgYnVmZmVyIGNvbnRhaW5pbmcgcmVxdWVzdCBib2R5XVxuXHQgKiBAcGFyYW0gcGFyYW1zIG9wdGlvbmFsIGhhc2ggb2YgcGFyYW1zXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCByZXNwb25zZSlcblx0ICovXG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKEh0dHAubWV0aG9kc1dpdGhvdXRCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcblx0XHRIdHRwW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRIdHRwWydkbyddKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgbnVsbCwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0XHRIdHRwW21ldGhvZCArICdVcmknXSA9IGZ1bmN0aW9uKHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0SHR0cC5kb1VyaShtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgbnVsbCwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0fSk7XG5cblx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goSHR0cC5tZXRob2RzV2l0aEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdEh0dHBbbWV0aG9kXSA9IGZ1bmN0aW9uKHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRcdEh0dHBbJ2RvJ10obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHRcdEh0dHBbbWV0aG9kICsgJ1VyaSddID0gZnVuY3Rpb24ocmVzdCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRIdHRwLmRvVXJpKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKTtcblx0XHR9O1xuXHR9KTtcblxuXHQvKiBVbmxpa2UgZm9yIGRvVXJpLCB0aGUgJ3Jlc3QnIHBhcmFtIGhlcmUgaXMgbWFuZGF0b3J5LCBhcyBpdCdzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGhvc3RzICovXG5cdEh0dHBbJ2RvJ10gPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cdFx0dmFyIHVyaUZyb21Ib3N0ID0gKHR5cGVvZihwYXRoKSA9PSAnZnVuY3Rpb24nKSA/IHBhdGggOiBmdW5jdGlvbihob3N0KSB7IHJldHVybiByZXN0LmJhc2VVcmkoaG9zdCkgKyBwYXRoOyB9O1xuXHRcdHZhciBiaW5hcnkgPSAoaGVhZGVycyAmJiBoZWFkZXJzLmFjY2VwdCAhPSAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdHZhciBkb0FyZ3MgPSBhcmd1bWVudHM7XG5cblx0XHR2YXIgY3VycmVudEZhbGxiYWNrID0gcmVzdC5fY3VycmVudEZhbGxiYWNrO1xuXHRcdGlmKGN1cnJlbnRGYWxsYmFjaykge1xuXHRcdFx0aWYoY3VycmVudEZhbGxiYWNrLnZhbGlkVW50aWwgPiBub3coKSkge1xuXHRcdFx0XHQvKiBVc2Ugc3RvcmVkIGZhbGxiYWNrICovXG5cdFx0XHRcdEh0dHAuUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGN1cnJlbnRGYWxsYmFjay5ob3N0KSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRpZihlcnIgJiYgc2hvdWxkRmFsbGJhY2soZXJyKSkge1xuXHRcdFx0XHRcdFx0LyogdW5zdG9yZSB0aGUgZmFsbGJhY2sgYW5kIHN0YXJ0IGZyb20gdGhlIHRvcCB3aXRoIHRoZSBkZWZhdWx0IHNlcXVlbmNlICovXG5cdFx0XHRcdFx0XHRyZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0SHR0cFsnZG8nXS5hcHBseShIdHRwLCBkb0FyZ3MpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogRmFsbGJhY2sgZXhwaXJlZDsgcmVtb3ZlIGl0IGFuZCBmYWxsdGhyb3VnaCB0byBub3JtYWwgc2VxdWVuY2UgKi9cblx0XHRcdFx0cmVzdC5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgaG9zdHMgPSBnZXRIb3N0cyhyZXN0KTtcblxuXHRcdC8qIGlmIHRoZXJlIGlzIG9ubHkgb25lIGhvc3QgZG8gaXQgKi9cblx0XHRpZihob3N0cy5sZW5ndGggPT0gMSkge1xuXHRcdFx0SHR0cC5kb1VyaShtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGhvc3RzWzBdKSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogaG9zdHMgaXMgYW4gYXJyYXkgd2l0aCBwcmVmZXJyZWQgaG9zdCBwbHVzIGF0IGxlYXN0IG9uZSBmYWxsYmFjayAqL1xuXHRcdHZhciB0cnlBSG9zdCA9IGZ1bmN0aW9uKGNhbmRpZGF0ZUhvc3RzLCBwZXJzaXN0T25TdWNjZXNzKSB7XG5cdFx0XHR2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG5cdFx0XHRIdHRwLmRvVXJpKG1ldGhvZCwgcmVzdCwgdXJpRnJvbUhvc3QoaG9zdCksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGlmKGVyciAmJiBzaG91bGRGYWxsYmFjayhlcnIpICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuXHRcdFx0XHRcdHRyeUFIb3N0KGNhbmRpZGF0ZUhvc3RzLCB0cnVlKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYocGVyc2lzdE9uU3VjY2Vzcykge1xuXHRcdFx0XHRcdC8qIFJTQzE1ZiAqL1xuXHRcdFx0XHRcdHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IHtcblx0XHRcdFx0XHRcdGhvc3Q6IGhvc3QsXG5cdFx0XHRcdFx0XHR2YWxpZFVudGlsOiBub3coKSArIHJlc3Qub3B0aW9ucy50aW1lb3V0cy5mYWxsYmFja1JldHJ5VGltZW91dFxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcblx0XHRcdH0pO1xuXHRcdH07XG5cdFx0dHJ5QUhvc3QoaG9zdHMpO1xuXHR9O1xuXG5cdEh0dHAuZG9VcmkgPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdEh0dHAuUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjayk7XG5cdH07XG5cblx0SHR0cC5zdXBwb3J0c0F1dGhIZWFkZXJzID0gZmFsc2U7XG5cdEh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA9IGZhbHNlO1xuXHRyZXR1cm4gSHR0cDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoSHR0cCk7XG5cblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuXG5cblxuXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uKCkge1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG5cdFx0dGhpcy5hbnkgPSBbXTtcblx0XHR0aGlzLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dGhpcy5hbnlPbmNlID0gW107XG5cdFx0dGhpcy5ldmVudHNPbmNlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0fVxuXG5cdC8qIENhbGwgdGhlIGxpc3RlbmVyLCBjYXRjaCBhbnkgZXhjZXB0aW9ucyBhbmQgbG9nLCBidXQgY29udGludWUgb3BlcmF0aW9uKi9cblx0ZnVuY3Rpb24gY2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpIHtcblx0XHR0cnkge1xuXHRcdFx0bGlzdGVuZXIuYXBwbHkoZXZlbnRUaGlzLCBhcmdzKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0V2ZW50RW1pdHRlci5lbWl0KCknLCAnVW5leHBlY3RlZCBsaXN0ZW5lciBleGNlcHRpb246ICcgKyBlICsgJzsgc3RhY2sgPSAnICsgKGUgJiYgZS5zdGFjaykpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBSZW1vdmUgbGlzdGVuZXJzIHRoYXQgbWF0Y2ggbGlzdGVuZXJcblx0ICogQHBhcmFtIHRhcmdldExpc3RlbmVycyBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBhcnJheXMgb3IgZXZlbnQgb2JqZWN0cyB3aXRoIGFycmF5cyBvZiBsaXN0ZW5lcnNcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciBjYWxsYmFjayB0byByZW1vdmVcblx0ICogQHBhcmFtIGV2ZW50RmlsdGVyIChvcHRpb25hbCkgZXZlbnQgbmFtZSBpbnN0cnVjdGluZyB0aGUgZnVuY3Rpb24gdG8gb25seSByZW1vdmUgbGlzdGVuZXJzIGZvciB0aGUgc3BlY2lmaWVkIGV2ZW50XG5cdCAqL1xuXHRmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcih0YXJnZXRMaXN0ZW5lcnMsIGxpc3RlbmVyLCBldmVudEZpbHRlcikge1xuXHRcdHZhciBsaXN0ZW5lcnMsIGlkeCwgZXZlbnROYW1lLCB0YXJnZXRMaXN0ZW5lcnNJbmRleDtcblxuXHRcdGZvciAodGFyZ2V0TGlzdGVuZXJzSW5kZXggPSAwOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCA8IHRhcmdldExpc3RlbmVycy5sZW5ndGg7IHRhcmdldExpc3RlbmVyc0luZGV4KyspIHtcblx0XHRcdGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG5cdFx0XHRpZiAoZXZlbnRGaWx0ZXIpIHsgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTsgfVxuXG5cdFx0XHRpZiAoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShsaXN0ZW5lcnMpKSB7XG5cdFx0XHRcdHdoaWxlICgoaWR4ID0gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihsaXN0ZW5lcnMsIGxpc3RlbmVyKSkgIT09IC0xKSB7XG5cdFx0XHRcdFx0bGlzdGVuZXJzLnNwbGljZShpZHgsIDEpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIElmIGV2ZW50cyBvYmplY3QgaGFzIGFuIGV2ZW50IG5hbWUga2V5IHdpdGggbm8gbGlzdGVuZXJzIHRoZW5cblx0XHRcdFx0ICAgcmVtb3ZlIHRoZSBrZXkgdG8gc3RvcCB0aGUgbGlzdCBncm93aW5nIGluZGVmaW5pdGVseSAqL1xuXHRcdFx0XHRpZiAoZXZlbnRGaWx0ZXIgJiYgKGxpc3RlbmVycy5sZW5ndGggPT09IDApKSB7XG5cdFx0XHRcdFx0ZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzT2JqZWN0KGxpc3RlbmVycykpIHtcblx0XHRcdFx0LyogZXZlbnRzICovXG5cdFx0XHRcdGZvciAoZXZlbnROYW1lIGluIGxpc3RlbmVycykge1xuXHRcdFx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGxpc3RlbmVycywgZXZlbnROYW1lKSAmJiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGxpc3RlbmVyc1tldmVudE5hbWVdKSkge1xuXHRcdFx0XHRcdFx0cmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXJcblx0ICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b1xuXHQgKiAgICAgICAgaWYgbm90IHN1cHBsaWVkLCBhbGwgZXZlbnRzIHRyaWdnZXIgYSBjYWxsIHRvIHRoZSBsaXN0ZW5lclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGJlIGNhbGxlZFxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2YoZXZlbnQpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuYW55LnB1c2goZXZlbnQpO1xuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSkge1xuXHRcdFx0dGhpcy5hbnkucHVzaChsaXN0ZW5lcik7XG5cdFx0fSBlbHNlIGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkoZXZlbnQpKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKGV2ZW50LCBmdW5jdGlvbihldikge1xuXHRcdFx0XHRzZWxmLm9uKGV2LCBsaXN0ZW5lcik7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c1tldmVudF0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdKSk7XG5cdFx0XHRsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBSZW1vdmUgb25lIG9yIG1vcmUgZXZlbnQgbGlzdGVuZXJzXG5cdCAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCB3aG9zZSBsaXN0ZW5lclxuXHQgKiAgICAgICAgaXMgdG8gYmUgcmVtb3ZlZC4gSWYgbm90IHN1cHBsaWVkLCB0aGUgbGlzdGVuZXIgaXNcblx0ICogICAgICAgIHRyZWF0ZWQgYXMgYW4gJ2FueScgbGlzdGVuZXJcblx0ICogQHBhcmFtIGxpc3RlbmVyIChvcHRpb25hbCkgdGhlIGxpc3RlbmVyIHRvIHJlbW92ZS4gSWYgbm90XG5cdCAqICAgICAgICBzdXBwbGllZCwgYWxsIGxpc3RlbmVycyBhcmUgcmVtb3ZlZC5cblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAwIHx8IChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSAmJiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGxpc3RlbmVyKSkpIHtcblx0XHRcdHRoaXMuYW55ID0gW107XG5cdFx0XHR0aGlzLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHR0aGlzLmFueU9uY2UgPSBbXTtcblx0XHRcdHRoaXMuZXZlbnRzT25jZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xuXHRcdFx0aWYodHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdC8qIHdlIHRha2UgdGhpcyB0byBiZSB0aGUgbGlzdGVuZXIgYW5kIHRyZWF0IHRoZSBldmVudCBhcyBcImFueVwiIC4uICovXG5cdFx0XHRcdGxpc3RlbmVyID0gZXZlbnQ7XG5cdFx0XHRcdGV2ZW50ID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdC8qIC4uLiBvciB3ZSB0YWtlIGV2ZW50IHRvIGJlIHRoZSBhY3R1YWwgZXZlbnQgbmFtZSBhbmQgbGlzdGVuZXIgdG8gYmUgYWxsICovXG5cdFx0fVxuXG5cdFx0aWYobGlzdGVuZXIgJiYgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhldmVudCkpIHtcblx0XHRcdHJlbW92ZUxpc3RlbmVyKFt0aGlzLmFueSwgdGhpcy5ldmVudHMsIHRoaXMuYW55T25jZSwgdGhpcy5ldmVudHNPbmNlXSwgbGlzdGVuZXIpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkoZXZlbnQpKSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKGV2ZW50LCBmdW5jdGlvbihldikge1xuXHRcdFx0XHRzZWxmLm9mZihldiwgbGlzdGVuZXIpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXG5cdFx0LyogXCJub3JtYWxcIiBjYXNlIHdoZXJlIGV2ZW50IGlzIGFuIGFjdHVhbCBldmVudCAqL1xuXHRcdGlmKGxpc3RlbmVyKSB7XG5cdFx0XHRyZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSB0aGlzLmV2ZW50c1tldmVudF07XG5cdFx0XHRkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuXHQgKiBAcGFyYW0gZXZlbnQgKG9wdGlvbmFsKSB0aGUgbmFtZSBvZiB0aGUgZXZlbnQsIG9yIG5vbmUgZm9yICdhbnknXG5cdCAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcblx0ICovXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRpZihldmVudCkge1xuXHRcdFx0dmFyIGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c1tldmVudF0gfHwgW10pO1xuXHRcdFx0aWYodGhpcy5ldmVudHNPbmNlW2V2ZW50XSlcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmV2ZW50c09uY2VbZXZlbnRdKTtcblx0XHRcdHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoID8gbGlzdGVuZXJzIDogbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuYW55Lmxlbmd0aCA/IHRoaXMuYW55IDogbnVsbDtcblx0fTtcblxuXHQvKipcblx0ICogRW1pdCBhbiBldmVudFxuXHQgKiBAcGFyYW0gZXZlbnQgdGhlIGV2ZW50IG5hbWVcblx0ICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuXHQgKi9cblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24oZXZlbnQgIC8qICwgYXJncy4uLiAqLykge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHR2YXIgZXZlbnRUaGlzID0ge2V2ZW50OmV2ZW50fTtcblx0XHR2YXIgbGlzdGVuZXJzID0gW107XG5cblx0XHRpZih0aGlzLmFueU9uY2UubGVuZ3RoKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55T25jZSk7XG5cdFx0XHR0aGlzLmFueU9uY2UgPSBbXTtcblx0XHR9XG5cdFx0aWYodGhpcy5hbnkubGVuZ3RoKSB7XG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcblx0XHR9XG5cdFx0dmFyIGV2ZW50c09uY2VMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuXHRcdGlmKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzT25jZUxpc3RlbmVycyk7XG5cdFx0XHRkZWxldGUgdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcblx0XHR9XG5cdFx0dmFyIGV2ZW50c0xpc3RlbmVycyA9IHRoaXMuZXZlbnRzW2V2ZW50XTtcblx0XHRpZihldmVudHNMaXN0ZW5lcnMpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcblx0XHR9XG5cblx0XHRfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHRcdGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogTGlzdGVuIGZvciBhIHNpbmdsZSBvY2N1cnJlbmNlIG9mIGFuIGV2ZW50XG5cdCAqIEBwYXJhbSBldmVudCB0aGUgbmFtZSBvZiB0aGUgZXZlbnQgdG8gbGlzdGVuIHRvXG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYmUgY2FsbGVkXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcblx0XHR2YXIgYXJnQ291bnQgPSBhcmd1bWVudHMubGVuZ3RoLCBzZWxmID0gdGhpcztcblx0XHRpZigoYXJnQ291bnQgPT09IDAgfHwgKGFyZ0NvdW50ID09PSAxICYmIHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykpICYmIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUHJvbWlzZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuXHRcdFx0XHRzZWxmLm9uY2UoZXZlbnQsIHJlc29sdmUpO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2YoZXZlbnQpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdHRoaXMuYW55T25jZS5wdXNoKGV2ZW50KTtcblx0XHR9IGVsc2UgaWYoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhldmVudCkpIHtcblx0XHRcdHRoaXMuYW55T25jZS5wdXNoKGxpc3RlbmVyKTtcblx0XHR9IGVsc2UgaWYoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShldmVudCkpe1xuXHRcdFx0dmFyIGxpc3RlbmVyV3JhcHBlciA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG5cdFx0XHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goZXZlbnQsIGZ1bmN0aW9uKGV2KSB7XG5cdFx0XHRcdFx0c2VsZi5vZmYoZXYsIGxpc3RlbmVyV3JhcHBlcik7XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcblx0XHRcdH07XG5cdFx0XHRfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKGV2ZW50LCBmdW5jdGlvbihldikge1xuXHRcdFx0XHRzZWxmLm9uKGV2LCBsaXN0ZW5lcldyYXBwZXIpO1xuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSAodGhpcy5ldmVudHNPbmNlW2V2ZW50XSB8fCAodGhpcy5ldmVudHNPbmNlW2V2ZW50XSA9IFtdKSk7XG5cdFx0XHRsaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBQcml2YXRlIEFQSVxuXHQgKlxuXHQgKiBMaXN0ZW4gZm9yIGEgc2luZ2xlIG9jY3VycmVuY2Ugb2YgYSBzdGF0ZSBldmVudCBhbmQgZmlyZSBpbW1lZGlhdGVseSBpZiBjdXJyZW50U3RhdGUgbWF0Y2hlcyB0YXJnZXRTdGF0ZVxuXHQgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGV2ZW50IHRvIGxpc3RlbiB0b1xuXHQgKiBAcGFyYW0gY3VycmVudFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb2JqZWN0XG5cdCAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgdG8gYmUgY2FsbGVkXG5cdCAqL1xuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLndoZW5TdGF0ZSA9IGZ1bmN0aW9uKHRhcmdldFN0YXRlLCBjdXJyZW50U3RhdGUsIGxpc3RlbmVyIC8qIC4uLmxpc3RlbmVyQXJncyAqLykge1xuXHRcdHZhciBldmVudFRoaXMgPSB7ZXZlbnQ6dGFyZ2V0U3RhdGV9LFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRsaXN0ZW5lckFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDMpO1xuXG5cdFx0aWYoKHR5cGVvZih0YXJnZXRTdGF0ZSkgIT09ICdzdHJpbmcnKSB8fCAodHlwZW9mKGN1cnJlbnRTdGF0ZSkgIT09ICdzdHJpbmcnKSkge1xuXHRcdFx0dGhyb3coXCJ3aGVuU3RhdGUgcmVxdWlyZXMgYSB2YWxpZCBldmVudCBTdHJpbmcgYXJndW1lbnRcIik7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJyAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlByb21pc2UpIHtcblx0XHRcdHJldHVybiBuZXcgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5Qcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcblx0XHRcdFx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUuYXBwbHkoc2VsZiwgW3RhcmdldFN0YXRlLCBjdXJyZW50U3RhdGUsIHJlc29sdmVdLmNvbmNhdChsaXN0ZW5lckFyZ3MpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0XHRpZih0YXJnZXRTdGF0ZSA9PT0gY3VycmVudFN0YXRlKSB7XG5cdFx0XHRjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgbGlzdGVuZXJBcmdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5vbmNlKHRhcmdldFN0YXRlLCBsaXN0ZW5lcik7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRXZlbnRFbWl0dGVyKTtcblxuXG4vKioqLyB9KSxcbi8qIDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJlc2VuY2VtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcblxuXG5cblxuXG52YXIgUHJvdG9jb2xNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIFByb3RvY29sTWVzc2FnZSgpIHtcblx0XHR0aGlzLmFjdGlvbiA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmZsYWdzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb3VudCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmVycm9yID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jaGFubmVsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2hhbm5lbFNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1lc3NhZ2VzID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucHJlc2VuY2UgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5hdXRoID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucGFyYW1zID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0dmFyIGFjdGlvbnMgPSBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uID0ge1xuXHRcdCdIRUFSVEJFQVQnIDogMCxcblx0XHQnQUNLJyA6IDEsXG5cdFx0J05BQ0snIDogMixcblx0XHQnQ09OTkVDVCcgOiAzLFxuXHRcdCdDT05ORUNURUQnIDogNCxcblx0XHQnRElTQ09OTkVDVCcgOiA1LFxuXHRcdCdESVNDT05ORUNURUQnIDogNixcblx0XHQnQ0xPU0UnIDogNyxcblx0XHQnQ0xPU0VEJyA6IDgsXG5cdFx0J0VSUk9SJyA6IDksXG5cdFx0J0FUVEFDSCcgOiAxMCxcblx0XHQnQVRUQUNIRUQnIDogMTEsXG5cdFx0J0RFVEFDSCcgOiAxMixcblx0XHQnREVUQUNIRUQnIDogMTMsXG5cdFx0J1BSRVNFTkNFJyA6IDE0LFxuXHRcdCdNRVNTQUdFJyA6IDE1LFxuXHRcdCdTWU5DJyA6IDE2LFxuXHRcdCdBVVRIJyA6IDE3XG5cdH07XG5cblx0UHJvdG9jb2xNZXNzYWdlLmNoYW5uZWxNb2RlcyA9IFsgJ1BSRVNFTkNFJywgJ1BVQkxJU0gnLCAnU1VCU0NSSUJFJywgJ1BSRVNFTkNFX1NVQlNDUklCRScgXTtcblxuXHRQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZSA9IFtdO1xuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5rZXlzQXJyYXkoUHJvdG9jb2xNZXNzYWdlLkFjdGlvbiwgdHJ1ZSksIGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZVthY3Rpb25zW25hbWVdXSA9IG5hbWU7XG5cdH0pO1xuXG5cdHZhciBmbGFncyA9IHtcblx0XHQvKiBDaGFubmVsIGF0dGFjaCBzdGF0ZSBmbGFncyAqL1xuXHRcdCdIQVNfUFJFU0VOQ0UnOiAgICAgICAxIDw8IDAsXG5cdFx0J0hBU19CQUNLTE9HJzogICAgICAgIDEgPDwgMSxcblx0XHQnUkVTVU1FRCc6ICAgICAgICAgICAgMSA8PCAyLFxuXHRcdCdUUkFOU0lFTlQnOiAgICAgICAgICAxIDw8IDQsXG5cdFx0J0FUVEFDSF9SRVNVTUUnOiAgICAgIDEgPDwgNSxcblx0XHQvKiBDaGFubmVsIG1vZGUgZmxhZ3MgKi9cblx0XHQnUFJFU0VOQ0UnOiAgICAgICAgICAgMSA8PCAxNixcblx0XHQnUFVCTElTSCc6ICAgICAgICAgICAgMSA8PCAxNyxcblx0XHQnU1VCU0NSSUJFJzogICAgICAgICAgMSA8PCAxOCxcblx0XHQnUFJFU0VOQ0VfU1VCU0NSSUJFJzogMSA8PCAxOVxuXHR9O1xuXHR2YXIgZmxhZ05hbWVzID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5rZXlzQXJyYXkoZmxhZ3MpO1xuXHRmbGFncy5NT0RFX0FMTCA9IGZsYWdzLlBSRVNFTkNFIHwgZmxhZ3MuUFVCTElTSCB8IGZsYWdzLlNVQlNDUklCRSB8IGZsYWdzLlBSRVNFTkNFX1NVQlNDUklCRTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmhhc0ZsYWcgPSBmdW5jdGlvbihmbGFnKSB7XG5cdFx0cmV0dXJuICgodGhpcy5mbGFncyAmIGZsYWdzW2ZsYWddKSA+IDApO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuc2V0RmxhZyA9IGZ1bmN0aW9uKGZsYWcpIHtcblx0XHRyZXR1cm4gdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5mbGFncyAmJiAodGhpcy5mbGFncyAmIGZsYWdzLk1PREVfQUxMKTtcblx0fTtcblxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU1vZGVzVG9GbGFncyA9IGZ1bmN0aW9uKG1vZGVzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChtb2RlcywgZnVuY3Rpb24obW9kZSkge1xuXHRcdFx0c2VsZi5zZXRGbGFnKG1vZGUpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZGVjb2RlTW9kZXNGcm9tRmxhZ3MgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbW9kZXMgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChQcm90b2NvbE1lc3NhZ2UuY2hhbm5lbE1vZGVzLCBmdW5jdGlvbihtb2RlKSB7XG5cdFx0XHRpZihzZWxmLmhhc0ZsYWcobW9kZSkpIHtcblx0XHRcdFx0bW9kZXMucHVzaChtb2RlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4gbW9kZXMubGVuZ3RoID4gMCA/IG1vZGVzIDogdW5kZWZpbmVkO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5zZXJpYWxpemUgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVuY29kZUJvZHk7XG5cblx0UHJvdG9jb2xNZXNzYWdlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgZm9ybWF0KSB7XG5cdFx0dmFyIGRlc2VyaWFsaXplZCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVjb2RlQm9keShzZXJpYWxpemVkLCBmb3JtYXQpO1xuXHRcdHJldHVybiBQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZChkZXNlcmlhbGl6ZWQpO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5mcm9tRGVzZXJpYWxpemVkID0gZnVuY3Rpb24oZGVzZXJpYWxpemVkKSB7XG5cdFx0dmFyIGVycm9yID0gZGVzZXJpYWxpemVkLmVycm9yO1xuXHRcdGlmKGVycm9yKSBkZXNlcmlhbGl6ZWQuZXJyb3IgPSBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhlcnJvcik7XG5cdFx0dmFyIG1lc3NhZ2VzID0gZGVzZXJpYWxpemVkLm1lc3NhZ2VzO1xuXHRcdGlmKG1lc3NhZ2VzKSBmb3IodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIG1lc3NhZ2VzW2ldID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKG1lc3NhZ2VzW2ldKTtcblx0XHR2YXIgcHJlc2VuY2UgPSBkZXNlcmlhbGl6ZWQucHJlc2VuY2U7XG5cdFx0aWYocHJlc2VuY2UpIGZvcih2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZS5sZW5ndGg7IGkrKykgcHJlc2VuY2VbaV0gPSBfcHJlc2VuY2VtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyhwcmVzZW5jZVtpXSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IFByb3RvY29sTWVzc2FnZSgpLCBkZXNlcmlhbGl6ZWQpO1xuXHR9O1xuXG5cdFByb3RvY29sTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IFByb3RvY29sTWVzc2FnZSgpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIHRvU3RyaW5nQXJyYXkoYXJyYXkpIHtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0aWYgKGFycmF5KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHJlc3VsdC5wdXNoKGFycmF5W2ldLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gJ1sgJyArIHJlc3VsdC5qb2luKCcsICcpICsgJyBdJztcblx0fVxuXG5cdHZhciBzaW1wbGVBdHRyaWJ1dGVzID0gJ2lkIGNoYW5uZWwgY2hhbm5lbFNlcmlhbCBjb25uZWN0aW9uSWQgY29ubmVjdGlvbktleSBjb25uZWN0aW9uU2VyaWFsIGNvdW50IG1zZ1NlcmlhbCB0aW1lc3RhbXAnLnNwbGl0KCcgJyk7XG5cblx0UHJvdG9jb2xNZXNzYWdlLnN0cmluZ2lmeSA9IGZ1bmN0aW9uKG1zZykge1xuXHRcdHZhciByZXN1bHQgPSAnW1Byb3RvY29sTWVzc2FnZSc7XG5cdFx0aWYobXNnLmFjdGlvbiAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGFjdGlvbj0nICsgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWVbbXNnLmFjdGlvbl0gfHwgZmFsc2U7XG5cblx0XHR2YXIgYXR0cmlidXRlO1xuXHRcdGZvciAodmFyIGF0dHJpYkluZGV4ID0gMDsgYXR0cmliSW5kZXggPCBzaW1wbGVBdHRyaWJ1dGVzLmxlbmd0aDsgYXR0cmliSW5kZXgrKykge1xuXHRcdFx0YXR0cmlidXRlID0gc2ltcGxlQXR0cmlidXRlc1thdHRyaWJJbmRleF07XG5cdFx0XHRpZihtc2dbYXR0cmlidXRlXSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgJyArIGF0dHJpYnV0ZSArICc9JyArIG1zZ1thdHRyaWJ1dGVdO1xuXHRcdH1cblxuXHRcdGlmKG1zZy5tZXNzYWdlcylcblx0XHRcdHJlc3VsdCArPSAnOyBtZXNzYWdlcz0nICsgdG9TdHJpbmdBcnJheShfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXNBcnJheShtc2cubWVzc2FnZXMpKTtcblx0XHRpZihtc2cucHJlc2VuY2UpXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHJlc2VuY2U9JyArIHRvU3RyaW5nQXJyYXkoX3ByZXNlbmNlbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXNBcnJheShtc2cucHJlc2VuY2UpKTtcblx0XHRpZihtc2cuZXJyb3IpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZXJyb3I9JyArIF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKG1zZy5lcnJvcikudG9TdHJpbmcoKTtcblx0XHRpZihtc2cuYXV0aCAmJiBtc2cuYXV0aC5hY2Nlc3NUb2tlbilcblx0XHRcdHJlc3VsdCArPSAnOyB0b2tlbj0nICsgbXNnLmF1dGguYWNjZXNzVG9rZW47XG5cdFx0aWYobXNnLmZsYWdzKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGZsYWdzPScgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZpbHRlcihmbGFnTmFtZXMsIGZ1bmN0aW9uKGZsYWcpIHtcblx0XHRcdFx0cmV0dXJuIG1zZy5oYXNGbGFnKGZsYWcpO1xuXHRcdFx0fSkuam9pbignLCcpO1xuXHRcdGlmKG1zZy5wYXJhbXMpIHtcblx0XHRcdHZhciBzdHJpbmdpZmllZFBhcmFtcyA9ICcnO1xuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mb3JJbk93bk5vbk51bGxQcm9wcyhtc2cucGFyYW1zLCBmdW5jdGlvbihwcm9wKSB7XG5cdFx0XHRcdGlmIChzdHJpbmdpZmllZFBhcmFtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdFx0c3RyaW5naWZpZWRQYXJhbXMgKz0gJzsgJztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdHJpbmdpZmllZFBhcmFtcyArPSBwcm9wICsgJz0nICsgbXNnLnBhcmFtc1twcm9wXTtcblx0XHRcdH0pO1xuXHRcdFx0aWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0cmVzdWx0ICs9ICc7IHBhcmFtcz1bJyArIHN0cmluZ2lmaWVkUGFyYW1zICsgJ10nO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0LyogT25seSB2YWxpZCBmb3IgY2hhbm5lbCBtZXNzYWdlcyAqL1xuXHRQcm90b2NvbE1lc3NhZ2UuaXNEdXBsaWNhdGUgPSBmdW5jdGlvbihhLCBiKSB7XG5cdFx0aWYgKGEgJiYgYikge1xuXHRcdFx0aWYgKChhLmFjdGlvbiA9PT0gYWN0aW9ucy5NRVNTQUdFIHx8IGEuYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFKSAmJlxuXHRcdFx0XHQoYS5hY3Rpb24gPT09IGIuYWN0aW9uKSAmJlxuXHRcdFx0XHQoYS5jaGFubmVsID09PSBiLmNoYW5uZWwpICYmXG5cdFx0XHRcdChhLmlkID09PSBiLmlkKSkge1xuXHRcdFx0XHRpZiAoYS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIGlmIChhLm1lc3NhZ2VzLmxlbmd0aCA9PT0gYi5tZXNzYWdlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGEubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBhTWVzc2FnZSA9IGEubWVzc2FnZXNbaV07XG5cdFx0XHRcdFx0XHR2YXIgYk1lc3NhZ2UgPSBiLm1lc3NhZ2VzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKChhTWVzc2FnZS5leHRyYXMgJiYgYU1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGFNZXNzYWdlLmV4dHJhcy5kZWx0YS5mb3JtYXQpICE9PVxuXHRcdFx0XHRcdFx0XHQoYk1lc3NhZ2UuZXh0cmFzICYmIGJNZXNzYWdlLmV4dHJhcy5kZWx0YSAmJiBiTWVzc2FnZS5leHRyYXMuZGVsdGEuZm9ybWF0KSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG5cblx0cmV0dXJuIFByb3RvY29sTWVzc2FnZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUHJvdG9jb2xNZXNzYWdlKTtcblxuXG4vKioqLyB9KSxcbi8qIDkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cbnZhciBNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIE1lc3NhZ2UoKSB7XG5cdFx0dGhpcy5uYW1lID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kYXRhID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZW5jb2RpbmcgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5leHRyYXMgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zaXplID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRNZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0ge1xuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxuXHRcdFx0aWQ6IHRoaXMuaWQsXG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcblx0XHRcdGNvbm5lY3Rpb25JZDogdGhpcy5jb25uZWN0aW9uSWQsXG5cdFx0XHRjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG5cdFx0XHRlbmNvZGluZzogdGhpcy5lbmNvZGluZyxcblx0XHRcdGV4dHJhczogdGhpcy5leHRyYXNcblx0XHR9O1xuXG5cdFx0LyogZW5jb2RlIGRhdGEgdG8gYmFzZTY0IGlmIHByZXNlbnQgYW5kIHdlJ3JlIHJldHVybmluZyByZWFsIEpTT047XG5cdFx0ICogYWx0aG91Z2ggbXNncGFjayBjYWxscyB0b0pTT04oKSwgd2Uga25vdyBpdCBpcyBhIHN0cmluZ2lmeSgpXG5cdFx0ICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcblx0XHRpZihkYXRhICYmIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG5cdFx0XHRcdC8qIHN0cmluZ2lmeSBjYWxsICovXG5cdFx0XHRcdHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG5cdFx0XHRcdHJlc3VsdC5lbmNvZGluZyA9IGVuY29kaW5nID8gKGVuY29kaW5nICsgJy9iYXNlNjQnKSA6ICdiYXNlNjQnO1xuXHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUoZGF0YSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQvKiBDYWxsZWQgYnkgbXNncGFjay4gdG9CdWZmZXIgcmV0dXJucyBhIGRhdGF0eXBlIHVuZGVyc3RhbmRhYmxlIGJ5XG5cdFx0XHRcdCAqIHRoYXQgcGxhdGZvcm0ncyBtc2dwYWNrIGltcGxlbWVudGF0aW9uIChCdWZmZXIgaW4gbm9kZSwgVWludDhBcnJheVxuXHRcdFx0XHQgKiBpbiBicm93c2VycykgKi9cblx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGF0YSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJlc3VsdC5kYXRhID0gZGF0YTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdE1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbTWVzc2FnZSc7XG5cdFx0aWYodGhpcy5uYW1lKVxuXHRcdFx0cmVzdWx0ICs9ICc7IG5hbWU9JyArIHRoaXMubmFtZTtcblx0XHRpZih0aGlzLmlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuXHRcdGlmKHRoaXMudGltZXN0YW1wKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHRpbWVzdGFtcD0nICsgdGhpcy50aW1lc3RhbXA7XG5cdFx0aWYodGhpcy5jbGllbnRJZClcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZClcblx0XHRcdHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuXHRcdGlmKHRoaXMuZW5jb2RpbmcpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZW5jb2Rpbmc9JyArIHRoaXMuZW5jb2Rpbmc7XG5cdFx0aWYodGhpcy5leHRyYXMpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZXh0cmFzID0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuXHRcdGlmKHRoaXMuZGF0YSkge1xuXHRcdFx0aWYgKHR5cGVvZih0aGlzLmRhdGEpID09ICdzdHJpbmcnKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xuXHRcdFx0ZWxzZSBpZiAocGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoYnVmZmVyKT0nICsgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUodGhpcy5kYXRhKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGpzb24pPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuXHRcdH1cblx0XHRpZih0aGlzLmV4dHJhcylcblx0XHRcdHJlc3VsdCArPSAnOyBleHRyYXM9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0TWVzc2FnZS5lbmNyeXB0ID0gZnVuY3Rpb24obXNnLCBvcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBkYXRhID0gbXNnLmRhdGEsXG5cdFx0XHRlbmNvZGluZyA9IG1zZy5lbmNvZGluZyxcblx0XHRcdGNpcGhlciA9IG9wdGlvbnMuY2hhbm5lbENpcGhlcjtcblxuXHRcdGVuY29kaW5nID0gZW5jb2RpbmcgPyAoZW5jb2RpbmcgKyAnLycpIDogJyc7XG5cdFx0aWYoIXBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcblx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhFbmNvZGUoU3RyaW5nKGRhdGEpKTtcblx0XHRcdGVuY29kaW5nID0gZW5jb2RpbmcgKyAndXRmLTgvJztcblx0XHR9XG5cdFx0Y2lwaGVyLmVuY3J5cHQoZGF0YSwgZnVuY3Rpb24oZXJyLCBkYXRhKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG1zZy5kYXRhID0gZGF0YTtcblx0XHRcdG1zZy5lbmNvZGluZyA9IGVuY29kaW5nICsgJ2NpcGhlcisnICsgY2lwaGVyLmFsZ29yaXRobTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIG1zZyk7XG5cdFx0fSk7XG5cdH07XG5cblx0TWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIGRhdGEgPSBtc2cuZGF0YSwgZW5jb2RpbmcsXG5cdFx0XHRuYXRpdmVEYXRhVHlwZSA9IHR5cGVvZihkYXRhKSA9PSAnc3RyaW5nJyB8fCBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpIHx8IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdW5kZWZpbmVkO1xuXG5cdFx0aWYgKCFuYXRpdmVEYXRhVHlwZSkge1xuXHRcdFx0aWYgKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNPYmplY3QoZGF0YSkgfHwgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGRhdGEpKSB7XG5cdFx0XHRcdG1zZy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG5cdFx0XHRcdG1zZy5lbmNvZGluZyA9IChlbmNvZGluZyA9IG1zZy5lbmNvZGluZykgPyAoZW5jb2RpbmcgKyAnL2pzb24nKSA6ICdqc29uJztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0RhdGEgdHlwZSBpcyB1bnN1cHBvcnRlZCcsIDQwMDEzLCA0MDApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmNpcGhlcikge1xuXHRcdFx0TWVzc2FnZS5lbmNyeXB0KG1zZywgb3B0aW9ucywgY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBtc2cpO1xuXHRcdH1cblx0fTtcblxuXHRNZXNzYWdlLmVuY29kZUFycmF5ID0gZnVuY3Rpb24obWVzc2FnZXMsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHByb2Nlc3NlZCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0TWVzc2FnZS5lbmNvZGUobWVzc2FnZXNbaV0sIG9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgbXNnKSB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwcm9jZXNzZWQrKztcblx0XHRcdFx0aWYgKHByb2Nlc3NlZCA9PSBtZXNzYWdlcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCBtZXNzYWdlcyk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRNZXNzYWdlLnNlcmlhbGl6ZSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZW5jb2RlQm9keTtcblxuXHRNZXNzYWdlLmRlY29kZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIGNvbnRleHQpIHtcblx0XHQvKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGNvdWxkIGJlIGVpdGhlciBFbmNvZGluZ0RlY29kaW5nQ29udGV4dCB0aGF0IGNvbnRhaW5zIENoYW5uZWxPcHRpb25zIG9yIENoYW5uZWxPcHRpb25zICovXG5cdFx0aWYoIWNvbnRleHQgfHwgIWNvbnRleHQuY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRcdHZhciBjaGFubmVsT3B0aW9ucyA9IGNvbnRleHQ7XG5cdFx0XHRjb250ZXh0ID0ge1xuXHRcdFx0XHRjaGFubmVsT3B0aW9uczogY2hhbm5lbE9wdGlvbnMsXG5cdFx0XHRcdHBsdWdpbnM6IHsgfSxcblx0XHRcdFx0YmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHVuZGVmaW5lZFxuXHRcdFx0fTtcblx0XHR9XG5cblx0XHR2YXIgbGFzdFBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG5cdFx0dmFyIGVuY29kaW5nID0gbWVzc2FnZS5lbmNvZGluZztcblx0XHRpZihlbmNvZGluZykge1xuXHRcdFx0dmFyIHhmb3JtcyA9IGVuY29kaW5nLnNwbGl0KCcvJyksXG5cdFx0XHRcdGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4LCBlbmNvZGluZ3NUb1Byb2Nlc3MgPSB4Zm9ybXMubGVuZ3RoLFxuXHRcdFx0XHRkYXRhID0gbWVzc2FnZS5kYXRhO1xuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHR3aGlsZSgobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSBlbmNvZGluZ3NUb1Byb2Nlc3MpID4gMCkge1xuXHRcdFx0XHRcdHZhciBtYXRjaCA9IHhmb3Jtc1stLWVuY29kaW5nc1RvUHJvY2Vzc10ubWF0Y2goLyhbXFwtXFx3XSspKFxcKyhbXFx3XFwtXSspKT8vKTtcblx0XHRcdFx0XHRpZighbWF0Y2gpIGJyZWFrO1xuXHRcdFx0XHRcdHZhciB4Zm9ybSA9IG1hdGNoWzFdO1xuXHRcdFx0XHRcdHN3aXRjaCh4Zm9ybSkge1xuXHRcdFx0XHRcdFx0Y2FzZSAnYmFzZTY0Jzpcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RGVjb2RlKFN0cmluZyhkYXRhKSk7XG5cdFx0XHRcdFx0XHRcdGlmKGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4ID09IHhmb3Jtcy5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0XHRsYXN0UGF5bG9hZCA9IGRhdGE7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0XHRjYXNlICd1dGYtOCc6XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhEZWNvZGUoZGF0YSk7XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0Y2FzZSAnanNvbic6XG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0XHRcdGNhc2UgJ2NpcGhlcic6XG5cdFx0XHRcdFx0XHRcdGlmKGNvbnRleHQuY2hhbm5lbE9wdGlvbnMgIT0gbnVsbCAmJiBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNpcGhlcikge1xuXHRcdFx0XHRcdFx0XHRcdHZhciB4Zm9ybUFsZ29yaXRobSA9IG1hdGNoWzNdLCBjaXBoZXIgPSBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNoYW5uZWxDaXBoZXI7XG5cdFx0XHRcdFx0XHRcdFx0LyogZG9uJ3QgYXR0ZW1wdCB0byBkZWNyeXB0IHVubGVzcyB0aGUgY2lwaGVyIHBhcmFtcyBhcmUgY29tcGF0aWJsZSAqL1xuXHRcdFx0XHRcdFx0XHRcdGlmKHhmb3JtQWxnb3JpdGhtICE9IGNpcGhlci5hbGdvcml0aG0pIHtcblx0XHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZSB3aXRoIGdpdmVuIGNpcGhlcjsgaW5jb21wYXRpYmxlIGNpcGhlciBwYXJhbXMnKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGNpcGhlci5kZWNyeXB0KGRhdGEpO1xuXHRcdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsJyk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGNhc2UgJ3ZjZGlmZic6XG5cdFx0XHRcdFx0XHRcdGlmKCFjb250ZXh0LnBsdWdpbnMgfHwgIWNvbnRleHQucGx1Z2lucy52Y2RpZmYpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdNaXNzaW5nIFZjZGlmZiBkZWNvZGVyIChodHRwczovL2dpdGh1Yi5jb20vYWJseS1mb3Jrcy92Y2RpZmYtZGVjb2RlciknLCA0MDAxOSwgNDAwKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdEZWx0YSBkZWNvZGluZyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgYnJvd3NlciAobmVlZCBBcnJheUJ1ZmZlciAmIFVpbnQ4QXJyYXkpJywgNDAwMjAsIDQwMCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgZGVsdGFCYXNlID0gY29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDtcblx0XHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgZGVsdGFCYXNlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGVsdGFCYXNlID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0LyogdmNkaWZmIGV4cGVjdHMgVWludDhBcnJheXMsIGNhbid0IGNvcHkgd2l0aCBBcnJheUJ1ZmZlcnMuIChhbHNvLCBpZiB3ZVxuXHRcdFx0XHRcdFx0XHRcdCAqIGRvbid0IGhhdmUgYSBUZXh0RGVjb2RlciwgZGVsdGFCYXNlIG1pZ2h0IGJlIGEgV29yZEFycmF5IGhlcmUsIHNvIG5lZWRcblx0XHRcdFx0XHRcdFx0XHQgKiB0byBwcm9jZXNzIGl0IGludG8gYSBidWZmZXIgYW55d2F5KSAqL1xuXHRcdFx0XHRcdFx0XHRcdGRlbHRhQmFzZSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGVsdGFCYXNlKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b0J1ZmZlcihkYXRhKTtcblxuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnR5cGVkQXJyYXlUb0J1ZmZlcihjb250ZXh0LnBsdWdpbnMudmNkaWZmLmRlY29kZShkYXRhLCBkZWx0YUJhc2UpKTtcblx0XHRcdFx0XHRcdFx0XHRsYXN0UGF5bG9hZCA9IGRhdGE7XG5cdFx0XHRcdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1ZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggJyArIGUsIDQwMDE4LCA0MDApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBlbmNvZGluZ1wiKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdFcnJvciBwcm9jZXNzaW5nIHRoZSAnICsgeGZvcm0gKyAnIGVuY29kaW5nLCBkZWNvZGVyIHJldHVybmVkIOKAmCcgKyBlLm1lc3NhZ2UgKyAn4oCZJywgZS5jb2RlIHx8IDQwMDEzLCA0MDApO1xuXHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0bWVzc2FnZS5lbmNvZGluZyA9IChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA8PSAwKSA/IG51bGwgOiB4Zm9ybXMuc2xpY2UoMCwgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXgpLmpvaW4oJy8nKTtcblx0XHRcdFx0bWVzc2FnZS5kYXRhID0gZGF0YTtcblx0XHRcdH1cblx0XHR9XG5cdFx0Y29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZCA9IGxhc3RQYXlsb2FkO1xuXHR9O1xuXG5cdE1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHksIG9wdGlvbnMsIGZvcm1hdCkge1xuXHRcdGlmKGZvcm1hdCkge1xuXHRcdFx0Ym9keSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuXHRcdH1cblxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgbXNnID0gYm9keVtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBib2R5O1xuXHR9O1xuXG5cdE1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBNZXNzYWdlKCksIHZhbHVlcyk7XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBNZXNzYWdlLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdGZ1bmN0aW9uIG5vcm1hbGl6ZUNpcGhlck9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5jaXBoZXIgJiYgIW9wdGlvbnMuY2lwaGVyLmNoYW5uZWxDaXBoZXIpIHtcblx0XHRcdGlmKCFwbGF0Zm9ybV9jcnlwdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWQnKTtcblx0XHRcdHZhciBjaXBoZXIgPSBwbGF0Zm9ybV9jcnlwdG9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIpO1xuXHRcdFx0b3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xuXHRcdFx0b3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcblx0XHR9XG5cdH1cblxuXHRNZXNzYWdlLmZyb21FbmNvZGVkID0gZnVuY3Rpb24oZW5jb2RlZCwgb3B0aW9ucykge1xuXHRcdHZhciBtc2cgPSBNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XG5cdFx0bm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhvcHRpb25zKTtcblx0XHQvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xuXHRcdCAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xuXHRcdHRyeSB7XG5cdFx0XHRNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ01lc3NhZ2UuZnJvbUVuY29kZWQoKScsIGUudG9TdHJpbmcoKSk7XG5cdFx0fVxuXHRcdHJldHVybiBtc2c7XG5cdH07XG5cblx0TWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24oZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XG5cdFx0bm9ybWFsaXplQ2lwaGVyT3B0aW9ucyhvcHRpb25zKTtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJNYXAoZW5jb2RlZEFycmF5LCBmdW5jdGlvbihlbmNvZGVkKSB7XG5cdFx0XHRyZXR1cm4gTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcblx0XHR9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBnZXRNZXNzYWdlU2l6ZShtc2cpIHtcblx0XHR2YXIgc2l6ZSA9IDA7XG5cdFx0aWYobXNnLm5hbWUpIHtcblx0XHRcdHNpemUgKz0gbXNnLm5hbWUubGVuZ3RoO1xuXHRcdH1cblx0XHRpZihtc2cuY2xpZW50SWQpIHtcblx0XHRcdHNpemUgKz0gbXNnLmNsaWVudElkLmxlbmd0aDtcblx0XHR9XG5cdFx0aWYobXNnLmV4dHJhcykge1xuXHRcdFx0c2l6ZSArPSBKU09OLnN0cmluZ2lmeShtc2cuZXh0cmFzKS5sZW5ndGg7XG5cdFx0fVxuXHRcdGlmKG1zZy5kYXRhKSB7XG5cdFx0XHRzaXplICs9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGF0YVNpemVCeXRlcyhtc2cuZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBzaXplO1xuXHR9O1xuXG5cdC8qIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBvbiBlbmNvZGUoKWQgKGFuZCBlbmNyeXB0KClkKSBNZXNzYWdlcyAoYXMgaXRcblx0ICogYXNzdW1lcyB0aGUgZGF0YSBpcyBhIHN0cmluZyBvciBidWZmZXIpICovXG5cdE1lc3NhZ2UuZ2V0TWVzc2FnZXNTaXplID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcblx0XHR2YXIgbXNnLCB0b3RhbCA9IDA7XG5cdFx0Zm9yKHZhciBpPTA7IGk8bWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdG1zZyA9IG1lc3NhZ2VzW2ldO1xuXHRcdFx0dG90YWwgKz0gKG1zZy5zaXplIHx8IChtc2cuc2l6ZSA9IGdldE1lc3NhZ2VTaXplKG1zZykpKVxuXHRcdH1cblx0XHRyZXR1cm4gdG90YWw7XG5cdH07XG5cblx0cmV0dXJuIE1lc3NhZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKE1lc3NhZ2UpO1xuXG5cbi8qKiovIH0pLFxuLyogMTAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gQ2hlY2sgaWYgdHlwZWQgYXJyYXlzIGFyZSBzdXBwb3J0ZWRcblx0ICAgIGlmICh0eXBlb2YgQXJyYXlCdWZmZXIgIT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgIHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXG5cdCAgICAvLyBSZWZlcmVuY2Ugb3JpZ2luYWwgaW5pdFxuXHQgICAgdmFyIHN1cGVySW5pdCA9IFdvcmRBcnJheS5pbml0O1xuXG5cdCAgICAvLyBBdWdtZW50IFdvcmRBcnJheS5pbml0IHRvIGhhbmRsZSB0eXBlZCBhcnJheXNcblx0ICAgIHZhciBzdWJJbml0ID0gV29yZEFycmF5LmluaXQgPSBmdW5jdGlvbiAodHlwZWRBcnJheSkge1xuXHQgICAgICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIENvbnZlcnQgb3RoZXIgYXJyYXkgdmlld3MgdG8gdWludDhcblx0ICAgICAgICBpZiAoXG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQ4QXJyYXkgfHxcblx0ICAgICAgICAgICAgKHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhDbGFtcGVkQXJyYXkpIHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0MzJBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQ2NEFycmF5XG5cdCAgICAgICAgKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5LmJ1ZmZlciwgdHlwZWRBcnJheS5ieXRlT2Zmc2V0LCB0eXBlZEFycmF5LmJ5dGVMZW5ndGgpO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIEhhbmRsZSBVaW50OEFycmF5XG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB0eXBlZEFycmF5Qnl0ZUxlbmd0aCA9IHR5cGVkQXJyYXkuYnl0ZUxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBFeHRyYWN0IGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHR5cGVkQXJyYXlCeXRlTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IHR5cGVkQXJyYXlbaV0gPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmNhbGwodGhpcywgd29yZHMsIHR5cGVkQXJyYXlCeXRlTGVuZ3RoKTtcblx0ICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcblx0ICAgICAgICAgICAgc3VwZXJJbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgc3ViSW5pdC5wcm90b3R5cGUgPSBXb3JkQXJyYXk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG5cblxuXG5cbnZhciBQcmVzZW5jZU1lc3NhZ2UgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIHRvQWN0aW9uVmFsdWUoYWN0aW9uU3RyaW5nKSB7XG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihQcmVzZW5jZU1lc3NhZ2UuQWN0aW9ucywgYWN0aW9uU3RyaW5nKVxuXHR9XG5cblx0ZnVuY3Rpb24gUHJlc2VuY2VNZXNzYWdlKCkge1xuXHRcdHRoaXMuYWN0aW9uID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5lbmNvZGluZyA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnNpemUgPSB1bmRlZmluZWQ7XG5cdH1cblxuXHRQcmVzZW5jZU1lc3NhZ2UuQWN0aW9ucyA9IFtcblx0XHQnYWJzZW50Jyxcblx0XHQncHJlc2VudCcsXG5cdFx0J2VudGVyJyxcblx0XHQnbGVhdmUnLFxuXHRcdCd1cGRhdGUnXG5cdF07XG5cblx0LyogUmV0dXJucyB3aGV0aGVyIHRoaXMgcHJlc2VuY2VNZXNzYWdlIGlzIHN5bnRoZXNpemVkLCBpLmUuIHdhcyBub3QgYWN0dWFsbHlcblx0ICogc2VudCBieSB0aGUgY29ubmVjdGlvbiAodXN1YWxseSBtZWFucyBhIGxlYXZlIGV2ZW50IHNlbnQgMTVzIGFmdGVyIGFcblx0ICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG5cdCAqIGNvbXBhcmVkIGZvciBuZXduZXNzIGJ5IGlkIGxleGljb2dyYXBoaWNhbGx5IC0gUlRQMmIxXG5cdCAqL1xuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLmlzU3ludGhlc2l6ZWQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pZC5zdWJzdHJpbmcodGhpcy5jb25uZWN0aW9uSWQubGVuZ3RoLCAwKSAhPT0gdGhpcy5jb25uZWN0aW9uSWQ7XG5cdH07XG5cblx0LyogUlRQMmIyICovXG5cdFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUucGFyc2VJZCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IHRoaXMuaWQuc3BsaXQoJzonKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0Y29ubmVjdGlvbklkOiBwYXJ0c1swXSxcblx0XHRcdG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcblx0XHRcdGluZGV4OiBwYXJzZUludChwYXJ0c1syXSwgMTApXG5cdFx0fTtcblx0fTtcblxuXHQvKipcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcblx0ICogQHJldHVybiB7Kn1cblx0ICovXG5cdFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9IHtcblx0XHRcdGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuXHRcdFx0LyogQ29udmVydCBwcmVzZW5jZSBhY3Rpb24gYmFjayB0byBhbiBpbnQgZm9yIHNlbmRpbmcgdG8gQWJseSAqL1xuXHRcdFx0YWN0aW9uOiB0b0FjdGlvblZhbHVlKHRoaXMuYWN0aW9uKSxcblx0XHRcdGVuY29kaW5nOiB0aGlzLmVuY29kaW5nXG5cdFx0fTtcblxuXHRcdC8qIGVuY29kZSBkYXRhIHRvIGJhc2U2NCBpZiBwcmVzZW50IGFuZCB3ZSdyZSByZXR1cm5pbmcgcmVhbCBKU09OO1xuXHRcdCAqIGFsdGhvdWdoIG1zZ3BhY2sgY2FsbHMgdG9KU09OKCksIHdlIGtub3cgaXQgaXMgYSBzdHJpbmdpZnkoKVxuXHRcdCAqIGNhbGwgaWYgaXQgaGFzIGEgbm9uLWVtcHR5IGFyZ3VtZW50cyBsaXN0ICovXG5cdFx0dmFyIGRhdGEgPSB0aGlzLmRhdGE7XG5cdFx0aWYoZGF0YSAmJiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpKSB7XG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHQvKiBzdHJpbmdpZnkgY2FsbCAqL1xuXHRcdFx0XHR2YXIgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xuXHRcdFx0XHRyZXN1bHQuZW5jb2RpbmcgPSBlbmNvZGluZyA/IChlbmNvZGluZyArICcvYmFzZTY0JykgOiAnYmFzZTY0Jztcblx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKGRhdGEpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogQ2FsbGVkIGJ5IG1zZ3BhY2suIHRvQnVmZmVyIHJldHVybnMgYSBkYXRhdHlwZSB1bmRlcnN0YW5kYWJsZSBieVxuXHRcdFx0XHQgKiB0aGF0IHBsYXRmb3JtJ3MgbXNncGFjayBpbXBsZW1lbnRhdGlvbiAoQnVmZmVyIGluIG5vZGUsIFVpbnQ4QXJyYXlcblx0XHRcdFx0ICogaW4gYnJvd3NlcnMpICovXG5cdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvQnVmZmVyKGRhdGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXN1bHQuZGF0YSA9IGRhdGE7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlc3VsdCA9ICdbUHJlc2VuY2VNZXNzYWdlJztcblx0XHRyZXN1bHQgKz0gJzsgYWN0aW9uPScgKyB0aGlzLmFjdGlvbjtcblx0XHRpZih0aGlzLmlkKVxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuXHRcdGlmKHRoaXMudGltZXN0YW1wKVxuXHRcdFx0cmVzdWx0ICs9ICc7IHRpbWVzdGFtcD0nICsgdGhpcy50aW1lc3RhbXA7XG5cdFx0aWYodGhpcy5jbGllbnRJZClcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZClcblx0XHRcdHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuXHRcdGlmKHRoaXMuZW5jb2RpbmcpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZW5jb2Rpbmc9JyArIHRoaXMuZW5jb2Rpbmc7XG5cdFx0aWYodGhpcy5kYXRhKSB7XG5cdFx0XHRpZiAodHlwZW9mKHRoaXMuZGF0YSkgPT0gJ3N0cmluZycpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhPScgKyB0aGlzLmRhdGE7XG5cdFx0XHRlbHNlIGlmIChwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKHRoaXMuZGF0YSkpXG5cdFx0XHRcdHJlc3VsdCArPSAnOyBkYXRhIChidWZmZXIpPScgKyBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NEVuY29kZSh0aGlzLmRhdGEpO1xuXHRcdFx0ZWxzZVxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XG5cdFx0fVxuXHRcdHJlc3VsdCArPSAnXSc7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblx0UHJlc2VuY2VNZXNzYWdlLmVuY29kZSA9IF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZW5jb2RlO1xuXHRQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWNvZGU7XG5cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBvcHRpb25zLCBmb3JtYXQpIHtcblx0XHRpZihmb3JtYXQpIHtcblx0XHRcdGJvZHkgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcblx0XHR9XG5cblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIG1zZyA9IGJvZHlbaV0gPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldLCB0cnVlKTtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdFByZXNlbmNlTWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYm9keTtcblx0fTtcblxuXHQvKiBDcmVhdGVzIGEgUHJlc2VuY2VNZXNzYWdlIGZyb20gc3BlY2lmaWVkIHZhbHVlcywgd2l0aCBhIHN0cmluZyBwcmVzZW5jZSBhY3Rpb24gKi9cblx0UHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMsIHN0cmluZ2lmeUFjdGlvbikge1xuXHRcdGlmKHN0cmluZ2lmeUFjdGlvbikge1xuXHRcdFx0dmFsdWVzLmFjdGlvbiA9IFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zW3ZhbHVlcy5hY3Rpb25dXG5cdFx0fVxuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKG5ldyBQcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgcmVzdWx0W2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uKGVuY29kZWQsIG9wdGlvbnMpIHtcblx0XHR2YXIgbXNnID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCwgdHJ1ZSk7XG5cdFx0LyogaWYgZGVjb2RpbmcgZmFpbHMgYXQgYW55IHBvaW50LCBjYXRjaCBhbmQgcmV0dXJuIHRoZSBtZXNzYWdlIGRlY29kZWQgdG9cblx0XHQgKiB0aGUgZnVsbGVzdCBleHRlbnQgcG9zc2libGUgKi9cblx0XHR0cnkge1xuXHRcdFx0UHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xuXHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcblx0XHR9XG5cdFx0cmV0dXJuIG1zZztcblx0fTtcblxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWRBcnJheSA9IGZ1bmN0aW9uKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyck1hcChlbmNvZGVkQXJyYXksIGZ1bmN0aW9uKGVuY29kZWQpIHtcblx0XHRcdHJldHVybiBQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoZW5jb2RlZCwgb3B0aW9ucyk7XG5cdFx0fSk7XG5cdH07XG5cblx0UHJlc2VuY2VNZXNzYWdlLmdldE1lc3NhZ2VzU2l6ZSA9IF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0TWVzc2FnZXNTaXplO1xuXG5cdHJldHVybiBQcmVzZW5jZU1lc3NhZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByZXNlbmNlTWVzc2FnZSk7XG5cblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7OyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeSgpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKCkge1xuXG5cdC8qZ2xvYmFscyB3aW5kb3csIGdsb2JhbCwgcmVxdWlyZSovXG5cblx0LyoqXG5cdCAqIENyeXB0b0pTIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XG5cblx0ICAgIHZhciBjcnlwdG87XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSAoZXhwZXJpbWVudGFsIElFIDExKSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXG5cdCAgICBpZiAoIWNyeXB0byAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubXNDcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSB3aW5kb3cubXNDcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gZnJvbSBnbG9iYWwgKE5vZGVKUylcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5jcnlwdG8pIHtcblx0ICAgICAgICBjcnlwdG8gPSBnbG9iYWwuY3J5cHRvO1xuXHQgICAgfVxuXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGltcG9ydCB2aWEgcmVxdWlyZSAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgXCJmdW5jdGlvblwiID09PSAnZnVuY3Rpb24nKSB7XG5cdCAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0NSk7XG5cdCAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgfVxuXG5cdCAgICAvKlxuXHQgICAgICogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXG5cdCAgICAgKlxuXHQgICAgICogQXMgTWF0aC5yYW5kb20oKSBpcyBjcnlwdG9ncmFwaGljYWxseSBub3Qgc2FmZSB0byB1c2Vcblx0ICAgICAqL1xuXHQgICAgdmFyIGNyeXB0b1NlY3VyZVJhbmRvbUludCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBpZiAoY3J5cHRvKSB7XG5cdCAgICAgICAgICAgIC8vIFVzZSBnZXRSYW5kb21WYWx1ZXMgbWV0aG9kIChCcm93c2VyKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFVzZSByYW5kb21CeXRlcyBtZXRob2QgKE5vZGVKUylcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjcnlwdG8ucmFuZG9tQnl0ZXMgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICAgICAgICAgIHRyeSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyg0KS5yZWFkSW50MzJMRSgpO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgY3J5cHRvIG1vZHVsZSBjb3VsZCBub3QgYmUgdXNlZCB0byBnZXQgc2VjdXJlIHJhbmRvbSBudW1iZXIuJyk7XG5cdCAgICB9O1xuXG5cdCAgICAvKlxuXHQgICAgICogTG9jYWwgcG9seWZpbGwgb2YgT2JqZWN0LmNyZWF0ZVxuXG5cdCAgICAgKi9cblx0ICAgIHZhciBjcmVhdGUgPSBPYmplY3QuY3JlYXRlIHx8IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gRigpIHt9XG5cblx0ICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG9iaikge1xuXHQgICAgICAgICAgICB2YXIgc3VidHlwZTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG9iajtcblxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcblxuXHQgICAgICAgICAgICBGLnByb3RvdHlwZSA9IG51bGw7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSlcblxuXHQgICAgLyoqXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGlicmFyeSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2xpYiA9IEMubGliID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZSBvYmplY3QgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XG5cblxuXHQgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdmVycmlkZXMgUHJvcGVydGllcyB0byBjb3B5IGludG8gdGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnLFxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgZXh0ZW5kOiBmdW5jdGlvbiAob3ZlcnJpZGVzKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTcGF3blxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIEF1Z21lbnRcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLm1peEluKG92ZXJyaWRlcyk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIENyZWF0ZSBkZWZhdWx0IGluaXRpYWxpemVyXG5cdCAgICAgICAgICAgICAgICBpZiAoIXN1YnR5cGUuaGFzT3duUHJvcGVydHkoJ2luaXQnKSB8fCB0aGlzLmluaXQgPT09IHN1YnR5cGUuaW5pdCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIuaW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIEluaXRpYWxpemVyJ3MgcHJvdG90eXBlIGlzIHRoZSBzdWJ0eXBlIG9iamVjdFxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlZmVyZW5jZSBzdXBlcnR5cGVcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcblxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHN1YnR5cGU7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxuXHQgICAgICAgICAgICAgKiBBcmd1bWVudHMgdG8gY3JlYXRlKCkgd2lsbCBiZSBwYXNzZWQgdG8gaW5pdCgpLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjcmVhdGU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XG5cdCAgICAgICAgICAgICAgICBpbnN0YW5jZS5pbml0LmFwcGx5KGluc3RhbmNlLCBhcmd1bWVudHMpO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBvYmplY3QuXG5cdCAgICAgICAgICAgICAqIE92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIGFkZCBzb21lIGxvZ2ljIHdoZW4geW91ciBvYmplY3RzIGFyZSBjcmVhdGVkLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgKiAgICAgICAgICAgICAvLyAuLi5cblx0ICAgICAgICAgICAgICogICAgICAgICB9XG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogQ29waWVzIHByb3BlcnRpZXMgaW50byB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgTXlUeXBlLm1peEluKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBmaWVsZDogJ3ZhbHVlJ1xuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBtaXhJbjogZnVuY3Rpb24gKHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgaWYgKHByb3BlcnRpZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBwcm9wZXJ0aWVzW3Byb3BlcnR5TmFtZV07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXG5cdCAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eSgndG9TdHJpbmcnKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMudG9TdHJpbmcgPSBwcm9wZXJ0aWVzLnRvU3RyaW5nO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBpbnN0YW5jZS5jbG9uZSgpO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluaXQucHJvdG90eXBlLmV4dGVuZCh0aGlzKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH07XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IHNpZ0J5dGVzIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICovXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgKE9wdGlvbmFsKSBBbiBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHNpZ0J5dGVzIChPcHRpb25hbCkgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGUgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKFsweDAwMDEwMjAzLCAweDA0MDUwNjA3XSwgNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHdvcmRzLCBzaWdCeXRlcykge1xuXHQgICAgICAgICAgICB3b3JkcyA9IHRoaXMud29yZHMgPSB3b3JkcyB8fCBbXTtcblxuXHQgICAgICAgICAgICBpZiAoc2lnQnl0ZXMgIT0gdW5kZWZpbmVkKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzID0gd29yZHMubGVuZ3RoICogNDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0VuY29kZXJ9IGVuY29kZXIgKE9wdGlvbmFsKSBUaGUgZW5jb2Rpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBDcnlwdG9KUy5lbmMuSGV4XG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5ICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZyhDcnlwdG9KUy5lbmMuVXRmOCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoZW5jb2RlciB8fCBIZXgpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uY2F0ZW5hdGVzIGEgd29yZCBhcnJheSB0byB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5IHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkxLmNvbmNhdCh3b3JkQXJyYXkyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB0aGlzV29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgdGhpc1NpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIHRoYXRTaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcCBleGNlc3MgYml0c1xuXHQgICAgICAgICAgICB0aGlzLmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29uY2F0XG5cdCAgICAgICAgICAgIGlmICh0aGlzU2lnQnl0ZXMgJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0aGF0Qnl0ZSA9ICh0aGF0V29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhhdFNpZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzV29yZHNbKHRoaXNTaWdCeXRlcyArIGkpID4+PiAyXSA9IHRoYXRXb3Jkc1tpID4+PiAyXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB0aGlzLnNpZ0J5dGVzICs9IHRoYXRTaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gdGhpcy53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDbGFtcFxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB3b3Jkcy5sZW5ndGggPSBNYXRoLmNlaWwoc2lnQnl0ZXMgLyA0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IHdvcmRBcnJheS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IG5CeXRlcyBUaGUgbnVtYmVyIG9mIHJhbmRvbSBieXRlcyB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHJhbmRvbSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5yYW5kb20oMTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CeXRlczsgaSArPSA0KSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkcy5wdXNoKGNyeXB0b1NlY3VyZVJhbmRvbUludCgpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIG5CeXRlcyk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogSGV4IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmVuYy5IZXguc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XG5cdCAgICAgICAgICAgICAgICBoZXhDaGFycy5wdXNoKChiaXRlICYgMHgwZikudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBoZXhDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBoZXhTdHIgVGhlIGhleCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaGV4U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoZXhTdHJMZW5ndGggPSBoZXhTdHIubGVuZ3RoO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGV4U3RyTGVuZ3RoOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIExhdGluMSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIExhdGluMSA9IENfZW5jLkxhdGluMSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBsYXRpbjFTdHJpbmcgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIExhdGluMSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuTGF0aW4xLnBhcnNlKGxhdGluMVN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChsYXRpbjFTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXRpbjFTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMl0gfD0gKGxhdGluMVN0ci5jaGFyQ29kZUF0KGkpICYgMHhmZikgPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbGF0aW4xU3RyTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi04IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoZXNjYXBlKExhdGluMS5zdHJpbmdpZnkod29yZEFycmF5KSkpO1xuXHQgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBVVEYtOCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjhTdHIgVGhlIFVURi04IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjhTdHIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJ1ZmZlcmVkIGJsb2NrIGFsZ29yaXRobSB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBUaGUgcHJvcGVydHkgYmxvY2tTaXplIG11c3QgYmUgaW1wbGVtZW50ZWQgaW4gYSBjb25jcmV0ZSBzdWJ0eXBlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcblx0ICAgICAqL1xuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFJlc2V0cyB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGRhdGEgYnVmZmVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzID0gMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWRkcyBuZXcgZGF0YSB0byB0aGlzIGJsb2NrIGFsZ29yaXRobSdzIGJ1ZmZlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBhcHBlbmQuIFN0cmluZ3MgYXJlIGNvbnZlcnRlZCB0byBhIFdvcmRBcnJheSB1c2luZyBVVEYtOC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9hcHBlbmQ6IGZ1bmN0aW9uIChkYXRhKSB7XG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICBkYXRhID0gVXRmOC5wYXJzZShkYXRhKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcblx0ICAgICAgICAgICAgdGhpcy5fbkRhdGFCeXRlcyArPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQcm9jZXNzZXMgYXZhaWxhYmxlIGRhdGEgYmxvY2tzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBfZG9Qcm9jZXNzQmxvY2sob2Zmc2V0KSwgd2hpY2ggbXVzdCBiZSBpbXBsZW1lbnRlZCBieSBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcHJvY2Vzc2VkIGRhdGEuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xuXHQgICAgICAgICAqICAgICB2YXIgcHJvY2Vzc2VkRGF0YSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgdmFyIHByb2Nlc3NlZFdvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZSA9IHRoaXMuYmxvY2tTaXplO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplQnl0ZXMgPSBibG9ja1NpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJsb2NrcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbkJsb2Nrc1JlYWR5ID0gZGF0YVNpZ0J5dGVzIC8gYmxvY2tTaXplQnl0ZXM7XG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBSb3VuZCB1cCB0byBpbmNsdWRlIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBuQmxvY2tzUmVhZHkgPSBNYXRoLmNlaWwobkJsb2Nrc1JlYWR5KTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIGRvd24gdG8gaW5jbHVkZSBvbmx5IGZ1bGwgYmxvY2tzLFxuXHQgICAgICAgICAgICAgICAgLy8gbGVzcyB0aGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IG11c3QgcmVtYWluIGluIHRoZSBidWZmZXJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5Xb3Jkc1JlYWR5ID0gbkJsb2Nrc1JlYWR5ICogYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQnl0ZXNSZWFkeSA9IE1hdGgubWluKG5Xb3Jkc1JlYWR5ICogNCwgZGF0YVNpZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xuXHQgICAgICAgICAgICBpZiAobldvcmRzUmVhZHkpIHtcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IG5Xb3Jkc1JlYWR5OyBvZmZzZXQgKz0gYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLl9kb1Byb2Nlc3NCbG9jayhkYXRhV29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbW92ZSBwcm9jZXNzZWQgd29yZHNcblx0ICAgICAgICAgICAgICAgIHByb2Nlc3NlZFdvcmRzID0gZGF0YVdvcmRzLnNwbGljZSgwLCBuV29yZHNSZWFkeSk7XG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHByb2Nlc3NlZFdvcmRzLCBuQnl0ZXNSZWFkeSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uY2xvbmUoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX21pbkJ1ZmZlclNpemU6IDBcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgaGFzaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiAxNiAoNTEyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBIYXNoZXIgPSBDX2xpYi5IYXNoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgaGFzaCBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2hlciA9IENyeXB0b0pTLmFsZ28uU0hBMjU2LmNyZWF0ZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgaGFzaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgaGFzaGVyIHdpdGggYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0hhc2hlcn0gVGhpcyBoYXNoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBVcGRhdGUgdGhlIGhhc2hcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBmaW5hbGl6ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgLy8gRmluYWwgbWVzc2FnZSB1cGRhdGVcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2FwcGVuZChtZXNzYWdlVXBkYXRlKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXG5cdCAgICAgICAgICAgIHZhciBoYXNoID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDUxMi8zMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byBhIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5TSEEyNTYpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9jcmVhdGVIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byB1c2UgaW4gdGhpcyBITUFDIGhlbHBlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhtYWNIZWxwZXI6IGZ1bmN0aW9uIChoYXNoZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ19hbGdvLkhNQUMuaW5pdChoYXNoZXIsIGtleSkuZmluYWxpemUobWVzc2FnZSk7XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWxnb3JpdGhtIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xuXG5cdCAgICByZXR1cm4gQztcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlM7XG5cbn0pKTtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXG5cbi8qKiovIH0pLFxuLyogMTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcblxuXG5cbnZhciBDb25uZWN0aW9uRXJyb3IgPSB7XG5cdGRpc2Nvbm5lY3RlZDogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAwMyxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUnXG5cdH0pLFxuXHRzdXNwZW5kZWQ6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0Y29kZTogODAwMDIsXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIHVuYXZhaWxhYmxlJ1xuXHR9KSxcblx0ZmFpbGVkOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdGNvZGU6IDgwMDAwLFxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIGZhaWxlZCBvciBkaXNjb25uZWN0ZWQgYnkgc2VydmVyJ1xuXHR9KSxcblx0Y2xvc2luZzogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xuXHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRjb2RlOiA4MDAxNyxcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBjbG9zaW5nJ1xuXHR9KSxcblx0Y2xvc2VkOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNDAwLFxuXHRcdGNvZGU6IDgwMDE3LFxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIGNsb3NlZCdcblx0fSksXG5cdHVua25vd25Db25uZWN0aW9uRXJyOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0c3RhdHVzQ29kZTogNTAwLFxuXHRcdGNvZGU6IDUwMDAyLFxuXHRcdG1lc3NhZ2U6ICdJbnRlcm5hbCBjb25uZWN0aW9uIGVycm9yJ1xuXHR9KSxcblx0dW5rbm93bkNoYW5uZWxFcnI6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcblx0XHRzdGF0dXNDb2RlOiA1MDAsXG5cdFx0Y29kZTogNTAwMDEsXG5cdFx0bWVzc2FnZTogJ0ludGVybmFsIGNoYW5uZWwgZXJyb3InXG5cdH0pXG59O1xuXG5Db25uZWN0aW9uRXJyb3IuaXNSZXRyaWFibGUgPSBmdW5jdGlvbihlcnIpIHtcblx0aWYgKCFlcnIuc3RhdHVzQ29kZSB8fCAhZXJyLmNvZGUgfHwgZXJyLnN0YXR1c0NvZGUgPj0gNTAwKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblx0dmFyIHJldHJpYWJsZSA9IGZhbHNlO1xuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnZhbHVlc0FycmF5KENvbm5lY3Rpb25FcnJvcikuZm9yRWFjaChmdW5jdGlvbihjb25uRXJyKSB7XG5cdFx0aWYgKGNvbm5FcnIuY29kZSAmJiBjb25uRXJyLmNvZGUgPT0gZXJyLmNvZGUpIHtcblx0XHRcdHJldHJpYWJsZSA9IHRydWU7XG5cdFx0fVxuXHR9KTtcblx0cmV0dXJuIHJldHJpYWJsZTtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29ubmVjdGlvbkVycm9yKTtcblxuXG4vKioqLyB9KSxcbi8qIDE0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2xvZ2dlci5qc1xudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXG52YXIgcGxhdGZvcm1fYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2h0dHAuanNcbnZhciBodHRwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9tdWx0aWNhc3Rlci5qc1xudmFyIG11bHRpY2FzdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2J1ZmZlcnV0aWxzLmpzXG52YXIgYnVmZmVydXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8uanNcbnZhciBlcnJvcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvYmFzZTY0LmpzXG4vKlxuIENvcHlyaWdodCAoYykgMjAwOCBGcmVkIFBhbG1lciBmcmVkLnBhbG1lcl9hdF9nbWFpbC5jb21cblxuIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uXG4gb2J0YWluaW5nIGEgY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb25cbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcbiByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSxcbiBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nXG4gY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlXG4gaW5jbHVkZWQgaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELFxuIEVYUFJFU1MgT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFU1xuIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXG4gTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFRcbiBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSxcbiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcbiBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SXG4gT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuICovXG52YXIgQmFzZTY0ID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBTdHJpbmdCdWZmZXIoKVxuXHR7XG5cdFx0dGhpcy5idWZmZXIgPSBbXTtcblx0fVxuXG5cdFN0cmluZ0J1ZmZlci5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gYXBwZW5kKHN0cmluZylcblx0e1xuXHRcdHRoaXMuYnVmZmVyLnB1c2goc3RyaW5nKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fTtcblxuXHRTdHJpbmdCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuYnVmZmVyLmpvaW4oXCJcIik7XG5cdH07XG5cblx0dmFyIEJhc2U2NCA9XG5cdHtcblx0XHRjb2RleCA6IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz1cIixcblxuXHRcdGVuY29kZSA6IGZ1bmN0aW9uIChpbnB1dClcblx0XHR7XG5cdFx0XHR2YXIgb3V0cHV0ID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xuXHRcdFx0dmFyIGNvZGV4ID0gQmFzZTY0LmNvZGV4O1xuXG5cdFx0XHR2YXIgZW51bWVyYXRvciA9IG5ldyBVdGY4RW5jb2RlRW51bWVyYXRvcihpbnB1dCk7XG5cdFx0XHR3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY2hyMSA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdHZhciBjaHIyID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0dmFyIGNocjMgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0dmFyIGVuYzEgPSBjaHIxID4+IDI7XG5cdFx0XHRcdHZhciBlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KTtcblx0XHRcdFx0dmFyIGVuYzMgPSAoKGNocjIgJiAxNSkgPDwgMikgfCAoY2hyMyA+PiA2KTtcblx0XHRcdFx0dmFyIGVuYzQgPSBjaHIzICYgNjM7XG5cblx0XHRcdFx0aWYgKGlzTmFOKGNocjIpKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0ZW5jMyA9IGVuYzQgPSA2NDtcblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIGlmIChpc05hTihjaHIzKSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVuYzQgPSA2NDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdG91dHB1dC5hcHBlbmQoY29kZXguY2hhckF0KGVuYzEpICsgY29kZXguY2hhckF0KGVuYzIpICsgY29kZXguY2hhckF0KGVuYzMpICsgY29kZXguY2hhckF0KGVuYzQpKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG91dHB1dC50b1N0cmluZygpO1xuXHRcdH0sXG5cblx0XHRkZWNvZGUgOiBmdW5jdGlvbiAoaW5wdXQpXG5cdFx0e1xuXHRcdFx0dmFyIG91dHB1dCA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcblxuXHRcdFx0dmFyIGVudW1lcmF0b3IgPSBuZXcgQmFzZTY0RGVjb2RlRW51bWVyYXRvcihpbnB1dCk7XG5cdFx0XHR3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgY2hhckNvZGUgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0aWYgKGNoYXJDb2RlIDwgMTI4KVxuXHRcdFx0XHRcdG91dHB1dC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkpO1xuXHRcdFx0XHRlbHNlIGlmICgoY2hhckNvZGUgPiAxOTEpICYmIChjaGFyQ29kZSA8IDIyNCkpXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XG5cdFx0XHRcdFx0dmFyIGNoYXJDb2RlMiA9IGVudW1lcmF0b3IuY3VycmVudDtcblxuXHRcdFx0XHRcdG91dHB1dC5hcHBlbmQoU3RyaW5nLmZyb21DaGFyQ29kZSgoKGNoYXJDb2RlICYgMzEpIDw8IDYpIHwgKGNoYXJDb2RlMiAmIDYzKSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcblx0XHRcdFx0XHR2YXIgY2hhckNvZGUyID0gZW51bWVyYXRvci5jdXJyZW50O1xuXG5cdFx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xuXHRcdFx0XHRcdHZhciBjaGFyQ29kZTMgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XG5cblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoKChjaGFyQ29kZSAmIDE1KSA8PCAxMikgfCAoKGNoYXJDb2RlMiAmIDYzKSA8PCA2KSB8IChjaGFyQ29kZTMgJiA2MykpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb3V0cHV0LnRvU3RyaW5nKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIFV0ZjhFbmNvZGVFbnVtZXJhdG9yKGlucHV0KVxuXHR7XG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcblx0XHR0aGlzLl9pbmRleCA9IC0xO1xuXHRcdHRoaXMuX2J1ZmZlciA9IFtdO1xuXHR9XG5cblx0VXRmOEVuY29kZUVudW1lcmF0b3IucHJvdG90eXBlID1cblx0e1xuXHRcdGN1cnJlbnQ6IE51bWJlci5OYU4sXG5cblx0XHRtb3ZlTmV4dDogZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9idWZmZXIubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gdGhpcy5fYnVmZmVyLnNoaWZ0KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodGhpcy5faW5kZXggPj0gKHRoaXMuX2lucHV0Lmxlbmd0aCAtIDEpKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBOdW1iZXIuTmFOO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRlbHNlXG5cdFx0XHR7XG5cdFx0XHRcdHZhciBjaGFyQ29kZSA9IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQoKyt0aGlzLl9pbmRleCk7XG5cblx0XHRcdFx0Ly8gXCJcXHJcXG5cIiAtPiBcIlxcblwiXG5cdFx0XHRcdC8vXG5cdFx0XHRcdGlmICgoY2hhckNvZGUgPT0gMTMpICYmICh0aGlzLl9pbnB1dC5jaGFyQ29kZUF0KHRoaXMuX2luZGV4ICsgMSkgPT0gMTApKVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y2hhckNvZGUgPSAxMDtcblx0XHRcdFx0XHR0aGlzLl9pbmRleCArPSAyO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGNoYXJDb2RlIDwgMTI4KVxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gY2hhckNvZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSBpZiAoKGNoYXJDb2RlID4gMTI3KSAmJiAoY2hhckNvZGUgPCAyMDQ4KSlcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3VycmVudCA9IChjaGFyQ29kZSA+PiA2KSB8IDE5Mjtcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaCgoY2hhckNvZGUgJiA2MykgfCAxMjgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGVsc2Vcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuY3VycmVudCA9IChjaGFyQ29kZSA+PiAxMikgfCAyMjQ7XG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goKChjaGFyQ29kZSA+PiA2KSAmIDYzKSB8IDEyOCk7XG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goKGNoYXJDb2RlICYgNjMpIHwgMTI4KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBCYXNlNjREZWNvZGVFbnVtZXJhdG9yKGlucHV0KVxuXHR7XG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcblx0XHR0aGlzLl9pbmRleCA9IC0xO1xuXHRcdHRoaXMuX2J1ZmZlciA9IFtdO1xuXHR9XG5cblx0QmFzZTY0RGVjb2RlRW51bWVyYXRvci5wcm90b3R5cGUgPVxuXHR7XG5cdFx0Y3VycmVudDogNjQsXG5cblx0XHRtb3ZlTmV4dDogZnVuY3Rpb24oKVxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9idWZmZXIubGVuZ3RoID4gMClcblx0XHRcdHtcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gdGhpcy5fYnVmZmVyLnNoaWZ0KCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZiAodGhpcy5faW5kZXggPj0gKHRoaXMuX2lucHV0Lmxlbmd0aCAtIDEpKVxuXHRcdFx0e1xuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSA2NDtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0ZWxzZVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgZW5jMSA9IEJhc2U2NC5jb2RleC5pbmRleE9mKHRoaXMuX2lucHV0LmNoYXJBdCgrK3RoaXMuX2luZGV4KSk7XG5cdFx0XHRcdHZhciBlbmMyID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcblx0XHRcdFx0dmFyIGVuYzMgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xuXHRcdFx0XHR2YXIgZW5jNCA9IEJhc2U2NC5jb2RleC5pbmRleE9mKHRoaXMuX2lucHV0LmNoYXJBdCgrK3RoaXMuX2luZGV4KSk7XG5cblx0XHRcdFx0dmFyIGNocjEgPSAoZW5jMSA8PCAyKSB8IChlbmMyID4+IDQpO1xuXHRcdFx0XHR2YXIgY2hyMiA9ICgoZW5jMiAmIDE1KSA8PCA0KSB8IChlbmMzID4+IDIpO1xuXHRcdFx0XHR2YXIgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcblxuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBjaHIxO1xuXG5cdFx0XHRcdGlmIChlbmMzICE9IDY0KVxuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKGNocjIpO1xuXG5cdFx0XHRcdGlmIChlbmM0ICE9IDY0KVxuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKGNocjMpO1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gQmFzZTY0O1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmFzZTY0ID0gKEJhc2U2NCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2J1aWxkL2htYWMtc2hhMjU2LmpzXG52YXIgaG1hY19zaGEyNTYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcbnZhciBobWFjX3NoYTI1Nl9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihobWFjX3NoYTI1Nik7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2J1aWxkL2VuYy1iYXNlNjQuanNcbnZhciBlbmNfYmFzZTY0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvYXV0aC5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciBhdXRoX0F1dGggPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBNQVhfVE9LRU5fTEVOR1RIID0gTWF0aC5wb3coMiwgMTcpO1xuXHRmdW5jdGlvbiBub29wKCkge31cblx0ZnVuY3Rpb24gcmFuZG9tKCkgeyByZXR1cm4gKCcwMDAwMDAnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMUUxNikpLnNsaWNlKC0xNik7IH1cblx0ZnVuY3Rpb24gbm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSB7XG5cdFx0LyogQSBjbGllbnQgYXV0aCBjYWxsYmFjayBtYXkgZ2l2ZSBlcnJvcnMgaW4gYW55IG51bWJlciBvZiBmb3JtYXRzOyBub3JtYWxpc2UgdG8gYW4gZXJyb3JpbmZvICovXG5cdFx0aWYoIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzRXJyb3JJbmZvKGVycikpIHtcblx0XHRcdHJldHVybiBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpLCBlcnIuY29kZSB8fCA0MDE3MCwgZXJyLnN0YXR1c0NvZGUgfHwgNDAxKTtcblx0XHR9XG5cdFx0LyogbmV0d29yayBlcnJvcnMgd2lsbCBub3QgaGF2ZSBhbiBpbmhlcmVudCBlcnJvciBjb2RlICovXG5cdFx0aWYoIWVyci5jb2RlKSB7XG5cdFx0XHRpZihlcnIuc3RhdHVzQ29kZSA9PT0gNDAzKSB7XG5cdFx0XHRcdGVyci5jb2RlID0gNDAzMDA7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlcnIuY29kZSA9IDQwMTcwO1xuXHRcdFx0XHQvKiBub3JtYWxpc2Ugc3RhdHVzQ29kZSB0byA0MDEgcGVyIFJTQTRlICovXG5cdFx0XHRcdGVyci5zdGF0dXNDb2RlID0gNDAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZXJyO1xuXHR9XG5cblx0dmFyIGhtYWMsIHRvQmFzZTY0O1xuXHRpZihwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNyZWF0ZUhtYWMpIHtcblx0XHR0b0Jhc2U2NCA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gKEJ1ZmZlci5mcm9tKHN0ciwgJ2FzY2lpJykpLnRvU3RyaW5nKCdiYXNlNjQnKTsgfTtcblx0XHRobWFjID0gZnVuY3Rpb24odGV4dCwga2V5KSB7XG5cdFx0XHR2YXIgaW5zdCA9IHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY3JlYXRlSG1hYygnU0hBMjU2Jywga2V5KTtcblx0XHRcdGluc3QudXBkYXRlKHRleHQpO1xuXHRcdFx0cmV0dXJuIGluc3QuZGlnZXN0KCdiYXNlNjQnKTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdHRvQmFzZTY0ID0gYmFzZTY0LmVuY29kZTtcblx0XHRobWFjID0gZnVuY3Rpb24odGV4dCwga2V5KSB7XG5cdFx0XHRyZXR1cm4gT2JqZWN0KGVuY19iYXNlNjRbXCJzdHJpbmdpZnlcIl0pKGhtYWNfc2hhMjU2X2RlZmF1bHQoKSh0ZXh0LCBrZXkpKTtcblx0XHR9O1xuXHR9XG5cblx0ZnVuY3Rpb24gYzE0bihjYXBhYmlsaXR5KSB7XG5cdFx0aWYoIWNhcGFiaWxpdHkpXG5cdFx0XHRyZXR1cm4gJyc7XG5cblx0XHRpZih0eXBlb2YoY2FwYWJpbGl0eSkgPT0gJ3N0cmluZycpXG5cdFx0XHRjYXBhYmlsaXR5ID0gSlNPTi5wYXJzZShjYXBhYmlsaXR5KTtcblxuXHRcdHZhciBjMTRuQ2FwYWJpbGl0eSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dmFyIGtleXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5rZXlzQXJyYXkoY2FwYWJpbGl0eSwgdHJ1ZSk7XG5cdFx0aWYoIWtleXMpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0a2V5cy5zb3J0KCk7XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdGMxNG5DYXBhYmlsaXR5W2tleXNbaV1dID0gY2FwYWJpbGl0eVtrZXlzW2ldXS5zb3J0KCk7XG5cdFx0fVxuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShjMTRuQ2FwYWJpbGl0eSk7XG5cdH1cblxuXHRmdW5jdGlvbiBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZChhdXRoT3B0aW9ucykge1xuXHRcdGlmKGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLmtleSkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nJyk7XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5Jyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtc2cgPSAnYXV0aE9wdGlvbnMgbXVzdCBpbmNsdWRlIHZhbGlkIGF1dGhlbnRpY2F0aW9uIHBhcmFtZXRlcnMnO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcblx0XHRcdHRocm93IG5ldyBFcnJvcihtc2cpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSB7XG5cdFx0cmV0dXJuICd1c2VUb2tlbkF1dGgnIGluIG9wdGlvbnMgJiYgIW9wdGlvbnMudXNlVG9rZW5BdXRoO1xuXHR9XG5cblx0LyogUlNBNCAqL1xuXHRmdW5jdGlvbiB1c2VUb2tlbkF1dGgob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLnVzZVRva2VuQXV0aCB8fFxuXHRcdFx0KCFiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykgJiZcblx0XHRcdCAob3B0aW9ucy5hdXRoQ2FsbGJhY2sgfHxcblx0XHRcdCAgb3B0aW9ucy5hdXRoVXJsICAgICAgfHxcblx0XHRcdCAgb3B0aW9ucy50b2tlbiAgICAgICAgfHxcblx0XHRcdCAgb3B0aW9ucy50b2tlbkRldGFpbHMpKVxuXHR9XG5cblx0LyogUlNBNGEgKi9cblx0ZnVuY3Rpb24gbm9XYXlUb1JlbmV3KG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gIW9wdGlvbnMua2V5ICYmXG5cdFx0XHQhb3B0aW9ucy5hdXRoQ2FsbGJhY2sgJiZcblx0XHRcdCFvcHRpb25zLmF1dGhVcmw7XG5cdH1cblxuXHR2YXIgdHJJZCA9IDA7XG5cdGZ1bmN0aW9uIGdldFRva2VuUmVxdWVzdElkKCkge1xuXHRcdHJldHVybiB0cklkKys7XG5cdH1cblxuXHRmdW5jdGlvbiBBdXRoKGNsaWVudCwgb3B0aW9ucykge1xuXHRcdHRoaXMuY2xpZW50ID0gY2xpZW50O1xuXHRcdHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcblx0XHQvKiBUaGUgaWQgb2YgdGhlIGN1cnJlbnQgdG9rZW4gcmVxdWVzdCBpZiBvbmUgaXMgaW4gcHJvZ3Jlc3MsIGVsc2UgbnVsbCAqL1xuXHRcdHRoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcblx0XHR0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuXG5cdFx0aWYodXNlVG9rZW5BdXRoKG9wdGlvbnMpKSB7XG5cdFx0XHQvKiBUb2tlbiBhdXRoICovXG5cdFx0XHRpZihvcHRpb25zLmtleSAmJiAhaG1hYykge1xuXHRcdFx0XHR2YXIgbXNnID0gJ2NsaWVudC1zaWRlIHRva2VuIHJlcXVlc3Qgc2lnbmluZyBub3Qgc3VwcG9ydGVkJztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0XHR9XG5cdFx0XHRpZihub1dheVRvUmVuZXcob3B0aW9ucykpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgJ1dhcm5pbmc6IGxpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwJyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zYXZlVG9rZW5PcHRpb25zKG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zLCBvcHRpb25zKTtcblx0XHRcdGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKHRoaXMuYXV0aE9wdGlvbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBCYXNpYyBhdXRoICovXG5cdFx0XHRpZighb3B0aW9ucy5rZXkpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdObyBhdXRoZW50aWNhdGlvbiBvcHRpb25zIHByb3ZpZGVkOyBuZWVkIG9uZSBvZjoga2V5LCBhdXRoVXJsLCBvciBhdXRoQ2FsbGJhY2sgKG9yIGZvciB0ZXN0aW5nIG9ubHksIHRva2VuIG9yIHRva2VuRGV0YWlscyknO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNjAsIDQwMSk7XG5cdFx0XHR9XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAnYW5vbnltb3VzLCB1c2luZyBiYXNpYyBhdXRoJyk7XG5cdFx0XHR0aGlzLl9zYXZlQmFzaWNPcHRpb25zKG9wdGlvbnMpO1xuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQgKiBJbnN0cnVjdHMgdGhlIGxpYnJhcnkgdG8gZ2V0IGEgdG9rZW4gaW1tZWRpYXRlbHkgYW5kIGVuc3VyZXMgVG9rZW4gQXV0aFxuXHQgKiBpcyB1c2VkIGZvciBhbGwgZnV0dXJlIHJlcXVlc3RzLCBzdG9yaW5nIHRoZSB0b2tlblBhcmFtcyBhbmQgYXV0aE9wdGlvbnNcblx0ICogZ2l2ZW4gYXMgdGhlIG5ldyBkZWZhdWx0cyBmb3Igc3Vic2VxdWVudCB1c2UuXG5cdCAqXG5cdCAqIEBwYXJhbSB0b2tlblBhcmFtc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcblx0ICpcblx0ICogLSB0dGw6ICAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiBhbnkgbmV3IHRva2VuIGluIG1zLiBJZiBub25lXG5cdCAqICAgICAgICAgICAgICAgaXMgc3BlY2lmaWVkIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lXG5cdCAqICAgICAgICAgICAgICAgaXMgMjRob3VyczsgYW55IHJlcXVlc3QgZXhjZWVlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWRcblx0ICogICAgICAgICAgICAgICB3aXRoIGFuIGVycm9yLlxuXHQgKlxuXHQgKiAtIGNhcGFiaWxpdHk6IChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cblx0ICogICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcblx0ICogICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG5cdCAqXG5cdCAqIC0gY2xpZW50SWQ6ICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW5cblx0ICpcblx0ICogLSB0aW1lc3RhbXA6ICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG5cdCAqICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyBhdXRoIG9wdGlvbnMgcmVsZXZhbnQgdG8gdG9rZW4gYXV0aDpcblx0ICpcblx0ICogLSBxdWVyeVRpbWUgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBBYmx5IHN5c3RlbSBzaG91bGQgYmVcblx0ICogICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseS5cblx0ICpcblx0ICogLSB0b2tlbkRldGFpbHM6IChvcHRpb25hbCkgb2JqZWN0OiBBbiBhdXRoZW50aWNhdGVkIFRva2VuRGV0YWlscyBvYmplY3QuXG5cdCAqXG5cdCAqIC0gdG9rZW46ICAgICAgICAob3B0aW9uYWwpIHN0cmluZzogdGhlIGB0b2tlbmAgcHJvcGVydHkgb2YgYSB0b2tlbkRldGFpbHMgb2JqZWN0XG5cdCAqXG5cdCAqIC0gYXV0aENhbGxiYWNrOiAgKG9wdGlvbmFsKSBhIEphdmFTY3JpcHQgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIHRvIGdldCBhdXRoIGluZm9ybWF0aW9uLlxuXHQgKiAgICAgICAgICAgICAgICAgIGF1dGhDYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbiBvZiAodG9rZW5QYXJhbXMsIGNhbGxiYWNrKSB0aGF0IGNhbGxzXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIGNhbGxiYWNrIHdpdGggKGVyciwgcmVzdWx0KSwgd2hlcmUgcmVzdWx0IGlzIGFueSBvZjpcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW5SZXF1ZXN0IG9iamVjdCAoaWUgdGhlIHJlc3VsdCBvZiBhIHJlc3QuYXV0aC5jcmVhdGVUb2tlblJlcXVlc3QgY2FsbCksXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuRGV0YWlscyBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGgucmVxdWVzdFRva2VuIGNhbGwpLFxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbiBzdHJpbmdcblx0ICpcblx0ICogLSBhdXRoVXJsOiAgICAgICAob3B0aW9uYWwpIGEgVVJMIHRvIGJlIHVzZWQgdG8gR0VUIG9yIFBPU1QgYSBzZXQgb2YgdG9rZW4gcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIHBhcmFtcywgdG8gb2J0YWluIGEgc2lnbmVkIHRva2VuIHJlcXVlc3QuXG5cdCAqXG5cdCAqIC0gYXV0aEhlYWRlcnM6ICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBoZWFkZXJzIHRvIGJlIGFkZGVkIHRvIGFueSByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgbWFkZSB0byB0aGUgYXV0aFVybC5cblx0ICpcblx0ICogLSBhdXRoUGFyYW1zOiAgICAob3B0aW9uYWwpIGEgc2V0IG9mIGFwcGxpY2F0aW9uLXNwZWNpZmljIHF1ZXJ5IHBhcmFtcyB0byBiZSBhZGRlZCB0byBhbnlcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0IG1hZGUgdG8gdGhlIGF1dGhVcmwuXG5cdCAqXG5cdCAqXG5cdCAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3Rcblx0ICpcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHRva2VuRGV0YWlscylcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmF1dGhvcml6ZSA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuXHRcdGlmKHR5cGVvZih0b2tlblBhcmFtcykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcblx0XHR9IGVsc2UgaWYodHlwZW9mKGF1dGhPcHRpb25zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2F1dGhvcml6ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8qIFJTQTEwYTogYXV0aG9yaXplKCkgY2FsbCBpbXBsaWVzIHRva2VuIGF1dGguIElmIGEga2V5IGlzIHBhc3NlZCBpdCwgd2Vcblx0XHQgKiBqdXN0IGNoZWNrIGlmIGl0IGRvZXNuJ3QgY2xhc2ggYW5kIGFzc3VtZSB3ZSdyZSBnZW5lcmF0aW5nIGEgdG9rZW4gZnJvbSBpdCAqL1xuXHRcdGlmKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLmtleSAmJiAodGhpcy5hdXRoT3B0aW9ucy5rZXkgIT09IGF1dGhPcHRpb25zLmtleSkpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byB1cGRhdGUgYXV0aCBvcHRpb25zIHdpdGggaW5jb21wYXRpYmxlIGtleScsIDQwMTAyLCA0MDEpO1xuXHRcdH1cblxuXHRcdGlmKGF1dGhPcHRpb25zICYmICgnZm9yY2UnIGluIGF1dGhPcHRpb25zKSkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5hdXRob3JpemUnLCAnRGVwcmVjYXRpb24gd2FybmluZzogc3BlY2lmeWluZyB7Zm9yY2U6IHRydWV9IGluIGF1dGhPcHRpb25zIGlzIG5vIGxvbmdlciBuZWNlc3NhcnksIGF1dGhvcml6ZSgpIG5vdyBhbHdheXMgZ2V0cyBhIG5ldyB0b2tlbi4gUGxlYXNlIHJlbW92ZSB0aGlzLCBhcyBpbiB2ZXJzaW9uIDEuMCBhbmQgbGF0ZXIsIGhhdmluZyBhIG5vbi1udWxsIGF1dGhPcHRpb25zIHdpbGwgb3ZlcndyaXRlIHN0b3JlZCBsaWJyYXJ5IGF1dGhPcHRpb25zLCB3aGljaCBtYXkgbm90IGJlIHdoYXQgeW91IHdhbnQnKTtcblx0XHRcdC8qIEVtdWxhdGUgdGhlIG9sZCBiZWhhdmlvdXI6IGlmICdmb3JjZScgd2FzIHRoZSBvbmx5IG1lbWJlciBvZiBhdXRoT3B0aW9ucyxcblx0XHRcdCAqIHNldCBpdCB0byBudWxsIHNvIGl0IGRvZXNuJ3Qgb3ZlcndyaXRlIHN0b3JlZC4gVE9ETzogcmVtb3ZlIGluIHZlcnNpb24gMS4wICovXG5cdFx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc09ubHlQcm9wSW4oYXV0aE9wdGlvbnMsICdmb3JjZScpKSB7XG5cdFx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLl9mb3JjZU5ld1Rva2VuKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRpZihzZWxmLmNsaWVudC5jb25uZWN0aW9uKSB7XG5cdFx0XHRcdFx0LyogV2UgaW50ZXJwcmV0IFJTQTRkIGFzIGluY2x1ZGluZyByZXF1ZXN0cyBtYWRlIGJ5IGEgY2xpZW50IGxpYiB0b1xuXHRcdFx0XHRcdCAqIGF1dGhlbnRpY2F0ZSB0cmlnZ2VyZWQgYnkgYW4gZXhwbGljaXQgYXV0aG9yaXplKCkgb3IgYW4gQVVUSCByZWNlaXZlZCBmcm9tXG5cdFx0XHRcdFx0ICogYWJseSwgbm90IGp1c3QgY29ubmVjdC1zZXF1ZW5jZS10cmlnZ2VyZWQgdG9rZW4gZmV0Y2hlcyAqL1xuXHRcdFx0XHRcdHNlbGYuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIFJUQzhcblx0XHRcdCAqIC0gV2hlbiBhdXRob3JpemUgY2FsbGVkIGJ5IGFuIGVuZCB1c2VyIGFuZCBoYXZlIGEgcmVhbHRpbWUgY29ubmVjdGlvbixcblx0XHRcdCAqIGRvbid0IGNhbGwgYmFjayB0aWxsIG5ldyB0b2tlbiBoYXMgdGFrZW4gZWZmZWN0LlxuXHRcdFx0ICogLSBVc2Ugc2VsZi5jbGllbnQuY29ubmVjdGlvbiBhcyBhIHByb3h5IGZvciAoc2VsZi5jbGllbnQgaW5zdGFuY2VvZiBSZWFsdGltZSksXG5cdFx0XHQgKiB3aGljaCBkb2Vzbid0IHdvcmsgaW4gbm9kZSBhcyBSZWFsdGltZSBpc24ndCBwYXJ0IG9mIHRoZSB2bSBjb250ZXh0IGZvciBSZXN0IGNsaWVudHMgKi9cblx0XHRcdGlmKHNlbGYuY2xpZW50LmNvbm5lY3Rpb24pIHtcblx0XHRcdFx0c2VsZi5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscywgY2FsbGJhY2spO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcblx0XHRcdH1cblx0XHR9KVxuXHR9O1xuXG5cdEF1dGgucHJvdG90eXBlLmF1dGhvcmlzZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdBdXRoLmF1dGhvcmlzZScsICdBdXRoLmF1dGhvcml6ZScpO1xuXHRcdHRoaXMuYXV0aG9yaXplLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0LyogRm9yIGludGVybmFsIHVzZSwgZWcgYnkgY29ubmVjdGlvbk1hbmFnZXIgLSB1c2VmdWwgd2hlbiB3YW50IHRvIGNhbGwgYmFja1xuXHQgKiBhcyBzb29uIGFzIHdlIGhhdmUgdGhlIG5ldyB0b2tlbiwgcmF0aGVyIHRoYW4gd2FpdGluZyBmb3IgaXQgdG8gdGFrZVxuXHQgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXG5cdEF1dGgucHJvdG90eXBlLl9mb3JjZU5ld1Rva2VuID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblxuXHRcdC8qIGdldCByaWQgb2YgY3VycmVudCB0b2tlbiBldmVuIGlmIHN0aWxsIHZhbGlkICovXG5cdFx0dGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xuXG5cdFx0LyogX3NhdmUgbm9ybWFsaXNlcyB0aGUgdG9rZW5QYXJhbXMgYW5kIGF1dGhPcHRpb25zIGFuZCB1cGRhdGVzIHRoZSBhdXRoXG5cdFx0ICogb2JqZWN0LiBBbGwgc3Vic2VxdWVudCBvcGVyYXRpb25zIHNob3VsZCB1c2UgdGhlIHZhbHVlcyBvbiBgdGhpc2AsXG5cdFx0ICogbm90IHRoZSBwYXNzZWQgaW4gb25lcy4gKi9cblx0XHR0aGlzLl9zYXZlVG9rZW5PcHRpb25zKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucyk7XG5cblx0XHRsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcblxuXHRcdHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKHRydWUsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XG5cdFx0XHQvKiBSU0ExMGcgKi9cblx0XHRcdGRlbGV0ZSBzZWxmLnRva2VuUGFyYW1zLnRpbWVzdGFtcDtcblx0XHRcdGRlbGV0ZSBzZWxmLmF1dGhPcHRpb25zLnF1ZXJ5VGltZTtcblx0XHRcdGNhbGxiYWNrKGVyciwgdG9rZW5EZXRhaWxzKTtcblx0XHR9KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBSZXF1ZXN0IGFuIGFjY2VzcyB0b2tlblxuXHQgKiBAcGFyYW0gYXV0aE9wdGlvbnNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3Qgb3B0aW9uczpcblx0ICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS5cblx0ICpcblx0ICogLSBhdXRoQ2FsbGJhY2s6ICAob3B0aW9uYWwpIGEgSmF2YVNjcmlwdCBjYWxsYmFjayB0byBiZSBjYWxsZWQgdG8gZ2V0IGF1dGggaW5mb3JtYXRpb24uXG5cdCAqICAgICAgICAgICAgICAgICAgYXV0aENhbGxiYWNrIHNob3VsZCBiZSBhIGZ1bmN0aW9uIG9mICh0b2tlblBhcmFtcywgY2FsbGJhY2spIHRoYXQgY2FsbHNcblx0ICogICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgd2l0aCAoZXJyLCByZXN1bHQpLCB3aGVyZSByZXN1bHQgaXMgYW55IG9mOlxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlblJlcXVlc3Qgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLmNyZWF0ZVRva2VuUmVxdWVzdCBjYWxsKSxcblx0ICogICAgICAgICAgICAgICAgICAtIGEgdG9rZW5EZXRhaWxzIG9iamVjdCAoaWUgdGhlIHJlc3VsdCBvZiBhIHJlc3QuYXV0aC5yZXF1ZXN0VG9rZW4gY2FsbCksXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuIHN0cmluZ1xuXHQgKlxuXHQgKiAtIGF1dGhVcmw6ICAgICAgIChvcHRpb25hbCkgYSBVUkwgdG8gYmUgdXNlZCB0byBHRVQgb3IgUE9TVCBhIHNldCBvZiB0b2tlbiByZXF1ZXN0XG5cdCAqICAgICAgICAgICAgICAgICAgcGFyYW1zLCB0byBvYnRhaW4gYSBzaWduZWQgdG9rZW4gcmVxdWVzdC5cblx0ICpcblx0ICogLSBhdXRoSGVhZGVyczogICAob3B0aW9uYWwpIGEgc2V0IG9mIGFwcGxpY2F0aW9uLXNwZWNpZmljIGhlYWRlcnMgdG8gYmUgYWRkZWQgdG8gYW55IHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBtYWRlIHRvIHRoZSBhdXRoVXJsLlxuXHQgKlxuXHQgKiAtIGF1dGhQYXJhbXM6ICAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgcXVlcnkgcGFyYW1zIHRvIGJlIGFkZGVkIHRvIGFueVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3QgbWFkZSB0byB0aGUgYXV0aFVybC5cblx0ICpcblx0ICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcblx0ICogICAgICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseVxuXHQgKlxuXHQgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG5cdCAqXG5cdCAqIEBwYXJhbSB0b2tlblBhcmFtc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcblx0ICogLSB0dGw6ICAgICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIHRoZSB0b2tlbiBpbiBtaWxsaXNlY29uZHMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG5cdCAqICAgICAgICAgICAgICAgICAgYSBkZWZhdWx0IG9mIDEgaG91ciBpcyBwcm92aWRlZC4gVGhlIG1heGltdW0gbGlmZXRpbWUgaXMgMjRob3VyczsgYW55IHJlcXVlc3Rcblx0ICogICAgICAgICAgICAgICAgICBleGNlZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuXHQgKlxuXHQgKiAtIGNhcGFiaWxpdHk6ICAgIChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cblx0ICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcblx0ICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXG5cdCAqXG5cdCAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuXHQgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcblx0ICpcblx0ICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXG5cdCAqXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCB0b2tlbkRldGFpbHMpXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5yZXF1ZXN0VG9rZW4gPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0Lyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cblx0XHRpZih0eXBlb2YodG9rZW5QYXJhbXMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xuXHRcdFx0YXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZW9mKGF1dGhPcHRpb25zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYoIWNhbGxiYWNrICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlcXVlc3RUb2tlbicsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0LyogUlNBOGU6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXG5cdFx0YXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuXHRcdHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uY29weSh0aGlzLnRva2VuUGFyYW1zKTtcblx0XHRjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG5cblx0XHQvKiBmaXJzdCBzZXQgdXAgd2hhdGV2ZXIgY2FsbGJhY2sgd2lsbCBiZSB1c2VkIHRvIGdldCBzaWduZWRcblx0XHQgKiB0b2tlbiByZXF1ZXN0cyAqL1xuXHRcdHZhciB0b2tlblJlcXVlc3RDYWxsYmFjaywgY2xpZW50ID0gdGhpcy5jbGllbnQ7XG5cblx0XHRpZihhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFjaycpO1xuXHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLmF1dGhVcmwpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhVcmwnKTtcblx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xuXHRcdFx0XHR2YXIgYXV0aEhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7YWNjZXB0OiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbid9LCBhdXRoT3B0aW9ucy5hdXRoSGVhZGVycyksXG5cdFx0XHRcdFx0dXNlUG9zdCA9IGF1dGhPcHRpb25zLmF1dGhNZXRob2QgJiYgYXV0aE9wdGlvbnMuYXV0aE1ldGhvZC50b0xvd2VyQ2FzZSgpID09PSAncG9zdCc7XG5cdFx0XHRcdGlmKCF1c2VQb3N0KSB7XG5cdFx0XHRcdFx0LyogQ29tYmluZSBhdXRoUGFyYW1zIHdpdGggYW55IHFzIHBhcmFtcyBnaXZlbiBpbiB0aGUgYXV0aFVybCAqL1xuXHRcdFx0XHRcdHZhciBxdWVyeUlkeCA9IGF1dGhPcHRpb25zLmF1dGhVcmwuaW5kZXhPZignPycpO1xuXHRcdFx0XHRcdGlmKHF1ZXJ5SWR4ID4gLTEpIHtcblx0XHRcdFx0XHRcdHZhciBwcm92aWRlZFFzUGFyYW1zID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucGFyc2VRdWVyeVN0cmluZyhhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG5cdFx0XHRcdFx0XHRhdXRoT3B0aW9ucy5hdXRoVXJsID0gYXV0aE9wdGlvbnMuYXV0aFVybC5zbGljZSgwLCBxdWVyeUlkeCk7XG5cdFx0XHRcdFx0XHQvKiBJbiBjYXNlIG9mIGNvbmZsaWN0LCBhdXRoUGFyYW1zIHRha2UgcHJlY2VkZW5jZSBvdmVyIHFzIHBhcmFtcyBpbiB0aGUgYXV0aFVybCAqL1xuXHRcdFx0XHRcdFx0YXV0aE9wdGlvbnMuYXV0aFBhcmFtcyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHByb3ZpZGVkUXNQYXJhbXMsIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHQvKiBSU0E4YzIgKi9cblx0XHRcdFx0dmFyIGF1dGhQYXJhbXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7fSwgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyB8fCB7fSwgcGFyYW1zKTtcblx0XHRcdFx0dmFyIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRcdFx0dmFyIGNvbnRlbnRUeXBlO1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQgRXJyb3I6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRlbnRUeXBlID0gaGVhZGVyc1snY29udGVudC10eXBlJ107XG5cdFx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlY2VpdmVkOyBjb250ZW50LXR5cGU6ICcgKyBjb250ZW50VHlwZSArICc7IGJvZHk6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0Qm9keShib2R5KSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKGVyciB8fCB1bnBhY2tlZCkgcmV0dXJuIGNiKGVyciwgYm9keSk7XG5cdFx0XHRcdFx0aWYoYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNCdWZmZXIoYm9keSkpIGJvZHkgPSBib2R5LnRvU3RyaW5nKCk7XG5cdFx0XHRcdFx0aWYoIWNvbnRlbnRUeXBlKSB7XG5cdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdhdXRoVXJsIHJlc3BvbnNlIGlzIG1pc3NpbmcgYSBjb250ZW50LXR5cGUgaGVhZGVyJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIganNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xLFxuXHRcdFx0XHRcdFx0dGV4dCA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2p3dCcpID4gLTE7XG5cdFx0XHRcdFx0aWYoIWpzb24gJiYgIXRleHQpIHtcblx0XHRcdFx0XHRcdGNiKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2F1dGhVcmwgcmVzcG9uZGVkIHdpdGggdW5hY2NlcHRhYmxlIGNvbnRlbnQtdHlwZSAnICsgY29udGVudFR5cGUgKyAnLCBzaG91bGQgYmUgZWl0aGVyIHRleHQvcGxhaW4sIGFwcGxpY2F0aW9uL2p3dCBvciBhcHBsaWNhdGlvbi9qc29uJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihqc29uKSB7XG5cdFx0XHRcdFx0XHRpZihib2R5Lmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcblx0XHRcdFx0XHRcdFx0Y2IobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnYXV0aFVybCByZXNwb25zZSBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCcsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdFx0Ym9keSA9IEpTT04ucGFyc2UoYm9keSk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0XHRcdFx0Y2IobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5leHBlY3RlZCBlcnJvciBwcm9jZXNzaW5nIGF1dGhVUkwgcmVzcG9uc2U7IGVyciA9ICcgKyBlLm1lc3NhZ2UsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYihudWxsLCBib2R5LCBjb250ZW50VHlwZSk7XG5cdFx0XHRcdH07XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVxdWVzdGluZyB0b2tlbiBmcm9tICcgKyBhdXRoT3B0aW9ucy5hdXRoVXJsICsgJzsgUGFyYW1zOiAnICsgSlNPTi5zdHJpbmdpZnkoYXV0aFBhcmFtcykgKyAnOyBtZXRob2Q6ICcgKyAodXNlUG9zdCA/ICdQT1NUJyA6ICdHRVQnKSk7XG5cdFx0XHRcdGlmKHVzZVBvc3QpIHtcblx0XHRcdFx0XHQvKiBzZW5kIGJvZHkgZm9ybS1lbmNvZGVkICovXG5cdFx0XHRcdFx0dmFyIGhlYWRlcnMgPSBhdXRoSGVhZGVycyB8fCB7fTtcblx0XHRcdFx0XHRoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuXHRcdFx0XHRcdHZhciBib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTsgLyogc2xpY2UgaXMgdG8gcmVtb3ZlIHRoZSBpbml0aWFsICc/JyAqL1xuXHRcdFx0XHRcdGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ucG9zdFVyaShjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGhlYWRlcnMsIGJvZHksIHt9LCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldFVyaShjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBhdXRoUGFyYW1zLCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMua2V5KSB7XG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBjbGllbnQtc2lkZSBzaWduaW5nJyk7XG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHsgc2VsZi5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCBhdXRoT3B0aW9ucywgY2IpOyB9O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbXNnID0gXCJOZWVkIGEgbmV3IHRva2VuLCBidXQgYXV0aE9wdGlvbnMgZG9lcyBub3QgaW5jbHVkZSBhbnkgd2F5IHRvIHJlcXVlc3Qgb25lIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSlcIjtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgoKScsICdsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscCcpO1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTcxLCA0MDMpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBub3JtYWxpc2UgdG9rZW4gcGFyYW1zICovXG5cdFx0aWYoJ2NhcGFiaWxpdHknIGluIHRva2VuUGFyYW1zKVxuXHRcdFx0dG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG5cblx0XHR2YXIgdG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24oc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpIHtcblx0XHRcdHZhciBrZXlOYW1lID0gc2lnbmVkVG9rZW5QYXJhbXMua2V5TmFtZSxcblx0XHRcdFx0cGF0aCA9ICcva2V5cy8nICsga2V5TmFtZSArICcvcmVxdWVzdFRva2VuJyxcblx0XHRcdFx0dG9rZW5VcmkgPSBmdW5jdGlvbihob3N0KSB7IHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7IH07XG5cblx0XHRcdHZhciByZXF1ZXN0SGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycygpO1xuXHRcdFx0aWYoYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHJlcXVlc3RIZWFkZXJzLCBhdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyk7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnJlcXVlc3RUb2tlbicsICdTZW5kaW5nIFBPU1QgdG8gJyArIHBhdGggKyAnOyBUb2tlbiBwYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcykpO1xuXHRcdFx0c2lnbmVkVG9rZW5QYXJhbXMgPSBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcyk7XG5cdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnBvc3QoY2xpZW50LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIHNpZ25lZFRva2VuUGFyYW1zLCBudWxsLCB0b2tlbkNiKTtcblx0XHR9O1xuXG5cdFx0dmFyIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSxcblx0XHRcdHRpbWVvdXRMZW5ndGggPSB0aGlzLmNsaWVudC5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcblx0XHRcdFx0dmFyIG1zZyA9ICdUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciAnICsgKHRpbWVvdXRMZW5ndGggLyAxMDAwKSArICcgc2Vjb25kcyc7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0fSwgdGltZW91dExlbmd0aCk7XG5cblx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayh0b2tlblBhcmFtcywgZnVuY3Rpb24oZXJyLCB0b2tlblJlcXVlc3RPckRldGFpbHMsIGNvbnRlbnRUeXBlKSB7XG5cdFx0XHRpZih0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkKSByZXR1cm47XG5cdFx0XHRjbGVhclRpbWVvdXQodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0KTtcblxuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBzaWduaW5nIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdGNhbGxiYWNrKG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbGJhY2sgbWlnaHQgYmUgYSB0b2tlbiBzdHJpbmcsIGEgc2lnbmVkIHJlcXVlc3Qgb3IgYSB0b2tlbiBkZXRhaWxzICovXG5cdFx0XHRpZih0eXBlb2YodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0aWYodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHN0cmluZyBpcyBlbXB0eScsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0fSBlbHNlIGlmKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVG9rZW4gc3RyaW5nIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoICh3YXMgJyArIHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0fSBlbHNlIGlmKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcgfHwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAnbnVsbCcpIHtcblx0XHRcdFx0XHQvKiBjb21tb24gZmFpbHVyZSBtb2RlIHdpdGggcG9vcmx5LWltcGxlbWVudGVkIGF1dGhDYWxsYmFja3MgKi9cblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUb2tlbiBzdHJpbmcgd2FzIGxpdGVyYWwgbnVsbC91bmRlZmluZWQnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdH0gZWxzZSBpZigodG9rZW5SZXF1ZXN0T3JEZXRhaWxzWzBdID09PSAneycpICYmICEoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vand0JykgPiAtMSkpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUb2tlbiB3YXMgZG91YmxlLWVuY29kZWQ7IG1ha2Ugc3VyZSB5b3VcXCdyZSBub3QgSlNPTi1lbmNvZGluZyBhbiBhbHJlYWR5IGVuY29kZWQgdG9rZW4gcmVxdWVzdCBvciBkZXRhaWxzJywgNDAxNzAsIDQwMSkpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHt0b2tlbjogdG9rZW5SZXF1ZXN0T3JEZXRhaWxzfSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYodHlwZW9mKHRva2VuUmVxdWVzdE9yRGV0YWlscykgIT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgJyArIHR5cGVvZih0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcblx0XHRcdGlmKG9iamVjdFNpemUgPiBNQVhfVE9LRU5fTEVOR1RIICYmICFhdXRoT3B0aW9ucy5zdXBwcmVzc01heExlbmd0aENoZWNrKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgJyArIG9iamVjdFNpemUgKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0aWYoJ2lzc3VlZCcgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSB7XG5cdFx0XHRcdC8qIGEgdG9rZW5EZXRhaWxzIG9iamVjdCAqL1xuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlblJlcXVlc3RPckRldGFpbHMpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRpZighKCdrZXlOYW1lJyBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0Jztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsIG1zZyk7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDE3MCwgNDAxKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGl0J3MgYSB0b2tlbiByZXF1ZXN0LCBzbyBtYWtlIHRoZSByZXF1ZXN0ICovXG5cdFx0XHR0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBmdW5jdGlvbihlcnIsIHRva2VuUmVzcG9uc2UsIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBBUEkgY2FsbCByZXR1cm5lZCBlcnJvcjsgZXJyID0gJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRjYWxsYmFjayhub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXVucGFja2VkKSB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZSh0b2tlblJlc3BvbnNlKTtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ3Rva2VuIHJlY2VpdmVkJyk7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuUmVzcG9uc2UpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdH07XG5cblx0LyoqXG5cdCAqIENyZWF0ZSBhbmQgc2lnbiBhIHRva2VuIHJlcXVlc3QgYmFzZWQgb24gdGhlIGdpdmVuIG9wdGlvbnMuXG5cdCAqIE5PVEUgdGhpcyBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGtleSB2YWx1ZSBpcyBhdmFpbGFibGUgbG9jYWxseS5cblx0ICogT3RoZXJ3aXNlLCBzaWduZWQgdG9rZW4gcmVxdWVzdHMgbXVzdCBiZSBvYnRhaW5lZCBmcm9tIHRoZSBrZXlcblx0ICogb3duZXIgKGVpdGhlciB1c2luZyB0aGUgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayBvciB1cmwpLlxuXHQgKlxuXHQgKiBAcGFyYW0gYXV0aE9wdGlvbnNcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHJlcXVlc3Qgb3B0aW9uczpcblx0ICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgYSBrZXkgcGFzc2VkIGluIGNvbnN0cnVjdGluZ1xuXHQgKiAgICAgICAgICAgICAgICAgIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcblx0ICpcblx0ICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcblx0ICogICAgICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseVxuXHQgKlxuXHQgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XG5cdCAqXG5cdCAqIEBwYXJhbSB0b2tlblBhcmFtc1xuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcblx0ICogLSB0dGw6ICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIHRoZSB0b2tlbiBpbiBtcy4gSWYgbm9uZSBpcyBzcGVjaWZpZWRcblx0ICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxuXHQgKiAgICAgICAgICAgICAgICAgIGV4Y2VlZWRpbmcgdGhhdCBsaWZldGltZSB3aWxsIGJlIHJlamVjdGVkIHdpdGggYW4gZXJyb3IuXG5cdCAqXG5cdCAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxuXHQgKiAgICAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxuXHQgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cblx0ICpcblx0ICogLSBjbGllbnRJZDogICAgICAob3B0aW9uYWwpIGEgY2xpZW50IElkIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlbjsgaWYgbm90XG5cdCAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuXHQgKlxuXHQgKiAtIHRpbWVzdGFtcDogICAgIChvcHRpb25hbCkgdGhlIHRpbWUgaW4gbXMgc2luY2UgdGhlIGVwb2NoLiBJZiBub25lIGlzIHNwZWNpZmllZCxcblx0ICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cblx0ICpcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmNyZWF0ZVRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xuXHRcdGlmKHR5cGVvZih0b2tlblBhcmFtcykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcblx0XHRcdGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcblx0XHR9IGVsc2UgaWYodHlwZW9mKGF1dGhPcHRpb25zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuXHRcdFx0Y2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYoIWNhbGxiYWNrICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2NyZWF0ZVRva2VuUmVxdWVzdCcsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXG5cdFx0LyogUlNBOWg6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXG5cdFx0YXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB0aGlzLmF1dGhPcHRpb25zO1xuXHRcdHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uY29weSh0aGlzLnRva2VuUGFyYW1zKTtcblxuXHRcdHZhciBrZXkgPSBhdXRoT3B0aW9ucy5rZXk7XG5cdFx0aWYoIWtleSkge1xuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnTm8ga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGtleVBhcnRzID0ga2V5LnNwbGl0KCc6JyksXG5cdFx0XHRrZXlOYW1lID0ga2V5UGFydHNbMF0sXG5cdFx0XHRrZXlTZWNyZXQgPSBrZXlQYXJ0c1sxXTtcblxuXHRcdGlmKCFrZXlTZWNyZXQpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0ludmFsaWQga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZih0b2tlblBhcmFtcy5jbGllbnRJZCA9PT0gJycpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIGNhbuKAmXQgYmUgYW4gZW1wdHkgc3RyaW5nJywgNDAwMTIsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCdjYXBhYmlsaXR5JyBpbiB0b2tlblBhcmFtcykge1xuXHRcdFx0dG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG5cdFx0fVxuXG5cdFx0dmFyIHJlcXVlc3QgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7IGtleU5hbWU6IGtleU5hbWUgfSwgdG9rZW5QYXJhbXMpLFxuXHRcdFx0Y2xpZW50SWQgPSB0b2tlblBhcmFtcy5jbGllbnRJZCB8fCAnJyxcblx0XHRcdHR0bCA9IHRva2VuUGFyYW1zLnR0bCB8fCAnJyxcblx0XHRcdGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8ICcnLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHQoZnVuY3Rpb24oYXV0aG9yaXNlQ2IpIHtcblx0XHRcdGlmKHJlcXVlc3QudGltZXN0YW1wKSB7XG5cdFx0XHRcdGF1dGhvcmlzZUNiKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH07XG5cdFx0XHRzZWxmLmdldFRpbWVzdGFtcChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5xdWVyeVRpbWUsIGZ1bmN0aW9uKGVyciwgdGltZSkge1xuXHRcdFx0XHRpZihlcnIpIHtjYWxsYmFjayhlcnIpOyByZXR1cm47fVxuXHRcdFx0XHRyZXF1ZXN0LnRpbWVzdGFtcCA9IHRpbWU7XG5cdFx0XHRcdGF1dGhvcmlzZUNiKCk7XG5cdFx0XHR9KTtcblx0XHR9KShmdW5jdGlvbigpIHtcblx0XHRcdC8qIG5vbmNlICovXG5cdFx0XHQvKiBOT1RFOiB0aGVyZSBpcyBubyBleHBlY3RhdGlvbiB0aGF0IHRoZSBjbGllbnRcblx0XHRcdCAqIHNwZWNpZmllcyB0aGUgbm9uY2U7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxuXHRcdFx0ICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2xpZW50XG5cdFx0XHQgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG5cdFx0XHR2YXIgbm9uY2UgPSByZXF1ZXN0Lm5vbmNlIHx8IChyZXF1ZXN0Lm5vbmNlID0gcmFuZG9tKCkpLFxuXHRcdFx0XHR0aW1lc3RhbXAgPSByZXF1ZXN0LnRpbWVzdGFtcDtcblxuXHRcdFx0dmFyIHNpZ25UZXh0XG5cdFx0XHQ9XHRyZXF1ZXN0LmtleU5hbWUgKyAnXFxuJ1xuXHRcdFx0K1x0dHRsICsgJ1xcbidcblx0XHRcdCtcdGNhcGFiaWxpdHkgKyAnXFxuJ1xuXHRcdFx0K1x0Y2xpZW50SWQgKyAnXFxuJ1xuXHRcdFx0K1x0dGltZXN0YW1wICsgJ1xcbidcblx0XHRcdCtcdG5vbmNlICsgJ1xcbic7XG5cblx0XHRcdC8qIG1hYyAqL1xuXHRcdFx0LyogTk9URTogdGhlcmUgaXMgbm8gZXhwZWN0YXRpb24gdGhhdCB0aGUgY2xpZW50XG5cdFx0XHQgKiBzcGVjaWZpZXMgdGhlIG1hYzsgdGhpcyBpcyBkb25lIGJ5IHRoZSBsaWJyYXJ5XG5cdFx0XHQgKiBIb3dldmVyLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcblx0XHRcdCAqIHNpbXBseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cblx0XHRcdHJlcXVlc3QubWFjID0gcmVxdWVzdC5tYWMgfHwgaG1hYyhzaWduVGV4dCwga2V5U2VjcmV0KTtcblxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlblJlcXVlc3QoKScsICdnZW5lcmF0ZWQgc2lnbmVkIHJlcXVlc3QnKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHJlcXVlc3QpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGF1dGggcXVlcnkgcGFyYW1zIHRvIHVzZSBmb3IgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbixcblx0ICogYmFzZWQgb24gdGhlIGN1cnJlbnQgYXV0aCBwYXJhbWV0ZXJzXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5nZXRBdXRoUGFyYW1zID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZih0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKVxuXHRcdFx0Y2FsbGJhY2sobnVsbCwge2tleTogdGhpcy5rZXl9KTtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgZnVuY3Rpb24oZXJyLCB0b2tlbkRldGFpbHMpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwge2FjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VufSk7XG5cdFx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuXHQgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcblx0ICovXG5cdEF1dGgucHJvdG90eXBlLmdldEF1dGhIZWFkZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHRpZih0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKSB7XG5cdFx0XHRjYWxsYmFjayhudWxsLCB7YXV0aG9yaXphdGlvbjogJ0Jhc2ljICcgKyB0aGlzLmJhc2ljS2V5fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBmdW5jdGlvbihlcnIsIHRva2VuRGV0YWlscykge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB7YXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdG9CYXNlNjQodG9rZW5EZXRhaWxzLnRva2VuKX0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBiYXNlZCBvbiB0aGUgbG9jYWwgY2xvY2ssXG5cdCAqIG9yIGlmIHRoZSBvcHRpb24gcXVlcnlUaW1lIGlzIHRydWUsIHJldHVybiB0aGUgc2VydmVyIHRpbWUuXG5cdCAqIFRoZSBzZXJ2ZXIgdGltZSBvZmZzZXQgZnJvbSB0aGUgbG9jYWwgdGltZSBpcyBzdG9yZWQgc28gdGhhdFxuXHQgKiBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSB0aW1lIGlzIGV2ZXIgbmVlZGVkXG5cdCAqL1xuXHRBdXRoLnByb3RvdHlwZS5nZXRUaW1lc3RhbXAgPSBmdW5jdGlvbihxdWVyeVRpbWUsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpICYmIChxdWVyeVRpbWUgfHwgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWUpKSB7XG5cdFx0XHR0aGlzLmNsaWVudC50aW1lKGNhbGxiYWNrKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKTtcblx0XHR9XG5cdH07XG5cblx0QXV0aC5wcm90b3R5cGUuZ2V0VGltZXN0YW1wVXNpbmdPZmZzZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubm93KCkgKyAodGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCB8fCAwKTtcblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5pc1RpbWVPZmZzZXRTZXQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCAhPT0gbnVsbDtcblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5fc2F2ZUJhc2ljT3B0aW9ucyA9IGZ1bmN0aW9uKGF1dGhPcHRpb25zKSB7XG5cdFx0dGhpcy5tZXRob2QgPSAnYmFzaWMnO1xuXHRcdHRoaXMua2V5ID0gYXV0aE9wdGlvbnMua2V5O1xuXHRcdHRoaXMuYmFzaWNLZXkgPSB0b0Jhc2U2NChhdXRoT3B0aW9ucy5rZXkpO1xuXHRcdHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB7fTtcblx0XHRpZignY2xpZW50SWQnIGluIGF1dGhPcHRpb25zKSB7XG5cdFx0XHR0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuXHRcdH1cblx0fVxuXG5cdEF1dGgucHJvdG90eXBlLl9zYXZlVG9rZW5PcHRpb25zID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKSB7XG5cdFx0dGhpcy5tZXRob2QgPSAndG9rZW4nO1xuXG5cdFx0aWYodG9rZW5QYXJhbXMpIHtcblx0XHRcdC8qIFdlIHRlbXBvcmFyaWx5IHBlcnNpc3QgdG9rZW5QYXJhbXMudGltZXN0YW1wIGluIGNhc2UgYSBuZXcgdG9rZW4gbmVlZHNcblx0XHRcdCAqIHRvIGJlIHJlcXVlc3RlZCwgdGhlbiBudWxsIGl0IG91dCBpbiB0aGUgY2FsbGJhY2sgb2Zcblx0XHRcdCAqIF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyBmb3IgUlNBMTBnIGNvbXBsaWFuY2UgKi9cblx0XHRcdHRoaXMudG9rZW5QYXJhbXMgPSB0b2tlblBhcmFtcztcblx0XHR9XG5cblx0XHRpZihhdXRoT3B0aW9ucykge1xuXHRcdFx0Lyogbm9ybWFsaXNlICovXG5cdFx0XHRpZihhdXRoT3B0aW9ucy50b2tlbikge1xuXHRcdFx0XHQvKiBvcHRpb25zLnRva2VuIG1heSBjb250YWluIGEgdG9rZW4gc3RyaW5nIG9yLCBmb3IgY29udmVuaWVuY2UsIGEgVG9rZW5EZXRhaWxzICovXG5cdFx0XHRcdGF1dGhPcHRpb25zLnRva2VuRGV0YWlscyA9ICh0eXBlb2YoYXV0aE9wdGlvbnMudG9rZW4pID09PSAnc3RyaW5nJykgPyB7dG9rZW46IGF1dGhPcHRpb25zLnRva2VufSA6IGF1dGhPcHRpb25zLnRva2VuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcblx0XHRcdFx0dGhpcy50b2tlbkRldGFpbHMgPSBhdXRoT3B0aW9ucy50b2tlbkRldGFpbHM7XG5cdFx0XHR9XG5cblx0XHRcdGlmKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcblx0XHRcdFx0dGhpcy5fdXNlclNldENsaWVudElkKGF1dGhPcHRpb25zLmNsaWVudElkKTtcblx0XHRcdH1cblxuXHRcdFx0dGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuXHRcdH1cblx0fTtcblxuXHQvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxuXHQgKiBwcm9ncmVzcywgbWFraW5nIGFsbCBwZW5kaW5nIGNhbGxiYWNrcyB3YWl0IGZvciB0aGUgbmV3IG9uZSAqL1xuXHRBdXRoLnByb3RvdHlwZS5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMgPSBmdW5jdGlvbihmb3JjZVN1cGVyc2VkZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHR0b2tlbiA9IHRoaXMudG9rZW5EZXRhaWxzO1xuXG5cdFx0aWYodG9rZW4pIHtcblx0XHRcdGlmKHRoaXMuX3Rva2VuQ2xpZW50SWRNaXNtYXRjaCh0b2tlbi5jbGllbnRJZCkpIHtcblx0XHRcdFx0LyogNDAzIHRvIHRyaWdnZXIgYSBwZXJtYW5lbnRseSBmYWlsZWQgY2xpZW50IC0gUlNBMTVjICovXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ01pc21hdGNoIGJldHdlZW4gY2xpZW50SWQgaW4gdG9rZW4gKCcgKyB0b2tlbi5jbGllbnRJZCArICcpIGFuZCBjdXJyZW50IGNsaWVudElkICgnICsgdGhpcy5jbGllbnRJZCArICcpJywgNDAxMDIsIDQwMykpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBSU0E0YjEgLS0gaWYgd2UgaGF2ZSBhIHNlcnZlciB0aW1lIG9mZnNldCBzZXQgYWxyZWFkeSwgd2UgY2FuXG5cdFx0XHQgKiBhdXRvcmVtb3ZlIGV4cGlyZWQgdG9rZW5zLiBFbHNlIGp1c3QgdXNlIHRoZSBjYWNoZWQgdG9rZW4uIElmIGl0IGlzXG5cdFx0XHQgKiBleHBpcmVkIEFibHkgd2lsbCB0ZWxsIHVzIGFuZCB3ZSdsbCBkaXNjYXJkIGl0IHRoZW4uICovXG5cdFx0XHRpZighdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSB8fCAhdG9rZW4uZXhwaXJlcyB8fCAodG9rZW4uZXhwaXJlcyA+PSB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICd1c2luZyBjYWNoZWQgdG9rZW47IGV4cGlyZXMgPSAnICsgdG9rZW4uZXhwaXJlcyk7XG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogZXhwaXJlZCwgc28gcmVtb3ZlIGFuZCBmYWxsdGhyb3VnaCB0byBnZXR0aW5nIGEgbmV3IG9uZSAqL1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ2RlbGV0aW5nIGV4cGlyZWQgdG9rZW4nKTtcblx0XHRcdHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcblx0XHR9XG5cblx0XHQodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8ICh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBPYmplY3QobXVsdGljYXN0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKCkpKS5wdXNoKGNhbGxiYWNrKTtcblx0XHRpZih0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCAhPT0gbnVsbCAmJiAhZm9yY2VTdXBlcnNlZGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBSZXF1ZXN0IGEgbmV3IHRva2VuICovXG5cdFx0dmFyIHRva2VuUmVxdWVzdElkID0gdGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPSBnZXRUb2tlblJlcXVlc3RJZCgpO1xuXHRcdHRoaXMucmVxdWVzdFRva2VuKHRoaXMudG9rZW5QYXJhbXMsIHRoaXMuYXV0aE9wdGlvbnMsIGZ1bmN0aW9uKGVyciwgdG9rZW5SZXNwb25zZSkge1xuXHRcdFx0aWYoc2VsZi5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPiB0b2tlblJlcXVlc3RJZCkge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscygpJywgJ0Rpc2NhcmRpbmcgdG9rZW4gcmVxdWVzdCByZXNwb25zZTsgb3ZlcnRha2VuIGJ5IG5ld2VyIG9uZScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG5cdFx0XHR2YXIgY2FsbGJhY2tzID0gc2VsZi53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8IG5vb3A7XG5cdFx0XHRzZWxmLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrcyhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFja3MobnVsbCwgKHNlbGYudG9rZW5EZXRhaWxzID0gdG9rZW5SZXNwb25zZSkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cblx0LyogVXNlci1zZXQ6IGNoZWNrIHR5cGVzLCAnKicgaXMgZGlzYWxsb3dlZCwgdGhyb3cgYW55IGVycm9ycyAqL1xuXHRBdXRoLnByb3RvdHlwZS5fdXNlclNldENsaWVudElkID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHRpZighKHR5cGVvZihjbGllbnRJZCkgPT09ICdzdHJpbmcnIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgbnVsbCcsIDQwMDEyLCA0MDApO1xuXHRcdH0gZWxzZSBpZihjbGllbnRJZCA9PT0gJyonKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDYW7igJl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsIDQwMDEyLCA0MDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgZXJyID0gdGhpcy5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuXHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIEFibHktc2V0OiBubyB0eXBlY2hlY2tpbmcsICcqJyBpcyBhbGxvd2VkIGJ1dCBub3Qgc2V0IG9uIHRoaXMuY2xpZW50SWQpLCByZXR1cm4gZXJyb3JzIHRvIHRoZSBjYWxsZXIgKi9cblx0QXV0aC5wcm90b3R5cGUuX3VuY2hlY2tlZFNldENsaWVudElkID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHRpZih0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2goY2xpZW50SWQpKSB7XG5cdFx0XHQvKiBTaG91bGQgbmV2ZXIgaGFwcGVuIGluIG5vcm1hbCBjaXJjdW1zdGFuY2VzIGFzIHJlYWx0aW1lIHNob3VsZFxuXHRcdFx0ICogcmVjb2duaXNlIG1pc21hdGNoIGFuZCByZXR1cm4gYW4gZXJyb3IgKi9cblx0XHRcdHZhciBtc2cgPSAnVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyAnICsgdGhpcy5jbGllbnRJZCArICcsIHJlcXVlc3RlZCAnICsgY2xpZW50SWQ7XG5cdFx0XHR2YXIgZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMTAyLCA0MDEpO1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoKScsIG1zZyk7XG5cdFx0XHRyZXR1cm4gZXJyO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvKiBSU0E3YTQ6IGlmIG9wdGlvbnMuY2xpZW50SWQgaXMgcHJvdmlkZWQgYW5kIGlzIG5vdFxuXHRcdFx0ICogbnVsbCwgaXQgb3ZlcnJpZGVzIGRlZmF1bHRUb2tlblBhcmFtcy5jbGllbnRJZCAqL1xuXHRcdFx0dGhpcy5jbGllbnRJZCA9IHRoaXMudG9rZW5QYXJhbXMuY2xpZW50SWQgPSBjbGllbnRJZDtcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRBdXRoLnByb3RvdHlwZS5fdG9rZW5DbGllbnRJZE1pc21hdGNoID0gZnVuY3Rpb24odG9rZW5DbGllbnRJZCkge1xuXHRcdHJldHVybiB0aGlzLmNsaWVudElkICYmXG5cdFx0XHQodGhpcy5jbGllbnRJZCAhPT0gJyonKSAmJlxuXHRcdFx0dG9rZW5DbGllbnRJZCAmJlxuXHRcdFx0KHRva2VuQ2xpZW50SWQgIT09ICcqJykgJiZcblx0XHRcdCh0aGlzLmNsaWVudElkICE9PSB0b2tlbkNsaWVudElkKTtcblx0fTtcblxuXHRBdXRoLmlzVG9rZW5FcnIgPSBmdW5jdGlvbihlcnJvcikge1xuXHRcdHJldHVybiBlcnJvci5jb2RlICYmIChlcnJvci5jb2RlID49IDQwMTQwKSAmJiAoZXJyb3IuY29kZSA8IDQwMTUwKTtcblx0fTtcblxuXHRyZXR1cm4gQXV0aDtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGF1dGggPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChhdXRoX0F1dGgpO1xuXG5cbi8qKiovIH0pLFxuLyogMTUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcblxuXG5cblxuXG5cblxuXG5cbnZhciBDb21ldFRyYW5zcG9ydCA9IChmdW5jdGlvbigpIHtcblxuXHR2YXIgUkVRX1NFTkQgPSAwLFxuXHRcdFJFUV9SRUNWID0gMSxcblx0XHRSRVFfUkVDVl9QT0xMID0gMixcblx0XHRSRVFfUkVDVl9TVFJFQU0gPSAzO1xuXG5cdC8qIFRPRE86IGNhbiByZW1vdmUgb25jZSByZWFsdGltZSBzZW5kcyBwcm90b2NvbCBtZXNzYWdlIHJlc3BvbnNlcyBmb3IgY29tZXQgZXJyb3JzICovXG5cdGZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XG5cdFx0dmFyIFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUyA9IFs4MDAxNSwgODAwMTcsIDgwMDMwXTtcblx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0aWYoX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihlcnIpKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRpZihfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKFVOUkVTT0xWQUJMRV9FUlJPUl9DT0RFUywgZXJyLmNvZGUpKSByZXR1cm4gdHJ1ZTtcblx0XHRcdHJldHVybiAoZXJyLmNvZGUgPj0gNDAwMDAgJiYgZXJyLmNvZGUgPCA1MDAwMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8qIExpa2VseSBhIG5ldHdvcmsgb3IgdHJhbnNwb3J0IGVycm9yIG9mIHNvbWUga2luZC4gQ2VydGFpbmx5IG5vdCBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcblx0XHQvKiBlcnIgd2lsbCBiZSBlaXRoZXIgYSBsZWdhY3kgKG5vbi1wcm90b2NvbG1lc3NhZ2UpIGNvbWV0IGVycm9yIHJlc3BvbnNlXG5cdFx0ICogKHdoaWNoIHdpbGwgaGF2ZSBhbiBlcnIuY29kZSksIG9yIGEgeGhyL25ldHdvcmsgZXJyb3IgKHdoaWNoIHdvbid0KS4gKi9cblx0XHRpZihzaG91bGRCZUVycm9yQWN0aW9uKGVycikpIHtcblx0XHRcdHJldHVybiBbX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe2FjdGlvbjogX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbi5FUlJPUiwgZXJyb3I6IGVycn0pXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIFtfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uLkRJU0NPTk5FQ1RFRCwgZXJyb3I6IGVycn0pXTtcblx0XHR9XG5cdH1cblxuXHQvKlxuXHQgKiBBIGJhc2UgY29tZXQgdHJhbnNwb3J0IGNsYXNzXG5cdCAqL1xuXHRmdW5jdGlvbiBDb21ldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG5cdFx0LyogYmluYXJ5IG5vdCBzdXBwb3J0ZWQgZm9yIGNvbWV0LCBzbyBqdXN0IGZhbGwgYmFjayB0byBkZWZhdWx0ICovXG5cdFx0cGFyYW1zLmZvcm1hdCA9IHVuZGVmaW5lZDtcblx0XHRwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG5cdFx0X3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdC8qIHN0cmVhbWluZyBkZWZhdWx0cyB0byB0cnVlICovXG5cdFx0dGhpcy5zdHJlYW0gPSAoJ3N0cmVhbScgaW4gcGFyYW1zKSA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuXHRcdHRoaXMuc2VuZFJlcXVlc3QgPSBudWxsO1xuXHRcdHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdHRoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcblx0XHR0aGlzLnBlbmRpbmdJdGVtcyA9IG51bGw7XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhDb21ldFRyYW5zcG9ydCwgX3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XG5cblx0Q29tZXRUcmFuc3BvcnQuUkVRX1NFTkQgPSBSRVFfU0VORDtcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1JFQ1YgPSBSRVFfUkVDVjtcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1JFQ1ZfUE9MTCA9IFJFUV9SRUNWX1BPTEw7XG5cdENvbWV0VHJhbnNwb3J0LlJFUV9SRUNWX1NUUkVBTSA9IFJFUV9SRUNWX1NUUkVBTTtcblxuXHQvKiBwdWJsaWMgaW5zdGFuY2UgbWV0aG9kcyAqL1xuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnc3RhcnRpbmcnKTtcblx0XHRfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcywgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xuXHRcdHZhciBob3N0ID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRIb3N0KG9wdGlvbnMsIHBhcmFtcy5ob3N0KTtcblx0XHR2YXIgcG9ydCA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UG9ydChvcHRpb25zKTtcblx0XHR2YXIgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG5cblx0XHR0aGlzLmJhc2VVcmkgPSBjb21ldFNjaGVtZSArIGhvc3QgKyAnOicgKyBwb3J0ICsgJy9jb21ldC8nO1xuXHRcdHZhciBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgJ2Nvbm5lY3QnO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAndXJpOiAnICsgY29ubmVjdFVyaSk7XG5cdFx0dGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG5cdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKHNlbGYuaXNEaXNwb3NlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmF1dGhQYXJhbXMgPSBhdXRoUGFyYW1zO1xuXHRcdFx0dmFyIGNvbm5lY3RQYXJhbXMgPSBzZWxmLnBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuXHRcdFx0aWYoJ3N0cmVhbScgaW4gY29ubmVjdFBhcmFtcykgc2VsZi5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnY29ubmVjdFBhcmFtczonICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpKTtcblxuXHRcdFx0LyogdGhpcyB3aWxsIGJlIHRoZSAncmVjdlJlcXVlc3QnIHNvIHRoaXMgY29ubmVjdGlvbiBjYW4gc3RyZWFtIG1lc3NhZ2VzICovXG5cdFx0XHR2YXIgcHJlY29ubmVjdGVkID0gZmFsc2UsXG5cdFx0XHRcdGNvbm5lY3RSZXF1ZXN0ID0gc2VsZi5yZWN2UmVxdWVzdCA9IHNlbGYuY3JlYXRlUmVxdWVzdChjb25uZWN0VXJpLCBudWxsLCBjb25uZWN0UGFyYW1zLCBudWxsLCAoc2VsZi5zdHJlYW0gPyBSRVFfUkVDVl9TVFJFQU0gOiBSRVFfUkVDVikpO1xuXG5cdFx0XHRjb25uZWN0UmVxdWVzdC5vbignZGF0YScsIGZ1bmN0aW9uKGRhdGEpIHtcblx0XHRcdFx0aWYoIXNlbGYucmVjdlJlcXVlc3QpIHtcblx0XHRcdFx0XHQvKiB0aGUgdHJhbnNwb3J0IHdhcyBkaXNwb3NlZCBiZWZvcmUgd2UgY29ubmVjdGVkICovXG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFwcmVjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRwcmVjb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncHJlY29ubmVjdCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xuXHRcdFx0fSk7XG5cdFx0XHRjb25uZWN0UmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIF9ib2R5LCBoZWFkZXJzKSB7XG5cdFx0XHRcdGlmKCFzZWxmLnJlY3ZSZXF1ZXN0KSB7XG5cdFx0XHRcdFx0LyogdGhlIHRyYW5zcG9ydCB3YXMgZGlzcG9zZWQgYmVmb3JlIHdlIGNvbm5lY3RlZCAqL1xuXHRcdFx0XHRcdGVyciA9IGVyciB8fCBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdSZXF1ZXN0IGNhbmNlbGxlZCcsIDgwMDAzLCA0MDApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdFx0XHQvKiBDb25uZWN0IHJlcXVlc3QgbWF5IGNvbXBsZXRlIHdpdGhvdXQgYSBlbWl0dGluZyAnZGF0YScgZXZlbnQgc2luY2UgdGhhdCBpcyBub3Rcblx0XHRcdFx0ICogZW1pdHRlZCBmb3IgZS5nLiBhIG5vbi1zdHJlYW1lZCBlcnJvciByZXNwb25zZS4gU3RpbGwgaW1wbGllcyBwcmVjb25uZWN0LiAqL1xuXHRcdFx0XHRpZighcHJlY29ubmVjdGVkICYmICFlcnIpIHtcblx0XHRcdFx0XHRwcmVjb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncHJlY29ubmVjdCcpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYub25BY3Rpdml0eSgpO1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0XHRcdFx0LyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG5cdFx0XHRcdFx0XHQgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxuXHRcdFx0XHRcdFx0ICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuXHRcdFx0XHRcdFx0c2VsZi5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuXHRcdFx0XHRcdFx0ICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cblx0XHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnJlY3YoKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9KTtcblx0XHRcdGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcblx0XHR9KTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpJyk7XG5cdFx0dGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KHRydWUpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpJyk7XG5cdFx0dGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KGZhbHNlKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCA9IGZ1bmN0aW9uKGNsb3NpbmcpIHtcblx0XHR2YXIgY2xvc2VPckRpc2Nvbm5lY3RVcmkgPSBjbG9zaW5nID8gdGhpcy5jbG9zZVVyaSA6IHRoaXMuZGlzY29ubmVjdFVyaTtcblx0XHRpZihjbG9zZU9yRGlzY29ubmVjdFVyaSkge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzLFxuXHRcdFx0XHRyZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFJFUV9TRU5EKTtcblxuXHRcdFx0cmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0JyArIChjbG9zaW5nID8gJ0Nsb3NlKCknIDogJ0Rpc2Nvbm5lY3QoKScpLCAncmVxdWVzdCByZXR1cm5lZCBlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdFx0c2VsZi5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0cmVxdWVzdC5leGVjKCk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcblx0XHRpZighdGhpcy5pc0Rpc3Bvc2VkKSB7XG5cdFx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuXHRcdFx0aWYodGhpcy5yZWN2UmVxdWVzdCkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJ2Fib3J0aW5nIHJlY3YgcmVxdWVzdCcpO1xuXHRcdFx0XHR0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG5cdFx0XHRcdHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0LyogSW4gYWxtb3N0IGFsbCBjYXNlcyB0aGUgdHJhbnNwb3J0IHdpbGwgYmUgZmluaXNoZWQgYmVmb3JlIGl0J3Ncblx0XHRcdCAqIGRpc3Bvc2VkLiBGaW5pc2ggaGVyZSBqdXN0IHRvIG1ha2Ugc3VyZS4gKi9cblx0XHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGlzY29ubmVjdGVkKTtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgnZGlzcG9zZWQnKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdC8qIGlmIHRoaXMgdHJhbnNwb3J0IGhhcyBiZWVuIGRpc3Bvc2VkIHdoaWxzdCBhd2FpdGluZyBjb25uZWN0aW9uLCBkbyBub3RoaW5nICovXG5cdFx0aWYodGhpcy5pc0Rpc3Bvc2VkKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0LyogdGhlIGNvbm5lY3Rpb25LZXkgaW4gYSBjb21ldCBjb25uZWN0ZWQgcmVzcG9uc2UgaXMgcmVhbGx5XG5cdFx0ICogPGluc3RJZD4tPGNvbm5lY3Rpb25LZXk+ICovXG5cdFx0dmFyIGNvbm5lY3Rpb25TdHIgPSBtZXNzYWdlLmNvbm5lY3Rpb25LZXk7XG5cdFx0X3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wcm90b3R5cGUub25Db25uZWN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG5cblx0XHR2YXIgYmFzZUNvbm5lY3Rpb25VcmkgPSAgdGhpcy5iYXNlVXJpICsgY29ubmVjdGlvblN0cjtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KCknLCAnYmFzZVVyaSA9ICcgKyBiYXNlQ29ubmVjdGlvblVyaSArICc7IGNvbm5lY3Rpb25LZXkgPSAnICsgbWVzc2FnZS5jb25uZWN0aW9uS2V5KTtcblx0XHR0aGlzLnNlbmRVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvc2VuZCc7XG5cdFx0dGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3JlY3YnO1xuXHRcdHRoaXMuY2xvc2VVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvY2xvc2UnO1xuXHRcdHRoaXMuZGlzY29ubmVjdFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9kaXNjb25uZWN0Jztcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRpZih0aGlzLnNlbmRSZXF1ZXN0KSB7XG5cdFx0XHQvKiB0aGVyZSBpcyBhIHBlbmRpbmcgc2VuZCwgc28gcXVldWUgdGhpcyBtZXNzYWdlICovXG5cdFx0XHR0aGlzLnBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuXHRcdFx0dGhpcy5wZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Lyogc2VuZCB0aGlzLCBwbHVzIGFueSBwZW5kaW5nLCBub3cgKi9cblx0XHR2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXMgfHwgW107XG5cdFx0cGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuXG5cdFx0dGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZEFueVBlbmRpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXM7XG5cblx0XHRpZighcGVuZGluZ0l0ZW1zKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuXHRcdHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XG5cdH1cblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuc2VuZEl0ZW1zID0gZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRzZW5kUmVxdWVzdCA9IHRoaXMuc2VuZFJlcXVlc3QgPSBzZWxmLmNyZWF0ZVJlcXVlc3Qoc2VsZi5zZW5kVXJpLCBudWxsLCBzZWxmLmF1dGhQYXJhbXMsIHRoaXMuZW5jb2RlUmVxdWVzdChpdGVtcyksIFJFUV9TRU5EKTtcblxuXHRcdHNlbmRSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uKGVyciwgZGF0YSkge1xuXHRcdFx0aWYoZXJyKSBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQuc2VuZEl0ZW1zKCknLCAnb24gY29tcGxldGU6IGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHRcdHNlbGYuc2VuZFJlcXVlc3QgPSBudWxsO1xuXG5cdFx0XHQvKiB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LCBldmVuIGlmIGEgbmFjaywgaXMgdXN1YWxseSBhIHByb3RvY29sIHJlc3BvbnNlXG5cdFx0XHQgKiBjb250YWluZWQgaW4gdGhlIGRhdGEuIEFuIGVyciBpcyBhbm9tb2xvdXMsIGFuZCBpbmRpY2F0ZXMgc29tZSBpc3N1ZSB3aXRoIHRoZVxuXHRcdFx0ICogbmV0d29yayx0cmFuc3BvcnQsIG9yIGNvbm5lY3Rpb24gKi9cblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRpZihlcnIuY29kZSkge1xuXHRcdFx0XHRcdC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuXHRcdFx0XHRcdCAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG5cdFx0XHRcdFx0ICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xuXHRcdFx0XHRcdHNlbGYub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuXHRcdFx0XHRcdCAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG5cdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihkYXRhKSB7XG5cdFx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihzZWxmLnBlbmRpbmdJdGVtcykge1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdC8qIElmIHRoZXJlJ3MgYSBuZXcgc2VuZCByZXF1ZXN0IGJ5IG5vdywgYW55IHBlbmRpbmcgaXRlbXMgd2lsbCBoYXZlXG5cdFx0XHRcdFx0ICogYmVlbiBwaWNrZWQgdXAgYnkgdGhhdDsgYW55IG5ldyBvbmVzIGFkZGVkIHNpbmNlIHRoZW4gd2lsbCBiZVxuXHRcdFx0XHRcdCAqIHBpY2tlZCB1cCBhZnRlciB0aGF0IG9uZSBjb21wbGV0ZXMgKi9cblx0XHRcdFx0XHRpZighc2VsZi5zZW5kUmVxdWVzdCkge1xuXHRcdFx0XHRcdFx0c2VsZi5zZW5kQW55UGVuZGluZygpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0c2VuZFJlcXVlc3QuZXhlYygpO1xuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZWN2ID0gZnVuY3Rpb24oKSB7XG5cdFx0LyogZG8gbm90aGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgcmVxdWVzdCwgd2hpY2ggbWlnaHQgYmUgc3RyZWFtaW5nICovXG5cdFx0aWYodGhpcy5yZWN2UmVxdWVzdClcblx0XHRcdHJldHVybjtcblxuXHRcdC8qIElmIHdlJ3JlIG5vIGxvbmdlciBjb25uZWN0ZWQsIGRvIG5vdGhpbmcgKi9cblx0XHRpZighdGhpcy5pc0Nvbm5lY3RlZClcblx0XHRcdHJldHVybjtcblxuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdHJlY3ZSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdCh0aGlzLnJlY3ZVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgbnVsbCwgKHNlbGYuc3RyZWFtID8gUkVRX1JFQ1ZfU1RSRUFNIDogUkVRX1JFQ1ZfUE9MTCkpO1xuXG5cdFx0cmVjdlJlcXVlc3Qub24oJ2RhdGEnLCBmdW5jdGlvbihkYXRhKSB7XG5cdFx0XHRzZWxmLm9uRGF0YShkYXRhKTtcblx0XHR9KTtcblx0XHRyZWN2UmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdHNlbGYucmVjdlJlcXVlc3QgPSBudWxsO1xuXHRcdFx0LyogQSByZXF1ZXN0IGNvbXBsZXRpbmcgbXVzdCBiZSBjb25zaWRlcmVkIGFjdGl2aXR5LCBhcyByZWFsdGltZSBzZW5kc1xuXHRcdFx0ICogaGVhcnRiZWF0cyBldmVyeSAxNXMgc2luY2UgYSByZXF1ZXN0IGJlZ2FuLCBub3QgZXZlcnkgMTVzIGFic29sdXRlbHkgKi9cblx0XHRcdHNlbGYub25BY3Rpdml0eSgpO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGlmKGVyci5jb2RlKSB7XG5cdFx0XHRcdFx0LyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG5cdFx0XHRcdFx0ICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcblx0XHRcdFx0XHQgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXG5cdFx0XHRcdFx0c2VsZi5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG5cdFx0XHRcdFx0ICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cblx0XHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlY3YoKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHRcdHJlY3ZSZXF1ZXN0LmV4ZWMoKTtcblx0fTtcblxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XG5cdFx0dHJ5IHtcblx0XHRcdHZhciBpdGVtcyA9IHRoaXMuZGVjb2RlUmVzcG9uc2UocmVzcG9uc2VEYXRhKTtcblx0XHRcdGlmKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21EZXNlcmlhbGl6ZWQoaXRlbXNbaV0pKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQub25EYXRhKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIGV2ZW50OiAnICsgZS5zdGFjayk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5lbmNvZGVSZXF1ZXN0ID0gZnVuY3Rpb24ocmVxdWVzdEl0ZW1zKSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RJdGVtcyk7XG5cdH07XG5cblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmRlY29kZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XG5cdFx0aWYodHlwZW9mKHJlc3BvbnNlRGF0YSkgPT0gJ3N0cmluZycpXG5cdFx0XHRyZXNwb25zZURhdGEgPSBKU09OLnBhcnNlKHJlc3BvbnNlRGF0YSk7XG5cdFx0cmV0dXJuIHJlc3BvbnNlRGF0YTtcblx0fTtcblxuXHQvKiBGb3IgY29tZXQsIHdlIGNvdWxkIGRvIHRoZSBhdXRoIHVwZGF0ZSBieSBhYm9ydGluZyB0aGUgY3VycmVudCByZWN2IGFuZFxuXHQgKiBzdGFydGluZyBhIG5ldyBvbmUgd2l0aCB0aGUgbmV3IHRva2VuLCB0aGF0J2QgYmUgc3VmZmljaWVudCBmb3IgcmVhbHRpbWUuXG5cdCAqIFByb2JsZW0gaXMgSlNPTlAgLSB5b3UgY2FuJ3QgY2FuY2VsIHRydWx5IGFib3J0IGEgcmVjdiBvbmNlIHN0YXJ0ZWQuIFNvXG5cdCAqIHdlIG5lZWQgdG8gc2VuZCBhbiBBVVRIIGZvciBqc29ucC4gSW4gd2hpY2ggY2FzZSBpdCdzIHNpbXBsZXIgdG8ga2VlcCBhbGxcblx0ICogY29tZXQgdHJhbnNwb3J0cyB0aGUgc2FtZSBhbmQgZG8gaXQgZm9yIGFsbCBvZiB0aGVtLiBTbyB3ZSBzZW5kIHRoZSBBVVRIXG5cdCAqIGluc3RlYWQsIGFuZCBkb24ndCBuZWVkIHRvIGFib3J0IHRoZSByZWN2ICovXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24odG9rZW5EZXRhaWxzKSB7XG5cdFx0dGhpcy5hdXRoUGFyYW1zID0ge2FjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VufTtcblx0fTtcblxuXHRyZXR1cm4gQ29tZXRUcmFuc3BvcnQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKENvbWV0VHJhbnNwb3J0KTtcblxuXG4vKioqLyB9KSxcbi8qIDE2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG5cbnZhciBXZWJTdG9yYWdlID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgc2Vzc2lvblN1cHBvcnRlZCxcblx0XHRsb2NhbFN1cHBvcnRlZCxcblx0XHR0ZXN0ID0gJ2FibHlqcy1zdG9yYWdlLXRlc3QnO1xuXG5cdC8qIEV2ZW4ganVzdCBhY2Nlc3NpbmcgdGhlIHNlc3Npb24vbG9jYWxTdG9yYWdlIG9iamVjdCBjYW4gdGhyb3cgYVxuXHQgKiBzZWN1cml0eSBleGNlcHRpb24gaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdpdGggc29tZSBicm93c2Vycy4gSW5cblx0ICogb3RoZXJzLCBjYWxsaW5nIHNldEl0ZW0gd2lsbCB0aHJvdy4gU28gaGF2ZSB0byBjaGVjayBpbiB0aGlzXG5cdCAqIHNvbWV3aGF0IHJvdW5kYWJvdXQgd2F5LiAoSWYgdW5zdXBwb3J0ZWQgb3Igbm8gZ2xvYmFsIG9iamVjdCxcblx0ICogd2lsbCB0aHJvdyBvbiBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSBvZiB1bmRlZmluZWQpICovXG5cdHRyeSB7XG5cdFx0Z2xvYmFsLnNlc3Npb25TdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XG5cdFx0Z2xvYmFsLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XG5cdFx0c2Vzc2lvblN1cHBvcnRlZCA9IHRydWU7XG5cdH0gY2F0Y2goZSkge1xuXHRcdHNlc3Npb25TdXBwb3J0ZWQgPSBmYWxzZTtcblx0fVxuXG5cdHRyeSB7XG5cdFx0Z2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuXHRcdGdsb2JhbC5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbSh0ZXN0KTtcblx0XHRsb2NhbFN1cHBvcnRlZCA9IHRydWU7XG5cdH0gY2F0Y2goZSkge1xuXHRcdGxvY2FsU3VwcG9ydGVkID0gZmFsc2U7XG5cdH1cblxuXHRmdW5jdGlvbiBXZWJTdG9yYWdlKCkge31cblxuXHRmdW5jdGlvbiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pIHtcblx0XHRyZXR1cm4gc2Vzc2lvbiA/IGdsb2JhbC5zZXNzaW9uU3RvcmFnZSA6IGdsb2JhbC5sb2NhbFN0b3JhZ2U7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQobmFtZSwgdmFsdWUsIHR0bCwgc2Vzc2lvbikge1xuXHRcdHZhciB3cmFwcGVkVmFsdWUgPSB7dmFsdWU6IHZhbHVlfTtcblx0XHRpZih0dGwpIHtcblx0XHRcdHdyYXBwZWRWYWx1ZS5leHBpcmVzID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpICsgdHRsO1xuXHRcdH1cblx0XHRyZXR1cm4gc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5zZXRJdGVtKG5hbWUsIEpTT04uc3RyaW5naWZ5KHdyYXBwZWRWYWx1ZSkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0KG5hbWUsIHNlc3Npb24pIHtcblx0XHR2YXIgcmF3SXRlbSA9IHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikuZ2V0SXRlbShuYW1lKTtcblx0XHRpZighcmF3SXRlbSkgcmV0dXJuIG51bGw7XG5cdFx0dmFyIHdyYXBwZWRWYWx1ZSA9IEpTT04ucGFyc2UocmF3SXRlbSk7XG5cdFx0aWYod3JhcHBlZFZhbHVlLmV4cGlyZXMgJiYgKHdyYXBwZWRWYWx1ZS5leHBpcmVzIDwgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpKSkge1xuXHRcdFx0c3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiB3cmFwcGVkVmFsdWUudmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiByZW1vdmUobmFtZSwgc2Vzc2lvbikge1xuXHRcdHJldHVybiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG5cdH1cblxuXHRpZihsb2NhbFN1cHBvcnRlZCkge1xuXHRcdFdlYlN0b3JhZ2Uuc2V0ICAgID0gZnVuY3Rpb24obmFtZSwgdmFsdWUsIHR0bCkgeyByZXR1cm4gc2V0KG5hbWUsIHZhbHVlLCB0dGwsIGZhbHNlKTsgfTtcblx0XHRXZWJTdG9yYWdlLmdldCAgICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGdldChuYW1lLCBmYWxzZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5yZW1vdmUgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiByZW1vdmUobmFtZSwgZmFsc2UpOyB9O1xuXHR9XG5cblx0aWYoc2Vzc2lvblN1cHBvcnRlZCkge1xuXHRcdFdlYlN0b3JhZ2Uuc2V0U2Vzc2lvbiAgICA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCB0dGwpIHsgcmV0dXJuIHNldChuYW1lLCB2YWx1ZSwgdHRsLCB0cnVlKTsgfTtcblx0XHRXZWJTdG9yYWdlLmdldFNlc3Npb24gICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBnZXQobmFtZSwgdHJ1ZSk7IH07XG5cdFx0V2ViU3RvcmFnZS5yZW1vdmVTZXNzaW9uID0gZnVuY3Rpb24obmFtZSkgeyByZXR1cm4gcmVtb3ZlKG5hbWUsIHRydWUpOyB9O1xuXHR9XG5cblx0cmV0dXJuIFdlYlN0b3JhZ2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFdlYlN0b3JhZ2UpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDE3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbnZhciBnO1xuXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxuZyA9IChmdW5jdGlvbigpIHtcblx0cmV0dXJuIHRoaXM7XG59KSgpO1xuXG50cnkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcbn0gY2F0Y2ggKGUpIHtcblx0Ly8gVGhpcyB3b3JrcyBpZiB0aGUgd2luZG93IHJlZmVyZW5jZSBpcyBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XG59XG5cbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXG4vLyBlYXNpZXIgdG8gaGFuZGxlIHRoaXMgY2FzZS4gaWYoIWdsb2JhbCkgeyAuLi59XG5cbm1vZHVsZS5leHBvcnRzID0gZztcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBiYXNlNjRTdHJpbmcgPSBDcnlwdG9KUy5lbmMuQmFzZTY0LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUxID0gKHdvcmRzW2kgPj4+IDJdICAgICAgID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICAgICAgICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMiA9ICh3b3Jkc1soaSArIDEpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMSkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgdHJpcGxldCA9IChieXRlMSA8PCAxNikgfCAoYnl0ZTIgPDwgOCkgfCBieXRlMztcblxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IChqIDwgNCkgJiYgKGkgKyBqICogMC43NSA8IHNpZ0J5dGVzKTsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChtYXAuY2hhckF0KCh0cmlwbGV0ID4+PiAoNiAqICgzIC0gaikpKSAmIDB4M2YpKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xuXHQgICAgICAgICAgICBpZiAocGFkZGluZ0NoYXIpIHtcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0Q2hhcnMucHVzaChwYWRkaW5nQ2hhcik7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gYmFzZTY0Q2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gYmFzZTY0U3RyIFRoZSBCYXNlNjQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5CYXNlNjQucGFyc2UoYmFzZTY0U3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGJhc2U2NFN0ckxlbmd0aCA9IGJhc2U2NFN0ci5sZW5ndGg7XG5cdCAgICAgICAgICAgIHZhciBtYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xuXHQgICAgICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXA7XG5cblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV2ZXJzZU1hcCA9IHRoaXMuX3JldmVyc2VNYXAgPSBbXTtcblx0ICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG1hcC5sZW5ndGg7IGorKykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSWdub3JlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgdmFyIHBhZGRpbmdJbmRleCA9IGJhc2U2NFN0ci5pbmRleE9mKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIGlmIChwYWRkaW5nSW5kZXggIT09IC0xKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICByZXR1cm4gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKTtcblxuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCkge1xuXHQgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XG5cdCAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmFzZTY0U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgIGlmIChpICUgNCkge1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzMiA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSldID4+PiAoNiAtIChpICUgNCkgKiAyKTtcblx0ICAgICAgICAgICAgICB2YXIgYml0c0NvbWJpbmVkID0gYml0czEgfCBiaXRzMjtcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IGJpdHNDb21iaW5lZCA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgICBuQnl0ZXMrKztcblx0ICAgICAgICAgIH1cblx0ICAgICAgfVxuXHQgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgbkJ5dGVzKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMTkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG5cblxuXG5cblxuXG5cbnZhciBDcnlwdG8gPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBERUZBVUxUX0FMR09SSVRITSA9ICdhZXMnO1xuXHR2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7IC8vIGJpdHNcblx0dmFyIERFRkFVTFRfTU9ERSA9ICdjYmMnO1xuXHR2YXIgREVGQVVMVF9CTE9DS0xFTkdUSCA9IDE2OyAvLyBieXRlc1xuXHR2YXIgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyA9IDQ7IC8vIDMyLWJpdCB3b3Jkc1xuXHR2YXIgVUlOVDMyX1NVUCA9IDB4MTAwMDAwMDAwO1xuXHR2YXIgSU5UMzJfU1VQID0gMHg4MDAwMDAwMDtcblxuXHQvKipcblx0ICogSW50ZXJuYWw6IGdlbmVyYXRlIGFuIGFycmF5IG9mIHNlY3VyZSByYW5kb20gd29yZHMgY29ycmVzcG9uZGluZyB0byB0aGUgZ2l2ZW4gbGVuZ3RoIG9mIGJ5dGVzXG5cdCAqIEBwYXJhbSBieXRlc1xuXHQgKiBAcGFyYW0gY2FsbGJhY2tcblx0ICovXG5cdHZhciBnZW5lcmF0ZVJhbmRvbTtcblx0aWYocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRSYW5kb21Xb3JkQXJyYXkpIHtcblx0XHRnZW5lcmF0ZVJhbmRvbSA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tV29yZEFycmF5O1xuXHR9IGVsc2UgaWYodHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcykge1xuXHRcdHZhciBibG9ja1JhbmRvbUFycmF5ID0gbmV3IFVpbnQzMkFycmF5KERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMpO1xuXHRcdGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24oYnl0ZXMsIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgd29yZHMgPSBieXRlcyAvIDQsIG5hdGl2ZUFycmF5ID0gKHdvcmRzID09IERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMpID8gYmxvY2tSYW5kb21BcnJheSA6IG5ldyBVaW50MzJBcnJheSh3b3Jkcyk7XG5cdFx0XHRwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyhuYXRpdmVBcnJheSwgZnVuY3Rpb24oZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShuYXRpdmVBcnJheSkpXG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24oYnl0ZXMsIGNhbGxiYWNrKSB7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NQUpPUiwgJ0FibHkuQ3J5cHRvLmdlbmVyYXRlUmFuZG9tKCknLCAnV2FybmluZzogdGhlIGJyb3dzZXIgeW91IGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IHNlY3VyZSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tbmVzcyBnZW5lcmF0aW9uOyBmYWxsaW5nIGJhY2sgdG8gaW5zZWN1cmUgTWF0aC5yYW5kb20oKScpO1xuXHRcdFx0dmFyIHdvcmRzID0gYnl0ZXMgLyA0LCBhcnJheSA9IG5ldyBBcnJheSh3b3Jkcyk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xuXHRcdFx0XHQvKiBjcnlwdG9qcyB3b3JkYXJyYXlzIHVzZSBzaWduZWQgaW50cy4gV2hlbiBXb3JkQXJyYXkuY3JlYXRlIGlzIGZlZCBhXG5cdFx0XHRcdCogVWludDMyQXJyYXkgdW5zaWduZWQgYXJlIGNvbnZlcnRlZCB0byBzaWduZWQgYXV0b21hdGljYWxseSwgYnV0IHdoZW5cblx0XHRcdFx0KiBmZWQgYSBub3JtYWwgYXJyYXkgdGhleSBhcmVuJ3QsIHNvIG5lZWQgdG8gZG8gc28gb3Vyc2VsdmVzIGJ5XG5cdFx0XHRcdCogc3VidHJhY3RpbmcgSU5UMzJfU1VQICovXG5cdFx0XHRcdGFycmF5W2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogVUlOVDMyX1NVUCkgLSBJTlQzMl9TVVA7XG5cdFx0XHR9XG5cblx0XHRcdGNhbGxiYWNrKG51bGwsIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGFycmF5KSk7XG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnRlcm5hbDogY2FsY3VsYXRlIHRoZSBwYWRkZWQgbGVuZ3RoIG9mIGEgZ2l2ZW4gcGxhaW50ZXh0XG5cdCAqIHVzaW5nIFBLQ1M1LlxuXHQgKiBAcGFyYW0gcGxhaW50ZXh0TGVuZ3RoXG5cdCAqIEByZXR1cm5cblx0ICovXG5cdGZ1bmN0aW9uIGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpIHtcblx0XHRyZXR1cm4gKHBsYWludGV4dExlbmd0aCArIERFRkFVTFRfQkxPQ0tMRU5HVEgpICYgLURFRkFVTFRfQkxPQ0tMRU5HVEg7XG5cdH1cblxuXHQvKipcblx0ICogSW50ZXJuYWw6IGNoZWNrcyB0aGF0IHRoZSBjaXBoZXJQYXJhbXMgYXJlIGEgdmFsaWQgY29tYmluYXRpb24uIEN1cnJlbnRseVxuXHQgKiBqdXN0IGNoZWNrcyB0aGF0IHRoZSBjYWxjdWxhdGVkIGtleUxlbmd0aCBpcyBhIHZhbGlkIG9uZSBmb3IgYWVzLWNiY1xuXHQgKi9cblx0ZnVuY3Rpb24gdmFsaWRhdGVDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG5cdFx0aWYocGFyYW1zLmFsZ29yaXRobSA9PT0gJ2FlcycgJiYgcGFyYW1zLm1vZGUgPT09ICdjYmMnKSB7XG5cdFx0XHRpZihwYXJhbXMua2V5TGVuZ3RoID09PSAxMjggfHwgcGFyYW1zLmtleUxlbmd0aCA9PT0gMjU2KSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQga2V5IGxlbmd0aCAnICsgcGFyYW1zLmtleUxlbmd0aCArICcgZm9yIGFlcy1jYmMgZW5jcnlwdGlvbi4gRW5jcnlwdGlvbiBrZXkgbXVzdCBiZSAxMjggb3IgMjU2IGJpdHMgKDE2IG9yIDMyIEFTQ0lJIGNoYXJhY3RlcnMpJyk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbm9ybWFsaXNlQmFzZTY0KHN0cmluZykge1xuXHRcdC8qIHVybC1zYWZlIGJhc2U2NCBzdHJpbmdzIHVzZSBfIGFuZCAtIGluc3RyZWFkIG9mIC8gYW5kICsgKi9cblx0XHRyZXR1cm4gc3RyaW5nLnJlcGxhY2UoJ18nLCAnLycpLnJlcGxhY2UoJy0nLCAnKycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEludGVybmFsOiBhIGJsb2NrIGNvbnRhaW5pbmcgemVyb3Ncblx0ICovXG5cdHZhciBlbXB0eUJsb2NrID0gY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzAsMCwwLDBdKTtcblxuXHQvKipcblx0ICogSW50ZXJuYWw6IG9idGFpbiB0aGUgcGtjczUgcGFkZGluZyBzdHJpbmcgZm9yIGEgZ2l2ZW4gcGFkZGVkIGxlbmd0aDtcblx0ICovXG5cdHZhciBwa2NzNVBhZGRpbmcgPSBbXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTBdLCAxNiksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDEwMDAwMDBdLCAxKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMjAyMDAwMF0sIDIpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAzMDMwMzAwXSwgMyksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDQwNDA0MDRdLCA0KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNTA1MDUwNSwweDA1MDAwMDAwXSwgNSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDYwNjA2MDYsMHgwNjA2MDAwMF0sIDYpLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA3MDcwNzA3LDB4MDcwNzA3MDBdLCA3KSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwODA4MDgwOCwweDA4MDgwODA4XSwgOCksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDkwOTA5MDksMHgwOTA5MDkwOSwweDA5MDAwMDAwXSwgOSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGEwYTBhMGEsMHgwYTBhMGEwYSwweDBhMGEwMDAwXSwgMTApLFxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBiMGIwYjBiLDB4MGIwYjBiMGIsMHgwYjBiMGIwMF0sIDExKSxcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwYzBjMGMwYywweDBjMGMwYzBjLDB4MGMwYzBjMGNdLCAxMiksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGQwZDBkMGQsMHgwZDBkMGQwZCwweDBkMGQwZDBkLDB4MGQwMDAwMDBdLCAxMyksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGUwZTBlMGUsMHgwZTBlMGUwZSwweDBlMGUwZTBlLDB4MGUwZTAwMDBdLCAxNCksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGYwZjBmMGYsMHgwZjBmMGYwZiwweDBmMGYwZjBmLDB4MGYwZjBmMGZdLCAxNSksXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTBdLCAxNilcblx0XTtcblxuXHQvKipcblx0ICogVXRpbGl0eSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGZvciBtZXNzYWdlIHBheWxvYWQgZW5jcnlwdGlvbi5cblx0ICpcblx0ICogVGhpcyBjbGFzcyBzdXBwb3J0cyBBRVMvQ0JDL1BLQ1M1IHdpdGggYSBkZWZhdWx0IGtleWxlbmd0aCBvZiAxMjggYml0c1xuXHQgKiBidXQgc3VwcG9ydGluZyBvdGhlciBrZXlsZW5ndGhzLiBPdGhlciBhbGdvcml0aG1zIGFuZCBjaGFpbmluZyBtb2RlcyBhcmVcblx0ICogbm90IHN1cHBvcnRlZCBkaXJlY3RseSwgYnV0IHN1cHBvcnRhYmxlIGJ5IGV4dGVuZGluZy9pbXBsZW1lbnRpbmcgdGhlIGJhc2Vcblx0ICogY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyBoZXJlLlxuXHQgKlxuXHQgKiBTZWN1cmUgcmFuZG9tIGRhdGEgZm9yIGNyZWF0aW9uIG9mIEluaXRpYWxpemF0aW9uIFZlY3RvcnMgKElWcykgYW5kIGtleXNcblx0ICogaXMgb2J0YWluZWQgZnJvbSB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpZiBhdmFpbGFibGUsIG9yIGZyb21cblx0ICogTWF0aC5yYW5kb20oKSBpZiBub3QuIENsaWVudHMgd2hvIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBNYXRoLnJhbmRvbSgpXG5cdCAqIHNob3VsZCBwb2x5ZmlsbCB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB3aXRoIGEgbGlicmFyeSB0aGF0IHNlZWRzXG5cdCAqIGEgUFJORyB3aXRoIHJlYWwgZW50cm9weS5cblx0ICpcblx0ICogRWFjaCBtZXNzYWdlIHBheWxvYWQgaXMgZW5jcnlwdGVkIHdpdGggYW4gSVYgaW4gQ0JDIG1vZGUsIGFuZCB0aGUgSVYgaXNcblx0ICogY29uY2F0ZW5hdGVkIHdpdGggdGhlIHJlc3VsdGluZyByYXcgY2lwaGVydGV4dCB0byBjb25zdHJ1Y3QgdGhlIFwiY2lwaGVydGV4dFwiXG5cdCAqIGRhdGEgcGFzc2VkIHRvIHRoZSByZWNpcGllbnQuXG5cdCAqL1xuXHRmdW5jdGlvbiBDcnlwdG8oKSB7fVxuXG5cdC8qKlxuXHQgKiBBIGNsYXNzIGVuY2Fwc3VsYXRpbmcgdGhlIGNsaWVudC1zcGVjaWZpYWJsZSBwYXJhbWV0ZXJzIGZvclxuXHQgKiB0aGUgY2lwaGVyLlxuXHQgKlxuXHQgKiBhbGdvcml0aG0gaXMgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobSBpbiB0aGUgZGVmYXVsdCBzeXN0ZW0gcHJvdmlkZXIsXG5cdCAqIG9yIHRoZSBsb3dlci1jYXNlZCB2ZXJzaW9uIG9mIGl0OyBlZyBcImFlc1wiIG9yIFwiQUVTXCIuXG5cdCAqXG5cdCAqIENsaWVudHMgYXJlIHJlY29tbWVuZGVkIHRvIG5vdCBjYWxsIHRoaXMgZGlyZWN0bHksIGJ1dCBpbnN0ZWFkIHRvIHVzZSB0aGVcblx0ICogQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMgaGVscGVyLCB3aGljaCB3aWxsIGZpbGwgaW4gYW55IGZpZWxkcyBub3Qgc3VwcGxpZWRcblx0ICogd2l0aCBkZWZhdWx0IHZhbHVlcyBhbmQgdmFsaWRhdGlvbiB0aGUgcmVzdWx0LlxuXHQgKi9cblx0ZnVuY3Rpb24gQ2lwaGVyUGFyYW1zKCkge1xuXHRcdHRoaXMuYWxnb3JpdGhtID0gbnVsbDtcblx0XHR0aGlzLmtleUxlbmd0aCA9IG51bGw7XG5cdFx0dGhpcy5tb2RlID0gbnVsbDtcblx0XHR0aGlzLmtleSA9IG51bGw7XG5cdH1cblx0Q3J5cHRvLkNpcGhlclBhcmFtcyA9IENpcGhlclBhcmFtcztcblxuXHQvKipcblx0ICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xuXHQgKiBpbiBhbnkgbm90IHByb3ZpZGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMsIGNhbGN1bGF0aW5nIGEga2V5TGVuZ3RoIGZyb21cblx0ICogdGhlIHN1cHBsaWVkIGtleSwgYW5kIHZhbGlkYXRpbmcgdGhlIHJlc3VsdC5cblx0ICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcblx0ICoga2V5LCBhcyBlaXRoZXIgYSBiaW5hcnkgKEFycmF5QnVmZmVyLCBBcnJheSwgV29yZEFycmF5KSBvciBhXG5cdCAqIGJhc2U2NC1lbmNvZGVkIHN0cmluZy4gTWF5IG9wdGlvbmFsbHkgYWxzbyBjb250YWluOiBhbGdvcml0aG0gKGRlZmF1bHRzIHRvXG5cdCAqIEFFUyksIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxuXHQgKi9cblx0Q3J5cHRvLmdldERlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHR2YXIga2V5O1xuXHRcdC8qIEJhY2t3YXJkIGNvbXBhdGliaWxpdHkgKi9cblx0XHRpZigodHlwZW9mKHBhcmFtcykgPT09ICdmdW5jdGlvbicpIHx8ICh0eXBlb2YocGFyYW1zKSA9PT0gJ3N0cmluZycpKSB7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlcHJlY2F0ZWQoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKGtleSwgY2FsbGJhY2spJywgJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pJyk7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkoZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdFx0cGFyYW1zKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pKTtcblx0XHRcdFx0fSlcblx0XHRcdH0gZWxzZSBpZih0eXBlb2YgYXJndW1lbnRzWzFdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGFyZ3VtZW50c1sxXShudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7a2V5OiBwYXJhbXN9KSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYXJndW1lbnRzIGZvciBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcycpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKCFwYXJhbXMua2V5KSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleSBpcyByZXF1aXJlZCcpO1xuXHRcdH1cblxuXHRcdGlmICh0eXBlb2YocGFyYW1zLmtleSkgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRrZXkgPSBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInBhcnNlXCJdKShub3JtYWxpc2VCYXNlNjQocGFyYW1zLmtleSkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRrZXkgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KHBhcmFtcy5rZXkpOyAvLyBFeHBlY3Qga2V5IHRvIGJlIGFuIEFycmF5LCBBcnJheUJ1ZmZlciwgb3IgV29yZEFycmF5IGF0IHRoaXMgcG9pbnRcblx0XHR9XG5cblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gbmV3IENpcGhlclBhcmFtcygpO1xuXHRcdGNpcGhlclBhcmFtcy5rZXkgPSBrZXk7XG5cdFx0Y2lwaGVyUGFyYW1zLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gfHwgREVGQVVMVF9BTEdPUklUSE07XG5cdFx0Y2lwaGVyUGFyYW1zLmtleUxlbmd0aCA9IGtleS53b3Jkcy5sZW5ndGggKiAoNCAqIDgpO1xuXHRcdGNpcGhlclBhcmFtcy5tb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xuXG5cdFx0aWYocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiAnICsgcGFyYW1zLmtleUxlbmd0aCArICcgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCAnICsgY2lwaGVyUGFyYW1zLmtleUxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0dmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcblx0XHRyZXR1cm4gY2lwaGVyUGFyYW1zO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuXHQgKiBkZWZhdWx0IGtleUxlbmd0aCBpZiBub25lIHN1cHBsaWVkKSBhcyBhIENyeXB0b0pTIFdvcmRBcnJheVxuXHQgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCBrZXkpXG5cdCAqL1xuXHRDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkgPSBmdW5jdGlvbihrZXlMZW5ndGgsIGNhbGxiYWNrKSB7XG5cdFx0aWYoYXJndW1lbnRzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihrZXlMZW5ndGgpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNhbGxiYWNrID0ga2V5TGVuZ3RoO1xuXHRcdFx0a2V5TGVuZ3RoID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRnZW5lcmF0ZVJhbmRvbSgoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgsIGNhbGxiYWNrKTtcblx0fTtcblxuXHQvKipcblx0ICogSW50ZXJuYWw7IGdldCBhIENoYW5uZWxDaXBoZXIgaW5zdGFuY2UgYmFzZWQgb24gdGhlIGdpdmVuIGNpcGhlclBhcmFtc1xuXHQgKiBAcGFyYW0gcGFyYW1zIGVpdGhlciBhIENpcGhlclBhcmFtcyBpbnN0YW5jZSBvciBzb21lIHN1YnNldCBvZiBpdHNcblx0ICogZmllbGRzIHRoYXQgaW5jbHVkZXMgYSBrZXlcblx0ICovXG5cdENyeXB0by5nZXRDaXBoZXIgPSBmdW5jdGlvbihwYXJhbXMpIHtcblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gKHBhcmFtcyBpbnN0YW5jZW9mIENpcGhlclBhcmFtcykgP1xuXHRcdCAgICAgICAgICAgICAgICAgICBwYXJhbXMgOlxuXHRcdCAgICAgICAgICAgICAgICAgICBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyhwYXJhbXMpO1xuXG5cdFx0cmV0dXJuIHtjaXBoZXJQYXJhbXM6IGNpcGhlclBhcmFtcywgY2lwaGVyOiBuZXcgQ0JDQ2lwaGVyKGNpcGhlclBhcmFtcywgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUywgcGFyYW1zLml2KX07XG5cdH07XG5cblx0ZnVuY3Rpb24gQ0JDQ2lwaGVyKHBhcmFtcywgYmxvY2tMZW5ndGhXb3JkcywgaXYpIHtcblx0XHR0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyAnLScgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyAnLScgKyBwYXJhbXMubW9kZTtcblx0XHR0aGlzLmNqc0FsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tXFxkKyQvLCAnJyk7XG5cdFx0dGhpcy5rZXkgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KHBhcmFtcy5rZXkpO1xuXHRcdGlmKGl2KSB7XG5cdFx0XHR0aGlzLml2ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShpdikuY2xvbmUoKTtcblx0XHR9XG5cdFx0dGhpcy5ibG9ja0xlbmd0aFdvcmRzID0gYmxvY2tMZW5ndGhXb3Jkcztcblx0fVxuXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCwgY2FsbGJhY2spIHtcblx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5lbmNyeXB0KCknLCAnJyk7XG5cdFx0cGxhaW50ZXh0ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShwbGFpbnRleHQpO1xuXHRcdHZhciBwbGFpbnRleHRMZW5ndGggPSBwbGFpbnRleHQuc2lnQnl0ZXMsXG5cdFx0XHRwYWRkZWRMZW5ndGggPSBnZXRQYWRkZWRMZW5ndGgocGxhaW50ZXh0TGVuZ3RoKSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0dmFyIHRoZW4gPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuZ2V0SXYoZnVuY3Rpb24oZXJyLCBpdikge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNpcGhlck91dCA9IHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHBsYWludGV4dC5jb25jYXQocGtjczVQYWRkaW5nW3BhZGRlZExlbmd0aCAtIHBsYWludGV4dExlbmd0aF0pKTtcblx0XHRcdFx0dmFyIGNpcGhlcnRleHQgPSBpdi5jb25jYXQoY2lwaGVyT3V0KTtcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgY2lwaGVydGV4dCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0aWYgKCF0aGlzLmVuY3J5cHRDaXBoZXIpIHtcblx0XHRcdGlmKHRoaXMuaXYpIHtcblx0XHRcdFx0dGhpcy5lbmNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bdGhpcy5janNBbGdvcml0aG1dLmNyZWF0ZUVuY3J5cHRvcih0aGlzLmtleSwgeyBpdjogdGhpcy5pdiB9KTtcblx0XHRcdFx0dGhlbigpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Z2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCwgZnVuY3Rpb24oZXJyLCBpdikge1xuXHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuZW5jcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3NlbGYuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3Ioc2VsZi5rZXksIHsgaXY6IGl2IH0pO1xuXHRcdFx0XHRcdHNlbGYuaXYgPSBpdjtcblx0XHRcdFx0XHR0aGVuKCk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGVuKCk7XG5cdFx0fVxuXHR9O1xuXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNpcGhlcnRleHQpIHtcblx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5kZWNyeXB0KCknLCAnJyk7XG5cdFx0Y2lwaGVydGV4dCA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkoY2lwaGVydGV4dCk7XG5cdFx0dmFyIGJsb2NrTGVuZ3RoV29yZHMgPSB0aGlzLmJsb2NrTGVuZ3RoV29yZHMsXG5cdFx0XHRjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzLFxuXHRcdFx0aXYgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMCwgYmxvY2tMZW5ndGhXb3JkcykpLFxuXHRcdFx0Y2lwaGVydGV4dEJvZHkgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoYmxvY2tMZW5ndGhXb3JkcykpO1xuXG5cdFx0dmFyIGRlY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1t0aGlzLmNqc0FsZ29yaXRobV0uY3JlYXRlRGVjcnlwdG9yKHRoaXMua2V5LCB7IGl2OiBpdiB9KTtcblx0XHR2YXIgcGxhaW50ZXh0ID0gZGVjcnlwdENpcGhlci5wcm9jZXNzKGNpcGhlcnRleHRCb2R5KTtcblx0XHR2YXIgZXBpbG9ndWUgPSBkZWNyeXB0Q2lwaGVyLmZpbmFsaXplKCk7XG5cdFx0ZGVjcnlwdENpcGhlci5yZXNldCgpO1xuXHRcdGlmKGVwaWxvZ3VlICYmIGVwaWxvZ3VlLnNpZ0J5dGVzKSBwbGFpbnRleHQuY29uY2F0KGVwaWxvZ3VlKTtcblx0XHRyZXR1cm4gcGxhaW50ZXh0O1xuXHR9O1xuXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZ2V0SXYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGlmKHRoaXMuaXYpIHtcblx0XHRcdHZhciBpdiA9IHRoaXMuaXY7XG5cdFx0XHR0aGlzLml2ID0gbnVsbDtcblx0XHRcdGNhbGxiYWNrKG51bGwsIGl2KTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBTaW5jZSB0aGUgaXYgZm9yIGEgbmV3IGJsb2NrIGlzIHRoZSBjaXBoZXJ0ZXh0IG9mIHRoZSBsYXN0LCB0aGlzXG5cdFx0KiBzZXRzIGEgbmV3IGl2ICg9IGFlcyhyYW5kb21CbG9jayBYT1IgbGFzdENpcGhlclRleHQpKSBhcyB3ZWxsIGFzXG5cdFx0KiByZXR1cm5pbmcgaXQgKi9cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0Z2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCwgZnVuY3Rpb24oZXJyLCByYW5kb21CbG9jaykge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9IFxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgc2VsZi5lbmNyeXB0Q2lwaGVyLnByb2Nlc3MocmFuZG9tQmxvY2spKTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gQ3J5cHRvO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDcnlwdG8pO1xuXG5cbi8qKiovIH0pLFxuLyogMjAgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG52YXIgVHJhbnNwb3J0ID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgYWN0aW9ucyA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb247XG5cdHZhciBjbG9zZU1lc3NhZ2UgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLkNMT1NFfSk7XG5cdHZhciBkaXNjb25uZWN0TWVzc2FnZSA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuRElTQ09OTkVDVH0pO1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cblx0Lypcblx0ICogRXZlbnRFbWl0dGVyLCBnZW5lcmF0ZXMgdGhlIGZvbGxvd2luZyBldmVudHM6XG5cdCAqXG5cdCAqIGV2ZW50IG5hbWUgICAgICAgZGF0YVxuXHQgKiBjbG9zZWQgICAgICAgICAgIGVycm9yXG5cdCAqIGZhaWxlZCAgICAgICAgICAgZXJyb3Jcblx0ICogZGlzcG9zZWRcblx0ICogY29ubmVjdGVkICAgICAgICBudWxsIGVycm9yLCBjb25uZWN0aW9uU2VyaWFsLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzXG5cdCAqIHN5bmMgICAgICAgICAgICAgY29ubmVjdGlvblNlcmlhbCwgY29ubmVjdGlvbklkXG5cdCAqIGV2ZW50ICAgICAgICAgICAgY2hhbm5lbCBtZXNzYWdlIG9iamVjdFxuXHQgKi9cblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcblx0XHRjb25uZWN0aW9uTWFuYWdlci5yZWdpc3RlclByb3Bvc2VkVHJhbnNwb3J0KHRoaXMpO1xuXHRcdHRoaXMuYXV0aCA9IGF1dGg7XG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XG5cdFx0dGhpcy50aW1lb3V0cyA9IHBhcmFtcy5vcHRpb25zLnRpbWVvdXRzO1xuXHRcdHRoaXMuZm9ybWF0ID0gcGFyYW1zLmZvcm1hdDtcblx0XHR0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG5cdFx0dGhpcy5pc0ZpbmlzaGVkID0gZmFsc2U7XG5cdFx0dGhpcy5pc0Rpc3Bvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuXHRcdHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhUcmFuc3BvcnQsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHt9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRpZih0aGlzLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3RDbG9zZSgpO1xuXHRcdH1cblx0XHR0aGlzLmZpbmlzaCgnY2xvc2VkJywgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jbG9zZWQpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKGVycikge1xuXHRcdC8qIFVzZWQgZm9yIG5ldHdvcmsvdHJhbnNwb3J0IGlzc3VlcyB0aGF0IG5lZWQgdG8gcmVzdWx0IGluIHRoZSB0cmFuc3BvcnRcblx0XHQgKiBiZWluZyBkaXNjb25uZWN0ZWQsIGJ1dCBzaG91bGQgbm90IGFmZmVjdCB0aGUgY29ubmVjdGlvbiAqL1xuXHRcdGlmKHRoaXMuaXNDb25uZWN0ZWQpIHtcblx0XHRcdHRoaXMucmVxdWVzdERpc2Nvbm5lY3QoKTtcblx0XHR9XG5cdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVyciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRpc2Nvbm5lY3RlZCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0LyogVXNlZCBmb3IgY2xpZW50LXNpZGUtZGV0ZWN0ZWQgZmF0YWwgY29ubmVjdGlvbiBpc3N1ZXMgKi9cblx0XHRpZih0aGlzLmlzQ29ubmVjdGVkKSB7XG5cdFx0XHR0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XG5cdFx0fVxuXHRcdHRoaXMuZmluaXNoKCdmYWlsZWQnLCBlcnIgfHwgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mYWlsZWQpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oZXZlbnQsIGVycikge1xuXHRcdGlmKHRoaXMuaXNGaW5pc2hlZCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMuaXNGaW5pc2hlZCA9IHRydWU7XG5cdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IGZhbHNlO1xuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcblx0XHRjbGVhclRpbWVvdXQodGhpcy5pZGxlVGltZXIpO1xuXHRcdHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcblx0XHR0aGlzLmVtaXQoZXZlbnQsIGVycik7XG5cdFx0dGhpcy5kaXNwb3NlKCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vblByb3RvY29sTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHRpZiAoX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2hvdWxkTG9nKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTykpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBvbiAnICsgdGhpcy5zaG9ydE5hbWUgKyAnOiAnICsgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ2lmeShtZXNzYWdlKSArICc7IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XG5cdFx0fVxuXHRcdHRoaXMub25BY3Rpdml0eSgpO1xuXG5cdFx0c3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XG5cdFx0Y2FzZSBhY3Rpb25zLkhFQVJUQkVBVDpcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsIHRoaXMuc2hvcnROYW1lICsgJyBoZWFydGJlYXQ7IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XG5cdFx0XHR0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcsIG1lc3NhZ2UuaWQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkNPTk5FQ1RFRDpcblx0XHRcdHRoaXMub25Db25uZWN0KG1lc3NhZ2UpO1xuXHRcdFx0dGhpcy5lbWl0KCdjb25uZWN0ZWQnLCBtZXNzYWdlLmVycm9yLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscywgbWVzc2FnZSk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuQ0xPU0VEOlxuXHRcdFx0dGhpcy5vbkNsb3NlKG1lc3NhZ2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkRJU0NPTk5FQ1RFRDpcblx0XHRcdHRoaXMub25EaXNjb25uZWN0KG1lc3NhZ2UpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkFDSzpcblx0XHRcdHRoaXMuZW1pdCgnYWNrJywgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLk5BQ0s6XG5cdFx0XHR0aGlzLmVtaXQoJ25hY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuU1lOQzpcblx0XHRcdGlmKG1lc3NhZ2UuY29ubmVjdGlvbklkICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0LyogYSB0cmFuc3BvcnQgU1lOQyAqL1xuXHRcdFx0XHR0aGlzLmVtaXQoJ3N5bmMnLCBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgbWVzc2FnZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0Lyogb3RoZXJ3aXNlIGl0J3MgYSBjaGFubmVsIFNZTkMsIHNvIGhhbmRsZSBpdCBpbiB0aGUgY2hhbm5lbCAqL1xuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkFVVEg6XG5cdFx0XHR0aGlzLmF1dGguYXV0aG9yaXplKGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZihlcnIpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAnQWJseSByZXF1ZXN0ZWQgcmUtYXV0aGVudGljYXRpb24sIGJ1dCB1bmFibGUgdG8gb2J0YWluIGEgbmV3IHRva2VuOiAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSBhY3Rpb25zLkVSUk9SOlxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGVycm9yIGFjdGlvbjsgY29ubmVjdGlvbklkID0gJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkICsgJzsgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdChtZXNzYWdlLmVycm9yKSArIChtZXNzYWdlLmNoYW5uZWwgPyAoJywgY2hhbm5lbDogJyArICBtZXNzYWdlLmNoYW5uZWwpIDogJycpKTtcblx0XHRcdGlmKG1lc3NhZ2UuY2hhbm5lbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMub25GYXRhbEVycm9yKG1lc3NhZ2UpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdC8qIG90aGVyd2lzZSBpdCdzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciwgc28gaGFuZGxlIGl0IGluIHRoZSBjaGFubmVsICovXG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG5cdFx0XHRicmVhaztcblx0XHRkZWZhdWx0OlxuXHRcdFx0LyogYWxsIG90aGVyIGFjdGlvbnMgYXJlIGNoYW5uZWwtc3BlY2lmaWMgKi9cblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcblx0XHR9XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XG5cdFx0dmFyIG1heFByb21pc2VkSWRsZSA9IG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMubWF4SWRsZUludGVydmFsO1xuXHRcdGlmKG1heFByb21pc2VkSWRsZSkge1xuXHRcdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBtYXhQcm9taXNlZElkbGUgKyB0aGlzLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XG5cdFx0XHR0aGlzLm9uQWN0aXZpdHkoKTtcblx0XHR9XG5cdFx0LyogZWxzZSBSZWFsdGltZSBkZWNsaW5lcyB0byBndWFyYW50ZWUgYW55IG1heGltdW0gaWRsZSBpbnRlcnZhbCAtIENEMmggKi9cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGlzY29ubmVjdCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHQvKiBVc2VkIGZvciB3aGVuIHRoZSBzZXJ2ZXIgaGFzIGRpc2Nvbm5lY3RlZCB0aGUgY2xpZW50ICh1c3VhbGx5IHdpdGggYVxuXHRcdCAqIERJU0NPTk5FQ1RFRCBhY3Rpb24pICovXG5cdFx0dmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uRGlzY29ubmVjdCgpJywgJ2VyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcblx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRmF0YWxFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcblx0XHQvKiBPbiByZWNlaXB0IG9mIGEgZmF0YWwgY29ubmVjdGlvbiBlcnJvciwgd2UgY2FuIGFzc3VtZSB0aGF0IHRoZSBzZXJ2ZXJcblx0XHQgKiB3aWxsIGNsb3NlIHRoZSBjb25uZWN0aW9uIGFuZCB0aGUgdHJhbnNwb3J0LCBhbmQgZG8gbm90IG5lZWQgdG8gcmVxdWVzdFxuXHRcdCAqIGEgZGlzY29ubmVjdGlvbiAtIFJUTjE1aSAqL1xuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkZhdGFsRXJyb3IoKScsICdlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0dGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVycik7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNsb3NlID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkNsb3NlKCknLCAnZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdHRoaXMuZmluaXNoKCdjbG9zZWQnLCBlcnIpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKScsICcnKTtcblx0XHR0aGlzLnNlbmQoY2xvc2VNZXNzYWdlKTtcblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3REaXNjb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpJywgJycpO1xuXHRcdHRoaXMuc2VuZChkaXNjb25uZWN0TWVzc2FnZSk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24oaWQpIHtcblx0XHR2YXIgbXNnID0ge2FjdGlvbjogX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbi5IRUFSVEJFQVR9O1xuXHRcdGlmKGlkKSBtc2cuaWQgPSBpZDtcblx0XHR0aGlzLnNlbmQoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMobXNnKSk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG5cdFx0dGhpcy5pc0Rpc3Bvc2VkID0gdHJ1ZTtcblx0XHR0aGlzLm9mZigpO1xuXHR9O1xuXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25BY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKCF0aGlzLm1heElkbGVJbnRlcnZhbCkgeyByZXR1cm47IH1cblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIubGFzdEFjdGl2aXR5ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKTtcblx0XHR0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5zZXRJZGxlVGltZXIgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKCF0aGlzLmlkbGVUaW1lcikge1xuXHRcdFx0dGhpcy5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLm9uSWRsZVRpbWVyRXhwaXJlKCk7XG5cdFx0XHR9LCB0aW1lb3V0KTtcblx0XHR9XG5cdH07XG5cblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbklkbGVUaW1lckV4cGlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaWRsZVRpbWVyID0gbnVsbDtcblx0XHR2YXIgc2luY2VMYXN0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSAtIHRoaXMubGFzdEFjdGl2aXR5LFxuXHRcdFx0dGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xuXHRcdGlmKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuXHRcdFx0dmFyIG1zZyA9ICdObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gJyArIHNpbmNlTGFzdCArICdtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZCc7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCknLCBtc2cpO1xuXHRcdFx0dGhpcy5kaXNjb25uZWN0KG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAwMywgNDA4KSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuXHRcdH1cblx0fTtcblxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbigpIHt9O1xuXG5cdHJldHVybiBUcmFuc3BvcnQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFRyYW5zcG9ydCk7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBDb25uZWN0aW9uU3RhdGVDaGFuZ2UgPSAoZnVuY3Rpb24oKSB7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENvbm5lY3Rpb25TdGF0ZUNoYW5nZShwcmV2aW91cywgY3VycmVudCwgcmV0cnlJbiwgcmVhc29uKSB7XG5cdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuXHRcdHRoaXMuY3VycmVudCA9IGN1cnJlbnQ7XG5cdFx0aWYocmV0cnlJbikgdGhpcy5yZXRyeUluID0gcmV0cnlJbjtcblx0XHRpZihyZWFzb24pIHRoaXMucmVhc29uID0gcmVhc29uO1xuXHR9XG5cblx0cmV0dXJuIENvbm5lY3Rpb25TdGF0ZUNoYW5nZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29ubmVjdGlvblN0YXRlQ2hhbmdlKTtcblxuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxudmFyIE11bHRpY2FzdGVyID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIE11bHRpY2FzdGVyKG1lbWJlcnMpIHtcblx0XHRtZW1iZXJzID0gbWVtYmVycyB8fCBbXTtcblxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWVtYmVycy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgbWVtYmVyID0gbWVtYmVyc1tpXTtcblx0XHRcdFx0aWYobWVtYmVyKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdG1lbWJlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuXHRcdFx0XHRcdH0gY2F0Y2goZSl7XG5cdFx0XHRcdFx0XHRfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdNdWx0aWNhc3RlciBtdWx0aXBsZSBjYWxsYmFjayBoYW5kbGVyJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uOiAnICsgZSArICc7IHN0YWNrID0gJyArIGUuc3RhY2spO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRoYW5kbGVyLnB1c2ggPSBmdW5jdGlvbigpIHtcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG1lbWJlcnMsIGFyZ3VtZW50cyk7XG5cdFx0fTtcblx0XHRyZXR1cm4gaGFuZGxlcjtcblx0fVxuXG5cdHJldHVybiBNdWx0aWNhc3Rlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTXVsdGljYXN0ZXIpO1xuXG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcblxuXG5cblxuXG5cbnZhciBFcnJvclJlcG9ydGVyID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBFcnJvclJlcG9ydGVyKCkge31cblxuXHR2YXIgbGV2ZWxzID0gRXJyb3JSZXBvcnRlci5sZXZlbHMgPSBbXG5cdFx0J2ZhdGFsJyxcblx0XHQnZXJyb3InLFxuXHRcdCd3YXJuaW5nJyxcblx0XHQnaW5mbycsXG5cdFx0J2RlYnVnJ1xuXHRdO1xuXG5cdC8qIChsZXZlbDogdHlwZW9mIEVycm9yUmVwb3J0ZXIubGV2ZWxzW251bWJlcl0sIG1lc3NhZ2U6IHN0cmluZywgZmluZ2VycHJpbnQ/OiBzdHJpbmcsIHRhZ3M/OiB7W2tleTogc3RyaW5nXTogc3RyaW5nfSk6IHZvaWQgKi9cblx0RXJyb3JSZXBvcnRlci5yZXBvcnQgPSBmdW5jdGlvbihsZXZlbCwgbWVzc2FnZSwgZmluZ2VycHJpbnQsIHRhZ3MpIHtcblx0XHR2YXIgZXZlbnRJZCA9IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJhbmRvbUhleFN0cmluZygxNik7XG5cblx0XHR2YXIgZXZlbnQgPSB7XG5cdFx0XHRldmVudF9pZDogZXZlbnRJZCxcblx0XHRcdHRhZ3M6IF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKHtcblx0XHRcdFx0YWJseUFnZW50OiBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFnZW50XG5cdFx0XHR9LCB0YWdzKSxcblx0XHRcdHBsYXRmb3JtOiAnamF2YXNjcmlwdCcsXG5cdFx0XHRsZXZlbDogbGV2ZWwsXG5cdFx0XHRyZWxlYXNlOiBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnZlcnNpb24sXG5cdFx0XHRmaW5nZXJwcmludDogZmluZ2VycHJpbnQgJiYgWyBmaW5nZXJwcmludCBdLFxuXHRcdFx0bWVzc2FnZTogbWVzc2FnZSxcblx0XHRcdHJlcXVlc3Q6IHtcblx0XHRcdFx0aGVhZGVyczoge1xuXHRcdFx0XHRcdCdVc2VyLUFnZW50JzogcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51c2VyQWdlbnRcblx0XHRcdFx0fSxcblx0XHRcdFx0dXJsOiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmN1cnJlbnRVcmxcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnRXJyb3JSZXBvcnRlcicsICdQT1NUaW5nIHRvIGVycm9yIHJlcG9ydGVyOiAnICsgbWVzc2FnZSk7XG5cdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnBvc3RVcmkobnVsbCwgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5lcnJvclJlcG9ydGluZ1VybCwgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5lcnJvclJlcG9ydGluZ0hlYWRlcnMsIEpTT04uc3RyaW5naWZ5KGV2ZW50KSwge30sIGZ1bmN0aW9uKGVyciwgcmVzKSB7XG5cdFx0XHRfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdFcnJvclJlcG9ydGVyJywgJ1BPU1RpbmcgdG8gZXJyb3IgcmVwb3J0ZXIgcmVzdWx0ZWQgaW46ICcgK1xuXHRcdFx0XHQoZXJyID8gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikgOiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0Qm9keShyZXMpKVxuXHRcdFx0KTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gRXJyb3JSZXBvcnRlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRXJyb3JSZXBvcnRlcik7XG5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbnZhciBtc2dwYWNrID0gKGZ1bmN0aW9uKCkge1xuXHRcInVzZSBzdHJpY3RcIjtcblxuXHR2YXIgZXhwb3J0cyA9IHt9O1xuXG5cdGV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XG5cdGZ1bmN0aW9uIGluc3BlY3QoYnVmZmVyKSB7XG5cdFx0aWYgKGJ1ZmZlciA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0cmV0dXJuIFwidW5kZWZpbmVkXCI7XG5cdFx0dmFyIHZpZXc7XG5cdFx0dmFyIHR5cGU7XG5cdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuXHRcdFx0dHlwZSA9IFwiQXJyYXlCdWZmZXJcIjtcblx0XHRcdHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblx0XHR9IGVsc2UgaWYgKCBidWZmZXIgaW5zdGFuY2VvZiBEYXRhVmlldykge1xuXHRcdFx0dHlwZSA9IFwiRGF0YVZpZXdcIjtcblx0XHRcdHZpZXcgPSBidWZmZXI7XG5cdFx0fVxuXHRcdGlmICghdmlldylcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShidWZmZXIpO1xuXHRcdHZhciBieXRlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYnVmZmVyLmJ5dGVMZW5ndGg7IGkrKykge1xuXHRcdFx0aWYgKGkgPiAyMCkge1xuXHRcdFx0XHRieXRlcy5wdXNoKFwiLi4uXCIpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHZhciBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSkudG9TdHJpbmcoMTYpO1xuXHRcdFx0aWYgKGJ5dGVfLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0Ynl0ZV8gPSBcIjBcIiArIGJ5dGVfO1xuXHRcdFx0Ynl0ZXMucHVzaChieXRlXyk7XG5cdFx0fVxuXHRcdHJldHVybiBcIjxcIiArIHR5cGUgKyBcIiBcIiArIGJ5dGVzLmpvaW4oXCIgXCIpICsgXCI+XCI7XG5cdH1cblxuXHQvLyBFbmNvZGUgc3RyaW5nIGFzIHV0ZjggaW50byBkYXRhdmlldyBhdCBvZmZzZXRcblx0ZXhwb3J0cy51dGY4V3JpdGUgPSB1dGY4V3JpdGU7XG5cdGZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cmluZykge1xuXHRcdHZhciBieXRlTGVuZ3RoID0gdmlldy5ieXRlTGVuZ3RoO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXG5cdFx0XHQvLyBPbmUgYnl0ZSBvZiBVVEYtOFxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4ODApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAwICYgMHg3ZiB8IDB4MDApO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVHdvIGJ5dGVzIG9mIFVURi04XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMHgxZiB8IDB4YzApO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaHJlZSBieXRlcyBvZiBVVEYtOC5cblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMTIgJiAweDBmIHwgMHhlMCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAwICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRm91ciBieXRlcyBvZiBVVEYtOFxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMTggJiAweDA3IHwgMHhmMCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMTIgJiAweDNmIHwgMHg4MCk7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDB4M2YgfCAweDgwKTtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiAwICYgMHgzZiB8IDB4ODApO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcImJhZCBjb2RlcG9pbnQgXCIgKyBjb2RlUG9pbnQpO1xuXHRcdH1cblx0fVxuXG5cblx0ZXhwb3J0cy51dGY4UmVhZCA9IHV0ZjhSZWFkO1xuXHRmdW5jdGlvbiB1dGY4UmVhZCh2aWV3LCBvZmZzZXQsIGxlbmd0aCkge1xuXHRcdHZhciBzdHJpbmcgPSBcIlwiO1xuXHRcdGZvciAodmFyIGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG5cdFx0XHR2YXIgYnl0ZV8gPSB2aWV3LmdldFVpbnQ4KGkpO1xuXHRcdFx0Ly8gT25lIGJ5dGUgY2hhcmFjdGVyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHg4MCkgPT09IDB4MDApIHtcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZV8pO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdC8vIFR3byBieXRlIGNoYXJhY3RlclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ZTApID09PSAweGMwKSB7XG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDBmKSA8PCA2KSB8ICh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0Ly8gVGhyZWUgYnl0ZSBjaGFyYWN0ZXJcblx0XHRcdGlmICgoYnl0ZV8gJiAweGYwKSA9PT0gMHhlMCkge1xuXHRcdFx0XHRzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwZikgPDwgMTIpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdC8vIEZvdXIgYnl0ZSBjaGFyYWN0ZXJcblx0XHRcdGlmICgoYnl0ZV8gJiAweGY4KSA9PT0gMHhmMCkge1xuXHRcdFx0XHRzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwNykgPDwgMTgpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAxMikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDYpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAwKSk7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBieXRlIFwiICsgYnl0ZV8udG9TdHJpbmcoMTYpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHN0cmluZztcblx0fVxuXG5cblx0ZXhwb3J0cy51dGY4Qnl0ZUNvdW50ID0gdXRmOEJ5dGVDb3VudDtcblx0ZnVuY3Rpb24gdXRmOEJ5dGVDb3VudChzdHJpbmcpIHtcblx0XHR2YXIgY291bnQgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4ODApIHtcblx0XHRcdFx0Y291bnQgKz0gMTtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcblx0XHRcdFx0Y291bnQgKz0gMjtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuXHRcdFx0XHRjb3VudCArPSAzO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuXHRcdFx0XHRjb3VudCArPSA0O1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHRocm93IG5ldyBFcnJvcihcImJhZCBjb2RlcG9pbnQgXCIgKyBjb2RlUG9pbnQpO1xuXHRcdH1cblx0XHRyZXR1cm4gY291bnQ7XG5cdH1cblxuXG5cdGV4cG9ydHMuZW5jb2RlID0gZnVuY3Rpb24odmFsdWUsIHNwYXJzZSkge1xuXHRcdHZhciBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xuXHRcdGlmKHNpemUgPT0gMClcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0dmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcblx0XHR2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuXHRcdGVuY29kZSh2YWx1ZSwgdmlldywgMCwgc3BhcnNlKTtcblx0XHRyZXR1cm4gYnVmZmVyO1xuXHR9O1xuXG5cdGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xuXG5cdHZhciBTSF9MXzMyID0gKDEgPDwgMTYpICogKDEgPDwgMTYpLCBTSF9SXzMyID0gMSAvIFNIX0xfMzI7XG5cdGZ1bmN0aW9uIGdldEludDY0KHZpZXcsIG9mZnNldCkge1xuXHRcdG9mZnNldCA9IG9mZnNldCB8fCAwO1xuXHRcdHJldHVybiB2aWV3LmdldEludDMyKG9mZnNldCkgKiBTSF9MXzMyICsgdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRVaW50NjQodmlldywgb2Zmc2V0KSB7XG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG5cdFx0cmV0dXJuIHZpZXcuZ2V0VWludDMyKG9mZnNldCkgKiBTSF9MXzMyICsgdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCk7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRJbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xuXHRcdGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwMDApIHtcblx0XHRcdHZpZXcuc2V0SW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcblx0XHRcdHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIDB4N2ZmZmZmZmYpO1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgMHg3ZmZmZmZmZik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gc2V0VWludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XG5cdFx0aWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCwgTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSk7XG5cdFx0XHR2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0LCAweGZmZmZmZmZmKTtcblx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDB4ZmZmZmZmZmYpO1xuXHRcdH1cblx0fVxuXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9mcnN5dWtpLzU0MzI1NTkgLSB2NSBzcGVjXG4vL1xuLy8gSSd2ZSB1c2VkIG9uZSBleHRlbnNpb24gcG9pbnQgZnJvbSBgZml4ZXh0IDFgIHRvIHN0b3JlIGB1bmRlZmluZWRgLiBPbiB0aGUgd2lyZSB0aGlzXG4vLyBzaG91bGQgdHJhbnNsYXRlIHRvIGV4YWN0bHkgMHhkNDAwMDBcbi8vXG4vLyArLS0tLS0tLS0rLS0tLS0tLS0rLS0tLS0tLS0rXG4vLyB8ICAweGQ0ICB8ICAweDAwICB8ICAweDAwICB8XG4vLyArLS0tLS0tLS0rLS0tLS0tLS0rLS0tLS0tLS0rXG4vLyAgICBeIGZpeGV4dCB8ICAgICAgICBeIHZhbHVlIHBhcnQgdW51c2VkIChmaXhlZCB0byBiZSAwKVxuLy8gICAgICAgICAgICAgXiBpbmRpY2F0ZXMgdW5kZWZpbmVkIHZhbHVlXG4vL1xuXG5cdGZ1bmN0aW9uIERlY29kZXIodmlldywgb2Zmc2V0KSB7XG5cdFx0dGhpcy5vZmZzZXQgPSBvZmZzZXQgfHwgMDtcblx0XHR0aGlzLnZpZXcgPSB2aWV3O1xuXHR9XG5cblxuXHREZWNvZGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIga2V5ID0gdGhpcy5wYXJzZSgpO1xuXHRcdFx0dmFsdWVba2V5XSA9IHRoaXMucGFyc2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLmJpbiA9IERlY29kZXIucHJvdG90eXBlLmJ1ZiA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IG5ldyBBcnJheUJ1ZmZlcihsZW5ndGgpO1xuXHRcdChuZXcgVWludDhBcnJheSh2YWx1ZSkpLnNldChuZXcgVWludDhBcnJheSh0aGlzLnZpZXcuYnVmZmVyLCB0aGlzLm9mZnNldCwgbGVuZ3RoKSwgMCk7XG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fTtcblxuXHREZWNvZGVyLnByb3RvdHlwZS5zdHIgPSBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSB1dGY4UmVhZCh0aGlzLnZpZXcsIHRoaXMub2Zmc2V0LCBsZW5ndGgpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHR2YXIgdmFsdWUgPSBuZXcgQXJyYXkobGVuZ3RoKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YWx1ZVtpXSA9IHRoaXMucGFyc2UoKTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXG5cdERlY29kZXIucHJvdG90eXBlLmV4dCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdHZhciB2YWx1ZSA9IHt9O1xuXHRcdC8vIEdldCB0aGUgdHlwZSBieXRlXG5cdFx0dmFsdWVbJ3R5cGUnXSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0KTtcblx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdC8vIEdldCB0aGUgZGF0YSBhcnJheSAobGVuZ3RoKVxuXHRcdHZhbHVlWydkYXRhJ10gPSB0aGlzLmJ1ZihsZW5ndGgpO1xuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcblx0XHRyZXR1cm4gdmFsdWU7XG5cdH07XG5cblx0RGVjb2Rlci5wcm90b3R5cGUucGFyc2UgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHlwZSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCk7XG5cdFx0dmFyIHZhbHVlLCBsZW5ndGg7XG5cblx0XHQvLyBQb3NpdGl2ZSBGaXhJbnQgLSAweHh4eHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ODApID09PSAweDAwKSB7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHR5cGU7XG5cdFx0fVxuXG5cdFx0Ly8gRml4TWFwIC0gMTAwMHh4eHhcblx0XHRpZiAoKHR5cGUgJiAweGYwKSA9PT0gMHg4MCkge1xuXHRcdFx0bGVuZ3RoID0gdHlwZSAmIDB4MGY7XG5cdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0cmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG5cdFx0fVxuXG5cdFx0Ly8gRml4QXJyYXkgLSAxMDAxeHh4eFxuXHRcdGlmICgodHlwZSAmIDB4ZjApID09PSAweDkwKSB7XG5cdFx0XHRsZW5ndGggPSB0eXBlICYgMHgwZjtcblx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRyZXR1cm4gdGhpcy5hcnJheShsZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIEZpeFN0ciAtIDEwMXh4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHhlMCkgPT09IDB4YTApIHtcblx0XHRcdGxlbmd0aCA9IHR5cGUgJiAweDFmO1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuXHRcdH1cblxuXHRcdC8vIE5lZ2F0aXZlIEZpeEludCAtIDExMXh4eHh4XG5cdFx0aWYgKCh0eXBlICYgMHhlMCkgPT09IDB4ZTApIHtcblx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQpO1xuXHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRzd2l0Y2ggKHR5cGUpIHtcblxuXHRcdFx0Ly8gbmlsXG5cdFx0XHRjYXNlIDB4YzA6XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0XHQvLyAweGMxIG5ldmVyIHVzZWQgLSB1c2UgZm9yIHVuZGVmaW5lZCAoTk9OLVNUQU5EQVJEKVxuXHRcdFx0Y2FzZSAweGMxOlxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBmYWxzZVxuXHRcdFx0Y2FzZSAweGMyOlxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdC8vIHRydWVcblx0XHRcdGNhc2UgMHhjMzpcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdC8vIGJpbiA4XG5cdFx0XHRjYXNlIDB4YzQ6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcblxuXHRcdFx0Ly8gYmluIDE2XG5cdFx0XHRjYXNlIDB4YzU6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XG5cblx0XHRcdC8vIGJpbiAzMlxuXHRcdFx0Y2FzZSAweGM2OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xuXG5cdFx0XHQvLyBleHQgOFxuXHRcdFx0Y2FzZSAweGM3OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDgodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGV4dCAxNlxuXHRcdFx0Y2FzZSAweGM4OlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBleHQgMzJcblx0XHRcdGNhc2UgMHhjOTpcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZmxvYXQgMzJcblx0XHRcdGNhc2UgMHhjYTpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQzMih0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGZsb2F0IDY0XG5cdFx0XHRjYXNlIDB4Y2I6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEZsb2F0NjQodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gOTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyB1aW50OFxuXHRcdFx0Y2FzZSAweGNjOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIHVpbnQgMTZcblx0XHRcdGNhc2UgMHhjZDpcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gdWludCAzMlxuXHRcdFx0Y2FzZSAweGNlOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyB1aW50IDY0XG5cdFx0XHRjYXNlIDB4Y2Y6XG5cdFx0XHRcdHZhbHVlID0gZ2V0VWludDY0KHRoaXMudmlldywgdGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gOTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXG5cdFx0XHQvLyBpbnQgOFxuXHRcdFx0Y2FzZSAweGQwOlxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gaW50IDE2XG5cdFx0XHRjYXNlIDB4ZDE6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gaW50IDMyXG5cdFx0XHRjYXNlIDB4ZDI6XG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblxuXHRcdFx0Ly8gaW50IDY0XG5cdFx0XHRjYXNlIDB4ZDM6XG5cdFx0XHRcdHZhbHVlID0gZ2V0SW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA5O1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cblx0XHRcdC8vIGZpeGV4dCAxXG5cdFx0XHRjYXNlIDB4ZDQ6XG5cdFx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmaXhleHQgMlxuXHRcdFx0Y2FzZSAweGQ1OlxuXHRcdFx0XHRsZW5ndGggPSAyO1xuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcblxuXHRcdFx0Ly8gZml4ZXh0IDRcblx0XHRcdGNhc2UgMHhkNjpcblx0XHRcdFx0bGVuZ3RoID0gNDtcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XG5cblx0XHRcdC8vIGZpeGV4dCA4XG5cdFx0XHRjYXNlIDB4ZDc6XG5cdFx0XHRcdGxlbmd0aCA9IDg7XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBmaXhleHQgMTZcblx0XHRcdGNhc2UgMHhkODpcblx0XHRcdFx0bGVuZ3RoID0gMTY7XG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xuXG5cdFx0XHQvLyBzdHI4XG5cdFx0XHRjYXNlIDB4ZDk6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcblxuXHRcdFx0Ly8gc3RyIDE2XG5cdFx0XHRjYXNlIDB4ZGE6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XG5cblx0XHRcdC8vIHN0ciAzMlxuXHRcdFx0Y2FzZSAweGRiOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xuXG5cdFx0XHQvLyBhcnJheSAxNlxuXHRcdFx0Y2FzZSAweGRjOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDE2KHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XG5cdFx0XHRcdHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XG5cblx0XHRcdC8vIGFycmF5IDMyXG5cdFx0XHRjYXNlIDB4ZGQ6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcblxuXHRcdFx0Ly8gbWFwIDE2XG5cdFx0XHRjYXNlIDB4ZGU6XG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMztcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XG5cblx0XHRcdC8vIG1hcCAzMlxuXHRcdFx0Y2FzZSAweGRmOlxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgMHhcIiArIHR5cGUudG9TdHJpbmcoMTYpKTtcblx0fTtcblxuXHRmdW5jdGlvbiBkZWNvZGUoYnVmZmVyKSB7XG5cdFx0dmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcblx0XHR2YXIgZGVjb2RlciA9IG5ldyBEZWNvZGVyKHZpZXcpO1xuXHRcdHZhciB2YWx1ZSA9IGRlY29kZXIucGFyc2UoKTtcblx0XHRpZiAoZGVjb2Rlci5vZmZzZXQgIT09IGJ1ZmZlci5ieXRlTGVuZ3RoKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKChidWZmZXIuYnl0ZUxlbmd0aCAtIGRlY29kZXIub2Zmc2V0KSArIFwiIHRyYWlsaW5nIGJ5dGVzXCIpO1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpIHtcblx0XHR2YXIga2V5cyA9IFtdOyAvLyBUT0RPOiB1c2UgT2JqZWN0LmtleXMgd2hlbiB3ZSBhcmUgYWJsZSB0byB0cmFuc3BpbGUgdG8gRVMzXG5cdFx0Zm9yICh2YXIga2V5IGluIHZhbHVlKSB7XG5cdFx0XHRpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KGtleSkpIGNvbnRpbnVlO1xuXHRcdFx0a2V5cy5wdXNoKGtleSk7XG5cdFx0fVxuXHRcdHJldHVybiBrZXlzLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuXHRcdFx0dmFyIHZhbCA9IHZhbHVlW2VdLCB0eXBlID0gdHlwZW9mKHZhbCk7XG5cdFx0XHRyZXR1cm4gKCFzcGFyc2UgfHwgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkpICYmICgnZnVuY3Rpb24nICE9PSB0eXBlIHx8ICEhdmFsLnRvSlNPTik7XG5cdFx0fSlcblx0fVxuXG5cdGZ1bmN0aW9uIGVuY29kZSh2YWx1ZSwgdmlldywgb2Zmc2V0LCBzcGFyc2UpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdC8vIFN0cmluZ3MgQnl0ZXNcblx0XHQvLyBUaGVyZSBhcmUgZm91ciBzdHJpbmcgdHlwZXM6IGZpeHN0ci9zdHI4L3N0cjE2L3N0cjMyXG5cdFx0aWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciBsZW5ndGggPSB1dGY4Qnl0ZUNvdW50KHZhbHVlKTtcblxuXHRcdFx0Ly8gZml4c3RyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgyMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoIHwgMHhhMCk7XG5cdFx0XHRcdHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAxICsgbGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdHI4XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDkpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAyLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiAyICsgbGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBzdHIxNlxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGEpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgMywgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdC8vIHN0cjMyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGIpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgNSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZihBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuXHRcdFx0Ly8gZXh0cmFjdCB0aGUgYXJyYXlidWZmZXIgYW5kIGZhbGx0aHJvdWdoXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLmJ1ZmZlcjtcblx0XHR9XG5cblx0XHQvLyBUaGVyZSBhcmUgdGhyZWUgYmluIHR5cGVzOiBiaW44L2JpbjE2L2JpbjMyXG5cdFx0aWYgKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuXG5cdFx0XHQvLyBiaW44XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzQpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDIpO1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmluMTZcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM1KTtcblx0XHRcdFx0dmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0KG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKSkuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgMyk7XG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBiaW4gMzJcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNik7XG5cdFx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aCk7XG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDUpO1xuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xuXG5cdFx0XHQvLyBGbG9hdGluZyBQb2ludFxuXHRcdFx0Ly8gTk9URTogV2UncmUgYWx3YXlzIHVzaW5nIGZsb2F0NjRcblx0XHRcdGlmIChNYXRoLmZsb29yKHZhbHVlKSAhPT0gdmFsdWUpIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2IpO1xuXHRcdFx0XHR2aWV3LnNldEZsb2F0NjQob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSW50ZWdlcnNcblx0XHRcdGlmICh2YWx1ZSA+PSAwKSB7XG5cdFx0XHRcdC8vIHBvc2l0aXZlIGZpeG51bVxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDgwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1aW50IDhcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDApIHtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjYyk7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHRcdH1cblx0XHRcdFx0Ly8gdWludCAxNlxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2QpO1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1aW50IDMyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2UpO1xuXHRcdFx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gNTtcblx0XHRcdFx0fVxuXHRcdFx0XHQvLyB1aW50IDY0XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZik7XG5cdFx0XHRcdFx0c2V0VWludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gbmVnYXRpdmUgZml4bnVtXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApIHtcblx0XHRcdFx0dmlldy5zZXRJbnQ4KG9mZnNldCwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblx0XHRcdC8vIGludCA4XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDApO1xuXHRcdFx0XHR2aWV3LnNldEludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblx0XHRcdC8vIGludCAxNlxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDEpO1xuXHRcdFx0XHR2aWV3LnNldEludDE2KG9mZnNldCArIDEsIHZhbHVlKTtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cdFx0XHQvLyBpbnQgMzJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMik7XG5cdFx0XHRcdHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuXHRcdFx0XHRyZXR1cm4gNTtcblx0XHRcdH1cblx0XHRcdC8vIGludCA2NFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwMDAwMDAwMDAwMDAwMDApIHtcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDMpO1xuXHRcdFx0XHRzZXRJbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiA5O1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArICgtdmFsdWUpLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuXHRcdH1cblxuXHRcdC8vIHVuZGVmaW5lZCAtIHVzZSBkNCAoTk9OLVNUQU5EQVJEKVxuXHRcdGlmICh0eXBlID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRpZihzcGFyc2UpIHJldHVybiAwO1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDQpO1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCAweDAwKTtcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMiwgMHgwMCk7XG5cdFx0XHRyZXR1cm4gMztcblx0XHR9XG5cblx0XHQvLyBudWxsXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSB7XG5cdFx0XHRpZihzcGFyc2UpIHJldHVybiAwO1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzApO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0Ly8gQm9vbGVhblxuXHRcdGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xuXHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIHZhbHVlID8gMHhjMyA6IDB4YzIpO1xuXHRcdFx0cmV0dXJuIDE7XG5cdFx0fVxuXG5cdFx0aWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcblx0XHRcdHJldHVybiBlbmNvZGUodmFsdWUudG9KU09OKCksIHZpZXcsIG9mZnNldCwgc3BhcnNlKTtcblxuXHRcdC8vIENvbnRhaW5lciBUeXBlc1xuXHRcdGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XG5cdFx0XHR2YXIgbGVuZ3RoLCBzaXplID0gMDtcblx0XHRcdHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG5cblx0XHRcdGlmIChpc0FycmF5KSB7XG5cdFx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSk7XG5cdFx0XHRcdGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc2l6ZTtcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBsZW5ndGggfCAoIGlzQXJyYXkgPyAweDkwIDogMHg4MCkpO1xuXHRcdFx0XHRzaXplID0gMTtcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDB4ZGMgOiAweGRlKTtcblx0XHRcdFx0dmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcblx0XHRcdFx0c2l6ZSA9IDM7XG5cdFx0XHR9IGVsc2UgaWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBpc0FycmF5ID8gMHhkZCA6IDB4ZGYpO1xuXHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xuXHRcdFx0XHRzaXplID0gNTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKGlzQXJyYXkpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHNpemUgKz0gZW5jb2RlKHZhbHVlW2ldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0c2l6ZSArPSBlbmNvZGUoa2V5LCB2aWV3LCBvZmZzZXQgKyBzaXplKTtcblx0XHRcdFx0XHRzaXplICs9IGVuY29kZSh2YWx1ZVtrZXldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzaXplO1xuXHRcdH1cblx0XHRpZih0eXBlID09PSBcImZ1bmN0aW9uXCIpXG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdC8vIGZpeHN0ciBvciBzdHI4IG9yIHN0cjE2IG9yIHN0cjMyXG5cdFx0aWYgKHR5cGUgPT09IFwic3RyaW5nXCIpIHtcblx0XHRcdHZhciBsZW5ndGggPSB1dGY4Qnl0ZUNvdW50KHZhbHVlKTtcblx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XG5cdFx0XHRcdHJldHVybiAxICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XG5cdFx0XHRcdHJldHVybiAyICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDMgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcblx0XHRcdC8vIGV4dHJhY3QgdGhlIGFycmF5YnVmZmVyIGFuZCBmYWxsdGhyb3VnaFxuXHRcdFx0dmFsdWUgPSB2YWx1ZS5idWZmZXI7XG5cdFx0fVxuXG5cdFx0Ly8gYmluOCBvciBiaW4xNiBvciBiaW4zMlxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMCkge1xuXHRcdFx0XHRyZXR1cm4gMiArIGxlbmd0aDtcblx0XHRcdH1cblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XG5cdFx0XHRcdHJldHVybiA1ICsgbGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XG5cdFx0XHQvLyBGbG9hdGluZyBQb2ludCAoMzIgYml0cylcblx0XHRcdC8vIGRvdWJsZVxuXHRcdFx0aWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcblx0XHRcdFx0cmV0dXJuIDk7XG5cblx0XHRcdC8vIEludGVnZXJzXG5cdFx0XHRpZiAodmFsdWUgPj0gMCkge1xuXHRcdFx0XHQvLyBwb3NpdGl2ZSBmaXhpbnRcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHg4MClcblx0XHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdFx0Ly8gdWludCA4XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwKVxuXHRcdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0XHQvLyB1aW50IDE2XG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDApXG5cdFx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHRcdC8vIHVpbnQgMzJcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApXG5cdFx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHRcdC8vIHVpbnQgNjRcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMClcblx0XHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdFx0Ly8gVG9vIGJpZ1xuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcblx0XHRcdH1cblx0XHRcdC8vIG5lZ2F0aXZlIGZpeGludFxuXHRcdFx0aWYgKHZhbHVlID49IC0weDIwKVxuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdC8vIGludCA4XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODApXG5cdFx0XHRcdHJldHVybiAyO1xuXHRcdFx0Ly8gaW50IDE2XG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMClcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHQvLyBpbnQgMzJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMClcblx0XHRcdFx0cmV0dXJuIDU7XG5cdFx0XHQvLyBpbnQgNjRcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKVxuXHRcdFx0XHRyZXR1cm4gOTtcblx0XHRcdC8vIFRvbyBzbWFsbFxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuXHRcdH1cblxuXHRcdC8vIEJvb2xlYW5cblx0XHRpZiAodHlwZSA9PT0gXCJib29sZWFuXCIpIHJldHVybiAxO1xuXG5cdFx0Ly8gdW5kZWZpbmVkLCBudWxsXG5cdFx0aWYgKHZhbHVlID09PSBudWxsKSByZXR1cm4gc3BhcnNlID8gMCA6IDE7XG5cdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybiBzcGFyc2UgPyAwIDogMztcblxuXHRcdGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXG5cdFx0XHRyZXR1cm4gc2l6ZW9mKHZhbHVlLnRvSlNPTigpLCBzcGFyc2UpO1xuXG5cdFx0Ly8gQ29udGFpbmVyIFR5cGVzXG5cdFx0aWYgKHR5cGUgPT09IFwib2JqZWN0XCIpIHtcblx0XHRcdHZhciBsZW5ndGgsIHNpemUgPSAwO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdHNpemUgKz0gc2l6ZW9mKHZhbHVlW2ldLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpXG5cdFx0XHRcdGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0c2l6ZSArPSBzaXplb2Yoa2V5KSArIHNpemVvZih2YWx1ZVtrZXldLCBzcGFyc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMCkge1xuXHRcdFx0XHRyZXR1cm4gMSArIHNpemU7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xuXHRcdFx0XHRyZXR1cm4gMyArIHNpemU7XG5cdFx0XHR9XG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcblx0XHRcdFx0cmV0dXJuIDUgKyBzaXplO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4XCIgKyBsZW5ndGgudG9TdHJpbmcoMTYpKTtcblx0XHR9XG5cdFx0aWYodHlwZSA9PT0gXCJmdW5jdGlvblwiKVxuXHRcdFx0cmV0dXJuIDA7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGUgXCIgKyB0eXBlKTtcblx0fVxuXG5cdHJldHVybiBleHBvcnRzO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChtc2dwYWNrKTtcblxuXG4vKioqLyB9KSxcbi8qIDI1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2xpZW50X2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9tdWx0aWNhc3Rlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fdHJhbnNwb3J0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJzb2NrZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG52YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBoYXZlV2ViU3RvcmFnZSA9ICEhKHR5cGVvZihwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXQpO1xuXHR2YXIgaGF2ZVNlc3Npb25TdG9yYWdlID0gISEodHlwZW9mKHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0pICE9PSAndW5kZWZpbmVkJyAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFNlc3Npb24pO1xuXHR2YXIgYWN0aW9ucyA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb247XG5cdHZhciBQZW5kaW5nTWVzc2FnZSA9IF9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlBlbmRpbmdNZXNzYWdlO1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdHZhciB0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcjtcblx0dmFyIG9wdGltYWxUcmFuc3BvcnQgPSB0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXJbdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLmxlbmd0aCAtIDFdO1xuXHR2YXIgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUgPSAnYWJseS10cmFuc3BvcnQtcHJlZmVyZW5jZSc7XG5cblx0dmFyIHNlc3Npb25SZWNvdmVyeU5hbWUgPSAnYWJseS1jb25uZWN0aW9uLXJlY292ZXJ5Jztcblx0ZnVuY3Rpb24gZ2V0U2Vzc2lvblJlY292ZXJEYXRhKCkge1xuXHRcdHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRTZXNzaW9uKHNlc3Npb25SZWNvdmVyeU5hbWUpO1xuXHR9XG5cdGZ1bmN0aW9uIHNldFNlc3Npb25SZWNvdmVyRGF0YSh2YWx1ZSkge1xuXHRcdHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zZXRTZXNzaW9uKHNlc3Npb25SZWNvdmVyeU5hbWUsIHZhbHVlKTtcblx0fVxuXHRmdW5jdGlvbiBjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpIHtcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVtb3ZlU2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGJldHRlclRyYW5zcG9ydFRoYW4oYSwgYikge1xuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YodHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLCBhLnNob3J0TmFtZSkgPlxuXHRcdCAgIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZih0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGIuc2hvcnROYW1lKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFRyYW5zcG9ydFBhcmFtcyhvcHRpb25zLCBob3N0LCBtb2RlLCBjb25uZWN0aW9uS2V5KSB7XG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcblx0XHR0aGlzLmhvc3QgPSBob3N0O1xuXHRcdHRoaXMubW9kZSA9IG1vZGU7XG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcblx0XHR0aGlzLmZvcm1hdCA9IG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbic7XG5cblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lU2VyaWFsID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0VHJhbnNwb3J0UGFyYW1zLnByb3RvdHlwZS5nZXRDb25uZWN0UGFyYW1zID0gZnVuY3Rpb24oYXV0aFBhcmFtcykge1xuXHRcdHZhciBwYXJhbXMgPSBhdXRoUGFyYW1zID8gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jb3B5KGF1dGhQYXJhbXMpIDoge307XG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG5cdFx0c3dpdGNoKHRoaXMubW9kZSkge1xuXHRcdFx0Y2FzZSAndXBncmFkZSc6XG5cdFx0XHRcdHBhcmFtcy51cGdyYWRlID0gdGhpcy5jb25uZWN0aW9uS2V5O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3Jlc3VtZSc6XG5cdFx0XHRcdHBhcmFtcy5yZXN1bWUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG5cdFx0XHRcdGlmKHRoaXMudGltZVNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0cGFyYW1zLnRpbWVTZXJpYWwgPSB0aGlzLnRpbWVTZXJpYWw7XG5cdFx0XHRcdH0gZWxzZSBpZih0aGlzLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdHBhcmFtcy5jb25uZWN0aW9uU2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncmVjb3Zlcic6XG5cdFx0XHRcdHZhciBtYXRjaCA9IG9wdGlvbnMucmVjb3Zlci5zcGxpdCgnOicpO1xuXHRcdFx0XHRpZihtYXRjaCkge1xuXHRcdFx0XHRcdHBhcmFtcy5yZWNvdmVyID0gbWF0Y2hbMF07XG5cdFx0XHRcdFx0dmFyIHJlY292ZXJTZXJpYWwgPSBtYXRjaFsxXTtcblx0XHRcdFx0XHRpZihpc05hTihyZWNvdmVyU2VyaWFsKSkge1xuXHRcdFx0XHRcdFx0cGFyYW1zLnRpbWVTZXJpYWwgPSByZWNvdmVyU2VyaWFsO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwYXJhbXMuY29ubmVjdGlvblNlcmlhbCA9IHJlY292ZXJTZXJpYWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHR9XG5cdFx0aWYob3B0aW9ucy5jbGllbnRJZCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwYXJhbXMuY2xpZW50SWQgPSBvcHRpb25zLmNsaWVudElkO1xuXHRcdH1cblx0XHRpZihvcHRpb25zLmVjaG9NZXNzYWdlcyA9PT0gZmFsc2UpIHtcblx0XHRcdHBhcmFtcy5lY2hvID0gJ2ZhbHNlJztcblx0XHR9XG5cdFx0aWYodGhpcy5mb3JtYXQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLmZvcm1hdCA9IHRoaXMuZm9ybWF0O1xuXHRcdH1cblx0XHRpZih0aGlzLnN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwYXJhbXMuc3RyZWFtID0gdGhpcy5zdHJlYW07XG5cdFx0fVxuXHRcdGlmKHRoaXMuaGVhcnRiZWF0cyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRwYXJhbXMuaGVhcnRiZWF0cyA9IHRoaXMuaGVhcnRiZWF0cztcblx0XHR9XG5cdFx0cGFyYW1zLnYgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFwaVZlcnNpb247XG5cdFx0cGFyYW1zLmFnZW50ID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZ2VudDtcblx0XHRpZihvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKHBhcmFtcywgb3B0aW9ucy50cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1zO1xuXHR9O1xuXG5cdFRyYW5zcG9ydFBhcmFtcy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVzdWx0ID0gJ1ttb2RlPScgKyB0aGlzLm1vZGU7XG5cdFx0aWYodGhpcy5ob3N0KSB7IHJlc3VsdCArPSAoJyxob3N0PScgKyB0aGlzLmhvc3QpOyB9XG5cdFx0aWYodGhpcy5jb25uZWN0aW9uS2V5KSB7IHJlc3VsdCArPSAoJyxjb25uZWN0aW9uS2V5PScgKyB0aGlzLmNvbm5lY3Rpb25LZXkpOyB9XG5cdFx0aWYodGhpcy5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHsgcmVzdWx0ICs9ICgnLGNvbm5lY3Rpb25TZXJpYWw9JyArIHRoaXMuY29ubmVjdGlvblNlcmlhbCk7IH1cblx0XHRpZih0aGlzLnRpbWVTZXJpYWwpIHsgcmVzdWx0ICs9ICgnLHRpbWVTZXJpYWw9JyArIHRoaXMudGltZVNlcmlhbCk7IH1cblx0XHRpZih0aGlzLmZvcm1hdCkgeyByZXN1bHQgKz0gKCcsZm9ybWF0PScgKyB0aGlzLmZvcm1hdCk7IH1cblx0XHRyZXN1bHQgKz0gJ10nO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ29ubmVjdGlvbk1hbmFnZXIocmVhbHRpbWUsIG9wdGlvbnMpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHZhciB0aW1lb3V0cyA9IG9wdGlvbnMudGltZW91dHM7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdC8qIGNvbm5lY3RpbmdUaW1lb3V0OiBsZWF2ZSBwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKH42cykgdG8gdHJ5IHRoZVxuXHRcdCAqIHByZWZlcmVuY2UgdHJhbnNwb3J0LCB0aGVuIHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgKH4xMHMpIHRvIGVzdGFibGlzaFxuXHRcdCAqIHRoZSBiYXNlIHRyYW5zcG9ydCBpbiBjYXNlIHRoYXQgZmFpbHMgKi9cblx0XHR2YXIgY29ubmVjdGluZ1RpbWVvdXQgPSB0aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuXHRcdHRoaXMuc3RhdGVzID0ge1xuXHRcdFx0aW5pdGlhbGl6ZWQ6ICAge3N0YXRlOiAnaW5pdGlhbGl6ZWQnLCAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRjb25uZWN0aW5nOiAgICB7c3RhdGU6ICdjb25uZWN0aW5nJywgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiBjb25uZWN0aW5nVGltZW91dCwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXG5cdFx0XHRjb25uZWN0ZWQ6ICAgICB7c3RhdGU6ICdjb25uZWN0ZWQnLCAgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IHRydWUsICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdHN5bmNocm9uaXppbmc6IHtzdGF0ZTogJ2Nvbm5lY3RlZCcsICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiB0cnVlLCAgc2VuZEV2ZW50czogZmFsc2UsIGZvcmNlUXVldWVFdmVudHM6IHRydWUsIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxuXHRcdFx0ZGlzY29ubmVjdGVkOiAge3N0YXRlOiAnZGlzY29ubmVjdGVkJywgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMuZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0LCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcblx0XHRcdHN1c3BlbmRlZDogICAgIHtzdGF0ZTogJ3N1c3BlbmRlZCcsICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnN1c3BlbmRlZFJldHJ5VGltZW91dCwgZmFpbFN0YXRlOiAnc3VzcGVuZGVkJ30sXG5cdFx0XHRjbG9zaW5nOiAgICAgICB7c3RhdGU6ICdjbG9zaW5nJywgICAgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LCBmYWlsU3RhdGU6ICdjbG9zZWQnfSxcblx0XHRcdGNsb3NlZDogICAgICAgIHtzdGF0ZTogJ2Nsb3NlZCcsICAgICAgICB0ZXJtaW5hbDogdHJ1ZSwgIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2Nsb3NlZCd9LFxuXHRcdFx0ZmFpbGVkOiAgICAgICAge3N0YXRlOiAnZmFpbGVkJywgICAgICAgIHRlcm1pbmFsOiB0cnVlLCAgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnZmFpbGVkJ31cblx0XHR9O1xuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5pbml0aWFsaXplZDtcblx0XHR0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcblxuXHRcdHRoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgX21lc3NhZ2VxdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCk7XG5cdFx0dGhpcy5tc2dTZXJpYWwgPSAwO1xuXHRcdHRoaXMuY29ubmVjdGlvbkRldGFpbHMgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSB0aW1lb3V0cy5jb25uZWN0aW9uU3RhdGVUdGw7XG5cdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuXG5cdFx0dGhpcy50cmFuc3BvcnRzID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcnNlY3QoKG9wdGlvbnMudHJhbnNwb3J0cyB8fCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlZmF1bHRUcmFuc3BvcnRzKSwgQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyk7XG5cdFx0LyogYmFzZVRyYW5zcG9ydHMgc2VsZWN0cyB0aGUgbGVmdG1vc3QgdHJhbnNwb3J0IGluIHRoZSBEZWZhdWx0cy5iYXNlVHJhbnNwb3J0T3JkZXIgbGlzdFxuXHRcdCogdGhhdCdzIGJvdGggcmVxdWVzdGVkIGFuZCBzdXBwb3J0ZWQuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB4aHJfcG9sbGluZztcblx0XHQqIGlmIHhociBpc24ndCBzdXBwb3J0ZWQgaXQgd2lsbCBiZSBqc29ucC4gSWYgdGhlIHVzZXIgaGFzIGZvcmNlZCBhXG5cdFx0KiB0cmFuc3BvcnQsIGl0J2xsIGp1c3QgYmUgdGhhdCBvbmUuICovXG5cdFx0dGhpcy5iYXNlVHJhbnNwb3J0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcnNlY3QoX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlVHJhbnNwb3J0T3JkZXIsIHRoaXMudHJhbnNwb3J0cylbMF07XG5cdFx0dGhpcy51cGdyYWRlVHJhbnNwb3J0cyA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW50ZXJzZWN0KHRoaXMudHJhbnNwb3J0cywgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51cGdyYWRlVHJhbnNwb3J0cyk7XG5cdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcblxuXHRcdHRoaXMuaHR0cEhvc3RzID0gX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRIb3N0cyhvcHRpb25zKTtcblx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gbnVsbDtcblx0XHR0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xuXHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcblx0XHR0aGlzLmhvc3QgPSBudWxsO1xuXHRcdHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcblx0XHR0aGlzLmxhc3RBY3Rpdml0eSA9IG51bGw7XG5cdFx0dGhpcy5tb3N0UmVjZW50TXNnID0gbnVsbDtcblx0XHR0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XG5cdFx0dGhpcy5jb25uZWN0Q291bnRlciA9IDA7XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdzdGFydGVkJyk7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAncmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbJyArIChvcHRpb25zLnRyYW5zcG9ydHMgfHwgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWZhdWx0VHJhbnNwb3J0cykgKyAnXScpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2F2YWlsYWJsZSB0cmFuc3BvcnRzID0gWycgKyB0aGlzLnRyYW5zcG9ydHMgKyAnXScpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2h0dHAgaG9zdHMgPSBbJyArIHRoaXMuaHR0cEhvc3RzICsgJ10nKTtcblxuXHRcdGlmKCF0aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG5cdFx0XHR2YXIgbXNnID0gJ25vIHJlcXVlc3RlZCB0cmFuc3BvcnRzIGF2YWlsYWJsZSc7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAncmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsIG1zZyk7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcblx0XHR9XG5cblx0XHR2YXIgYWRkRXZlbnRMaXN0ZW5lciA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWRkRXZlbnRMaXN0ZW5lcjtcblx0XHRpZihhZGRFdmVudExpc3RlbmVyKSB7XG5cdFx0XHQvKiBpbnRlcmNlcHQgY2xvc2UgZXZlbnQgaW4gYnJvd3NlciB0byBwZXJzaXN0IGNvbm5lY3Rpb24gaWQgaWYgcmVxdWVzdGVkICovXG5cdFx0XHRpZihoYXZlU2Vzc2lvblN0b3JhZ2UgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHQvKiBVc3VhbGx5IGNhbid0IHVzZSBiaW5kIGFzIG5vdCBzdXBwb3J0ZWQgaW4gSUU4LCBidXQgSUUgZG9lc24ndCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlLCBzby4uLiAqL1xuXHRcdFx0XHRhZGRFdmVudExpc3RlbmVyKCdiZWZvcmV1bmxvYWQnLCB0aGlzLnBlcnNpc3RDb25uZWN0aW9uLmJpbmQodGhpcykpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZihvcHRpb25zLmNsb3NlT25VbmxvYWQgPT09IHRydWUpIHtcblx0XHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NQUpPUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlJyk7XG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY2xvc2luZyd9KTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIExpc3RlbiBmb3Igb25saW5lIGFuZCBvZmZsaW5lIGV2ZW50cyAqL1xuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuZGlzY29ubmVjdGVkIHx8IHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuc3VzcGVuZGVkKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIOKAmG9ubGluZeKAmSBldmVudCcsICdyZWF0dGVtcHRpbmcgY29ubmVjdGlvbicpO1xuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZihzZWxmLnN0YXRlID09IHNlbGYuc3RhdGVzLmNvbm5lY3RlZCkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciDigJhvZmZsaW5l4oCZIGV2ZW50JywgJ2Rpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydCcpO1xuXHRcdFx0XHRcdC8vIE5vdCBzdWZmaWNpZW50IHRvIGp1c3QgZ28gdG8gdGhlICdkaXNjb25uZWN0ZWQnIHN0YXRlLCB3YW50IHRvXG5cdFx0XHRcdFx0Ly8gZm9yY2UgYWxsIHRyYW5zcG9ydHMgdG8gcmVhdHRlbXB0IHRoZSBjb25uZWN0aW9uLiBXaWxsIGltbWVkaWF0ZWx5XG5cdFx0XHRcdFx0Ly8gcmV0cnkuXG5cdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhDb25uZWN0aW9uTWFuYWdlciwgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKipcblx0ICogdHJhbnNwb3J0IG1hbmFnZW1lbnRcblx0ICoqKioqKioqKioqKioqKioqKioqKi9cblxuXHRDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzID0ge307XG5cblx0T2JqZWN0KF93ZWJzb2NrZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKENvbm5lY3Rpb25NYW5hZ2VyKTtcblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKHBsYXRmb3JtX3RyYW5zcG9ydHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X19bLyogZGVmYXVsdCAqLyBcImFcIl0sIGZ1bmN0aW9uIChpbml0Rm4pIHtcblx0XHRpbml0Rm4oQ29ubmVjdGlvbk1hbmFnZXIpO1xuXHR9KTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24oaG9zdCwgbW9kZSkge1xuXHRcdHZhciBwYXJhbXMgPSBuZXcgVHJhbnNwb3J0UGFyYW1zKHRoaXMub3B0aW9ucywgaG9zdCwgbW9kZSwgdGhpcy5jb25uZWN0aW9uS2V5KTtcblx0XHRpZih0aGlzLnRpbWVTZXJpYWwpIHtcblx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsO1xuXHRcdH0gZWxzZSBpZih0aGlzLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0cGFyYW1zLmNvbm5lY3Rpb25TZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWw7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJhbXM7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zcG9ydFBhcmFtcyA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gZGVjaWRlTW9kZShtb2RlQ2IpIHtcblx0XHRcdGlmKHNlbGYuY29ubmVjdGlvbktleSkge1xuXHRcdFx0XHRtb2RlQ2IoJ3Jlc3VtZScpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmKHR5cGVvZiBzZWxmLm9wdGlvbnMucmVjb3ZlciA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0bW9kZUNiKCdyZWNvdmVyJyk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHJlY292ZXJGbiA9IHNlbGYub3B0aW9ucy5yZWNvdmVyLFxuXHRcdFx0XHRsYXN0U2Vzc2lvbkRhdGEgPSBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKTtcblx0XHRcdGlmKGxhc3RTZXNzaW9uRGF0YSAmJiB0eXBlb2YocmVjb3ZlckZuKSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnQ2FsbGluZyBjbGllbnRPcHRpb25zLXByb3ZpZGVkIHJlY292ZXIgZnVuY3Rpb24gd2l0aCBsYXN0IHNlc3Npb24gZGF0YScpO1xuXHRcdFx0XHRyZWNvdmVyRm4obGFzdFNlc3Npb25EYXRhLCBmdW5jdGlvbihzaG91bGRSZWNvdmVyKSB7XG5cdFx0XHRcdFx0aWYoc2hvdWxkUmVjb3Zlcikge1xuXHRcdFx0XHRcdFx0c2VsZi5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG5cdFx0XHRcdFx0XHRtb2RlQ2IoJ3JlY292ZXInKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bW9kZUNiKCdjbGVhbicpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdG1vZGVDYignY2xlYW4nKTtcblx0XHR9XG5cblx0XHRkZWNpZGVNb2RlKGZ1bmN0aW9uKG1vZGUpIHtcblx0XHRcdHZhciB0cmFuc3BvcnRQYXJhbXMgPSBzZWxmLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhudWxsLCBtb2RlKTtcblx0XHRcdGlmKG1vZGUgPT09ICdyZWNvdmVyJykge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnVHJhbnNwb3J0IHJlY292ZXJ5IG1vZGUgPSByZWNvdmVyOyByZWNvdmVyeUtleSA9ICcgKyBzZWxmLm9wdGlvbnMucmVjb3Zlcik7XG5cdFx0XHRcdHZhciBtYXRjaCA9IHNlbGYub3B0aW9ucy5yZWNvdmVyLnNwbGl0KCc6Jyk7XG5cdFx0XHRcdGlmKG1hdGNoICYmIG1hdGNoWzJdKSB7XG5cdFx0XHRcdFx0c2VsZi5tc2dTZXJpYWwgPSBtYXRjaFsyXTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ1RyYW5zcG9ydCBwYXJhbXMgPSAnICsgdHJhbnNwb3J0UGFyYW1zLnRvU3RyaW5nKCkpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sodHJhbnNwb3J0UGFyYW1zKTtcblx0XHR9KTtcblx0fTtcblxuXHQvKipcblx0ICogQXR0ZW1wdCB0byBjb25uZWN0IHVzaW5nIGEgZ2l2ZW4gdHJhbnNwb3J0XG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcblx0ICogQHBhcmFtIGNhbmRpZGF0ZSwgdGhlIHRyYW5zcG9ydCB0byB0cnlcblx0ICogQHBhcmFtIGNhbGxiYWNrXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudHJ5QVRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcywgY2FuZGlkYXRlLCBjYWxsYmFjaykge1xuXHRcdHZhciBzZWxmID0gdGhpcywgaG9zdCA9IHRyYW5zcG9ydFBhcmFtcy5ob3N0O1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndHJ5aW5nICcgKyBjYW5kaWRhdGUpO1xuXHRcdChDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW2NhbmRpZGF0ZV0pLnRyeUNvbm5lY3QodGhpcywgdGhpcy5yZWFsdGltZS5hdXRoLCB0cmFuc3BvcnRQYXJhbXMsIGZ1bmN0aW9uKHdyYXBwZWRFcnIsIHRyYW5zcG9ydCkge1xuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5zdGF0ZTtcblx0XHRcdGlmKHN0YXRlID09IHNlbGYuc3RhdGVzLmNsb3NpbmcgfHwgc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY2xvc2VkIHx8IHN0YXRlID09IHNlbGYuc3RhdGVzLmZhaWxlZCkge1xuXHRcdFx0XHRpZih0cmFuc3BvcnQpIHtcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb24gJyArIHN0YXRlLnN0YXRlICsgJyB3aGlsZSB3ZSB3ZXJlIGF0dGVtcHRpbmcgdGhlIHRyYW5zcG9ydDsgY2xvc2luZyAnICsgdHJhbnNwb3J0KTtcblx0XHRcdFx0XHR0cmFuc3BvcnQuY2xvc2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayh0cnVlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZih3cmFwcGVkRXJyKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnICcgKyB3cmFwcGVkRXJyLmV2ZW50ICsgJywgZXJyOiAnICsgd3JhcHBlZEVyci5lcnJvci50b1N0cmluZygpKTtcblxuXHRcdFx0XHQvKiBDb21ldCB0cmFuc3BvcnQgb25jb25uZWN0IHRva2VuIGVycm9ycyBjYW4gYmUgZGVhbHQgd2l0aCBoZXJlLlxuXHRcdFx0XHQqIFdlYnNvY2tldCBvbmVzIG9ubHkgaGFwcGVuIGFmdGVyIHRoZSB0cmFuc3BvcnQgY2xhaW1zIHRvIGJlIHZpYWJsZSxcblx0XHRcdFx0KiBzbyBhcmUgZGVhbHQgd2l0aCBhcyBub24tb25jb25uZWN0IHRva2VuIGVycm9ycyAqL1xuXHRcdFx0XHRpZihfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycih3cmFwcGVkRXJyLmVycm9yKSAmJiAhKHNlbGYuZXJyb3JSZWFzb24gJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIoc2VsZi5lcnJvclJlYXNvbikpKSB7XG5cdFx0XHRcdFx0c2VsZi5lcnJvclJlYXNvbiA9IHdyYXBwZWRFcnIuZXJyb3I7XG5cdFx0XHRcdFx0LyogcmUtZ2V0IGEgdG9rZW4gYW5kIHRyeSBhZ2FpbiAqL1xuXHRcdFx0XHRcdHNlbGYucmVhbHRpbWUuYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsLCBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdFx0XHRzZWxmLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2UgaWYod3JhcHBlZEVyci5ldmVudCA9PT0gJ2ZhaWxlZCcpIHtcblx0XHRcdFx0XHQvKiBFcnJvciB0aGF0J3MgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cblx0XHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiB3cmFwcGVkRXJyLmVycm9yfSk7XG5cdFx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZih3cmFwcGVkRXJyLmV2ZW50ID09PSAnZGlzY29ubmVjdGVkJykge1xuXHRcdFx0XHRcdGlmKCFfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzUmV0cmlhYmxlKHdyYXBwZWRFcnIuZXJyb3IpKSB7XG5cdFx0XHRcdFx0XHQvKiBFcnJvciByZWNlaXZlZCBmcm9tIHRoZSBzZXJ2ZXIgdGhhdCBkb2VzIG5vdCBjYWxsIGZvciB0cnlpbmcgYSBmYWxsYmFjayBob3N0LCBlZyBhIHJhdGUgbGltaXQgKi9cblx0XHRcdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiBzZWxmLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3J9KTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrKHRydWUpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHQvKiBFcnJvciB3aXRoIHRoYXQgdHJhbnNwb3J0IG9ubHk7IGNvbnRpbnVlIHRyeWluZyBvdGhlciBmYWxsYmFjayBob3N0cyAqL1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZmFsc2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgY2FuZGlkYXRlICsgJzsgc2V0dGluZyBwZW5kaW5nJyk7XG5cdFx0XHRzZWxmLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBpbmRpY2F0ZWQgdG8gYmUgdmlhYmxlLCBhbmQgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyXG5cdCAqIGV4cGVjdHMgdG8gYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgYXMgc29vbiBhcyBpdCBpcyBjb25uZWN0ZWQuXG5cdCAqIEBwYXJhbSBob3N0XG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRUcmFuc3BvcnRQZW5kaW5nID0gZnVuY3Rpb24odHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHR2YXIgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRUcmFuc3BvcnRQZW5kaW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IG1vZGUgPSAnICsgbW9kZSk7XG5cblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMucHVzaCh0cmFuc3BvcnQpO1xuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRyYW5zcG9ydC5vbmNlKCdjb25uZWN0ZWQnLCBmdW5jdGlvbihlcnJvciwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKSB7XG5cdFx0XHRpZihtb2RlID09ICd1cGdyYWRlJyAmJiBzZWxmLmFjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRcdC8qICBpZiB3cyBhbmQgeGhycyBhcmUgY29ubmVjdGluZyBpbiBwYXJhbGxlbCwgZGVsYXkgeGhycyBhY3RpdmF0aW9uIHRvIGxldCB3cyBnbyBhaGVhZCAqL1xuXHRcdFx0XHRpZih0cmFuc3BvcnQuc2hvcnROYW1lICE9PSBvcHRpbWFsVHJhbnNwb3J0ICYmIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4oc2VsZi5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpLCBvcHRpbWFsVHJhbnNwb3J0KSkge1xuXHRcdFx0XHRcdHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pO1xuXHRcdFx0XHRcdH0sIHNlbGYub3B0aW9ucy50aW1lb3V0cy5wYXJhbGxlbFVwZ3JhZGVEZWxheSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pO1xuXG5cdFx0XHRcdC8qIGFsbG93IGNvbm5lY3RJbXBsIHRvIHN0YXJ0IHRoZSB1cGdyYWRlIHByb2Nlc3MgaWYgbmVlZGVkLCBidXQgYWxsb3dcblx0XHRcdFx0ICogb3RoZXIgZXZlbnQgaGFuZGxlcnMsIGluY2x1ZGluZyBhY3RpdmF0aW5nIHRoZSB0cmFuc3BvcnQsIHRvIHJ1biBmaXJzdCAqL1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHNlbGYuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdGlmKG1vZGUgPT09ICdyZWNvdmVyJyAmJiBzZWxmLm9wdGlvbnMucmVjb3Zlcikge1xuXHRcdFx0XHQvKiBBZnRlciBhIHN1Y2Nlc3NmdWwgcmVjb3ZlcnksIHdlIHVucGVyc2lzdCwgYXMgYSByZWNvdmVyeSBrZXkgY2Fubm90XG5cdFx0XHRcdCogYmUgdXNlZCBtb3JlIHRoYW4gb25jZSAqL1xuXHRcdFx0XHRzZWxmLm9wdGlvbnMucmVjb3ZlciA9IG51bGw7XG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dHJhbnNwb3J0Lm9uKFsnZGlzY29ubmVjdGVkJywgJ2Nsb3NlZCcsICdmYWlsZWQnXSwgZnVuY3Rpb24oZXJyb3IpIHtcblx0XHRcdHNlbGYuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuZW1pdCgndHJhbnNwb3J0LnBlbmRpbmcnLCB0cmFuc3BvcnQpO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhbiB1cGdyYWRlIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsXG5cdCAqIHRvIHNjaGVkdWxlIHRoZSBhY3RpdmF0aW9uIG9mIHRoYXQgdHJhbnNwb3J0LlxuXHQgKiBAcGFyYW0gZXJyb3Jcblx0ICogQHBhcmFtIHRyYW5zcG9ydFxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbklkXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlsc1xuXHQgKiBAcGFyYW0gY29ubmVjdGVkTWVzc2FnZVxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbiA9IGZ1bmN0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIHVwZ3JhZGVDb25uZWN0aW9uUG9zaXRpb24pIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMsXG5cdFx0XHRjdXJyZW50VHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLFxuXHRcdFx0YWJhbmRvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHNlbGYucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cdFx0XHR9O1xuXG5cdFx0aWYodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkICYmIHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcblx0XHRcdC8qIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGZvciB0aGUgZGVsYXllZCB4aHJzLCB3aGVuIHhocnMgYW5kIHdzIGFyZSBzY2hlZHVsZWQgaW4gcGFyYWxsZWwqL1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArIHRoaXMuc3RhdGUuc3RhdGUgKyAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgKyAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdGFiYW5kb24oKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihjdXJyZW50VHJhbnNwb3J0ICYmICFiZXR0ZXJUcmFuc3BvcnRUaGFuKHRyYW5zcG9ydCwgY3VycmVudFRyYW5zcG9ydCkpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcm9wb3NlZCB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnIGlzIG5vIGJldHRlciB0aGFuIGN1cnJlbnQgYWN0aXZlIHRyYW5zcG9ydCAnICsgY3VycmVudFRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnIC0gYWJhbmRvbmluZyB1cGdyYWRlJyk7XG5cdFx0XHRhYmFuZG9uKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1NjaGVkdWxpbmcgdHJhbnNwb3J0IHVwZ3JhZGU7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXG5cdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5vbmNlTm9wZW5kaW5nKGZ1bmN0aW9uKGVycikge1xuXHRcdFx0dmFyIG9sZFByb3RvY29sO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVbmFibGUgdG8gYWN0aXZhdGUgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0ICsgJzsgZXJyID0gJyArIGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0XHQvKiBUaGlzIGlzIG9ubHkgcG9zc2libGUgaWYgdGhlIHhociBzdHJlYW1pbmcgdHJhbnNwb3J0IHdhcyBkaXNjb25uZWN0ZWQgZHVyaW5nIHRoZSBwYXJhbGxlbFVwZ3JhZGVEZWxheSAqL1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJvcG9zZWQgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJ2lzIG5vIGxvbmdlciBjb25uZWN0ZWQ7IGFiYW5kb25pbmcgdXBncmFkZScpO1xuXHRcdFx0XHRhYmFuZG9uKCk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50bHkgY29ubmVjdGVkLCBzbyB0ZW1wb3JhcmlseSBwYXVzaW5nIGV2ZW50cyB1bnRpbCB0aGUgdXBncmFkZSBpcyBjb21wbGV0ZScpO1xuXHRcdFx0XHRzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZztcblx0XHRcdFx0b2xkUHJvdG9jb2wgPSBzZWxmLmFjdGl2ZVByb3RvY29sO1xuXHRcdFx0fSBlbHNlIGlmKHNlbGYuc3RhdGUgIT09IHNlbGYuc3RhdGVzLmNvbm5lY3RpbmcpIHtcblx0XHRcdFx0LyogTm90ZTogdXBncmFkaW5nIGZyb20gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgaXMgdmFsaWQgaWYgdGhlIG9sZCBhY3RpdmVcblx0XHRcdFx0KiB0cmFuc3BvcnQgd2FzIGRlYWN0aXZhdGVkIGFmdGVyIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCBmaXJzdCBjb25uZWN0ZWQ7XG5cdFx0XHRcdCogc2VlIGxvZ2ljIGluIGRlYWN0aXZhdGVUcmFuc3BvcnQgKi9cblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArIHNlbGYuc3RhdGUuc3RhdGUgKyAoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgKyAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdFx0YWJhbmRvbigpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8qIElmIHRoZSBjb25uZWN0aW9uSWQgaGFzIGNoYW5nZWQsIHRoZSB1cGdyYWRlIGhhc24ndCB3b3JrZWQuIEJ1dCBhc1xuXHRcdFx0KiBpdCdzIHN0aWxsIGFuIHVwZ3JhZGUsIHJlYWx0aW1lIHN0aWxsIGV4cGVjdHMgYSBzeW5jIC0gaXQganVzdCBuZWVkcyB0b1xuXHRcdFx0KiBiZSBhIHN5bmMgd2l0aCB0aGUgbmV3IGNvbm5lY3Rpb24gcG9zaXRpb24uIChBbmQgaXRcblx0XHRcdCogbmVlZHMgdG8gYmUgc2V0IGluIHRoZSBsaWJyYXJ5LCB3aGljaCBpcyBkb25lIGJ5IGFjdGl2YXRlVHJhbnNwb3J0KS4gKi9cblx0XHRcdHZhciBjb25uZWN0aW9uUmVzZXQgPSBjb25uZWN0aW9uSWQgIT09IHNlbGYuY29ubmVjdGlvbklkLFxuXHRcdFx0XHRzeW5jUG9zaXRpb24gPSBjb25uZWN0aW9uUmVzZXQgPyB1cGdyYWRlQ29ubmVjdGlvblBvc2l0aW9uIDogc2VsZjtcblxuXHRcdFx0aWYoY29ubmVjdGlvblJlc2V0KSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVcGdyYWRlIHJlc3VsdGVkIGluIG5ldyBjb25uZWN0aW9uSWQ7IHJlc2V0dGluZyBsaWJyYXJ5IGNvbm5lY3Rpb24gcG9zaXRpb24gZnJvbSAnICsgKHNlbGYudGltZVNlcmlhbCB8fCBzZWxmLmNvbm5lY3Rpb25TZXJpYWwpICsgJyB0byAnICsgKHN5bmNQb3NpdGlvbi50aW1lU2VyaWFsIHx8IHN5bmNQb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsKSArICc7IHVwZ3JhZGUgZXJyb3Igd2FzICcgKyBlcnJvcik7XG5cdFx0XHR9XG5cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdTeW5jaW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRzZWxmLnN5bmModHJhbnNwb3J0LCBzeW5jUG9zaXRpb24sIGZ1bmN0aW9uKHN5bmNFcnIsIGNvbm5lY3Rpb25JZCwgcG9zdFN5bmNQb3NpdGlvbikge1xuXHRcdFx0XHQvKiBJZiB0aGVyZSdzIGJlZW4gc29tZSBwcm9ibGVtIHdpdGggc3luY2luZyAoYW5kIHRoZSBjb25uZWN0aW9uIGhhc24ndFxuXHRcdFx0XHQgKiBjbG9zZWQgb3Igc29tZXRoaW5nIGluIHRoZSBtZWFudGltZSksIHdlIGhhdmUgYSBwcm9ibGVtIC0tIHdlIGNhbid0XG5cdFx0XHRcdCAqIGp1c3QgZmFsbCBiYWNrIG9uIHRoZSBvbGQgdHJhbnNwb3J0LCBhcyB3ZSBkb24ndCBrbm93IHdoZXRoZXJcblx0XHRcdFx0ICogcmVhbHRpbWUgZ290IHRoZSBzeW5jIC0tIGlmIGl0IGRpZCwgdGhlIG9sZCB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyXG5cdFx0XHRcdCAqIHZhbGlkLiBUbyBiZSBzYWZlLCB3ZSBkaXNjb25uZWN0IGJvdGggYW5kIHN0YXJ0IGFnYWluIGZyb20gc2NyYXRjaC4gKi9cblx0XHRcdFx0aWYoc3luY0Vycikge1xuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcblx0XHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdVbmV4cGVjdGVkIGVycm9yIGF0dGVtcHRpbmcgdG8gc3luYyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQgKyAnOyBlcnIgPSAnICsgc3luY0Vycik7XG5cdFx0XHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgZmluaXNoVXBncmFkZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdBY3RpdmF0aW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRcdFx0c2VsZi5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBwb3N0U3luY1Bvc2l0aW9uKTtcblx0XHRcdFx0XHQvKiBSZXN0b3JlIHByZS1zeW5jIHN0YXRlLiBJZiBzdGF0ZSBoYXMgY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWUsXG5cdFx0XHRcdFx0ICogZG9uJ3QgdG91Y2ggaXQgLS0gc2luY2UgdGhlIHdlYnNvY2tldCB0cmFuc3BvcnQgd2FpdHMgYSB0aWNrIGJlZm9yZVxuXHRcdFx0XHRcdCAqIGRpc3Bvc2luZyBpdHNlbGYsIGl0J3MgcG9zc2libGUgZm9yIGl0IHRvIGhhdmUgaGFwcGlseSBzeW5jZWRcblx0XHRcdFx0XHQgKiB3aXRob3V0IGVyciB3aGlsZSwgdW5rbm93biB0byBpdCwgdGhlIGNvbm5lY3Rpb24gaGFzIGNsb3NlZCBpbiB0aGVcblx0XHRcdFx0XHQgKiBtZWFudGltZSBhbmQgdGhlIHdzIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGRlYXRoICovXG5cdFx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZykge1xuXHRcdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1ByZS11cGdyYWRlIHByb3RvY29sIGlkbGUsIHNlbmRpbmcgcXVldWVkIG1lc3NhZ2VzIG9uIHVwZ3JhZGVkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRcdFx0XHRzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJlLXVwZ3JhZGUgcHJvdG9jb2wgaWRsZSwgYnV0IHN0YXRlIGlzIG5vdyAnICsgc2VsZi5zdGF0ZS5zdGF0ZSArICcsIHNvIGxlYXZpbmcgdW5jaGFuZ2VkJyk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0XHRcdFx0c2VsZi5zZW5kUXVldWVkTWVzc2FnZXMoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0LyogV2FpdCB1bnRpbCBzeW5jIGlzIGRvbmUgYW5kIG9sZCB0cmFuc3BvcnQgaXMgaWRsZSBiZWZvcmUgYWN0aXZhdGluZyBuZXcgdHJhbnNwb3J0LiBUaGlzXG5cdFx0XHRcdCAqIGd1YXJhbnRlZXMgdGhhdCBtZXNzYWdlcyBhcnJpdmUgYXQgcmVhbHRpbWUgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSBhcmUgc2VudC5cblx0XHRcdFx0ICpcblx0XHRcdFx0ICogSWYgYSBtZXNzYWdlIHRpbWVzIG91dCBvbiB0aGUgb2xkIHRyYW5zcG9ydCwgc2luY2UgaXQncyBzdGlsbCB0aGUgYWN0aXZlIHRyYW5zcG9ydCB0aGVcblx0XHRcdFx0ICogbWVzc2FnZSB3aWxsIGJlIHJlcXVldWVkLiBkZWFjdGl2YXRlVHJhbnNwb3J0IHdpbGwgc2VlIHRoZSBwZW5kaW5nIHRyYW5zcG9ydCBhbmQgbm90aWZ5XG5cdFx0XHRcdCAqIHRoZSBgY29ubmVjdGluZ2Agc3RhdGUgd2l0aG91dCBzdGFydGluZyBhIG5ldyBjb25uZWN0aW9uLCBzbyB0aGUgbmV3IHRyYW5zcG9ydCBjYW4gdGFrZVxuXHRcdFx0XHQgKiBvdmVyIG9uY2UgZGVhY3RpdmF0ZVRyYW5zcG9ydCBjbGVhcnMgdGhlIG9sZCBwcm90b2NvbCdzIHF1ZXVlLlxuXHRcdFx0XHQgKlxuXHRcdFx0XHQgKiBJZiB0aGVyZSBpcyBubyBvbGQgcHJvdG9jb2wsIHRoYXQgbWVhbnQgdGhhdCB3ZSB3ZXJlbid0IGluIHRoZSBjb25uZWN0ZWQgc3RhdGUgYXQgdGhlXG5cdFx0XHRcdCAqIGJlZ2lubmluZyBvZiB0aGUgc3luYyAtIGxpa2VseSB0aGUgYmFzZSB0cmFuc3BvcnQgZGllZCBqdXN0IGJlZm9yZSB0aGUgc3luYy4gU28gY2FuIGp1c3Rcblx0XHRcdFx0ICogZmluaXNoIHRoZSB1cGdyYWRlLiBJZiB3ZSdyZSBhY3R1YWxseSBpbiBjbG9zaW5nL2ZhaWxlZCByYXRoZXIgdGhhbiBjb25uZWN0aW5nLCB0aGF0J3Ncblx0XHRcdFx0ICogZmluZSwgYWN0aXZhdGV0cmFuc3BvcnQgd2lsbCBkZWFsIHdpdGggdGhhdC4gKi9cblx0XHRcdFx0aWYob2xkUHJvdG9jb2wpIHtcblx0XHRcdFx0IC8qIE1vc3Qgb2YgdGhlIHRpbWUgdGhpcyB3aWxsIGJlIGFscmVhZHkgdHJ1ZTogdGhlIG5ldy10cmFuc3BvcnQgc3luYyB3aWxsIGhhdmUgZ2l2ZW5cblx0XHRcdFx0ICogZW5vdWdoIHRpbWUgZm9yIGluLWZsaWdodCBtZXNzYWdlcyBvbiB0aGUgb2xkIHRyYW5zcG9ydCB0byBjb21wbGV0ZS4gKi9cblx0XHRcdFx0XHRvbGRQcm90b2NvbC5vbmNlSWRsZShmaW5pc2hVcGdyYWRlKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmaW5pc2hVcGdyYWRlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQsIGFuZCB0aGUgY29ubmVjdGlvbm1hbmFnZXIgZGVjaWRlcyB0aGF0XG5cdCAqIGl0IHdpbGwgbm93IGJlIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBSZXR1cm5zIHdoZXRoZXIgb3Igbm90IGl0IGFjdGl2YXRlZFxuXHQgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0IHRoZSB0cmFuc3BvcnQgaW5zdGFuY2Vcblx0ICogQHBhcmFtIGNvbm5lY3Rpb25JZCB0aGUgaWQgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuXHQgKiBAcGFyYW0gY29ubmVjdGlvblBvc2l0aW9uIHRoZSBwb3NpdGlvbiBhdCB0aGUgcG9pbnQgYWN0aXZhdGlvbjsgZWl0aGVyIHtjb25uZWN0aW9uU2VyaWFsOiA8c2VyaWFsPn0gb3Ige3RpbWVTZXJpYWw6IDxzZXJpYWw+fVxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cdFx0aWYoZXJyb3IpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Vycm9yID0gJyArIGVycm9yKTtcblx0XHR9XG5cdFx0aWYoY29ubmVjdGlvbklkKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uSWQgPSAgJyArIGNvbm5lY3Rpb25JZCk7XG5cdFx0fVxuXHRcdGlmKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uRGV0YWlscyA9ICAnICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpKTtcblx0XHR9XG5cdFx0aWYoY29ubmVjdGlvblBvc2l0aW9uKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdzZXJpYWwgPSAgJyArIChjb25uZWN0aW9uUG9zaXRpb24udGltZVNlcmlhbCB8fCBjb25uZWN0aW9uUG9zaXRpb24uY29ubmVjdGlvblNlcmlhbCkpO1xuXHRcdH1cblxuXHRcdHRoaXMucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KTtcblxuXHRcdC8qIGlmIHRoZSBjb25uZWN0aW9ubWFuYWdlciBtb3ZlZCB0byB0aGUgY2xvc2luZy9jbG9zZWQgc3RhdGUgYmVmb3JlIHRoaXNcblx0XHQgKiBjb25uZWN0aW9uIGV2ZW50LCB0aGVuIHdlIHdvbid0IGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGV4aXN0aW5nU3RhdGUgPSB0aGlzLnN0YXRlLFxuXHRcdFx0Y29ubmVjdGVkU3RhdGUgPSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGU7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY3VycmVudCBzdGF0ZSA9ICcgKyBleGlzdGluZ1N0YXRlLnN0YXRlKTtcblx0XHRpZihleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5jbG9zZWQuc3RhdGUgfHwgZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5mYWlsZWQuc3RhdGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0Rpc2Nvbm5lY3RpbmcgdHJhbnNwb3J0IGFuZCBhYmFuZG9uaW5nJyk7XG5cdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8qIHJlbW92ZSB0aGlzIHRyYW5zcG9ydCBmcm9tIHBlbmRpbmcgdHJhbnNwb3J0cyAqL1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblxuXHRcdC8qIGlmIHRoZSB0cmFuc3BvcnQgaXMgbm90IGNvbm5lY3RlZCAoZWcgYmVjYXVzZSBpdCBmYWlsZWQgZHVyaW5nIGFcblx0XHQgKiBzY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24jb25jZU5vUGVuZGluZyB3YWl0KSB0aGVuIGRvbid0IGFjdGl2YXRlIGl0ICovXG5cdFx0aWYoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnRGVjbGluaW5nIHRvIGFjdGl2YXRlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0ICsgJyBzaW5jZSBpdCBhcHBlYXJzIHRvIG5vIGxvbmdlciBiZSBjb25uZWN0ZWQnKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvKiB0aGUgZ2l2ZW4gdHJhbnNwb3J0IGlzIGNvbm5lY3RlZDsgdGhpcyB3aWxsIGltbWVkaWF0ZWx5XG5cdFx0ICogdGFrZSBvdmVyIGFzIHRoZSBhY3RpdmUgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuXHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wgPSBuZXcgX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0odHJhbnNwb3J0KTtcblx0XHR0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG5cblx0XHR2YXIgY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG5cdFx0aWYoY29ubmVjdGlvbktleSAmJiB0aGlzLmNvbm5lY3Rpb25LZXkgIT0gY29ubmVjdGlvbktleSkgIHtcblx0XHRcdHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24sICEhZXJyb3IpO1xuXHRcdH1cblxuXHRcdC8qIFJlYnJvYWRjYXN0IGFueSBuZXcgY29ubmVjdGlvbkRldGFpbHMgZnJvbSB0aGUgYWN0aXZlIHRyYW5zcG9ydCwgd2hpY2hcblx0XHQgKiBjYW4gY29tZSBhdCBhbnkgdGltZSAoZWcgZm9sbG93aW5nIGEgcmVhdXRoKSwgYW5kIGVtaXQgYW4gUlROMjQgVVBEQVRFXG5cdFx0ICogZXZlbnQuIChMaXN0ZW5lciBhZGRlZCBvbiBuZXh0VGljayBiZWNhdXNlIHdlJ3JlIGluIGEgdHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnKVxuXHRcdCAqIGNhbGxiYWNrIGF0IHRoZSBtb21lbnQ7IGlmIHdlIGFkZCBpdCBub3cgd2UnbGwgYmUgYWRkaW5nIGl0IHRvIHRoZSBlbmRcblx0XHQgKiBvZiB0aGUgbGlzdGVuZXJzIGFycmF5IGFuZCBpdCdsbCBiZSBjYWxsZWQgaW1tZWRpYXRlbHkpICovXG5cdFx0dGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0dHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnLCBmdW5jdGlvbihjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG5cdFx0XHRcdHNlbGYub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZShjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KTtcblx0XHRcdFx0c2VsZi5lbWl0KCd1cGRhdGUnLCBuZXcgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXShjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGNvbm5lY3RlZEVycikpO1xuXHRcdFx0fSk7XG5cdFx0fSlcblxuXHRcdC8qIElmIHByZXZpb3VzbHkgbm90IGNvbm5lY3RlZCwgbm90aWZ5IHRoZSBzdGF0ZSBjaGFuZ2UgKGluY2x1ZGluZyBhbnlcblx0XHQgKiBlcnJvcikuICovXG5cdFx0aWYoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG5cdFx0XHRpZihlcnJvcikge1xuXHRcdFx0XHQvKiBpZiB1cGdyYWRpbmcgd2l0aG91dCBlcnJvciwgbGVhdmUgYW55IGV4aXN0aW5nIGVycm9yUmVhc29uIGFsb25lICovXG5cdFx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvcjtcblx0XHRcdFx0LyogT25seSBib3RoZXIgZW1pdHRpbmcgYW4gdXBncmFkZSBpZiB0aGVyZSdzIGFuIGVycm9yOyBvdGhlcndpc2UgaXQnc1xuXHRcdFx0XHQgKiBqdXN0IGEgdHJhbnNwb3J0IHVwZ3JhZGUsIHNvIGF1dGggZGV0YWlscyB3b24ndCBoYXZlIGNoYW5nZWQgKi9cblx0XHRcdFx0dGhpcy5lbWl0KCd1cGRhdGUnLCBuZXcgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXShjb25uZWN0ZWRTdGF0ZSwgY29ubmVjdGVkU3RhdGUsIG51bGwsIGVycm9yKSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnY29ubmVjdGVkJywgZXJyb3I6IGVycm9yfSk7XG5cdFx0XHR0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3IgfHwgbnVsbDtcblx0XHR9XG5cblx0XHQvKiBTZW5kIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIHVwZGF0ZSwgYXMgQ2hhbm5lbHMgaG9va3MgaW50byB0aGlzIHRvXG5cdFx0ICogcmVzZW5kIGF0dGFjaGVzIG9uIGEgbmV3IHRyYW5zcG9ydCBpZiBuZWNlc3NhcnkgKi9cblx0XHR0aGlzLmVtaXQoJ3RyYW5zcG9ydC5hY3RpdmUnLCB0cmFuc3BvcnQpO1xuXG5cdFx0LyogR3JhY2VmdWxseSB0ZXJtaW5hdGUgZXhpc3RpbmcgcHJvdG9jb2wgKi9cblx0XHRpZihleGlzdGluZ0FjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRpZihleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpID4gMCkge1xuXHRcdFx0XHQvKiBXZSBjb3VsZCBqdXN0IHJlcXVldWUgcGVuZGluZyBtZXNzYWdlcyBvbiB0aGUgbmV3IHRyYW5zcG9ydCwgYnV0XG5cdFx0XHRcdCAqIGFjdHVhbGx5IHRoaXMgc2hvdWxkIG5ldmVyIGhhcHBlbjogdHJhbnNwb3J0cyBzaG91bGQgb25seSB0YWtlIG92ZXJcblx0XHRcdFx0ICogZnJvbSBvdGhlciBhY3RpdmUgdHJhbnNwb3J0cyB3aGVuIHVwZ3JhZGluZywgYW5kIHVwZ3JhZGluZyB3YWl0cyBmb3Jcblx0XHRcdFx0ICogdGhlIG9sZCB0cmFuc3BvcnQgdG8gYmUgaWRsZS4gU28gbG9nIGFuIGVycm9yLiAqL1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdQcmV2aW91cyBhY3RpdmUgcHJvdG9jb2wgKGZvciB0cmFuc3BvcnQgJyArIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wudHJhbnNwb3J0LnNob3J0TmFtZSArICcsIG5ldyBvbmUgaXMgJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnKSBmaW5pc2hpbmcgd2l0aCAnICsgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5tZXNzYWdlUXVldWUuY291bnQoKSArICcgbWVzc2FnZXMgc3RpbGwgcGVuZGluZycpO1xuXHRcdFx0fVxuXHRcdFx0aWYoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuXHRcdFx0XHR2YXIgbXNnID0gJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCB3YXMgYWxzbyB0aGUgdHJhbnNwb3J0IGZvciB0aGUgcHJldmlvdXMgYWN0aXZlIHByb3RvY29sOyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICc7IHN0YWNrID0gJyArIG5ldyBFcnJvcigpLnN0YWNrO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG5cdFx0XHRcdF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVwb3J0KCdlcnJvcicsIG1zZywgJ3RyYW5zcG9ydC1wcmV2aW91c2x5LWFjdGl2ZScpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5maW5pc2goKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvKiBUZXJtaW5hdGUgYW55IG90aGVyIHBlbmRpbmcgdHJhbnNwb3J0KHMpLCBhbmRcblx0XHQgKiBhYm9ydCBhbnkgbm90LXlldC1wZW5kaW5nIHRyYW5zcG9ydCBhdHRlbXB0cyAqL1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24ocGVuZGluZ1RyYW5zcG9ydCkge1xuXHRcdFx0aWYocGVuZGluZ1RyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IGlzIHN0aWxsIG1hcmtlZCBhcyBhIHBlbmRpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICc7IHN0YWNrID0gJyArIG5ldyBFcnJvcigpLnN0YWNrO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG5cdFx0XHRcdF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVwb3J0KCdlcnJvcicsIG1zZywgJ3RyYW5zcG9ydC1hY3RpdmF0aW5nLXBlbmRpbmcnKTtcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZShzZWxmLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cGVuZGluZ1RyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24ocHJvcG9zZWRUcmFuc3BvcnQpIHtcblx0XHRcdGlmKHByb3Bvc2VkVHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcblx0XHRcdFx0dmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgaXMgc3RpbGwgbWFya2VkIGFzIGEgcHJvcG9zZWQgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICc7IHN0YWNrID0gJyArIG5ldyBFcnJvcigpLnN0YWNrO1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XG5cdFx0XHRcdF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVwb3J0KCdlcnJvcicsIG1zZywgJ3RyYW5zcG9ydC1hY3RpdmF0aW5nLXByb3Bvc2VkJyk7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUoc2VsZi5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwcm9wb3NlZFRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyIHRoZSBhY3RpdmUgdHJhbnNwb3J0LiBUaGlzIGNhbiBvY2N1clxuXHQgKiBpbiBhbnkgdHJhbnNwb3J0IGNvbm5lY3Rpb24gc3RhdGUuXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kZWFjdGl2YXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24odHJhbnNwb3J0LCBzdGF0ZSwgZXJyb3IpIHtcblx0XHR2YXIgY3VycmVudFByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbCxcblx0XHRcdHdhc0FjdGl2ZSA9IGN1cnJlbnRQcm90b2NvbCAmJiBjdXJyZW50UHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkgPT09IHRyYW5zcG9ydCxcblx0XHRcdHdhc1BlbmRpbmcgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCksXG5cdFx0XHR3YXNQcm9wb3NlZCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCksXG5cdFx0XHRub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gdGhpcy5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKCk7XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnc3RhdGUgPSAnICsgc3RhdGUgKyAod2FzQWN0aXZlID8gJzsgd2FzIGFjdGl2ZScgOiB3YXNQZW5kaW5nID8gJzsgd2FzIHBlbmRpbmcnIDogd2FzUHJvcG9zZWQgPyAnOyB3YXMgcHJvcG9zZWQnIDogJycpICsgKG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPyAnJyA6ICc7IGFub3RoZXIgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbicpKTtcblx0XHRpZihlcnJvciAmJiBlcnJvci5tZXNzYWdlKVxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdyZWFzb24gPSAgJyArIGVycm9yLm1lc3NhZ2UpO1xuXG5cdFx0aWYod2FzQWN0aXZlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0dldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XG5cdFx0XHR0aGlzLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKGN1cnJlbnRQcm90b2NvbC5nZXRQZW5kaW5nTWVzc2FnZXMoKSk7XG5cdFx0XHQvKiBDbGVhciBhbnkgbWVzc2FnZXMgd2UgcmVxdWV1ZSB0byBhbGxvdyB0aGUgcHJvdG9jb2wgdG8gYmVjb21lIGlkbGUuXG5cdFx0XHQgKiBJbiBjYXNlIG9mIGFuIHVwZ3JhZGUsIHRoaXMgd2lsbCB0cmlnZ2VyIGFuIGltbWVkaWF0ZSBhY3RpdmF0aW9uIG9mXG5cdFx0XHQgKiB0aGUgdXBncmFkZSB0cmFuc3BvcnQsIHNvIGRlbGF5IGEgdGljayBzbyB0aGlzIHRyYW5zcG9ydCBjYW4gZmluaXNoXG5cdFx0XHQgKiBkZWFjdGl2YXRpbmcgKi9cblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGN1cnJlbnRQcm90b2NvbC5jbGVhclBlbmRpbmdNZXNzYWdlcygpO1xuXHRcdFx0fSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gdGhpcy5ob3N0ID0gbnVsbDtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmNoYW5uZWxSZXN1bWVDaGVja1RpbWVyKTtcblx0XHR9XG5cblx0XHR0aGlzLmVtaXQoJ3RyYW5zcG9ydC5pbmFjdGl2ZScsIHRyYW5zcG9ydCk7XG5cblx0XHQvKiB0aGlzIHRyYW5zcG9ydCBzdGF0ZSBjaGFuZ2UgaXMgYSBzdGF0ZSBjaGFuZ2UgZm9yIHRoZSBjb25uZWN0aW9ubWFuYWdlciBpZlxuXHRcdCAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzXG5cdFx0ICogICB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIGp1c3Qgd2FpdGluZyBmb3IgdGhlXG5cdFx0ICogICBhY3RpdmUgdHJhbnNwb3J0IHRvIGZpbmlzaCB3aGF0IGl0cyBkb2luZzsgb3Jcblx0XHQgKiAtIHRoZSB0cmFuc3BvcnQgd2FzIHRoZSBhY3RpdmUgdHJhbnNwb3J0IGFuZCB0aGUgZXJyb3Igd2FzIGZhdGFsIChzb1xuXHRcdCAqICAgdW5oZWFsYWJsZSBieSBhbm90aGVyIHRyYW5zcG9ydCk7IG9yXG5cdFx0ICogLSB0aGVyZSBpcyBubyBhY3RpdmUgdHJhbnNwb3J0LCBhbmQgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmdcblx0XHQgKiAgIHBlbmRpbmcgdHJhbnNwb3J0IChzbyB3ZSB3ZXJlIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlKVxuXHRcdCAqL1xuXHRcdGlmKCh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbikgfHxcblx0XHRcdCh3YXNBY3RpdmUgJiYgKHN0YXRlID09PSAnZmFpbGVkJykgfHwgKHN0YXRlID09PSAnY2xvc2VkJykpIHx8XG5cdFx0XHQoY3VycmVudFByb3RvY29sID09PSBudWxsICYmIHdhc1BlbmRpbmcgJiYgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGggPT09IDApKSB7XG5cblx0XHRcdC8qIElmIHdlJ3JlIGRpc2Nvbm5lY3RlZCB3aXRoIGEgNXh4IHdlIG5lZWQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG5cdFx0XHQgKiAoUlROMTRkKSwgYnV0IChhKSBkdWUgdG8gaG93IHRoZSB1cGdyYWRlIHNlcXVlbmNlIHdvcmtzLCB0aGVcblx0XHRcdCAqIGhvc3QvdHJhbnNwb3J0IHNlbGVjdGlvbiBzZXF1ZW5jZSBvbmx5IGNhcmVzIGFib3V0IGdldHRpbmcgdG9cblx0XHRcdCAqIGBwcmVjb25uZWN0YCAoZWcgZXN0YWJsaXNoaW5nIGEgd2Vic29ja2V0KSBnZXR0aW5nIGEgYGRpc2Nvbm5lY3RlZGBcblx0XHRcdCAqIHByb3RvY29sIG1lc3NhZ2UgYWZ0ZXJ3YXJkcyBpcyB0b28gbGF0ZTsgYW5kIChiKSBob3N0IHJldHJ5IG9ubHlcblx0XHRcdCAqIGFwcGxpZXMgdG8gY29ubmVjdEJhc2UgdW5sZXNzIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSB0cmFuc3BvcnQgZG9lc24ndFxuXHRcdFx0ICogd29yay4gV2Ugc29sdmUgdGhpcyBieSB1bnBlcnNpc3RpbmcgdGhlIHRyYW5zcG9ydCBwcmVmZXJlbmNlIGFuZFxuXHRcdFx0ICogc2V0dGluZyBhbiBpbnN0YW5jZSB2YXJpYWJsZSB0byBmb3JjZSBmYWxsYmFjayBob3N0cyB0byBiZSB1c2VkIChpZlxuXHRcdFx0ICogYW55KSBoZXJlLiBCaXQgb2YgYSBrbHVkZ2UsIGJ1dCBubyByZWFsIGJldHRlciBhbHRlcm5hdGl2ZXMgd2l0aG91dFxuXHRcdFx0ICogcmV3cml0aW5nIHRoZSBlbnRpcmUgdGhpbmcgKi9cblx0XHRcdGlmKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiBlcnJvciAmJiBlcnJvci5zdGF0dXNDb2RlID4gNTAwICYmIHRoaXMuaHR0cEhvc3RzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG5cdFx0XHRcdHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSB0cnVlO1xuXHRcdFx0XHQvKiBhbmQgdHJ5IHRvIGNvbm5lY3QgYWdhaW4gdG8gdHJ5IGEgZmFsbGJhY2sgaG9zdCB3aXRob3V0IHdhaXRpbmcgZm9yIHRoZSB1c3VhbCAxNXMgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0ICovXG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiBzdGF0ZSwgZXJyb3I6IGVycm9yLCByZXRyeUltbWVkaWF0ZWx5OiB0cnVlfSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogVE9ETyByZW1vdmUgYmVsb3cgbGluZSBvbmNlIHJlYWx0aW1lIHNlbmRzIHRva2VuIGVycm9ycyBhcyBESVNDT05ORUNURURzICovXG5cdFx0XHR2YXIgbmV3Q29ubmVjdGlvblN0YXRlID0gKHN0YXRlID09PSAnZmFpbGVkJyAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihlcnJvcikpID8gJ2Rpc2Nvbm5lY3RlZCcgOiBzdGF0ZTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yOiBlcnJvcn0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmKHdhc0FjdGl2ZSAmJiAoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnKSAmJiAodGhpcy5zdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZykpIHtcblx0XHRcdC8qIElmIHdlIHdlcmUgYWN0aXZlIGJ1dCB0aGVyZSBpcyBhbm90aGVyIHRyYW5zcG9ydCBzY2hlZHVsZWQgZm9yXG5cdFx0XHQqIGFjdGl2YXRpb24sIGdvIGludG8gdG8gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgdW50aWwgdGhhdCB0cmFuc3BvcnRcblx0XHRcdCogYWN0aXZhdGVzIGFuZCBzZXRzIHVzIGJhY2sgdG8gY29ubmVjdGVkLiAobWFudWFsbHkgc3RhcnRpbmcgdGhlXG5cdFx0XHQqIHRyYW5zaXRpb24gdGltZXJzIGluIGNhc2UgdGhhdCBuZXZlciBoYXBwZW5zKS4gKElmIHdlIHdlcmUgaW4gdGhlXG5cdFx0XHQqIHN5bmNocm9uaXppbmcgc3RhdGUsIHRoZW4gdGhhdCdzIGZpbmUsIHRoZSBvbGQgdHJhbnNwb3J0IGp1c3QgZ290IGl0c1xuXHRcdFx0KiBkaXNjb25uZWN0ZWQgYmVmb3JlIHRoZSBuZXcgb25lIGdvdCB0aGUgc3luYyAtLSBpZ25vcmUgaXQgYW5kIGtlZXBcblx0XHRcdCogd2FpdGluZyBmb3IgdGhlIHN5bmMuIElmIGl0IGZhaWxzIHdlIGhhdmUgYSBzZXBhcmF0ZSBzeW5jIHRpbWVyIHRoYXRcblx0XHRcdCogd2lsbCBleHBpcmUpLiAqL1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd3YXNBY3RpdmUgYnV0IGFub3RoZXIgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBzbyBnb2luZyBpbnRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIGl0IGFjdGl2YXRlcycpO1xuXHRcdFx0dGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuXHRcdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZycsIGVycm9yOiBlcnJvcn0pO1xuXHRcdH1cblx0fTtcblxuXHQvKiBIZWxwZXIgdGhhdCByZXR1cm5zIHRydWUgaWYgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHMgd2hpY2ggYXJlIHBlbmRpbmcsXG5cdCogaGF2ZSBiZWVuIGNvbm5lY3RlZCwgYW5kIGFyZSBqdXN0IHdhaXRpbmcgZm9yIG9uY2VOb1BlbmRpbmcgdG8gZmlyZSBiZWZvcmVcblx0KiBiZWluZyBhY3RpdmF0ZWQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5KHRoaXMucGVuZGluZ1RyYW5zcG9ydHMpIHx8XG5cdFx0XHR0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmV2ZXJ5KGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0XHRyZXR1cm4gIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZDtcblx0XHRcdH0pO1xuXHR9O1xuXG5cdC8qKlxuXHQgKiBDYWxsZWQgd2hlbiBhY3RpdmF0aW5nIGEgbmV3IHRyYW5zcG9ydCwgdG8gZW5zdXJlIG1lc3NhZ2UgZGVsaXZlcnlcblx0ICogb24gdGhlIG5ldyB0cmFuc3BvcnQgc3luY2hyb25pc2VzIHdpdGggdGhlIG1lc3NhZ2VzIGFscmVhZHkgcmVjZWl2ZWRcblx0ICovXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zeW5jID0gZnVuY3Rpb24odHJhbnNwb3J0LCByZXF1ZXN0ZWRTeW5jUG9zaXRpb24sIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcblx0XHRcdHRyYW5zcG9ydC5vZmYoJ3N5bmMnKTtcblx0XHRcdGNhbGxiYWNrKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdUaW1lb3V0IHdhaXRpbmcgZm9yIHN5bmMgcmVzcG9uc2UnLCA1MDAwMCwgNTAwKSk7XG5cdFx0fSwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuXG5cdFx0Lyogc2VuZCBzeW5jIHJlcXVlc3QgKi9cblx0XHR2YXIgc3luY01lc3NhZ2UgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0XHRhY3Rpb246IGFjdGlvbnMuU1lOQyxcblx0XHRcdGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleVxuXHRcdH0pO1xuXG5cdFx0aWYocmVxdWVzdGVkU3luY1Bvc2l0aW9uLnRpbWVTZXJpYWwpIHtcblx0XHRcdHN5bmNNZXNzYWdlLnRpbWVTZXJpYWwgPSByZXF1ZXN0ZWRTeW5jUG9zaXRpb24udGltZVNlcmlhbDtcblx0XHR9IGVsc2UgaWYocmVxdWVzdGVkU3luY1Bvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0c3luY01lc3NhZ2UuY29ubmVjdGlvblNlcmlhbCA9IHJlcXVlc3RlZFN5bmNQb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsO1xuXHRcdH1cblx0XHR0cmFuc3BvcnQuc2VuZChzeW5jTWVzc2FnZSk7XG5cblx0XHR0cmFuc3BvcnQub25jZSgnc3luYycsIGZ1bmN0aW9uKGNvbm5lY3Rpb25JZCwgc3luY1Bvc2l0aW9uKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XG5cdFx0XHRjYWxsYmFjayhudWxsLCBjb25uZWN0aW9uSWQsIHN5bmNQb3NpdGlvbik7XG5cdFx0fSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldENvbm5lY3Rpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24sIGhhc0Nvbm5lY3Rpb25FcnJvcikge1xuXHRcdC8qIGlmIGNvbm5lY3Rpb25LZXkgY2hhbmdlcyBidXQgY29ubmVjdGlvbklkIHN0YXlzIHRoZSBzYW1lLCB0aGVuIGp1c3QgYVxuXHRcdCAqIHRyYW5zcG9ydCBjaGFuZ2Ugb24gdGhlIHNhbWUgY29ubmVjdGlvbi4gSWYgY29ubmVjdGlvbklkIGNoYW5nZXMsIHdlJ3JlXG5cdFx0ICogb24gYSBuZXcgY29ubmVjdGlvbiwgd2l0aCBpbXBsaWNhdGlvbnMgZm9yIG1zZ1NlcmlhbCBhbmQgY2hhbm5lbCBzdGF0ZSxcblx0XHQgKiBhbmQgcmVzZXR0aW5nIHRoZSBjb25uZWN0aW9uU2VyaWFsIHBvc2l0aW9uICovXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdC8qIElmIG5vIHByZXZpb3VzIGNvbm5lY3Rpb25JZCwgZG9uJ3QgcmVzZXQgdGhlIG1zZ1NlcmlhbCBhcyBpdCBtYXkgaGF2ZVxuXHRcdCAqIGJlZW4gc2V0IGJ5IHJlY292ZXIgZGF0YSAodW5sZXNzIHRoZSByZWNvdmVyIGZhaWxlZCkgKi9cblx0XHR2YXIgcHJldkNvbm5JZCA9IHRoaXMuY29ubmVjdGlvbmlkLFxuXHRcdFx0Y29ubklkQ2hhbmdlZCA9IHByZXZDb25uSWQgJiYgKHByZXZDb25uSWQgIT09IGNvbm5lY3Rpb25JZCksXG5cdFx0XHRyZWNvdmVyRmFpbHVyZSA9ICFwcmV2Q29ubklkICYmIGhhc0Nvbm5lY3Rpb25FcnJvcjtcblx0XHRpZihjb25uSWRDaGFuZ2VkIHx8IHJlY292ZXJGYWlsdXJlKSAge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdSZXNldHRpbmcgbXNnU2VyaWFsJyk7XG5cdFx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XG5cdFx0fVxuXHRcdC8qIGJ1dCBkbyBuZWVkIHRvIHJlYXR0YWNoIGNoYW5uZWxzLCBmb3IgY2hhbm5lbHMgdGhhdCB3ZXJlIHByZXZpb3VzbHkgaW5cblx0XHQgKiB0aGUgYXR0YWNoZWQgc3RhdGUgZXZlbiB0aG91Z2ggdGhlIGNvbm5lY3Rpb24gbW9kZSB3YXMgJ2NsZWFuJyBkdWUgdG8gYVxuXHRcdCAqIGZyZXNobmVzcyBjaGVjayAtIHNlZSBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzL2lzc3Vlcy8zOTQgKi9cblx0XHRpZih0aGlzLmNvbm5lY3Rpb25JZCAhPT0gY29ubmVjdGlvbklkKSAge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdOZXcgY29ubmVjdGlvbklkOyByZWF0dGFjaGluZyBhbnkgYXR0YWNoZWQgY2hhbm5lbHMnKTtcblx0XHRcdC8qIFdhaXQgdGlsbCBuZXh0IHRpY2sgYmVmb3JlIHJlYXR0YWNoaW5nIGNoYW5uZWxzLCBzbyB0aGF0IGNvbm5lY3Rpb25cblx0XHRcdCAqIHN0YXRlIHdpbGwgYmUgdXBkYXRlZCBhbmQgc28gdGhhdCBpdCB3aWxsIGJlIGFwcGxpZWQgYWZ0ZXJcblx0XHRcdCAqIENoYW5uZWxzI29uVHJhbnNwb3J0VXBkYXRlLCBlbHNlIGNoYW5uZWxzIHdpbGwgbm90IGhhdmUgYW4gQVRUQUNIRURcblx0XHRcdCAqIHNlbnQgdHdpY2UgKG9uY2UgZnJvbSB0aGlzIGFuZCBvbmNlIGZyb20gdGhhdCkuICovXG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlYWx0aW1lLmNoYW5uZWxzLnJlYXR0YWNoKCk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2UgaWYodGhpcy5vcHRpb25zLmNoZWNrQ2hhbm5lbHNPblJlc3VtZSkge1xuXHRcdFx0LyogRm9yIGF0dGFjaGVkIGNoYW5uZWxzLCBzZXQgdGhlIGF0dGFjaGVkIG1zZyBpbmRpY2F0b3IgdmFyaWFibGUgdG8gZmFsc2UsXG5cdFx0XHQgKiB3YWl0IDMwcywgYW5kIGNoZWNrIHdlIGdvdCBhbiBhdHRhY2hlZCBmb3IgZWFjaCBvbmUuXG5cdFx0XHQgKiAzMHMgd2FzIGNob3NlbiB0byBiZSA1cyBsb25nZXIgdGhhbiB0aGUgdHJhbnNwb3J0IGlkbGUgdGltZW91dCBleHBpcmVcblx0XHRcdCAqIHRpbWUsIGluIGFuIGF0dGVtcHQgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGR1ZSB0byBhIHRyYW5zcG9ydFxuXHRcdFx0ICogc2lsZW50bHkgZmFpbGluZyBpbW1lZGlhdGVseSBhZnRlciBhIHJlc3VtZSAqL1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdTYW1lIGNvbm5lY3Rpb25JZDsgY2hlY2tDaGFubmVsc09uUmVzdW1lIGlzIGVuYWJsZWQnKTtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmNoYW5uZWxSZXN1bWVDaGVja1RpbWVyKTtcblx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVzZXRBdHRhY2hlZE1zZ0luZGljYXRvcnMoKTtcblx0XHRcdHRoaXMuY2hhbm5lbFJlc3VtZUNoZWNrVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLnJlYWx0aW1lLmNoYW5uZWxzLmNoZWNrQXR0YWNoZWRNc2dJbmRpY2F0b3JzKGNvbm5lY3Rpb25JZCk7XG5cdFx0XHR9LCAzMDAwMCk7XG5cdFx0fVxuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5rZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xuXHRcdHZhciBmb3JjZVJlc2V0TWVzc2FnZVNlcmlhbCA9IGNvbm5JZENoYW5nZWQgfHwgIXByZXZDb25uSWQ7XG5cdFx0dGhpcy5zZXRDb25uZWN0aW9uU2VyaWFsKGNvbm5lY3Rpb25Qb3NpdGlvbiwgZm9yY2VSZXNldE1lc3NhZ2VTZXJpYWwpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ua2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuY2xlYXJDb25uZWN0aW9uU2VyaWFsKCk7XG5cdFx0dGhpcy5tc2dTZXJpYWwgPSAwO1xuXHRcdHRoaXMudW5wZXJzaXN0Q29ubmVjdGlvbigpO1xuXHR9O1xuXG5cdC8qIGZvcmNlOiBzZXQgdGhlIGNvbm5lY3Rpb25TZXJpYWwgZXZlbiBpZiBpdCdzIGxlc3MgdGhhbiB0aGUgY3VycmVudFxuXHQgKiBjb25uZWN0aW9uU2VyaWFsLiBVc2VkIGZvciBuZXcgY29ubmVjdGlvbnMuXG5cdCAqIFJldHVybnMgdHJ1ZSBpZmYgdGhlIG1lc3NhZ2Ugd2FzIHJlamVjdGVkIGFzIGEgZHVwbGljYXRlLiAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0Q29ubmVjdGlvblNlcmlhbCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25Qb3NpdGlvbiwgZm9yY2UpIHtcblx0XHR2YXIgdGltZVNlcmlhbCA9IGNvbm5lY3Rpb25Qb3NpdGlvbi50aW1lU2VyaWFsLFxuXHRcdFx0Y29ubmVjdGlvblNlcmlhbCA9IGNvbm5lY3Rpb25Qb3NpdGlvbi5jb25uZWN0aW9uU2VyaWFsO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uU2VyaWFsKCknLCAnVXBkYXRpbmcgY29ubmVjdGlvbiBzZXJpYWw7IHNlcmlhbCA9ICcgKyBjb25uZWN0aW9uU2VyaWFsICsgJzsgdGltZVNlcmlhbCA9ICcgKyB0aW1lU2VyaWFsICsgJzsgZm9yY2UgPSAnICsgZm9yY2UgKyAnOyBwcmV2aW91cyA9ICcgKyB0aGlzLmNvbm5lY3Rpb25TZXJpYWwpO1xuXHRcdGlmKHRpbWVTZXJpYWwgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodGltZVNlcmlhbCA8PSB0aGlzLnRpbWVTZXJpYWwgJiYgIWZvcmNlKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uU2VyaWFsKCknLCAncmVjZWl2ZWQgbWVzc2FnZSB3aXRoIHRpbWVTZXJpYWwgJyArIHRpbWVTZXJpYWwgKyAnLCBidXQgY3VycmVudCB0aW1lU2VyaWFsIGlzICcgKyB0aGlzLnRpbWVTZXJpYWwgKyAnOyBhc3N1bWluZyBtZXNzYWdlIGlzIGEgZHVwbGljYXRlIGFuZCBkaXNjYXJkaW5nIGl0Jyk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnRpbWVTZXJpYWwgPSB0aGlzLnRpbWVTZXJpYWwgPSB0aW1lU2VyaWFsO1xuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpZihjb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKGNvbm5lY3Rpb25TZXJpYWwgPD0gdGhpcy5jb25uZWN0aW9uU2VyaWFsICYmICFmb3JjZSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvblNlcmlhbCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2Ugd2l0aCBjb25uZWN0aW9uU2VyaWFsICcgKyBjb25uZWN0aW9uU2VyaWFsICsgJywgYnV0IGN1cnJlbnQgY29ubmVjdGlvblNlcmlhbCBpcyAnICsgdGhpcy5jb25uZWN0aW9uU2VyaWFsICsgJzsgYXNzdW1pbmcgbWVzc2FnZSBpcyBhIGR1cGxpY2F0ZSBhbmQgZGlzY2FyZGluZyBpdCcpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5zZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSBjb25uZWN0aW9uU2VyaWFsO1xuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJDb25uZWN0aW9uU2VyaWFsID0gZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnNlcmlhbCA9IHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24udGltZVNlcmlhbCA9IHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsZWFyUmVjb3ZlcnlLZXkoKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0UmVjb3ZlcnlLZXkgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ucmVjb3ZlcnlLZXkgPSB0aGlzLmNvbm5lY3Rpb25LZXkgKyAnOicgKyAodGhpcy50aW1lU2VyaWFsIHx8IHRoaXMuY29ubmVjdGlvblNlcmlhbCkgKyAnOicgKyB0aGlzLm1zZ1NlcmlhbDtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJSZWNvdmVyeUtleSA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5yZWNvdmVyeUtleSA9IG51bGw7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLmNvbm5lY3Rpb25JZCkgeyByZXR1cm47IH1cblxuXHRcdHZhciBzaW5jZUxhc3QgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG5cdFx0aWYoc2luY2VMYXN0ID4gdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgKyB0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCknLCAnTGFzdCBrbm93biBhY3Rpdml0eSBmcm9tIHJlYWx0aW1lIHdhcyAnICsgc2luY2VMYXN0ICsgJ21zIGFnbzsgZGlzY2FyZGluZyBjb25uZWN0aW9uIHN0YXRlJyk7XG5cdFx0XHR0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuXHRcdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcblx0XHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcucXVldWVFdmVudHMgPSBmYWxzZTtcblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuXHQgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxuXHQgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XG5cdFx0aWYoaGF2ZVNlc3Npb25TdG9yYWdlKSB7XG5cdFx0XHR2YXIgcmVjb3ZlcnlLZXkgPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ucmVjb3ZlcnlLZXk7XG5cdFx0XHRpZihyZWNvdmVyeUtleSkge1xuXHRcdFx0XHRzZXRTZXNzaW9uUmVjb3ZlckRhdGEoe1xuXHRcdFx0XHRcdHJlY292ZXJ5S2V5OiByZWNvdmVyeUtleSxcblx0XHRcdFx0XHRkaXNjb25uZWN0ZWRBdDogX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSxcblx0XHRcdFx0XHRsb2NhdGlvbjogZ2xvYmFsLmxvY2F0aW9uLFxuXHRcdFx0XHRcdGNsaWVudElkOiB0aGlzLnJlYWx0aW1lLmF1dGguY2xpZW50SWRcblx0XHRcdFx0fSwgdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHQvKipcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG5cdCAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudW5wZXJzaXN0Q29ubmVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuXHRcdGNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKioqKlxuXHQgKiBzdGF0ZSBtYW5hZ2VtZW50XG5cdCAqKioqKioqKioqKioqKioqKioqKiovXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXJyb3JSZWFzb24gfHwgdGhpcy5nZXRTdGF0ZUVycm9yKCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFN0YXRlRXJyb3IgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfX1svKiBkZWZhdWx0ICovIFwiYVwiXVt0aGlzLnN0YXRlLnN0YXRlXTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0aXZlU3RhdGUgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cyB8fCB0aGlzLnN0YXRlLnNlbmRFdmVudHM7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmVuYWN0U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdHZhciBsb2dMZXZlbCA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnID8gX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SIDogX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01BSk9SO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihsb2dMZXZlbCwgJ0Nvbm5lY3Rpb24gc3RhdGUnLCBzdGF0ZUNoYW5nZS5jdXJyZW50ICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiA/ICgnOyByZWFzb246ICcgKyBzdGF0ZUNoYW5nZS5yZWFzb24pIDogJycpKTtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZScsICdzZXR0aW5nIG5ldyBzdGF0ZTogJyArIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAnOyByZWFzb24gPSAnICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSkpO1xuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZUNoYW5nZS5jdXJyZW50XTtcblx0XHRpZihzdGF0ZUNoYW5nZS5yZWFzb24pIHtcblx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG5cdFx0fVxuXHRcdGlmKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0Lyogc3VzcGVuZGVkIGlzIG5vbnRlcm1pbmFsLCBidXQgb25jZSBpbiB0aGUgc3VzcGVuZGVkIHN0YXRlLCByZWFsdGltZVxuXHRcdFx0ICogd2lsbCBoYXZlIGRpc2NhcmRlZCBvdXIgY29ubmVjdGlvbiBzdGF0ZSwgc28gZnV0aGVyIGNvbm5lY3Rpb25cblx0XHRcdCAqIGF0dGVtcHRzIHNob3VsZCBzdGFydCBmcm9tIHNjcmF0Y2ggKi9cblx0XHRcdHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCgnY29ubmVjdGlvbnN0YXRlJywgc3RhdGVDaGFuZ2UpO1xuXHR9O1xuXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXG5cdCAqIENvbm5lY3Rpb25NYW5hZ2VyIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG5cdCAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFRyYW5zaXRpb25UaW1lciA9IGZ1bmN0aW9uKHRyYW5zaXRpb25TdGF0ZSkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpJywgJ3RyYW5zaXRpb25TdGF0ZTogJyArIHRyYW5zaXRpb25TdGF0ZS5zdGF0ZSk7XG5cblx0XHRpZih0aGlzLnRyYW5zaXRpb25UaW1lcikge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAnY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyJyk7XG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuXHRcdH1cblxuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLnRyYW5zaXRpb25UaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihzZWxmLnRyYW5zaXRpb25UaW1lcikge1xuXHRcdFx0XHRzZWxmLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciAnICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlICsgJyB0aW1lciBleHBpcmVkJywgJ3JlcXVlc3RpbmcgbmV3IHN0YXRlOiAnICsgdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZSk7XG5cdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlfSk7XG5cdFx0XHR9XG5cdFx0fSwgdHJhbnNpdGlvblN0YXRlLnJldHJ5RGVsYXkpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxUcmFuc2l0aW9uVGltZXIgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2FuY2VsVHJhbnNpdGlvblRpbWVyKCknLCAnJyk7XG5cdFx0aWYodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG5cdFx0XHR0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRpZih0aGlzLnN1c3BlbmRUaW1lcilcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRpZihzZWxmLnN1c3BlbmRUaW1lcikge1xuXHRcdFx0XHRzZWxmLnN1c3BlbmRUaW1lciA9IG51bGw7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZCcpO1xuXHRcdFx0XHRzZWxmLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xuXHRcdFx0XHRzZWxmLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gZmFsc2U7XG5cdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiAnc3VzcGVuZGVkJ30pO1xuXHRcdFx0fVxuXHRcdH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tTdXNwZW5kVGltZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xuXHRcdGlmKHN0YXRlICE9PSAnZGlzY29ubmVjdGVkJyAmJiBzdGF0ZSAhPT0gJ3N1c3BlbmRlZCcgJiYgc3RhdGUgIT09ICdjb25uZWN0aW5nJylcblx0XHRcdHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XG5cdFx0dGhpcy5zdGF0ZXMuY29ubmVjdGluZy5xdWV1ZUV2ZW50cyA9IHRydWU7XG5cdFx0aWYodGhpcy5zdXNwZW5kVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnN1c3BlbmRUaW1lcik7XG5cdFx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbihpbnRlcnZhbCkge1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIHJldHJ5IHRpbWVyIGV4cGlyZWQnLCAncmV0cnlpbmcnKTtcblx0XHRcdHNlbGYucmV0cnlUaW1lciA9IG51bGw7XG5cdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xuXHRcdH0sIGludGVydmFsKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsUmV0cnlUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMucmV0cnlUaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG5cdFx0XHR0aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbihpbmRpY2F0ZWQpIHtcblx0XHR2YXIgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGUsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdC8qIFdlIHJldHJ5IGltbWVkaWF0ZWx5IGlmOlxuXHRcdCAqIC0gc29tZXRoaW5nIGRpc2Nvbm5lY3RzIHVzIHdoaWxlIHdlJ3JlIGNvbm5lY3RlZCwgb3Jcblx0XHQgKiAtIGEgdmlhYmxlIChidXQgbm90IHlldCBhY3RpdmUpIHRyYW5zcG9ydCBmYWlscyBkdWUgdG8gYSB0b2tlbiBlcnJvciAoc29cblx0XHQgKiAgIHRoaXMuZXJyb3JSZWFzb24gd2lsbCBiZSBzZXQsIGFuZCBzdGFydENvbm5lY3Qgd2lsbCBkbyBhIGZvcmNlZFxuXHRcdCAqICAgYXV0aG9yaXplKS4gSWYgdGhpcy5lcnJvclJlYXNvbiBpcyBhbHJlYWR5IHNldCAodG8gYSB0b2tlbiBlcnJvciksXG5cdFx0ICogICB0aGVuIHRoZXJlIGhhcyBiZWVuIGF0IGxlYXN0IG9uZSBwcmV2aW91cyBhdHRlbXB0IHRvIGNvbm5lY3QgdGhhdCBhbHNvXG5cdFx0ICogICBmYWlsZWQgZm9yIGEgdG9rZW4gZXJyb3IsIHNvIGJ5IFJUTjE0YiB3ZSBnbyB0byBESVNDT05ORUNURUQgYW5kIHdhaXRcblx0XHQgKiAgIGJlZm9yZSB0cnlpbmcgYWdhaW4gKi9cblx0XHR2YXIgcmV0cnlJbW1lZGlhdGVseSA9IChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiZcblx0XHRcdCh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQgICAgIHx8XG5cdFx0XHQgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyB8fFxuXHRcdFx0IGluZGljYXRlZC5yZXRyeUltbWVkaWF0ZWx5ICAgICAgICAgICAgICAgfHxcblx0XHRcdFx0KHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcgJiZcblx0XHRcdFx0XHRpbmRpY2F0ZWQuZXJyb3IgJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJlxuXHRcdFx0XHRcdCEodGhpcy5lcnJvclJlYXNvbiAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpKSk7XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICduZXcgc3RhdGU6ICcgKyBzdGF0ZSArIChyZXRyeUltbWVkaWF0ZWx5ID8gJzsgd2lsbCByZXRyeSBjb25uZWN0aW9uIGltbWVkaWF0ZWx5JyA6ICcnKSk7XG5cdFx0LyogZG8gbm90aGluZyBpZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBpbmRpY2F0ZWQgc3RhdGUgKi9cblx0XHRpZihzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0Lyoga2lsbCB0aW1lcnMgKHBvc3NpYmx5IGV4Y2VwdGluZyBzdXNwZW5kIHRpbWVyIGRlcGVuZGluZyBvbiB0aGUgbm90aWZpZWRcblx0XHQqIHN0YXRlKSwgYXMgdGhlc2UgYXJlIHN1cGVyc2VkZWQgYnkgdGhpcyBub3RpZmljYXRpb24gKi9cblx0XHR0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuXHRcdHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xuXHRcdHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcblxuXHRcdC8qIGRvIG5vdGhpbmcgaWYgd2UncmUgdW5hYmxlIHRvIG1vdmUgZnJvbSB0aGUgY3VycmVudCBzdGF0ZSAqL1xuXHRcdGlmKHRoaXMuc3RhdGUudGVybWluYWwpXG5cdFx0XHRyZXR1cm47XG5cblx0XHQvKiBwcm9jZXNzIG5ldyBzdGF0ZSAqL1xuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW2luZGljYXRlZC5zdGF0ZV0sXG5cdFx0XHRjaGFuZ2UgPSBuZXcgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXSh0aGlzLnN0YXRlLnN0YXRlLCBuZXdTdGF0ZS5zdGF0ZSwgbmV3U3RhdGUucmV0cnlEZWxheSwgKGluZGljYXRlZC5lcnJvciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdW25ld1N0YXRlLnN0YXRlXSkpO1xuXG5cdFx0aWYocmV0cnlJbW1lZGlhdGVseSkge1xuXHRcdFx0dmFyIGF1dG9SZWNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuZGlzY29ubmVjdGVkKSB7XG5cdFx0XHRcdFx0c2VsZi5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpO1xuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHR2YXIgc2luY2VMYXN0ID0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgJiYgKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkgLSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCArIDEpO1xuXHRcdFx0aWYoc2luY2VMYXN0ICYmIChzaW5jZUxhc3QgPCAxMDAwKSkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICdMYXN0IHJlY29ubmVjdCBhdHRlbXB0IHdhcyBvbmx5ICcgKyBzaW5jZUxhc3QgKyAnbXMgYWdvLCB3YWl0aW5nIGFub3RoZXIgJyArICgxMDAwIC0gc2luY2VMYXN0KSArICdtcyBiZWZvcmUgdHJ5aW5nIGFnYWluJyk7XG5cdFx0XHRcdHNldFRpbWVvdXQoYXV0b1JlY29ubmVjdCwgMTAwMCAtIHNpbmNlTGFzdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGF1dG9SZWNvbm5lY3QpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHR0aGlzLnN0YXJ0UmV0cnlUaW1lcihuZXdTdGF0ZS5yZXRyeURlbGF5KTtcblx0XHR9XG5cblx0XHQgLyogSWYgZ29pbmcgaW50byBkaXNjb25uZWN0L3N1c3BlbmRlZCAoYW5kIG5vdCByZXRyeWluZyBpbW1lZGlhdGVseSksIG9yIGFcblx0XHRcdCogdGVybWluYWwgc3RhdGUsIGVuc3VyZSB0aGVyZSBhcmUgbm8gb3JwaGFuZWQgdHJhbnNwb3J0cyBoYW5naW5nIGFyb3VuZC4gKi9cblx0XHRpZigoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmICFyZXRyeUltbWVkaWF0ZWx5KSB8fFxuXHRcdFx0IChzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHx8XG5cdFx0XHQgbmV3U3RhdGUudGVybWluYWwpIHtcblx0XHRcdFx0IC8qIFdhaXQgdGlsbCB0aGUgbmV4dCB0aWNrIHNvIHRoZSBjb25uZWN0aW9uIHN0YXRlIGNoYW5nZSBpcyBlbmFjdGVkLFxuXHRcdFx0XHQgKiBzbyBhYm9ydGluZyB0cmFuc3BvcnRzIGRvZXNuJ3QgdHJpZ2dlciByZWR1bmRhbnQgc3RhdGUgY2hhbmdlcyAqL1xuXHRcdFx0XHQgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHQgc2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHQgfSk7XG5cdFx0IH1cblxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0ZWQnICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICdCcm9rZW4gaW52YXJpYW50OiBhdHRlbXB0ZWQgdG8gZ28gaW50byBjb25uZWN0ZWQgc3RhdGUsIGJ1dCB0aGVyZSBpcyBubyBhY3RpdmUgcHJvdG9jb2wnKTtcblx0XHR9XG5cblx0XHQvKiBpbXBsZW1lbnQgdGhlIGNoYW5nZSBhbmQgbm90aWZ5ICovXG5cdFx0dGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG5cdFx0aWYodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XG5cdFx0XHR0aGlzLnNlbmRRdWV1ZWRNZXNzYWdlcygpO1xuXHRcdH0gZWxzZSBpZighdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cykge1xuXHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKHN0YXRlLCBjaGFuZ2UucmVhc29uKTtcblx0XHRcdHRoaXMuZmFpbFF1ZXVlZE1lc3NhZ2VzKGNoYW5nZS5yZWFzb24pOyAvLyBSVE43Y1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuXHRcdHZhciBzdGF0ZSA9IHJlcXVlc3Quc3RhdGUsIHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoKScsICdyZXF1ZXN0ZWQgc3RhdGU6ICcgKyBzdGF0ZSArICc7IGN1cnJlbnQgc3RhdGU6ICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcblx0XHRpZihzdGF0ZSA9PSB0aGlzLnN0YXRlLnN0YXRlKVxuXHRcdFx0cmV0dXJuOyAvKiBzaWxlbnRseSBkbyBub3RoaW5nICovXG5cblx0XHQvKiBraWxsIHJ1bm5pbmcgdGltZXJzLCBhcyB0aGlzIHJlcXVlc3Qgc3VwZXJzZWRlcyB0aGVtICovXG5cdFx0dGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcblx0XHR0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcblx0XHQvKiBmb3Igc3VzcGVuZCB0aW1lciBjaGVjayByYXRoZXIgdGhhbiBjYW5jZWwgLS0gZWcgcmVxdWVzdGluZyBhIGNvbm5lY3Rpbmdcblx0XHQqIHN0YXRlIHNob3VsZCBub3QgcmVzZXQgdGhlIHN1c3BlbmQgdGltZXIgKi9cblx0XHR0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKHN0YXRlKTtcblxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0aW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjb25uZWN0ZWQnKSByZXR1cm47XG5cdFx0aWYoc3RhdGUgPT0gJ2Nsb3NpbmcnICYmIHRoaXMuc3RhdGUuc3RhdGUgPT0gJ2Nsb3NlZCcpIHJldHVybjtcblxuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlXSxcblx0XHRcdGNoYW5nZSA9IG5ldyBfY2xpZW50X2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCBudWxsLCAocmVxdWVzdC5lcnJvciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdW25ld1N0YXRlLnN0YXRlXSkpO1xuXG5cdFx0dGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG5cblx0XHRpZihzdGF0ZSA9PSAnY29ubmVjdGluZycpIHtcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuc3RhcnRDb25uZWN0KCk7IH0pO1xuXHRcdH1cblx0XHRpZihzdGF0ZSA9PSAnY2xvc2luZycpIHtcblx0XHRcdHRoaXMuY2xvc2VJbXBsKCk7XG5cdFx0fVxuXHR9O1xuXG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0Q29ubmVjdCA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKScsICdNdXN0IGJlIGluIGNvbm5lY3Rpbmcgc3RhdGUgdG8gY29ubmVjdCwgYnV0IHdhcyAnICsgdGhpcy5zdGF0ZS5zdGF0ZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dmFyIGF1dGggPSB0aGlzLnJlYWx0aW1lLmF1dGgsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdC8qIFRoZSBwb2ludCBvZiB0aGUgY29ubmVjdENvdW50ZXIgbWVjaGFuaXNtIGlzIHRvIGVuc3VyZSB0aGF0IHRoZVxuXHRcdCAqIGNvbm5lY3Rpb24gcHJvY2VkdXJlIGNhbiBiZSBjYW5jZWxsZWQuIFdlIHdhbnQgZGlzY29ubmVjdEFsbFRyYW5zcG9ydHNcblx0XHQgKiB0byBiZSBhYmxlIHRvIHN0b3AgYW55IGluLXByb2dyZXNzIGNvbm5lY3Rpb24sIGV2ZW4gYmVmb3JlIGl0IGdldHMgdG9cblx0XHQgKiB0aGUgc3RhZ2Ugb2YgaGF2aW5nIGEgcGVuZGluZyAob3IgZXZlbiBhIHByb3Bvc2VkKSB0cmFuc3BvcnQgdGhhdCBpdCBjYW5cblx0XHQgKiBkaXNwb3NlKCkgb2YuIFNvIHdlIGNoZWNrIHRoYXQgaXQncyBzdGlsbCBjdXJyZW50IGFmdGVyIGFueSBhc3luYyBzdGFnZSxcblx0XHQgKiB1cCB1bnRpbCB0aGUgc3RhZ2UgdGhhdCBpcyBzeW5jaHJvbm91cyB3aXRoIGluc3RhbnRpYXRpbmcgYSB0cmFuc3BvcnQgKi9cblx0XHR2YXIgY29ubmVjdENvdW50ID0gKyt0aGlzLmNvbm5lY3RDb3VudGVyO1xuXG5cdFx0dmFyIGNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRcdHNlbGYuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MoKTtcblx0XHRcdHNlbGYuZ2V0VHJhbnNwb3J0UGFyYW1zKGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0c2VsZi5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpJywgJ3N0YXJ0aW5nIGNvbm5lY3Rpb24nKTtcblx0XHR0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XG5cdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcblxuXHRcdGlmKGF1dGgubWV0aG9kID09PSAnYmFzaWMnKSB7XG5cdFx0XHRjb25uZWN0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBhdXRoQ2IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoY29ubmVjdENvdW50ICE9PSBzZWxmLmNvbm5lY3RDb3VudGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdHNlbGYuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25uZWN0KCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRpZih0aGlzLmVycm9yUmVhc29uICYmIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSB7XG5cdFx0XHRcdC8qIEZvcmNlIGEgcmVmZXRjaCBvZiBhIG5ldyB0b2tlbiAqL1xuXHRcdFx0XHRhdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGF1dGhDYik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdXRoLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgYXV0aENiKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0LyoqXG5cdCAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgaW4gY29ubmVjdGluZzpcblx0ICogLSBwcmVmZXJlbmNlOiBpZiB0aGVyZSBpcyBhIGNhY2hlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSwgd2UgdHJ5IHRvIGNvbm5lY3Rcblx0ICogICBvbiB0aGF0LiBJZiB0aGF0IGZhaWxzIG9yIHRpbWVzIG91dCB3ZSBhYm9ydCB0aGUgYXR0ZW1wdCwgcmVtb3ZlIHRoZVxuXHQgKiAgIHByZWZlcmVuY2UgYW5kIGZhbGwgYmFjayB0byBiYXNlLiBJZiBpdCBzdWNjZWVkcywgd2UgdHJ5IHVwZ3JhZGluZyBpdCBpZlxuXHQgKiAgIG5lZWRlZCAod2lsbCBvbmx5IGJlIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBwcmVmZXJlbmNlIGlzIHhocnMgYW5kIHRoZVxuXHQgKiAgIGJyb3dzZXIgc3VwcG9ydHMgd3MpLlxuXHQgKiAtIGJhc2U6IHdlIHRyeSB0byBjb25uZWN0IHdpdGggdGhlIGJlc3QgdHJhbnNwb3J0IHRoYXQgd2UgdGhpbmsgd2lsbFxuXHQgKiAgIG5ldmVyIGZhaWwgZm9yIHRoaXMgYnJvd3NlciAodXN1YWxseSB0aGlzIGlzIHhocl9wb2xsaW5nOyBmb3IgdmVyeSBvbGRcblx0ICogICBicm93c2VycyB3aWxsIGJlIGpzb25wLCBmb3Igbm9kZSB3aWxsIGJlIGNvbWV0KS4gSWYgaXQgZG9lc24ndCB3b3JrLCB3ZVxuXHQgKiAgIHRyeSBmYWxsYmFjayBob3N0cy5cblx0ICogLSB1cGdyYWRlOiBnaXZlbiBhIGNvbm5lY3RlZCB0cmFuc3BvcnQsIHdlIHNlZSBpZiB0aGVyZSBhcmUgYW55IGJldHRlclxuXHQgKiAgIG9uZXMsIGFuZCBpZiBzbywgdHJ5IHRvIHVwZ3JhZGUgdG8gdGhlbS5cblx0ICpcblx0ICogY29ubmVjdEltcGwgd29ya3Mgb3V0IHdoYXQgc3RhZ2UgeW91J3JlIGF0ICh3aGljaCBpcyBwdXJlbHkgYSBmdW5jdGlvbiBvZlxuXHQgKiB0aGUgY3VycmVudCBjb25uZWN0aW9uIHN0YXRlIGFuZCB3aGV0aGVyIHRoZXJlIGFyZSBhbnkgc3RvcmVkIHByZWZlcmVuY2VzKSxcblx0ICogYW5kIGRpc3BhdGNoZXMgYWNjb3JkaW5nbHkuIEFmdGVyIGEgdHJhbnNwb3J0IGhhcyBiZWVuIHNldCBwZW5kaW5nLFxuXHQgKiB0cnlBVHJhbnNwb3J0IGNhbGxzIGNvbm5lY3RJbXBsIHRvIHNlZSBpZiB0aGVyZSdzIGFub3RoZXIgc3RhZ2UgdG8gYmUgZG9uZS5cblx0ICogKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RJbXBsID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLnN0YXRlLnN0YXRlO1xuXG5cdFx0aWYoc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3Rpbmcuc3RhdGUgJiYgc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xuXHRcdFx0LyogT25seSBrZWVwIHRyeWluZyBhcyBsb25nIGFzIGluIHRoZSAnY29ubmVjdGluZycgc3RhdGUgKG9yICdjb25uZWN0ZWQnXG5cdFx0XHQgKiBmb3IgdXBncmFkaW5nKS4gQW55IG9wZXJhdGlvbiBjYW4gcHV0IHVzIGludG8gJ2Rpc2Nvbm5lY3RlZCcgdG8gY2FuY2VsXG5cdFx0XHQgKiBjb25uZWN0aW9uIGF0dGVtcHRzIGFuZCB3YWl0IGJlZm9yZSByZXRyeWluZywgb3IgJ2ZhaWxlZCcgdG8gZmFpbC4gKi9cblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0IChvciBjb25uZWN0ZWQgdG8gdXBncmFkZSksIGJ1dCB3YXMgJyArIHN0YXRlKTtcblx0XHR9IGVsc2UgaWYodGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGgpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ1RyYW5zcG9ydHMgJyArIHRoaXMucGVuZGluZ1RyYW5zcG9ydHNbMF0udG9TdHJpbmcoKSArICcgY3VycmVudGx5IHBlbmRpbmc7IHRha2luZyBubyBhY3Rpb24nKTtcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG5cdFx0XHR0aGlzLnVwZ3JhZGVJZk5lZWRlZCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH0gZWxzZSBpZih0aGlzLnRyYW5zcG9ydHMubGVuZ3RoID4gMSAmJiB0aGlzLmdldFRyYW5zcG9ydFByZWZlcmVuY2UoKSkge1xuXHRcdFx0dGhpcy5jb25uZWN0UHJlZmVyZW5jZSh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLmNvbm5lY3RCYXNlKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcblx0XHR9XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdFByZWZlcmVuY2UgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMpIHtcblx0XHR2YXIgcHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpLFxuXHRcdFx0c2VsZiA9IHRoaXMsXG5cdFx0XHRwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSBmYWxzZTtcblxuXHRcdGlmKCFfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKHRoaXMudHJhbnNwb3J0cywgcHJlZmVyZW5jZSkpIHtcblx0XHRcdHRoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0dGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH1cblxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0UHJlZmVyZW5jZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggc3RvcmVkIHRyYW5zcG9ydCBwcmVmZXJlbmNlICcgKyBwcmVmZXJlbmNlKTtcblxuXHRcdHZhciBwcmVmZXJlbmNlVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG5cdFx0XHRwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuXHRcdFx0aWYoIShzZWxmLnN0YXRlLnN0YXRlID09PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpKSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0UHJlZmVyZW5jZSgpJywgJ1Nob3J0Y2lyY3VpdCBjb25uZWN0aW9uIGF0dGVtcHQgd2l0aCAnICsgcHJlZmVyZW5jZSArICcgZmFpbGVkOyBjbGVhcmluZyBwcmVmZXJlbmNlIGFuZCB0cnlpbmcgZnJvbSBzY3JhdGNoJyk7XG5cdFx0XHRcdC8qIEFib3J0IGFsbCBjb25uZWN0aW9uIGF0dGVtcHRzLiAoVGhpcyBhbHNvIGRpc2Nvbm5lY3RzIHRoZSBhY3RpdmVcblx0XHRcdFx0ICogcHJvdG9jb2wsIGJ1dCBub25lIGV4aXN0cyBpZiB3ZSdyZSBub3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSkgKi9cblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuXHRcdFx0XHQvKiBCZSBxdWl0ZSBhZ3Jlc3NpdmUgYWJvdXQgY2xlYXJpbmcgdGhlIHN0b3JlZCBwcmVmZXJlbmNlIGlmIGV2ZXIgaXQgZG9lc24ndCB3b3JrICovXG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xuXHRcdH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQpO1xuXG5cdFx0LyogRm9yIGNvbm5lY3RQcmVmZXJlbmNlLCBqdXN0IHVzZSB0aGUgbWFpbiBob3N0LiBJZiBob3N0IGZhbGxiYWNrIGlzIG5lZWRlZCwgZG8gaXQgaW4gY29ubmVjdEJhc2UuXG5cdFx0ICogVGhlIHdzdHJhbnNwb3J0IGl0IHdpbGwgc3Vic3RpdHV0ZSB0aGUgaHR0cGhvc3QgZm9yIGFuIGFwcHJvcHJpYXRlIHdzaG9zdCAqL1xuXHRcdHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gc2VsZi5odHRwSG9zdHNbMF07XG5cdFx0c2VsZi50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgcHJlZmVyZW5jZSwgZnVuY3Rpb24oZmF0YWwsIHRyYW5zcG9ydCkge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHByZWZlcmVuY2VUaW1lb3V0KTtcblx0XHRcdGlmKHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCAmJiB0cmFuc3BvcnQpIHtcblx0XHRcdFx0LyogVmlhYmxlLCBidXQgdG9vIGxhdGUgLSBjb25uZWN0SW1wbCgpIHdpbGwgYWxyZWFkeSBiZSB0cnlpbmdcblx0XHRcdFx0KiBjb25uZWN0QmFzZSwgYW5kIHdlIHdlcmVuJ3QgaW4gdXBncmFkZSBtb2RlLiBKdXN0IHJlbW92ZSB0aGVcblx0XHRcdFx0KiBvbmNvbm5lY3RlZCBsaXN0ZW5lciBhbmQgZ2V0IHJpZCBvZiBpdCAqL1xuXHRcdFx0XHR0cmFuc3BvcnQub2ZmKCk7XG5cdFx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcblx0XHRcdH0gZWxzZSBpZighdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuXHRcdFx0XHQvKiBQcmVmZXJlbmNlIGZhaWxlZCBpbiBhIHRyYW5zcG9ydC1zcGVjaWZpYyB3YXkuIFRyeSBtb3JlICovXG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuXHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHR9XG5cdFx0XHQvKiBJZiBzdWNlZWRlZCwgb3IgZmFpbGVkIGZhdGFsbHksIG5vdGhpbmcgdG8gZG8gKi9cblx0XHR9KTtcblx0fTtcblxuXG5cdC8qKlxuXHQgKiBUcnkgdG8gZXN0YWJsaXNoIGEgdHJhbnNwb3J0IG9uIHRoZSBiYXNlIHRyYW5zcG9ydCAodGhlIGJlc3QgdHJhbnNwb3J0XG5cdCAqIHN1Y2ggdGhhdCBpZiBpdCBkb2Vzbid0IHdvcmssIG5vdGhpbmcgd2lsbCB3b3JrKSBhcyBkZXRlcm1pbmVkIHRocm91Z2hcblx0ICogc3RhdGljIGZlYXR1cmUgZGV0ZWN0aW9uLCBjaGVja2luZyBmb3IgbmV0d29yayBjb25uZWN0aXZpdHkgYW5kIHRyeWluZ1xuXHQgKiBmYWxsYmFjayBob3N0cyBpZiBhcHBsaWNhYmxlLlxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0UGFyYW1zXG5cdCAqL1xuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY29ubmVjdEJhc2UgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdGdpdmVVcCA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogc2VsZi5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUsIGVycm9yOiBlcnJ9KTtcblx0XHRcdH0sXG5cdFx0XHRjYW5kaWRhdGVIb3N0cyA9IHRoaXMuaHR0cEhvc3RzLnNsaWNlKCksXG5cdFx0XHRob3N0QXR0ZW1wdENiID0gZnVuY3Rpb24oZmF0YWwsIHRyYW5zcG9ydCkge1xuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcblx0XHRcdFx0XHR0cnlGYWxsYmFja0hvc3RzKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEJhc2UoKScsICdUcnlpbmcgdG8gY29ubmVjdCB3aXRoIGJhc2UgdHJhbnNwb3J0ICcgKyB0aGlzLmJhc2VUcmFuc3BvcnQpO1xuXG5cdFx0LyogZmlyc3QgdHJ5IHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcHJpb3JpdHkgaG9zdCB3aXRoIGh0dHAgdHJhbnNwb3J0ICovXG5cdFx0dmFyIGhvc3QgPSBjYW5kaWRhdGVIb3N0cy5zaGlmdCgpO1xuXHRcdGlmKCFob3N0KSB7XG5cdFx0XHRnaXZlVXAobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBjb25uZWN0IChubyBhdmFpbGFibGUgaG9zdCknLCA4MDAwMywgNDA0KSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gaG9zdDtcblxuXHRcdC8qIHRoaXMgaXMgd2hhdCB3ZSdsbCBiZSBkb2luZyBpZiB0aGUgYXR0ZW1wdCBmb3IgdGhlIG1haW4gaG9zdCBmYWlscyAqL1xuXHRcdGZ1bmN0aW9uIHRyeUZhbGxiYWNrSG9zdHMoKSB7XG5cdFx0XHQvKiBpZiB0aGVyZSBhcmVuJ3QgYW55IGZhbGxiYWNrIGhvc3RzLCBmYWlsICovXG5cdFx0XHRpZighY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XG5cdFx0XHRcdGdpdmVVcChuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSknLCA4MDAwMywgNDA0KSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdC8qIGJlZm9yZSB0cnlpbmcgYW55IGZhbGxiYWNrIChvciBhbnkgcmVtYWluaW5nIGZhbGxiYWNrKSB3ZSBkZWNpZGUgaWZcblx0XHRcdCAqIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBhYmx5IGhvc3QsIG9yIHRoZXJlIGlzIGEgZ2VuZXJhbCBjb25uZWN0aXZpdHlcblx0XHRcdCAqIHByb2JsZW0gKi9cblx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkoZnVuY3Rpb24oZXJyLCBjb25uZWN0aXZpdHkpIHtcblx0XHRcdFx0aWYoY29ubmVjdENvdW50ICE9PSBzZWxmLmNvbm5lY3RDb3VudGVyKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdC8qIHdlIGtub3cgZXJyIHdvbid0IGhhcHBlbiBidXQgaGFuZGxlIGl0IGhlcmUgYW55d2F5ICovXG5cdFx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRcdGdpdmVVcChlcnIpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZighY29ubmVjdGl2aXR5KSB7XG5cdFx0XHRcdFx0LyogdGhlIGludGVybmV0IGlzbid0IHJlYWNoYWJsZSwgc28gZG9uJ3QgdHJ5IHRoZSBmYWxsYmFjayBob3N0cyAqL1xuXHRcdFx0XHRcdGdpdmVVcChuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIGNvbm5lY3QgKG5ldHdvcmsgdW5yZWFjaGFibGUpJywgODAwMDMsIDQwNCkpO1xuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0XHQvKiB0aGUgbmV0d29yayBpcyB0aGVyZSwgc28gdGhlcmUncyBhIHByb2JsZW0gd2l0aCB0aGUgbWFpbiBob3N0LCBvclxuXHRcdFx0XHQgKiBpdHMgZG5zLiBUcnkgdGhlIGZhbGxiYWNrIGhvc3RzLiBXZSBjb3VsZCB0cnkgdGhlbSBzaW11bHRhbmVvdXNseSBidXRcblx0XHRcdFx0ICogdGhhdCB3b3VsZCBwb3RlbnRpYWxseSBjYXVzZSBhIGh1Z2Ugc3Bpa2UgaW4gbG9hZCBvbiB0aGUgbG9hZCBiYWxhbmNlciAqL1xuXHRcdFx0XHR0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyUG9wUmFuZG9tRWxlbWVudChjYW5kaWRhdGVIb3N0cyk7XG5cdFx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHNlbGYuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRpZih0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuXHRcdFx0dGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IGZhbHNlO1xuXHRcdFx0dHJ5RmFsbGJhY2tIb3N0cygpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHRoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHRoaXMuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VXBncmFkZVBvc3NpYmlsaXRpZXMgPSBmdW5jdGlvbigpIHtcblx0XHQvKiByZXR1cm5zIHRoZSBzdWJzZXQgb2YgdXBncmFkZVRyYW5zcG9ydHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG5cdFx0ICogdHJhbnNwb3J0IGluIHVwZ3JhZGVUcmFuc3BvcnRzIChpZiBpdCdzIGluIHRoZXJlIC0gaWYgbm90LCBjdXJyZW50UG9zaXRpb25cblx0XHQgKiB3aWxsIGJlIC0xLCBzbyByZXR1cm4gdXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoMCkgPT0gdXBncmFkZVRyYW5zcG9ydHMgKi9cblx0XHR2YXIgY3VycmVudCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuc2hvcnROYW1lO1xuXHRcdHZhciBjdXJyZW50UG9zaXRpb24gPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YodGhpcy51cGdyYWRlVHJhbnNwb3J0cywgY3VycmVudCk7XG5cdFx0cmV0dXJuIHRoaXMudXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoY3VycmVudFBvc2l0aW9uICsgMSk7XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBncmFkZUlmTmVlZGVkID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zKSB7XG5cdFx0dmFyIHVwZ3JhZGVQb3NzaWJpbGl0aWVzID0gdGhpcy5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnVwZ3JhZGVJZk5lZWRlZCgpJywgJ3VwZ3JhZGUgcG9zc2liaWxpdGllczogJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdCh1cGdyYWRlUG9zc2liaWxpdGllcykpO1xuXG5cdFx0aWYoIXVwZ3JhZGVQb3NzaWJpbGl0aWVzLmxlbmd0aCkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaCh1cGdyYWRlUG9zc2liaWxpdGllcywgZnVuY3Rpb24odXBncmFkZVRyYW5zcG9ydCkge1xuXHRcdFx0LyogTm90ZTogdGhlIHRyYW5zcG9ydCBtYXkgbXV0YXRlIHRoZSBwYXJhbXMsIHNvIGdpdmUgZWFjaCB0cmFuc3BvcnQgYSBmcmVzaCBvbmUgKi9cblx0XHRcdHZhciB1cGdyYWRlVHJhbnNwb3J0UGFyYW1zID0gc2VsZi5jcmVhdGVUcmFuc3BvcnRQYXJhbXModHJhbnNwb3J0UGFyYW1zLmhvc3QsICd1cGdyYWRlJyk7XG5cdFx0XHRzZWxmLnRyeUFUcmFuc3BvcnQodXBncmFkZVRyYW5zcG9ydFBhcmFtcywgdXBncmFkZVRyYW5zcG9ydCwgbm9vcCk7XG5cdFx0fSk7XG5cdH07XG5cblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xvc2VJbXBsID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ2Nsb3NpbmcgY29ubmVjdGlvbicpO1xuXHRcdHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG5cdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jbG9zaW5nKTtcblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBwZW5kaW5nIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5jbG9zZSgpO1xuXHRcdH0pO1xuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnRGlzcG9zaW5nIG9mIHByb3Bvc2VkIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdFx0fSk7XG5cblx0XHRpZih0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmNsb3NlKCk7XG5cdFx0fVxuXG5cdFx0LyogSWYgdGhlcmUgd2FzIGFuIGFjdGl2ZSB0cmFuc3BvcnQsIHRoaXMgd2lsbCBwcm9iYWJseSBiZVxuXHRcdCAqIHByZWVtcHRlZCBieSB0aGUgbm90aWZ5U3RhdGUgY2FsbCBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXG5cdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdjbG9zZWQnfSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbih0b2tlbkRldGFpbHMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJywgJ1NlbmRpbmcgQVVUSCBtZXNzYWdlIG9uIGFjdGl2ZSB0cmFuc3BvcnQnKTtcblx0XHRcdFx0LyogSWYgdGhlcmUgYXJlIGFueSBwcm9wb3NlZC9wZW5kaW5nIHRyYW5zcG9ydHMgKGVnIGFuIHVwZ3JhZGUgdGhhdFxuXHRcdFx0XHQgKiBpc24ndCB5ZXQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uKSB0aGF0IGhhc24ndCB5ZXQgc3RhcnRlZCBzeW5jaW5nLFxuXHRcdFx0XHQgKiBqdXN0IHRvIGdldCByaWQgb2YgdGhlbSAmIHJlc3RhcnQgdGhlIHVwZ3JhZGUgd2l0aCB0aGUgbmV3IHRva2VuLCB0b1xuXHRcdFx0XHQgKiBhdm9pZCBhIHJhY2UgY29uZGl0aW9uLiAoSWYgaXQgaGFzIHN0YXJ0ZWQgc3luY2luZywgdGhlIEFVVEggd2lsbCBiZVxuXHRcdFx0XHQgKiBxdWV1ZWQgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUsIHNvIGV2ZXJ5dGhpbmcncyBmaW5lKSAqL1xuXHRcdFx0XHRpZigodGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5sZW5ndGggfHwgdGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMubGVuZ3RoKSAmJlxuXHRcdFx0XHRcdHNlbGYuc3RhdGUgIT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcblx0XHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKC8qIGV4Y2VwdEFjdGl2ZTogKi90cnVlKTtcblx0XHRcdFx0XHR2YXIgdHJhbnNwb3J0UGFyYW1zID0gdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5wYXJhbXM7XG5cdFx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG5cdFx0XHRcdFx0XHRcdHNlbGYudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvKiBEbyBhbnkgdHJhbnNwb3J0LXNwZWNpZmljIG5ldy10b2tlbiBhY3Rpb24gKi9cblx0XHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5vbkF1dGhVcGRhdGVkKHRva2VuRGV0YWlscyk7XG5cblx0XHRcdFx0dmFyIGF1dGhNc2cgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XG5cdFx0XHRcdFx0YWN0aW9uOiBhY3Rpb25zLkFVVEgsXG5cdFx0XHRcdFx0YXV0aDoge1xuXHRcdFx0XHRcdFx0YWNjZXNzVG9rZW46IHRva2VuRGV0YWlscy50b2tlblxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHRcdHRoaXMuc2VuZChhdXRoTXNnKTtcblxuXHRcdFx0XHQvKiBUaGUgYW5zd2VyIHdpbGwgY29tZSBiYWNrIGFzIGVpdGhlciBhIGNvbm5lY3Rpb25kZXRhaWxzIGV2ZW50XG5cdFx0XHRcdCAqIChyZWFsdGltZSBzZW5kcyBhIENPTk5FQ1RFRCB0byBhc2tub3dsZWRnZSB0aGUgcmVhdXRoKSBvciBhXG5cdFx0XHRcdCAqIHN0YXRlY2hhbmdlIHRvIGZhaWxlZCAqL1xuXHRcdFx0XHR2YXIgc3VjY2Vzc0xpc3RlbmVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0c2VsZi5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgZmFpbHVyZUxpc3RlbmVyID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdFx0XHRpZihzdGF0ZUNoYW5nZS5jdXJyZW50ID09PSAnZmFpbGVkJykge1xuXHRcdFx0XHRcdFx0c2VsZi5vZmYoc3VjY2Vzc0xpc3RlbmVyKTtcblx0XHRcdFx0XHRcdHNlbGYub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgc2VsZi5nZXRTdGF0ZUVycm9yKCkpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0dGhpcy5vbmNlKCdjb25uZWN0aW9uZGV0YWlscycsIHN1Y2Nlc3NMaXN0ZW5lcik7XG5cdFx0XHRcdHRoaXMub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZhaWx1cmVMaXN0ZW5lcik7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRjYXNlICdjb25uZWN0aW5nJzpcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsXG5cdFx0XHRcdFx0J0Fib3J0aW5nIGN1cnJlbnQgY29ubmVjdGlvbiBhdHRlbXB0cyBpbiBvcmRlciB0byBzdGFydCBhZ2FpbiB3aXRoIHRoZSBuZXcgYXV0aCBkZXRhaWxzJyk7XG5cdFx0XHRcdHRoaXMuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcblx0XHRcdFx0LyogZmFsbHRocm91Z2ggdG8gYWRkIHN0YXRlY2hhbmdlIGxpc3RlbmVyICovXG5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLFxuXHRcdFx0XHRcdCdDb25uZWN0aW9uIHN0YXRlIGlzICcgKyB0aGlzLnN0YXRlLnN0YXRlICsgJzsgd2FpdGluZyB1bnRpbCBlaXRoZXIgY29ubmVjdGVkIG9yIGZhaWxlZCcpO1xuXHRcdFx0XHR2YXIgbGlzdGVuZXIgPSBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0XHRcdHN3aXRjaChzdGF0ZUNoYW5nZS5jdXJyZW50KSB7XG5cdFx0XHRcdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxuXHRcdFx0XHRcdFx0XHRzZWxmLm9mZihsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XG5cdFx0XHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRcdFx0XHRzZWxmLm9mZihsaXN0ZW5lcik7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBzZWxmLmdldFN0YXRlRXJyb3IoKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0XHRcdFx0LyogaWdub3JlIHRpbGwgd2UgZ2V0IGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkICovXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdFx0c2VsZi5vbignY29ubmVjdGlvbnN0YXRlJywgbGlzdGVuZXIpO1xuXHRcdFx0XHRpZih0aGlzLnN0YXRlLnN0YXRlID09PSAnY29ubmVjdGluZycpIHtcblx0XHRcdFx0XHQvKiBjYW4gaGFwcGVuIGlmIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlIGJ1dCBubyB0cmFuc3BvcnQgd2FzIHBlbmRpbmdcblx0XHRcdFx0XHQgKiB5ZXQsIHNvIGRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzIGRpZCBub3QgdHJpZ2dlciBhIGRpc2Nvbm5lY3RlZCBzdGF0ZSAqL1xuXHRcdFx0XHRcdHNlbGYuc3RhcnRDb25uZWN0KCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcblx0XHRcdFx0fVxuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMgPSBmdW5jdGlvbihleGNlcHRBY3RpdmUpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFsbCB0cmFuc3BvcnRzJyArIChleGNlcHRBY3RpdmUgPyAnIGV4Y2VwdCB0aGUgYWN0aXZlIHRyYW5zcG9ydCcgOiAnJykpO1xuXG5cdFx0LyogVGhpcyB3aWxsIHByZXZlbnQgYW55IGNvbm5lY3Rpb24gcHJvY2VkdXJlIGluIGFuIGFzeW5jIHBhcnQgb2Ygb25lIG9mIGl0cyBlYXJseSBzdGFnZXMgZnJvbSBjb250aW51aW5nICovXG5cdFx0dGhpcy5jb25uZWN0Q291bnRlcisrO1xuXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuXHRcdH0pO1xuXHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcblxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzcG9zaW5nIG9mIHByb3Bvc2VkIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5kaXNwb3NlKCk7XG5cdFx0fSk7XG5cdFx0dGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMgPSBbXTtcblxuXHRcdGlmKHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgIWV4Y2VwdEFjdGl2ZSkge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLmRpc2Nvbm5lY3QoKTtcblx0XHR9XG5cdFx0LyogTm8gbmVlZCB0byBub3RpZnkgc3RhdGUgZGlzY29ubmVjdGVkOyBkaXNjb25uZWN0aW5nIHRoZSBhY3RpdmUgdHJhbnNwb3J0XG5cdFx0ICogd2lsbCBoYXZlIHRoYXQgZWZmZWN0ICovXG5cdH07XG5cblx0LyoqKioqKioqKioqKioqKioqKlxuXHQgKiBldmVudCBxdWV1ZWluZ1xuXHQgKioqKioqKioqKioqKioqKioqL1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLnN0YXRlO1xuXG5cdFx0aWYoc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsICdzZW5kaW5nIGV2ZW50Jyk7XG5cdFx0XHR0aGlzLnNlbmRJbXBsKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciBzaG91bGRRdWV1ZSA9IChxdWV1ZUV2ZW50ICYmIHN0YXRlLnF1ZXVlRXZlbnRzKSB8fCBzdGF0ZS5mb3JjZVF1ZXVlRXZlbnRzO1xuXHRcdGlmKCFzaG91bGRRdWV1ZSkge1xuXHRcdFx0dmFyIGVyciA9ICdyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzICcgKyBxdWV1ZUV2ZW50ICsgJywgc3RhdGUgd2FzICcgKyBzdGF0ZS5zdGF0ZTtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCBlcnIpO1xuXHRcdFx0Y2FsbGJhY2sodGhpcy5lcnJvclJlYXNvbiB8fCBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXShlcnIsIDkwMDAwLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aWYoX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2hvdWxkTG9nKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTykpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAncXVldWVpbmcgbXNnOyAnICsgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ2lmeShtc2cpKTtcblx0XHR9XG5cdFx0dGhpcy5xdWV1ZShtc2csIGNhbGxiYWNrKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZEltcGwgPSBmdW5jdGlvbihwZW5kaW5nTWVzc2FnZSkge1xuXHRcdHZhciBtc2cgPSBwZW5kaW5nTWVzc2FnZS5tZXNzYWdlO1xuXHRcdC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCB0aGlzLCByZXNlbmQgd2l0aCB0aGUgc2FtZSBtc2dTZXJpYWwsXG5cdFx0ICogc28gQWJseSBjYW4gZGVkdXAgaWYgdGhlIHByZXZpb3VzIHNlbmQgc3VjY2VlZGVkICovXG5cdFx0aWYocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQgJiYgIXBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQpIHtcblx0XHRcdG1zZy5tc2dTZXJpYWwgPSB0aGlzLm1zZ1NlcmlhbCsrO1xuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xuXHRcdH1cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5zZW5kKHBlbmRpbmdNZXNzYWdlKTtcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGluIHRyYW5zcG9ydC5zZW5kKCk6ICcgKyBlLnN0YWNrKTtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYnVuZGxlV2l0aChkZXN0LCBzcmMsIG1heFNpemUpIHtcblx0XHR2YXIgYWN0aW9uO1xuXHRcdGlmKGRlc3QuY2hhbm5lbCAhPT0gc3JjLmNoYW5uZWwpIHtcblx0XHRcdC8qIFJUTDZkMyAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZigoYWN0aW9uID0gZGVzdC5hY3Rpb24pICE9PSBhY3Rpb25zLlBSRVNFTkNFICYmIGFjdGlvbiAhPT0gYWN0aW9ucy5NRVNTQUdFKSB7XG5cdFx0XHQvKiBSVEw2ZCAtIGNhbiBvbmx5IGJ1bmRsZSBtZXNzYWdlcyBvciBwcmVzZW5jZSAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRpZihhY3Rpb24gIT09IHNyYy5hY3Rpb24pIHtcblx0XHRcdC8qIFJUTDZkNCAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHR2YXIga2luZCA9IChhY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpID8gJ3ByZXNlbmNlJyA6ICdtZXNzYWdlcycsXG5cdFx0XHRwcm9wb3NlZCA9IGRlc3Rba2luZF0uY29uY2F0KHNyY1traW5kXSksXG5cdFx0XHRzaXplID0gX3R5cGVzX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0TWVzc2FnZXNTaXplKHByb3Bvc2VkKTtcblx0XHRpZihzaXplID4gbWF4U2l6ZSkge1xuXHRcdFx0LyogUlRMNmQxICovXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdGlmKCFfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFsbFNhbWUocHJvcG9zZWQsICdjbGllbnRJZCcpKSB7XG5cdFx0XHQvKiBSVEw2ZDIgKi9cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0aWYoIV91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRXZlcnkocHJvcG9zZWQsIGZ1bmN0aW9uKG1zZykge1xuXHRcdFx0cmV0dXJuICFtc2cuaWQ7XG5cdFx0fSkpIHtcblx0XHRcdC8qIFJUTDZkNyAqL1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHQvKiB3ZSdyZSBnb29kIHRvIGdvISAqL1xuXHRcdGRlc3Rba2luZF0gPSBwcm9wb3NlZDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucXVldWUgPSBmdW5jdGlvbihtc2csIGNhbGxiYWNrKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlKCknLCAncXVldWVpbmcgZXZlbnQnKTtcblx0XHR2YXIgbGFzdFF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMubGFzdCgpO1xuXHRcdHZhciBtYXhTaXplID0gdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuXHRcdC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCBhIG1lc3NhZ2UsIGRvbid0IG1lcmdlIG1vcmUgbWVzc2FnZXNcblx0XHQgKiBpbnRvIGl0LCBhcyBpZiB0aGUgcHJldmlvdXMgc2VuZCBhY3R1YWxseSBzdWNjZWVkZWQgYW5kIHJlYWx0aW1lIGlnbm9yZXNcblx0XHQgKiB0aGUgZHVwLCB0aGV5J2xsIGJlIGxvc3QgKi9cblx0XHRpZihsYXN0UXVldWVkICYmICFsYXN0UXVldWVkLnNlbmRBdHRlbXB0ZWQgJiYgYnVuZGxlV2l0aChsYXN0UXVldWVkLm1lc3NhZ2UsIG1zZywgbWF4U2l6ZSkpIHtcblx0XHRcdGlmKCFsYXN0UXVldWVkLm1lcmdlZCkge1xuXHRcdFx0XHRsYXN0UXVldWVkLmNhbGxiYWNrID0gT2JqZWN0KF91dGlsX211bHRpY2FzdGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKShbbGFzdFF1ZXVlZC5jYWxsYmFja10pO1xuXHRcdFx0XHRsYXN0UXVldWVkLm1lcmdlZCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRsYXN0UXVldWVkLmNhbGxiYWNrLnB1c2goY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IFBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmRRdWV1ZWRNZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kUXVldWVkTWVzc2FnZXMoKScsICdzZW5kaW5nICcgKyB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCkgKyAnIHF1ZXVlZCBtZXNzYWdlcycpO1xuXHRcdHZhciBwZW5kaW5nTWVzc2FnZTtcblx0XHR3aGlsZShwZW5kaW5nTWVzc2FnZSA9IHRoaXMucXVldWVkTWVzc2FnZXMuc2hpZnQoKSlcblx0XHRcdHRoaXMuc2VuZEltcGwocGVuZGluZ01lc3NhZ2UpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZVBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlcykge1xuXHRcdGlmKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIucXVldWVQZW5kaW5nTWVzc2FnZXMoKScsICdxdWV1ZWluZyAnICsgcGVuZGluZ01lc3NhZ2VzLmxlbmd0aCArICcgcGVuZGluZyBtZXNzYWdlcycpO1xuXHRcdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcy5wcmVwZW5kKHBlbmRpbmdNZXNzYWdlcyk7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5mYWlsUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbihlcnIpIHtcblx0XHR2YXIgbnVtUXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpO1xuXHRcdGlmKG51bVF1ZXVlZCA+IDApIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5mYWlsUXVldWVkTWVzc2FnZXMoKScsICdmYWlsaW5nICcgKyBudW1RdWV1ZWQgKyAnIHF1ZXVlZCBtZXNzYWdlcywgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0dGhpcy5xdWV1ZWRNZXNzYWdlcy5jb21wbGV0ZUFsbE1lc3NhZ2VzKGVycik7XG5cdFx0fVxuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkNoYW5uZWxNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSwgdHJhbnNwb3J0KSB7XG5cdFx0dmFyIG9uQWN0aXZlVHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0cmFuc3BvcnQgPT09IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksXG5cdFx0XHRvblVwZ3JhZGVUcmFuc3BvcnQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCkgJiYgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nLFxuXHRcdFx0bm90Q29udHJvbE1zZyA9IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLk1FU1NBR0UgfHwgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0U7XG5cblx0XHQvKiBBcyB0aGUgbGliIG5vdyBoYXMgYSBwZXJpb2Qgd2hlcmUgdGhlIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIHN5bmNlZCBidXRcblx0XHQgKiBiZWZvcmUgaXQncyBiZWNvbWUgYWN0aXZlICh3aGlsZSB3YWl0aW5nIGZvciB0aGUgb2xkIG9uZSB0byBiZWNvbWVcblx0XHQgKiBpZGxlKSwgbWVzc2FnZSBjYW4gdmFsaWRseSBhcnJpdmUgb24gaXQgZXZlbiB0aG91Z2ggaXQgaXNuJ3QgYWN0aXZlICovXG5cdFx0aWYob25BY3RpdmVUcmFuc3BvcnQgfHwgb25VcGdyYWRlVHJhbnNwb3J0KSB7XG5cdFx0XHRpZihub3RDb250cm9sTXNnKSB7XG5cdFx0XHRcdHZhciBzdXBwcmVzc2VkID0gdGhpcy5zZXRDb25uZWN0aW9uU2VyaWFsKG1lc3NhZ2UpO1xuXHRcdFx0XHRpZihzdXBwcmVzc2VkKSB7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0R1cGxpY2F0ZShtZXNzYWdlLCB0aGlzLm1vc3RSZWNlbnRNc2cpKSB7XG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBtZXNzYWdlIHdpdGggZGlmZmVyZW50IGNvbm5lY3Rpb25TZXJpYWwsIGJ1dCBzYW1lIG1lc3NhZ2UgaWQgYXMgYSBwcmV2aW91czsgZGlzY2FyZGluZzsgaWQgPSAnICsgbWVzc2FnZS5pZCk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMubW9zdFJlY2VudE1zZyA9IG1lc3NhZ2U7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIE1lc3NhZ2UgY2FtZSBpbiBvbiBhIGRlZnVuY3QgdHJhbnNwb3J0LiBBbGxvdyBvbmx5IGFja3MsIG5hY2tzLCAmIGVycm9ycyBmb3Igb3V0c3RhbmRpbmdcblx0XHRcdC8vIG1lc3NhZ2VzLCAgbm8gbmV3IG1lc3NhZ2VzIChhcyBzeW5jIGhhcyBiZWVuIHNlbnQgb24gbmV3IHRyYW5zcG9ydCBzbyBuZXcgbWVzc2FnZXMgd2lsbFxuXHRcdFx0Ly8gYmUgcmVzZW50IHRoZXJlLCBvciBjb25uZWN0aW9uIGhhcyBiZWVuIGNsb3NlZCBzbyBkb24ndCB3YW50IG5ldyBtZXNzYWdlcylcblx0XHRcdGlmKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihbYWN0aW9ucy5BQ0ssIGFjdGlvbnMuTkFDSywgYWN0aW9ucy5FUlJPUl0sIG1lc3NhZ2UuYWN0aW9uKSA+IC0xKSB7XG5cdFx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgbWVzc2FnZSAnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkgKyAnb24gZGVmdW5jdCB0cmFuc3BvcnQ7IGRpc2NhcmRpbmcnKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbih0cmFuc3BvcnQsIGNhbGxiYWNrKSB7XG5cdFx0LyogaWYgdHJhbnNwb3J0IGlzIHNwZWNpZmllZCwgdHJ5IHRoYXQgKi9cblx0XHRpZih0cmFuc3BvcnQpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5waW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG5cblx0XHRcdHZhciBvblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHRyYW5zcG9ydC5vZmYoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0KTtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1RpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlJywgNTAwMDAsIDUwMCkpO1xuXHRcdFx0fTtcblxuXHRcdFx0dmFyIHBpbmdTdGFydCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCksXG5cdFx0XHRcdGlkID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVhcFJhbmRTdHIoKTtcblxuXHRcdFx0dmFyIG9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHJlc3BvbnNlSWQpIHtcblx0XHRcdFx0aWYocmVzcG9uc2VJZCA9PT0gaWQpIHtcblx0XHRcdFx0XHR0cmFuc3BvcnQub2ZmKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcblx0XHRcdFx0XHR2YXIgcmVzcG9uc2VUaW1lID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSAtIHBpbmdTdGFydDtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXNwb25zZVRpbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuXG5cdFx0XHR0cmFuc3BvcnQub24oJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0KTtcblx0XHRcdHRyYW5zcG9ydC5waW5nKGlkKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvKiBpZiB3ZSdyZSBub3QgY29ubmVjdGVkLCBkb24ndCBhdHRlbXB0ICovXG5cdFx0aWYodGhpcy5zdGF0ZS5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdVbmFibGUgdG8gcGluZyBzZXJ2aWNlOyBub3QgY29ubmVjdGVkJywgNDAwMDAsIDQwMCkpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8qIG5vIHRyYW5zcG9ydCB3YXMgc3BlY2lmaWVkLCBzbyB1c2UgdGhlIGN1cnJlbnQgKGNvbm5lY3RlZCkgb25lXG5cdFx0ICogYnV0IGVuc3VyZSB0aGF0IHdlIHJldHJ5IGlmIHRoZSB0cmFuc3BvcnQgaXMgc3VwZXJzZWRlZCBiZWZvcmUgd2UgY29tcGxldGUgKi9cblx0XHR2YXIgY29tcGxldGVkID0gZmFsc2UsIHNlbGYgPSB0aGlzO1xuXG5cdFx0dmFyIG9uUGluZ0NvbXBsZXRlID0gZnVuY3Rpb24oZXJyLCByZXNwb25zZVRpbWUpIHtcblx0XHRcdHNlbGYub2ZmKCd0cmFuc3BvcnQuYWN0aXZlJywgb25UcmFuc3BvcnRBY3RpdmUpO1xuXHRcdFx0aWYoIWNvbXBsZXRlZCkge1xuXHRcdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHJlc3BvbnNlVGltZSk7XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdHZhciBvblRyYW5zcG9ydEFjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYoIWNvbXBsZXRlZCkge1xuXHRcdFx0XHQvKiBlbnN1cmUgdGhhdCBubyBjYWxsYmFjayBoYXBwZW5zIGZvciB0aGUgY3VycmVudGx5IG91dHN0YW5kaW5nIG9wZXJhdGlvbiAqL1xuXHRcdFx0XHRjb21wbGV0ZWQgPSB0cnVlO1xuXHRcdFx0XHQvKiByZXBlYXQgYnV0IHBpY2tpbmcgdXAgdGhlIG5ldyB0cmFuc3BvcnQgKi9cblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRzZWxmLnBpbmcobnVsbCwgY2FsbGJhY2spO1xuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9O1xuXG5cdFx0dGhpcy5vbigndHJhbnNwb3J0LmFjdGl2ZScsIG9uVHJhbnNwb3J0QWN0aXZlKTtcblx0XHR0aGlzLnBpbmcodGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSwgb25QaW5nQ29tcGxldGUpO1xuXHR9O1xuXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKGVycm9yKSB7XG5cdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5mYWlsKGVycm9yKTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVnaXN0ZXJQcm9wb3NlZFRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xuXHRcdHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgfHwgKGhhdmVXZWJTdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0KHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKSk7XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlID0gZnVuY3Rpb24odHJhbnNwb3J0KSB7XG5cdFx0aWYoX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbihfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnVwZ3JhZGVUcmFuc3BvcnRzLCB0cmFuc3BvcnQuc2hvcnROYW1lKSkge1xuXHRcdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gdHJhbnNwb3J0LnNob3J0TmFtZTtcblx0XHRcdGlmKGhhdmVXZWJTdG9yYWdlKSB7XG5cdFx0XHRcdHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2V0KHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lLCB0cmFuc3BvcnQuc2hvcnROYW1lKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnRyYW5zcG9ydFByZWZlcmVuY2UgPSBudWxsO1xuXHRcdGlmKGhhdmVXZWJTdG9yYWdlKSB7XG5cdFx0XHRwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlbW92ZSh0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFRoaXMgbWV0aG9kIGlzIG9ubHkgdXNlZCBkdXJpbmcgY29ubmVjdGlvbiBhdHRlbXB0cywgc28gaW1wbGVtZW50cyBSU0E0YzEsXG5cdCAqIFJTQTRjMiwgYW5kIFJTQTRkLiBJbiBwYXJ0aWN1bGFyIGl0IGlzIG5vdCBpbnZva2VkIGZvclxuXHQgKiBzZXJ2ZXJzaWRlLXRyaWdnZXJlZCByZWF1dGhzIG9yIG1hbnVhbCByZWF1dGhzLCBzbyBSU0E0YzMgZG9lcyBub3QgYXBwbHkgKi9cblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplID0gZnVuY3Rpb24oZXJyKSB7XG5cdFx0aWYoZXJyLmNvZGUgPT09IDQwMTcxKSB7XG5cdFx0XHQvKiBObyB3YXkgdG8gcmVhdXRoICovXG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiBlcnJ9KTtcblx0XHR9IGVsc2UgaWYoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuXHRcdFx0dmFyIG1zZyA9ICdDbGllbnQgY29uZmlndXJlZCBhdXRoZW50aWNhdGlvbiBwcm92aWRlciByZXR1cm5lZCA0MDM7IGZhaWxpbmcgdGhlIGNvbm5lY3Rpb24nO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKCknLCBtc2cpO1xuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAxOSwgNDAzLCBlcnIpfSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBtc2cgPSAnQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmVxdWVzdCBmYWlsZWQnO1xuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplJywgbXNnKTtcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiB0aGlzLnN0YXRlLmZhaWxTdGF0ZSwgZXJyb3I6IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKG1zZywgODAwMTksIDQwMSwgZXJyKX0pO1xuXHRcdH1cblx0fTtcblxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpIHtcblx0XHRpZighY29ubmVjdGlvbkRldGFpbHMpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IGNvbm5lY3Rpb25EZXRhaWxzO1xuXHRcdGlmKGNvbm5lY3Rpb25EZXRhaWxzLm1heE1lc3NhZ2VTaXplKSB7XG5cdFx0XHR0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZTtcblx0XHR9XG5cdFx0dmFyIGNsaWVudElkID0gY29ubmVjdGlvbkRldGFpbHMuY2xpZW50SWQ7XG5cdFx0aWYoY2xpZW50SWQpIHtcblx0XHRcdHZhciBlcnIgPSB0aGlzLnJlYWx0aW1lLmF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcblx0XHRcdGlmKGVycikge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSgpJywgZXJyLm1lc3NhZ2UpO1xuXHRcdFx0XHQvKiBFcnJvcnMgc2V0dGluZyB0aGUgY2xpZW50SWQgYXJlIGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG5cdFx0XHRcdHRyYW5zcG9ydC5mYWlsKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIGNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcblx0XHRpZihjb25uZWN0aW9uU3RhdGVUdGwpIHtcblx0XHRcdHRoaXMuY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvblN0YXRlVHRsO1xuXHRcdH1cblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcblx0XHR0aGlzLmVtaXQoJ2Nvbm5lY3Rpb25kZXRhaWxzJywgY29ubmVjdGlvbkRldGFpbHMpO1xuXHR9O1xuXG5cdHJldHVybiBDb25uZWN0aW9uTWFuYWdlcjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29ubmVjdGlvbk1hbmFnZXIpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDI2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG5cbnZhciBNZXNzYWdlUXVldWUgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIE1lc3NhZ2VRdWV1ZSgpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMubWVzc2FnZXMgPSBbXTtcblx0fVxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKE1lc3NhZ2VRdWV1ZSwgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlcy5sZW5ndGg7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdHRoaXMubWVzc2FnZXMucHVzaChtZXNzYWdlKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZXMuc2hpZnQoKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlc1t0aGlzLm1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29weUFsbCA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzLnNsaWNlKCk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbihtZXNzYWdlcykge1xuXHRcdHRoaXMubWVzc2FnZXMucHVzaC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG5cdH07XG5cblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcblx0XHR0aGlzLm1lc3NhZ2VzLnVuc2hpZnQuYXBwbHkodGhpcy5tZXNzYWdlcywgbWVzc2FnZXMpO1xuXHR9O1xuXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29tcGxldGVNZXNzYWdlcyA9IGZ1bmN0aW9uKHNlcmlhbCwgY291bnQsIGVycikge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCk7XG5cdFx0ZXJyID0gZXJyIHx8IG51bGw7XG5cdFx0dmFyIG1lc3NhZ2VzID0gdGhpcy5tZXNzYWdlcztcblx0XHR2YXIgZmlyc3QgPSBtZXNzYWdlc1swXTtcblx0XHRpZihmaXJzdCkge1xuXHRcdFx0dmFyIHN0YXJ0U2VyaWFsID0gZmlyc3QubWVzc2FnZS5tc2dTZXJpYWw7XG5cdFx0XHR2YXIgZW5kU2VyaWFsID0gc2VyaWFsICsgY291bnQ7IC8qIHRoZSBzZXJpYWwgb2YgdGhlIGZpcnN0IG1lc3NhZ2UgdGhhdCBpcyAqbm90KiB0aGUgc3ViamVjdCBvZiB0aGlzIGNhbGwgKi9cblx0XHRcdGlmKGVuZFNlcmlhbCA+IHN0YXJ0U2VyaWFsKSB7XG5cdFx0XHRcdHZhciBjb21wbGV0ZU1lc3NhZ2VzID0gbWVzc2FnZXMuc3BsaWNlKDAsIChlbmRTZXJpYWwgLSBzdGFydFNlcmlhbCkpO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY29tcGxldGVNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGNvbXBsZXRlTWVzc2FnZXNbaV0uY2FsbGJhY2soZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYobWVzc2FnZXMubGVuZ3RoID09IDApXG5cdFx0XHRcdHRoaXMuZW1pdCgnaWRsZScpO1xuXHRcdH1cblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNvbXBsZXRlQWxsTWVzc2FnZXMgPSBmdW5jdGlvbihlcnIpIHtcblx0XHR0aGlzLmNvbXBsZXRlTWVzc2FnZXMoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTnVtYmVyLk1BWF9WQUxVRSwgZXJyKTtcblx0fTtcblxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ01lc3NhZ2VRdWV1ZS5jbGVhcigpJywgJ2NsZWFyaW5nICcgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArICcgbWVzc2FnZXMnKTtcblx0XHR0aGlzLm1lc3NhZ2VzID0gW107XG5cdFx0dGhpcy5lbWl0KCdpZGxlJyk7XG5cdH07XG5cblx0cmV0dXJuIE1lc3NhZ2VRdWV1ZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTWVzc2FnZVF1ZXVlKTtcblxuXG4vKioqLyB9KSxcbi8qIDI3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZG9tZXZlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzUpO1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgWEhSUmVxdWVzdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xuXHR2YXIgaWRDb3VudGVyID0gMDtcblx0dmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xuXG5cdHZhciBSRVFfU0VORCA9IDAsXG5cdFx0UkVRX1JFQ1YgPSAxLFxuXHRcdFJFUV9SRUNWX1BPTEwgPSAyLFxuXHRcdFJFUV9SRUNWX1NUUkVBTSA9IDM7XG5cblx0ZnVuY3Rpb24gY2xlYXJQZW5kaW5nUmVxdWVzdHMoKSB7XG5cdFx0Zm9yKHZhciBpZCBpbiBwZW5kaW5nUmVxdWVzdHMpXG5cdFx0XHRwZW5kaW5nUmVxdWVzdHNbaWRdLmRpc3Bvc2UoKTtcblx0fVxuXG5cdHZhciBpc0lFID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLlhEb21haW5SZXF1ZXN0O1xuXG5cdGZ1bmN0aW9uIGllVmVyc2lvbigpIHtcblx0XHR2YXIgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCkubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKTtcblx0XHRyZXR1cm4gbWF0Y2ggJiYgTnVtYmVyKG1hdGNoWzFdKTtcblx0fVxuXG5cdGZ1bmN0aW9uIG5lZWRKc29uRW52ZWxvcGUoKSB7XG5cdFx0LyogSUUgMTAgeGhyIGJ1ZzogaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTYzMjAzMzkgKi9cblx0XHR2YXIgdmVyc2lvbjtcblx0XHRyZXR1cm4gaXNJRSAmJiAodmVyc2lvbiA9IGllVmVyc2lvbigpKSAmJiB2ZXJzaW9uID09PSAxMDtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEhlYWRlcih4aHIsIGhlYWRlcikge1xuXHRcdHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIgJiYgeGhyLmdldFJlc3BvbnNlSGVhZGVyKGhlYWRlcik7XG5cdH1cblxuXHQvKiBTYWZhcmkgbXlzdGVyaW91c2x5IHJldHVybnMgJ0lkZW50aXR5JyBmb3IgdHJhbnNmZXItZW5jb2Rpbmcgd2hlbiBpbiBmYWN0XG5cdCAqIGl0IGlzICdjaHVua2VkJy4gU28gaW5zdGVhZCwgZGVjaWRlIHRoYXQgaXQgaXMgY2h1bmtlZCB3aGVuXG5cdCAqIHRyYW5zZmVyLWVuY29kaW5nIGlzIHByZXNlbnQgb3IgY29udGVudC1sZW5ndGggaXMgYWJzZW50LiAgKCdvcicgYmVjYXVzZVxuXHQgKiB3aGVuIHVzaW5nIGh0dHAyIHN0cmVhbWluZywgdGhlcmUncyBubyB0cmFuc2Zlci1lbmNvZGluZyBoZWFkZXIsIGJ1dCBjYW5cblx0ICogc3RpbGwgZGVkdWNlIHN0cmVhbWluZyBmcm9tIGxhY2sgb2YgY29udGVudC1sZW5ndGgpICovXG5cdGZ1bmN0aW9uIGlzRW5jb2RpbmdDaHVua2VkKHhocikge1xuXHRcdHJldHVybiB4aHIuZ2V0UmVzcG9uc2VIZWFkZXJcblx0XHRcdCYmICh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJylcblx0XHRcdHx8ICF4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ2NvbnRlbnQtbGVuZ3RoJykpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0SGVhZGVyc0FzT2JqZWN0KHhocikge1xuXHRcdHZhciBoZWFkZXJQYWlycyA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50cmltKHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKSkuc3BsaXQoJ1xcclxcbicpLFxuXHRcdFx0aGVhZGVycyA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaGVhZGVyUGFpcnMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0cyA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJNYXAoaGVhZGVyUGFpcnNbaV0uc3BsaXQoJzonKSwgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRyaW0pO1xuXHRcdFx0aGVhZGVyc1twYXJ0c1swXS50b0xvd2VyQ2FzZSgpXSA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHRyZXR1cm4gaGVhZGVycztcblx0fVxuXG5cdGZ1bmN0aW9uIFhIUlJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG5cdFx0X2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0XHRwYXJhbXMucm5kID0gX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWFwUmFuZFN0cigpO1xuXHRcdGlmKG5lZWRKc29uRW52ZWxvcGUoKSAmJiAhcGFyYW1zLmVudmVsb3BlKVxuXHRcdFx0cGFyYW1zLmVudmVsb3BlID0gJ2pzb24nO1xuXHRcdHRoaXMudXJpID0gdXJpICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvUXVlcnlTdHJpbmcocGFyYW1zKTtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuXHRcdHRoaXMuYm9keSA9IGJvZHk7XG5cdFx0dGhpcy5tZXRob2QgPSBtZXRob2QgPyBtZXRob2QudG9VcHBlckNhc2UoKSA6IChfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhib2R5KSA/ICdHRVQnIDogJ1BPU1QnKTtcblx0XHR0aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG5cdFx0dGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xuXHRcdHRoaXMudGltZWRPdXQgPSBmYWxzZTtcblx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkID0gU3RyaW5nKCsraWRDb3VudGVyKV0gPSB0aGlzO1xuXHR9XG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhYSFJSZXF1ZXN0LCBfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHR2YXIgY3JlYXRlUmVxdWVzdCA9IFhIUlJlcXVlc3QuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuXHRcdC8qIFhIUiByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG5cdFx0ICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcblx0XHQgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuXHRcdHRpbWVvdXRzID0gdGltZW91dHMgfHwgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRJTUVPVVRTO1xuXHRcdHJldHVybiBuZXcgWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jb3B5KHBhcmFtcyksIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKTtcblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRpZighdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcblx0XHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdGlmKCFlcnIgJiYgYm9keSkge1xuXHRcdFx0XHR0aGlzLmVtaXQoJ2RhdGEnLCBib2R5KTtcblx0XHRcdH1cblx0XHRcdHRoaXMuZW1pdCgnY29tcGxldGUnLCBlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXHRcdH1cblx0fTtcblxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGlzcG9zZSgpO1xuXHR9O1xuXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGltZW91dCA9ICh0aGlzLnJlcXVlc3RNb2RlID09IFJFUV9TRU5EKSA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dCxcblx0XHRcdHNlbGYgPSB0aGlzLFxuXHRcdFx0dGltZXIgPSB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0c2VsZi50aW1lZE91dCA9IHRydWU7XG5cdFx0XHRcdHhoci5hYm9ydCgpO1xuXHRcdFx0fSwgdGltZW91dCksXG5cdFx0XHRib2R5ID0gdGhpcy5ib2R5LFxuXHRcdFx0bWV0aG9kID0gdGhpcy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzID0gdGhpcy5oZWFkZXJzLFxuXHRcdFx0eGhyID0gdGhpcy54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcblx0XHRcdGFjY2VwdCA9IGhlYWRlcnNbJ2FjY2VwdCddLFxuXHRcdFx0cmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuXG5cdFx0aWYoIWFjY2VwdCkge1xuXHRcdFx0aGVhZGVyc1snYWNjZXB0J10gPSAnYXBwbGljYXRpb24vanNvbic7XG5cdFx0fSBlbHNlIGlmKGFjY2VwdC5pbmRleE9mKCdhcHBsaWNhdGlvbi94LW1zZ3BhY2snKSA9PT0gMCkge1xuXHRcdFx0cmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcblx0XHR9XG5cblx0XHRpZihib2R5KSB7XG5cdFx0XHR2YXIgY29udGVudFR5cGUgPSBoZWFkZXJzWydjb250ZW50LXR5cGUnXSB8fCAoaGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24vanNvbicpO1xuXHRcdFx0aWYoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgJiYgdHlwZW9mKGJvZHkpICE9ICdzdHJpbmcnKVxuXHRcdFx0XHRib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XG5cdFx0fVxuXG5cdFx0eGhyLm9wZW4obWV0aG9kLCB0aGlzLnVyaSwgdHJ1ZSk7XG5cdFx0eGhyLnJlc3BvbnNlVHlwZSA9IHJlc3BvbnNlVHlwZTtcblxuXHRcdGlmICgnYXV0aG9yaXphdGlvbicgaW4gaGVhZGVycykge1xuXHRcdFx0eGhyLndpdGhDcmVkZW50aWFscyA9IHRydWU7XG5cdFx0fVxuXG5cdFx0Zm9yKHZhciBoIGluIGhlYWRlcnMpXG5cdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlcihoLCBoZWFkZXJzW2hdKTtcblxuXHRcdHZhciBlcnJvckhhbmRsZXIgPSBmdW5jdGlvbihlcnJvckV2ZW50LCBtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHR2YXIgZXJyb3JNZXNzYWdlID0gbWVzc2FnZSArICcgKGV2ZW50IHR5cGU6ICcgKyBlcnJvckV2ZW50LnR5cGUgKyAnKScgKyAoc2VsZi54aHIuc3RhdHVzVGV4dCA/ICcsIGN1cnJlbnQgc3RhdHVzVGV4dCBpcyAnICsgc2VsZi54aHIuc3RhdHVzVGV4dCA6ICcnKTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnUmVxdWVzdC5vbicgKyBlcnJvckV2ZW50LnR5cGUgKyAnKCknLCBlcnJvck1lc3NhZ2UpO1xuXHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0oZXJyb3JNZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSk7XG5cdFx0fTtcblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcblx0XHRcdGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnWEhSIGVycm9yIG9jY3VycmVkJywgbnVsbCwgNDAwKTtcblx0XHR9XG5cdFx0eGhyLm9uYWJvcnQgPSBmdW5jdGlvbihlcnJvckV2ZW50KSB7XG5cdFx0XHRpZihzZWxmLnRpbWVkT3V0KSB7XG5cdFx0XHRcdGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCBhYm9ydGVkIGR1ZSB0byByZXF1ZXN0IHRpbWVvdXQgZXhwaXJpbmcnLCBudWxsLCA0MDgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IGNhbmNlbGxlZCcsIG51bGwsIDQwMCk7XG5cdFx0XHR9XG5cdFx0fTtcblx0XHR4aHIub250aW1lb3V0ID0gZnVuY3Rpb24oZXJyb3JFdmVudCkge1xuXHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IHRpbWVkIG91dCcsIG51bGwsIDQwOCk7XG5cdFx0fTtcblxuXHRcdHZhciBzdHJlYW1pbmcsXG5cdFx0XHRzdGF0dXNDb2RlLFxuXHRcdFx0cmVzcG9uc2VCb2R5LFxuXHRcdFx0Y29udGVudFR5cGUsXG5cdFx0XHRzdWNjZXNzUmVzcG9uc2UsXG5cdFx0XHRzdHJlYW1Qb3MgPSAwLFxuXHRcdFx0dW5wYWNrZWQgPSBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIG9uUmVzcG9uc2UoKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0c3VjY2Vzc1Jlc3BvbnNlID0gKHN0YXR1c0NvZGUgPCA0MDApO1xuXHRcdFx0aWYoc3RhdHVzQ29kZSA9PSAyMDQpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBudWxsLCBzdGF0dXNDb2RlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c3RyZWFtaW5nID0gKHNlbGYucmVxdWVzdE1vZGUgPT0gUkVRX1JFQ1ZfU1RSRUFNICYmIHN1Y2Nlc3NSZXNwb25zZSAmJiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBvbkVuZCgpIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHZhciBjb250ZW50VHlwZSA9IGdldEhlYWRlcih4aHIsICdjb250ZW50LXR5cGUnKSxcblx0XHRcdFx0XHRoZWFkZXJzLFxuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSxcblx0XHRcdFx0XHQvKiBCZSBsaWJlcmFsIGluIHdoYXQgd2UgYWNjZXB0OyBidWdneSBhdXRoIHNlcnZlcnMgbWF5IHJlc3BvbmRcblx0XHRcdFx0XHQgKiB3aXRob3V0IHRoZSBjb3JyZWN0IGNvbnRlbnR0eXBlLCBidXQgYXNzdW1lIHRoZXkncmUgc3RpbGxcblx0XHRcdFx0XHQgKiByZXNwb25kaW5nIHdpdGgganNvbiAqL1xuXHRcdFx0XHRcdGpzb24gPSBjb250ZW50VHlwZSA/IChjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPj0gMCkgOiAoeGhyLnJlc3BvbnNlVHlwZSA9PSAndGV4dCcpO1xuXG5cdFx0XHRcdGlmKGpzb24pIHtcblx0XHRcdFx0XHQvKiBJZiB3ZSByZXF1ZXN0ZWQgbXNncGFjayBidXQgc2VydmVyIHJlc3BvbmRlZCB3aXRoIGpzb24sIHRoZW4gc2luY2Vcblx0XHRcdFx0XHQgKiB3ZSBzZXQgdGhlIHJlc3BvbnNlVHlwZSBleHBlY3RpbmcgbXNncGFjaywgdGhlIHJlc3BvbnNlIHdpbGwgYmVcblx0XHRcdFx0XHQgKiBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGpzb24gKi9cblx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSAoeGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJykgPyBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhEZWNvZGUoeGhyLnJlc3BvbnNlKSA6IFN0cmluZyh4aHIucmVzcG9uc2VUZXh0KTtcblx0XHRcdFx0XHRpZihyZXNwb25zZUJvZHkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlQm9keSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHVucGFja2VkID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2U7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZihyZXNwb25zZUJvZHkucmVzcG9uc2UgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdC8qIHVud3JhcCBKU09OIGVudmVsb3BlICovXG5cdFx0XHRcdFx0c3RhdHVzQ29kZSA9IHJlc3BvbnNlQm9keS5zdGF0dXNDb2RlO1xuXHRcdFx0XHRcdHN1Y2Nlc3NSZXNwb25zZSA9IChzdGF0dXNDb2RlIDwgNDAwKTtcblx0XHRcdFx0XHRoZWFkZXJzID0gcmVzcG9uc2VCb2R5LmhlYWRlcnM7XG5cdFx0XHRcdFx0cmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5LnJlc3BvbnNlO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGhlYWRlcnMgPSBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuXHRcdFx0ICogaXMgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG5cdFx0XHQgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG5cdFx0XHQgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuXHRcdFx0aWYoc3VjY2Vzc1Jlc3BvbnNlIHx8IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KHJlc3BvbnNlQm9keSkpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgZXJyID0gcmVzcG9uc2VCb2R5LmVycm9yICYmIF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcblx0XHRcdGlmKCFlcnIpIHtcblx0XHRcdFx0ZXJyID0gbmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogJyArIHN0YXR1c0NvZGUgKyAnIGJvZHkgd2FzOiAnICsgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3QocmVzcG9uc2VCb2R5KSwgbnVsbCwgc3RhdHVzQ29kZSk7XG5cdFx0XHR9XG5cdFx0XHRzZWxmLmNvbXBsZXRlKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gb25Qcm9ncmVzcygpIHtcblx0XHRcdHJlc3BvbnNlQm9keSA9IHhoci5yZXNwb25zZVRleHQ7XG5cdFx0XHR2YXIgYm9keUVuZCA9IHJlc3BvbnNlQm9keS5sZW5ndGggLSAxLCBpZHgsIGNodW5rO1xuXHRcdFx0d2hpbGUoKHN0cmVhbVBvcyA8IGJvZHlFbmQpICYmIChpZHggPSByZXNwb25zZUJvZHkuaW5kZXhPZignXFxuJywgc3RyZWFtUG9zKSkgPiAtMSkge1xuXHRcdFx0XHRjaHVuayA9IHJlc3BvbnNlQm9keS5zbGljZShzdHJlYW1Qb3MsIGlkeCk7XG5cdFx0XHRcdHN0cmVhbVBvcyA9IGlkeCArIDE7XG5cdFx0XHRcdG9uQ2h1bmsoY2h1bmspO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uQ2h1bmsoY2h1bmspIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNodW5rID0gSlNPTi5wYXJzZShjaHVuayk7XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ01hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiAnICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0c2VsZi5lbWl0KCdkYXRhJywgY2h1bmspO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIG9uU3RyZWFtRW5kKCkge1xuXHRcdFx0b25Qcm9ncmVzcygpO1xuXHRcdFx0c2VsZi5zdHJlYW1Db21wbGV0ZSA9IHRydWU7XG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuY29tcGxldGUoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XG5cdFx0XHRpZihyZWFkeVN0YXRlIDwgMykgcmV0dXJuO1xuXHRcdFx0aWYoeGhyLnN0YXR1cyAhPT0gMCkge1xuXHRcdFx0XHRpZihzdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzdGF0dXNDb2RlID0geGhyLnN0YXR1cztcblx0XHRcdFx0XHQvKiBJRSByZXR1cm5zIDEyMjMgZm9yIDIwNDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTQ1MCAqL1xuXHRcdFx0XHRcdGlmKHN0YXR1c0NvZGUgPT09IDEyMjMpIHN0YXR1c0NvZGUgPSAyMDQ7XG5cdFx0XHRcdFx0b25SZXNwb25zZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKHJlYWR5U3RhdGUgPT0gMyAmJiBzdHJlYW1pbmcpIHtcblx0XHRcdFx0XHRvblByb2dyZXNzKCk7XG5cdFx0XHRcdH0gZWxzZSBpZihyZWFkeVN0YXRlID09IDQpIHtcblx0XHRcdFx0XHRpZihzdHJlYW1pbmcpXG5cdFx0XHRcdFx0XHRvblN0cmVhbUVuZCgpO1xuXHRcdFx0XHRcdGVsc2Vcblx0XHRcdFx0XHRcdG9uRW5kKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHhoci5zZW5kKGJvZHkpO1xuXHR9O1xuXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeGhyID0gdGhpcy54aHI7XG5cdFx0aWYoeGhyKSB7XG5cdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0geGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPSBub29wO1xuXHRcdFx0dGhpcy54aHIgPSBudWxsO1xuXHRcdFx0dmFyIHRpbWVyID0gdGhpcy50aW1lcjtcblx0XHRcdGlmKHRpbWVyKSB7XG5cdFx0XHRcdGNsZWFyVGltZW91dCh0aW1lcik7XG5cdFx0XHRcdHRoaXMudGltZXIgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKVxuXHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHBlbmRpbmdSZXF1ZXN0c1t0aGlzLmlkXTtcblx0fTtcblxuXHRpZihwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnhoclN1cHBvcnRlZCkge1xuXHRcdGlmKHR5cGVvZiBfdXRpbF9kb21ldmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdID09PSAnb2JqZWN0Jykge1xuXHRcdFx0X3V0aWxfZG9tZXZlbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZGRVbmxvYWRMaXN0ZW5lcihjbGVhclBlbmRpbmdSZXF1ZXN0cyk7XG5cdFx0fVxuXHRcdGlmKHR5cGVvZihwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0pICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuXHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJlcXVlc3QgPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgcmVxID0gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgUkVRX1NFTkQsIHJlc3QgJiYgcmVzdC5vcHRpb25zLnRpbWVvdXRzLCBtZXRob2QpO1xuXHRcdFx0XHRyZXEub25jZSgnY29tcGxldGUnLCBjYWxsYmFjayk7XG5cdFx0XHRcdHJlcS5leGVjKCk7XG5cdFx0XHRcdHJldHVybiByZXE7XG5cdFx0XHR9O1xuXG5cdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0XHR2YXIgdXBVcmwgPSBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW50ZXJuZXRVcFVybDtcblx0XHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICcoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIHVwVXJsKTtcblx0XHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFVyaShudWxsLCB1cFVybCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZVRleHQpIHtcblx0XHRcdFx0XHR2YXIgcmVzdWx0ID0gKCFlcnIgJiYgcmVzcG9uc2VUZXh0LnJlcGxhY2UoL1xcbi8sICcnKSA9PSAneWVzJyk7XG5cdFx0XHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICcoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXN1bHQpO1xuXHRcdFx0XHR9KTtcblx0XHRcdH07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFhIUlJlcXVlc3Q7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFhIUlJlcXVlc3QpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDI4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMTApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygxOCksIF9fd2VicGFja19yZXF1aXJlX18oMzcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSksIF9fd2VicGFja19yZXF1aXJlX18oMzApLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NyksIF9fd2VicGFja19yZXF1aXJlX18oNDgpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDI5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cblx0ICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG5cdCAgICAgKi9cblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG5cdCAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0LyoqXG5cdCAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXG5cdCAqL1xuXHRDcnlwdG9KUy5saWIuQ2lwaGVyIHx8IChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG07XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmODtcblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQ7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXHQgICAgdmFyIEV2cEtERiA9IENfYWxnby5FdnBLREY7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXZTaXplIFRoaXMgY2lwaGVyJ3MgSVYgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gX0VOQ19YRk9STV9NT0RFIEEgY29uc3RhbnQgcmVwcmVzZW50aW5nIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ2lwaGVyID0gQ19saWIuQ2lwaGVyID0gQnVmZmVyZWRCbG9ja0FsZ29yaXRobS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGVuY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZUVuY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9FTkNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgY2lwaGVyIGluIGRlY3J5cHRpb24gbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyfSBBIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZURlY3J5cHRvcihrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZSh0aGlzLl9ERUNfWEZPUk1fTU9ERSwga2V5LCBjZmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IHhmb3JtTW9kZSBFaXRoZXIgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiB0cmFuc29ybWF0aW9uIG1vZGUgY29uc3RhbnQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXIgPSBDcnlwdG9KUy5hbGdvLkFFUy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5BRVMuX0VOQ19YRk9STV9NT0RFLCBrZXlXb3JkQXJyYXksIHsgaXY6IGl2V29yZEFycmF5IH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIFN0b3JlIHRyYW5zZm9ybSBtb2RlIGFuZCBrZXlcblx0ICAgICAgICAgICAgdGhpcy5feGZvcm1Nb2RlID0geGZvcm1Nb2RlO1xuXHQgICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XG5cblx0ICAgICAgICAgICAgLy8gU2V0IGluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgY2lwaGVyIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBjaXBoZXIucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBSZXNldCBkYXRhIGJ1ZmZlclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIGRhdGEgdG8gYmUgZW5jcnlwdGVkIG9yIGRlY3J5cHRlZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLnByb2Nlc3Mod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYXZhaWxhYmxlIGJsb2Nrc1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5fcHJvY2VzcygpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxuXHQgICAgICAgICAqIE5vdGUgdGhhdCB0aGUgZmluYWxpemUgb3BlcmF0aW9uIGlzIGVmZmVjdGl2ZWx5IGEgZGVzdHJ1Y3RpdmUsIHJlYWQtb25jZSBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBmaW5hbCBwcm9jZXNzaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBkYXRhIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKGRhdGFVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1jaXBoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkRGF0YSA9IHRoaXMuX2RvRmluYWxpemUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWREYXRhO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cblx0ICAgICAgICBpdlNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIF9FTkNfWEZPUk1fTU9ERTogMSxcblxuXHQgICAgICAgIF9ERUNfWEZPUk1fTU9ERTogMixcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgc2hvcnRjdXQgZnVuY3Rpb25zIHRvIGEgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBlbmNyeXB0IGFuZCBkZWNyeXB0IHNob3J0Y3V0IGZ1bmN0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEFFUyA9IENyeXB0b0pTLmxpYi5DaXBoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLkFFUyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgZnVuY3Rpb24gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KSB7XG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBQYXNzd29yZEJhc2VkQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjaXBoZXIpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiB7XG5cdCAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmVuY3J5cHQoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VsZWN0Q2lwaGVyU3RyYXRlZ3koa2V5KS5kZWNyeXB0KGNpcGhlciwgY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIH07XG5cdCAgICAgICAgICAgIH07XG5cdCAgICAgICAgfSgpKVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBzdHJlYW0gY2lwaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBTdHJlYW1DaXBoZXIgPSBDX2xpYi5TdHJlYW1DaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIHBhcnRpYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogTW9kZSBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX21vZGUgPSBDLm1vZGUgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciBtb2RlIHRlbXBsYXRlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBtb2RlIGZvciBlbmNyeXB0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuY3JlYXRlRW5jcnlwdG9yKGNpcGhlciwgaXYud29yZHMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgbW9kZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcblx0ICAgICAgICAgICAgdGhpcy5fY2lwaGVyID0gY2lwaGVyO1xuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIENpcGhlciBCbG9jayBDaGFpbmluZyBtb2RlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ0JDID0gQ19tb2RlLkNCQyA9IChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICB2YXIgQ0JDID0gQmxvY2tDaXBoZXJNb2RlLmV4dGVuZCgpO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGVuY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRW5jcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gWE9SIGFuZCBlbmNyeXB0XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXIuZW5jcnlwdEJsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHdvcmRzLnNsaWNlKG9mZnNldCwgb2Zmc2V0ICsgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cblx0ICAgICAgICAgKi9cblx0ICAgICAgICBDQkMuRGVjcnlwdG9yID0gQ0JDLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIG1vZGUucHJvY2Vzc0Jsb2NrKGRhdGEud29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXG5cdCAgICAgICAgICAgICAgICB2YXIgdGhpc0Jsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1Jcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5kZWNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFRoaXMgYmxvY2sgYmVjb21lcyB0aGUgcHJldmlvdXMgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHRoaXMuX3ByZXZCbG9jayA9IHRoaXNCbG9jaztcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0pO1xuXG5cdCAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIHZhciBibG9jaztcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgaXYgPSB0aGlzLl9pdjtcblxuXHQgICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXG5cdCAgICAgICAgICAgIGlmIChpdikge1xuXHQgICAgICAgICAgICAgICAgYmxvY2sgPSBpdjtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIElWIGZvciBzdWJzZXF1ZW50IGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgdGhpcy5faXYgPSB1bmRlZmluZWQ7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IHRoaXMuX3ByZXZCbG9jaztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFhPUiBibG9ja3Ncblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBibG9ja1NpemU7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICByZXR1cm4gQ0JDO1xuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQYWRkaW5nIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfcGFkID0gQy5wYWQgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBQS0NTICM1LzcgcGFkZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUGFkcyBkYXRhIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gZGF0YSBUaGUgZGF0YSB0byBwYWQuXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbXVsdGlwbGUgdGhhdCB0aGUgZGF0YSBzaG91bGQgYmUgcGFkZGVkIHRvLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcucGFkKHdvcmRBcnJheSwgNCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFkOiBmdW5jdGlvbiAoZGF0YSwgYmxvY2tTaXplKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgcGFkZGluZyBieXRlc1xuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nIHdvcmRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBwYWRkaW5nXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuUGFkZGluZ0J5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmdXb3Jkcy5wdXNoKHBhZGRpbmdXb3JkKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IFdvcmRBcnJheS5jcmVhdGUocGFkZGluZ1dvcmRzLCBuUGFkZGluZ0J5dGVzKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLmNvbmNhdChwYWRkaW5nKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVW5wYWRzIGRhdGEgdGhhdCBoYWQgYmVlbiBwYWRkZWQgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHVucGFkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBDcnlwdG9KUy5wYWQuUGtjczcudW5wYWQod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gR2V0IG51bWJlciBvZiBwYWRkaW5nIGJ5dGVzIGZyb20gbGFzdCBieXRlXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gZGF0YS53b3Jkc1soZGF0YS5zaWdCeXRlcyAtIDEpID4+PiAyXSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgLy8gUmVtb3ZlIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyAtPSBuUGFkZGluZ0J5dGVzO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYmFzZSBibG9jayBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogUGtjczdcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgbW9kZTogQ0JDLFxuXHQgICAgICAgICAgICBwYWRkaW5nOiBQa2NzN1xuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yO1xuXG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGNpcGhlclxuXHQgICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXHQgICAgICAgICAgICB2YXIgaXYgPSBjZmcuaXY7XG5cdCAgICAgICAgICAgIHZhciBtb2RlID0gY2ZnLm1vZGU7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgYmxvY2sgbW9kZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xuXHQgICAgICAgICAgICAgICAgbW9kZUNyZWF0b3IgPSBtb2RlLmNyZWF0ZURlY3J5cHRvcjtcblx0ICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbWluQnVmZmVyU2l6ZSA9IDE7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBpZiAodGhpcy5fbW9kZSAmJiB0aGlzLl9tb2RlLl9fY3JlYXRvciA9PSBtb2RlQ3JlYXRvcikge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5pbml0KHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUgPSBtb2RlQ3JlYXRvci5jYWxsKG1vZGUsIHRoaXMsIGl2ICYmIGl2LndvcmRzKTtcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuX19jcmVhdG9yID0gbW9kZUNyZWF0b3I7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xuXHQgICAgICAgICAgICB0aGlzLl9tb2RlLnByb2Nlc3NCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gdGhpcy5jZmcucGFkZGluZztcblxuXHQgICAgICAgICAgICAvLyBGaW5hbGl6ZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0VOQ19YRk9STV9NT0RFKSB7XG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy5wYWQodGhpcy5fZGF0YSwgdGhpcy5ibG9ja1NpemUpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICAgICAgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmcudW5wYWQoZmluYWxQcm9jZXNzZWRCbG9ja3MpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGZpbmFsUHJvY2Vzc2VkQmxvY2tzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBibG9ja1NpemU6IDEyOC8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjb2xsZWN0aW9uIG9mIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBjaXBoZXJ0ZXh0IFRoZSByYXcgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBrZXkgVGhlIGtleSB0byB0aGlzIGNpcGhlcnRleHQuXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gc2FsdCBUaGUgc2FsdCB1c2VkIHdpdGggYSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Q2lwaGVyfSBhbGdvcml0aG0gVGhlIGNpcGhlciBhbGdvcml0aG0uXG5cdCAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7UGFkZGluZ30gcGFkZGluZyBUaGUgcGFkZGluZyBzY2hlbWUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIGJsb2NrIHNpemUgb2YgdGhlIGNpcGhlci5cblx0ICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXMgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMubGliLkNpcGhlclBhcmFtcy5jcmVhdGUoe1xuXHQgICAgICAgICAqICAgICAgICAgY2lwaGVydGV4dDogY2lwaGVydGV4dFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgaXY6IGl2V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgc2FsdDogc2FsdFdvcmRBcnJheSxcblx0ICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXG5cdCAgICAgICAgICogICAgICAgICBtb2RlOiBDcnlwdG9KUy5tb2RlLkNCQyxcblx0ICAgICAgICAgKiAgICAgICAgIHBhZGRpbmc6IENyeXB0b0pTLnBhZC5QS0NTNyxcblx0ICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcblx0ICAgICAgICAgKiAgICAgICAgIGZvcm1hdHRlcjogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0xcblx0ICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB0aGlzLm1peEluKGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0Zvcm1hdH0gZm9ybWF0dGVyIChPcHRpb25hbCkgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgc3RyaW5naWZpZWQgY2lwaGVyIHBhcmFtcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zICsgJyc7XG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMudG9TdHJpbmcoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChmb3JtYXR0ZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBGb3JtYXQgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIE9wZW5TU0wgZm9ybWF0dGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcblx0ICAgICAgICAgICAgdmFyIHdvcmRBcnJheTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgdmFyIHNhbHQgPSBjaXBoZXJQYXJhbXMuc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcblx0ICAgICAgICAgICAgaWYgKHNhbHQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRBcnJheSA9IFdvcmRBcnJheS5jcmVhdGUoWzB4NTM2MTZjNzQsIDB4NjU2NDVmNWZdKS5jb25jYXQoc2FsdCkuY29uY2F0KGNpcGhlcnRleHQpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgd29yZEFycmF5ID0gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB3b3JkQXJyYXkudG9TdHJpbmcoQmFzZTY0KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYW4gT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9wZW5TU0xTdHIgVGhlIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAob3BlblNTTFN0cikge1xuXHQgICAgICAgICAgICB2YXIgc2FsdDtcblxuXHQgICAgICAgICAgICAvLyBQYXJzZSBiYXNlNjRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gVGVzdCBmb3Igc2FsdFxuXHQgICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcblx0ICAgICAgICAgICAgICAgIC8vIEV4dHJhY3Qgc2FsdFxuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKDIsIDQpKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHNhbHQgZnJvbSBjaXBoZXJ0ZXh0XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0V29yZHMuc3BsaWNlKDAsIDQpO1xuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEEgY2lwaGVyIHdyYXBwZXIgdGhhdCByZXR1cm5zIGNpcGhlcnRleHQgYXMgYSBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgKi9cblx0ICAgIHZhciBTZXJpYWxpemFibGVDaXBoZXIgPSBDX2xpYi5TZXJpYWxpemFibGVDaXBoZXIgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IGNpcGhlciBwYXJhbSBvYmplY3RzIHRvIGFuZCBmcm9tIGEgc3RyaW5nLiBEZWZhdWx0OiBPcGVuU1NMXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgIGZvcm1hdDogT3BlblNTTEZvcm1hdHRlclxuXHQgICAgICAgIH0pLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXkpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGVuY3J5cHRvciA9IGNpcGhlci5jcmVhdGVFbmNyeXB0b3Ioa2V5LCBjZmcpO1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGVuY3J5cHRvci5maW5hbGl6ZShtZXNzYWdlKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVyQ2ZnID0gZW5jcnlwdG9yLmNmZztcblxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgYW5kIHJldHVybiBzZXJpYWxpemFibGUgY2lwaGVyIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxuXHQgICAgICAgICAgICAgICAga2V5OiBrZXksXG5cdCAgICAgICAgICAgICAgICBpdjogY2lwaGVyQ2ZnLml2LFxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXG5cdCAgICAgICAgICAgICAgICBtb2RlOiBjaXBoZXJDZmcubW9kZSxcblx0ICAgICAgICAgICAgICAgIHBhZGRpbmc6IGNpcGhlckNmZy5wYWRkaW5nLFxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxuXHQgICAgICAgICAgICAgICAgZm9ybWF0dGVyOiBjZmcuZm9ybWF0XG5cdCAgICAgICAgICAgIH0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXG5cdCAgICAgICAgICogZWxzZSBhc3N1bWVkIENpcGhlclBhcmFtcyBhbHJlYWR5IGFuZCByZXR1cm5zIGNpcGhlcnRleHQgdW5jaGFuZ2VkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gdXNlIHRvIHBhcnNlIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfcGFyc2U6IGZ1bmN0aW9uIChjaXBoZXJ0ZXh0LCBmb3JtYXQpIHtcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gZm9ybWF0LnBhcnNlKGNpcGhlcnRleHQsIHRoaXMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2tkZiA9IEMua2RmID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbi5cblx0ICAgICAqL1xuXHQgICAgdmFyIE9wZW5TU0xLZGYgPSBDX2tkZi5PcGVuU1NMID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQgdG8gZGVyaXZlIGZyb20uXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gaXZTaXplIFRoZSBzaXplIGluIHdvcmRzIG9mIHRoZSBJViB0byBnZW5lcmF0ZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgKE9wdGlvbmFsKSBBIDY0LWJpdCBzYWx0IHRvIHVzZS4gSWYgb21pdHRlZCwgYSBzYWx0IHdpbGwgYmUgZ2VuZXJhdGVkIHJhbmRvbWx5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0IHdpdGggdGhlIGtleSwgSVYsIGFuZCBzYWx0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIpO1xuXHQgICAgICAgICAqICAgICB2YXIgZGVyaXZlZFBhcmFtcyA9IENyeXB0b0pTLmtkZi5PcGVuU1NMLmV4ZWN1dGUoJ1Bhc3N3b3JkJywgMjU2LzMyLCAxMjgvMzIsICdzYWx0c2FsdCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGV4ZWN1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwga2V5U2l6ZSwgaXZTaXplLCBzYWx0KSB7XG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIHJhbmRvbSBzYWx0XG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgc2FsdCA9IFdvcmRBcnJheS5yYW5kb20oNjQvOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIga2V5ID0gRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IGtleVNpemUgKyBpdlNpemUgfSkuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XG5cblx0ICAgICAgICAgICAgLy8gU2VwYXJhdGUga2V5IGFuZCBJVlxuXHQgICAgICAgICAgICB2YXIgaXYgPSBXb3JkQXJyYXkuY3JlYXRlKGtleS53b3Jkcy5zbGljZShrZXlTaXplKSwgaXZTaXplICogNCk7XG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBwYXJhbXNcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBzZXJpYWxpemFibGUgY2lwaGVyIHdyYXBwZXIgdGhhdCBkZXJpdmVzIHRoZSBrZXkgZnJvbSBhIHBhc3N3b3JkLFxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFBhc3N3b3JkQmFzZWRDaXBoZXIgPSBDX2xpYi5QYXNzd29yZEJhc2VkQ2lwaGVyID0gU2VyaWFsaXphYmxlQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IFNlcmlhbGl6YWJsZUNpcGhlci5jZmcuZXh0ZW5kKHtcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UgdXNpbmcgYSBwYXNzd29yZC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBlbmNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgbWVzc2FnZSwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSk7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xuXHQgICAgICAgICAgICBjZmcuaXYgPSBkZXJpdmVkUGFyYW1zLml2O1xuXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgbWVzc2FnZSwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQubWl4SW4oZGVyaXZlZFBhcmFtcyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0IHRvIGRlY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgZm9ybWF0dGVkQ2lwaGVydGV4dCwgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIHBhc3N3b3JkLCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIGNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xuXHQgICAgICAgICAgICBjaXBoZXJ0ZXh0ID0gdGhpcy5fcGFyc2UoY2lwaGVydGV4dCwgY2ZnLmZvcm1hdCk7XG5cblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkUGFyYW1zID0gY2ZnLmtkZi5leGVjdXRlKHBhc3N3b3JkLCBjaXBoZXIua2V5U2l6ZSwgY2lwaGVyLml2U2l6ZSwgY2lwaGVydGV4dC5zYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxuXHQgICAgICAgICAgICB2YXIgcGxhaW50ZXh0ID0gU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQuY2FsbCh0aGlzLCBjaXBoZXIsIGNpcGhlcnRleHQsIGRlcml2ZWRQYXJhbXMua2V5LCBjZmcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cdH0oKSk7XG5cblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5IZXg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmODtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZXF1ZXVlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuXG5cblxuXG5cblxuXG52YXIgUHJvdG9jb2wgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBhY3Rpb25zID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbjtcblxuXHRmdW5jdGlvbiBQcm90b2NvbCh0cmFuc3BvcnQpIHtcblx0XHRfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuXHRcdHRoaXMubWVzc2FnZVF1ZXVlID0gbmV3IF9tZXNzYWdlcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgpO1xuXHRcdHZhciBzZWxmID0gdGhpcztcblx0XHR0cmFuc3BvcnQub24oJ2FjaycsIGZ1bmN0aW9uKHNlcmlhbCwgY291bnQpIHsgc2VsZi5vbkFjayhzZXJpYWwsIGNvdW50KTsgfSk7XG5cdFx0dHJhbnNwb3J0Lm9uKCduYWNrJywgZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7IHNlbGYub25OYWNrKHNlcmlhbCwgY291bnQsIGVycik7IH0pO1xuXHR9XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoUHJvdG9jb2wsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUub25BY2sgPSBmdW5jdGlvbihzZXJpYWwsIGNvdW50KSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1Byb3RvY29sLm9uQWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50KTtcblx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5vbk5hY2sgPSBmdW5jdGlvbihzZXJpYWwsIGNvdW50LCBlcnIpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnUHJvdG9jb2wub25OYWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50ICsgJzsgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdGlmKCFlcnIpIHtcblx0XHRcdGVyciA9IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBzZW5kIG1lc3NhZ2U7IGNoYW5uZWwgbm90IHJlc3BvbmRpbmcnLCA1MDAwMSwgNTAwKTtcblx0XHR9XG5cdFx0dGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50LCBlcnIpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5vbmNlSWRsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG5cdFx0dmFyIG1lc3NhZ2VRdWV1ZSA9IHRoaXMubWVzc2FnZVF1ZXVlO1xuXHRcdGlmKG1lc3NhZ2VRdWV1ZS5jb3VudCgpID09PSAwKSB7XG5cdFx0XHRsaXN0ZW5lcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRtZXNzYWdlUXVldWUub25jZSgnaWRsZScsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlKSB7XG5cdFx0aWYocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQpIHtcblx0XHRcdHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gocGVuZGluZ01lc3NhZ2UpO1xuXHRcdH1cblx0XHRpZiAoX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2hvdWxkTG9nKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTykpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdQcm90b2NvbC5zZW5kKCknLCAnc2VuZGluZyBtc2c7ICcgKyBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3RyaW5naWZ5KHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpKTtcblx0XHR9XG5cdFx0cGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCA9IHRydWU7XG5cdFx0dGhpcy50cmFuc3BvcnQuc2VuZChwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKTtcblx0fTtcblxuXHRQcm90b2NvbC5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNwb3J0O1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5nZXRQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY29weUFsbCgpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5jbGVhclBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jbGVhcigpO1xuXHR9O1xuXG5cdFByb3RvY29sLnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnQ7XG5cdFx0dGhpcy5vbmNlSWRsZShmdW5jdGlvbigpIHtcblx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG5cdFx0fSk7XG5cdH07XG5cblx0ZnVuY3Rpb24gUGVuZGluZ01lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2spIHtcblx0XHR0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuXHRcdHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcblx0XHR0aGlzLm1lcmdlZCA9IGZhbHNlO1xuXHRcdHZhciBhY3Rpb24gPSBtZXNzYWdlLmFjdGlvbjtcblx0XHR0aGlzLnNlbmRBdHRlbXB0ZWQgPSBmYWxzZTtcblx0XHR0aGlzLmFja1JlcXVpcmVkID0gKGFjdGlvbiA9PSBhY3Rpb25zLk1FU1NBR0UgfHwgYWN0aW9uID09IGFjdGlvbnMuUFJFU0VOQ0UpO1xuXHR9XG5cdFByb3RvY29sLlBlbmRpbmdNZXNzYWdlID0gUGVuZGluZ01lc3NhZ2U7XG5cblx0cmV0dXJuIFByb3RvY29sO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChQcm90b2NvbCk7XG5cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgRG9tRXZlbnQgPSAoZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIERvbUV2ZW50KCkge31cblxuXHREb21FdmVudC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyKSB7XG5cdFx0aWYodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcblx0XHRcdHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0YXJnZXQuYXR0YWNoRXZlbnQoJ29uJytldmVudCwgZnVuY3Rpb24oKSB7IGxpc3RlbmVyLmFwcGx5KHRhcmdldCwgYXJndW1lbnRzKTsgfSk7XG5cdFx0fVxuXHR9O1xuXG5cdERvbUV2ZW50LnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odGFyZ2V0LCBldmVudCwgbGlzdGVuZXIpIHtcblx0XHRpZih0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xuXHRcdFx0dGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5kZXRhY2hFdmVudCgnb24nK2V2ZW50LCBmdW5jdGlvbigpIHsgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpOyB9KTtcblx0XHR9XG5cdH07XG5cblx0RG9tRXZlbnQuYWRkTWVzc2FnZUxpc3RlbmVyID0gZnVuY3Rpb24odGFyZ2V0LCBsaXN0ZW5lcikge1xuXHRcdERvbUV2ZW50LmFkZExpc3RlbmVyKHRhcmdldCwgJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0RG9tRXZlbnQucmVtb3ZlTWVzc2FnZUxpc3RlbmVyID0gZnVuY3Rpb24odGFyZ2V0LCBsaXN0ZW5lcikge1xuXHRcdERvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRhcmdldCwgJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG5cdH07XG5cblx0RG9tRXZlbnQuYWRkVW5sb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuXHRcdERvbUV2ZW50LmFkZExpc3RlbmVyKGdsb2JhbCwgJ3VubG9hZCcsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRyZXR1cm4gRG9tRXZlbnQ7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKERvbUV2ZW50KTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcblxuLyoqKi8gfSksXG4vKiAzNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIEluaXRpYWxpemF0aW9uIGFuZCByb3VuZCBjb25zdGFudHMgdGFibGVzXG5cdCAgICB2YXIgSCA9IFtdO1xuXHQgICAgdmFyIEsgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZnVuY3Rpb24gaXNQcmltZShuKSB7XG5cdCAgICAgICAgICAgIHZhciBzcXJ0TiA9IE1hdGguc3FydChuKTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKCEobiAlIGZhY3RvcikpIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XG5cdCAgICAgICAgICAgIHJldHVybiAoKG4gLSAobiB8IDApKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXG5cdCAgICAgICAgdmFyIG4gPSAyO1xuXHQgICAgICAgIHZhciBuUHJpbWUgPSAwO1xuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xuXHQgICAgICAgICAgICBpZiAoaXNQcmltZShuKSkge1xuXHQgICAgICAgICAgICAgICAgaWYgKG5QcmltZSA8IDgpIHtcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgS1tuUHJpbWVdID0gZ2V0RnJhY3Rpb25hbEJpdHMoTWF0aC5wb3cobiwgMSAvIDMpKTtcblxuXHQgICAgICAgICAgICAgICAgblByaW1lKys7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICBuKys7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUmV1c2FibGUgb2JqZWN0XG5cdCAgICB2YXIgVyA9IFtdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBTSEEyNTYgPSBDX2FsZ28uU0hBMjU2ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChILnNsaWNlKDApKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhYmxlc1xuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XG5cdCAgICAgICAgICAgIHZhciBiID0gSFsxXTtcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XG5cdCAgICAgICAgICAgIHZhciBlID0gSFs0XTtcblx0ICAgICAgICAgICAgdmFyIGYgPSBIWzVdO1xuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XG5cdCAgICAgICAgICAgIHZhciBoID0gSFs3XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMTYpIHtcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTB4ID0gV1tpIC0gMTVdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWEweCA8PCAxNCkgfCAoZ2FtbWEweCA+Pj4gMTgpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMHggPj4+IDMpO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMXggPSBXW2kgLSAyXTtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExICA9ICgoZ2FtbWExeCA8PCAxNSkgfCAoZ2FtbWExeCA+Pj4gMTcpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTF4ID4+PiAxMCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XG5cdCAgICAgICAgICAgICAgICB2YXIgbWFqID0gKGEgJiBiKSBeIChhICYgYykgXiAoYiAmIGMpO1xuXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWExID0gKChlIDw8IDI2KSB8IChlID4+PiA2KSkgXiAoKGUgPDwgMjEpIHwgKGUgPj4+IDExKSkgXiAoKGUgPDwgNykgIHwgKGUgPj4+IDI1KSk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gc2lnbWEwICsgbWFqO1xuXG5cdCAgICAgICAgICAgICAgICBoID0gZztcblx0ICAgICAgICAgICAgICAgIGcgPSBmO1xuXHQgICAgICAgICAgICAgICAgZiA9IGU7XG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xuXHQgICAgICAgICAgICAgICAgZCA9IGM7XG5cdCAgICAgICAgICAgICAgICBjID0gYjtcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xuXHQgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJbnRlcm1lZGlhdGUgaGFzaCB2YWx1ZVxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcblx0ICAgICAgICAgICAgSFsyXSA9IChIWzJdICsgYykgfCAwO1xuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcblx0ICAgICAgICAgICAgSFs1XSA9IChIWzVdICsgZikgfCAwO1xuXHQgICAgICAgICAgICBIWzZdID0gKEhbNl0gKyBnKSB8IDA7XG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSBuQml0c1RvdGFsO1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gSGFzaCBmaW5hbCBibG9ja3Ncblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xuXG5cdCAgICAgICAgICAgIC8vIFJldHVybiBmaW5hbCBjb21wdXRlZCBoYXNoXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBIYXNoZXIuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2hhc2ggPSB0aGlzLl9oYXNoLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KCdtZXNzYWdlJyk7XG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihTSEEyNTYpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgKlxuXHQgICAgICogQHN0YXRpY1xuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEEyNTYgPSBIYXNoZXIuX2NyZWF0ZUhtYWNIZWxwZXIoU0hBMjU2KTtcblx0fShNYXRoKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMzcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsXG5cdCAgICAgICAgICAgICAgICAweGMzZDJlMWYwXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZSA9IGQ7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTE7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzOCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTLkhtYWNTSEEyNTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cblxuXG5cblxuXG5cblxuXG52YXIgSlNPTlBUcmFuc3BvcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlcikge1xuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XG5cdC8qIENhbid0IGp1c3QgdXNlIHdpbmRvdy5BYmx5LCBhcyB0aGF0IHdvbid0IGV4aXN0IGlmIHVzaW5nIHRoZSBjb21tb25qcyB2ZXJzaW9uLiAqL1xuXHR2YXIgXyA9IGdsb2JhbC5fYWJseWpzX2pzb25wID0ge307XG5cblx0LyogZXhwcmVzcyBzdHJpcHMgb3V0IHBhcmFudGhlc2VzIGZyb20gdGhlIGNhbGxiYWNrIVxuXHQgKiBLbHVkZ2UgdG8gc3RpbGwgYWxvdyBpdHMgcmVzcG9uc2VzIHRvIHdvcmssIHdoaWxlIG5vdCBrZWVwaW5nIHRoZVxuXHQgKiBmdW5jdGlvbiBmb3JtIGZvciBub3JtYWwgdXNlIGFuZCBub3QgY2x1dHRlcmluZyB3aW5kb3cuQWJseVxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL2V4cHJlc3MvYmxvYi81YjRkNGI0YWIxMzI0NzQzNTM0ZmJjZDQ3MDlmNGU3NWJiNGI0ZTlkL2xpYi9yZXNwb25zZS5qcyNMMzA1XG5cdCAqL1xuXHRfLl8gPSBmdW5jdGlvbihpZCkgeyByZXR1cm4gX1snXycgKyBpZF0gfHwgbm9vcDsgfTtcblx0dmFyIGlkQ291bnRlciA9IDE7XG5cdHZhciBoZWFkID0gbnVsbDtcblx0dmFyIHNob3J0TmFtZSA9ICdqc29ucCc7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIEpTT05QVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG5cdFx0X2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcblx0fVxuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoSlNPTlBUcmFuc3BvcnQsIF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRKU09OUFRyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmpzb25wU3VwcG9ydGVkICYmIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWxsb3dDb21ldDtcblx0fTtcblx0aWYoSlNPTlBUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IEpTT05QVHJhbnNwb3J0O1xuXHR9XG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQpIHtcblx0XHRoZWFkID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0fVxuXG5cdC8qIGNvbm5lY3Rpdml0eSBjaGVjazsgc2luY2UgdGhpcyBoYXMgYSBoYXJkLWNvZGVkIGNhbGxiYWNrIGlkLFxuXHQgKiB3ZSBqdXN0IG1ha2Ugc3VyZSB0aGF0IHdlIGhhbmRsZSBjb25jdXJyZW50IHJlcXVlc3RzIChidXQgdGhlXG5cdCAqIGNvbm5lY3Rpb25tYW5hZ2VyIHNob3VsZCBlbnN1cmUgdGhpcyBkb2Vzbid0IGhhcHBlbiBhbnl3YXkgKi9cblx0dmFyIGNoZWNrc0luUHJvZ3Jlc3MgPSBudWxsO1xuXHRnbG9iYWwuSlNPTlBUcmFuc3BvcnQgPSBKU09OUFRyYW5zcG9ydFxuXG5cdEpTT05QVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgSlNPTlBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHR0cmFuc3BvcnQub24oJ3ByZWNvbm5lY3QnLCBmdW5jdGlvbigpIHtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnSlNPTlBUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHR0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdFx0dHJhbnNwb3J0LmNvbm5lY3QoKTtcblx0fTtcblxuXHRKU09OUFRyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ0pTT05QVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuXHR9O1xuXG5cdHZhciBjcmVhdGVSZXF1ZXN0ID0gSlNPTlBUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcblx0XHQvKiBKU09OUCByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG5cdFx0ICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcblx0XHQgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuXHRcdHRpbWVvdXRzID0gKHRoaXMgJiYgdGhpcy50aW1lb3V0cykgfHwgdGltZW91dHMgfHwgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRJTUVPVVRTO1xuXHRcdHJldHVybiBuZXcgUmVxdWVzdCh1bmRlZmluZWQsIHVyaSwgaGVhZGVycywgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFJlcXVlc3QoaWQsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuXHRcdF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcblx0XHRpZihpZCA9PT0gdW5kZWZpbmVkKSBpZCA9IGlkQ291bnRlcisrO1xuXHRcdHRoaXMuaWQgPSBpZDtcblx0XHR0aGlzLnVyaSA9IHVyaTtcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0XHR0aGlzLnBhcmFtcy5ybmQgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlYXBSYW5kU3RyKCk7XG5cdFx0aWYoaGVhZGVycykge1xuXHRcdFx0LyogSlNPTlAgZG9lc24ndCBhbGxvdyBoZWFkZXJzLiBDaGVycnktcGljayBhIGNvdXBsZSB0byB0dXJuIGludG8gcXMgcGFyYW1zICovXG5cdFx0XHRpZihoZWFkZXJzWydYLUFibHktVmVyc2lvbiddKSB0aGlzLnBhcmFtcy52ID0gaGVhZGVyc1snWC1BYmx5LVZlcnNpb24nXTtcblx0XHRcdGlmKGhlYWRlcnNbJ0FibHktQWdlbnQnXSkgdGhpcy5wYXJhbXMuYWdlbnQgPSBoZWFkZXJzWydBYmx5LUFnZW50J107XG5cdFx0fVxuXHRcdHRoaXMuYm9keSA9IGJvZHk7XG5cdFx0dGhpcy5tZXRob2QgPSBtZXRob2Q7XG5cdFx0dGhpcy5yZXF1ZXN0TW9kZSA9IHJlcXVlc3RNb2RlO1xuXHRcdHRoaXMudGltZW91dHMgPSB0aW1lb3V0cztcblx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuXHR9XG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhSZXF1ZXN0LCBfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlkID0gdGhpcy5pZCxcblx0XHRcdGJvZHkgPSB0aGlzLmJvZHksXG5cdFx0XHRtZXRob2QgPSB0aGlzLm1ldGhvZCxcblx0XHRcdHVyaSA9IHRoaXMudXJpLFxuXHRcdFx0cGFyYW1zID0gdGhpcy5wYXJhbXMsXG5cdFx0XHRzZWxmID0gdGhpcztcblxuXHRcdHBhcmFtcy5jYWxsYmFjayA9ICdfYWJseWpzX2pzb25wLl8oJyArIGlkICsgJyknO1xuXG5cdFx0cGFyYW1zLmVudmVsb3BlID0gJ2pzb25wJztcblx0XHRpZihib2R5KSB7XG5cdFx0XHRwYXJhbXMuYm9keSA9IGJvZHk7XG5cdFx0fVxuXHRcdGlmKG1ldGhvZCAmJiBtZXRob2QgIT09ICdnZXQnKSB7XG5cdFx0XHRwYXJhbXMubWV0aG9kID0gbWV0aG9kO1xuXHRcdH1cblxuXHRcdHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuXHRcdHZhciBzcmMgPSB1cmkgKyBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9RdWVyeVN0cmluZyhwYXJhbXMpO1xuXHRcdHNjcmlwdC5zcmMgPSBzcmM7XG5cdFx0aWYoc2NyaXB0LnNyYy5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSAhPT0gc3JjLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdKSB7XG5cdFx0XHQvKiBUaGUgc3JjIGhhcyBiZWVuIHRydW5jYXRlZC4gQ2FuJ3QgYWJvcnQsIGJ1dCBjYW4gYXQgbGVhc3QgZW1pdCBhblxuXHRcdFx0ICogZXJyb3Igc28gdGhlIHVzZXIga25vd3Mgd2hhdCdzIGdvbmUgd3JvbmcuIChDYW4ndCBjb21wYXJlIHN0cmluZ3Ncblx0XHRcdCAqIGRpcmVjdGx5IGFzIHNyYyBtYXkgaGF2ZSBhIHBvcnQsIHNjcmlwdC5zcmMgd29uJ3QpICovXG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0pTT05QIFJlcXVlc3QuZXhlYygpJywgJ1dhcm5pbmc6IHRoZSBicm93c2VyIGFwcGVhcnMgdG8gaGF2ZSB0cnVuY2F0ZWQgdGhlIHNjcmlwdCBVUkkuIFRoaXMgd2lsbCBsaWtlbHkgcmVzdWx0IGluIHRoZSByZXF1ZXN0IGZhaWxpbmcgZHVlIHRvIGFuIHVucGFyc2VhYmxlIGJvZHkgcGFyYW0nKTtcblx0XHR9XG5cdFx0c2NyaXB0LmFzeW5jID0gdHJ1ZTtcblx0XHRzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuXHRcdHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04Jztcblx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0pTT05QIHNjcmlwdCBlcnJvciAoZXZlbnQ6ICcgKyBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdChlcnIpICsgJyknLCBudWxsLCA0MDApKTtcblx0XHR9O1xuXG5cdFx0X1snXycgKyBpZF0gPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0XHRpZihtZXNzYWdlLnN0YXR1c0NvZGUpIHtcblx0XHRcdFx0LyogSGFuZGxlIGFzIGVudmVsb3BlZCBqc29ucCwgYXMgYWxsIGpzb25wIHRyYW5zcG9ydCB1c2VzIHNob3VsZCBiZSAqL1xuXHRcdFx0XHR2YXIgcmVzcG9uc2UgPSBtZXNzYWdlLnJlc3BvbnNlO1xuXHRcdFx0XHRpZihtZXNzYWdlLnN0YXR1c0NvZGUgPT0gMjA0KSB7XG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYoIXJlc3BvbnNlKSB7XG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0ludmFsaWQgc2VydmVyIHJlc3BvbnNlOiBubyBlbnZlbG9wZSBkZXRlY3RlZCcsIG51bGwsIDUwMCkpO1xuXHRcdFx0XHR9IGVsc2UgaWYobWVzc2FnZS5zdGF0dXNDb2RlIDwgNDAwIHx8IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KHJlc3BvbnNlKSkge1xuXHRcdFx0XHRcdC8qIElmIHJlc3BvbnNlIGlzIGFuIGFycmF5LCBpdCdzIGFuIGFycmF5IG9mIHByb3RvY29sIG1lc3NhZ2VzIC0tIGV2ZW4gaWZcblx0XHRcdFx0XHQgKiBpdCBjb250YWlucyBhbiBlcnJvciBhY3Rpb24gKGhlbmNlIHRoZSBub25zdWNjZXNzIHN0YXR1c2NvZGUpLCB3ZSBjYW5cblx0XHRcdFx0XHQgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG5cdFx0XHRcdFx0ICogb25Qcm90b2NvbE1lc3NhZ2UgdG8gZGVjaWRlIHdoYXQgdG8gZG8gKi9cblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIHJlc3BvbnNlLCBtZXNzYWdlLmhlYWRlcnMsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIGVyciA9IHJlc3BvbnNlLmVycm9yIHx8IG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXInLCBudWxsLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuXHRcdFx0XHRcdHNlbGYuY29tcGxldGUoZXJyKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0LyogSGFuZGxlIGFzIG5vbi1lbnZlbG9wZWQgLS0gYXMgd2lsbCBiZSBlZyBmcm9tIGEgY3VzdG9tZXIncyBhdXRoVXJsIHNlcnZlciAqL1xuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIG1lc3NhZ2UpO1xuXHRcdFx0fVxuXHRcdH07XG5cblx0XHR2YXIgdGltZW91dCA9ICh0aGlzLnJlcXVlc3RNb2RlID09IF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJFUV9TRU5EKSA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dDtcblx0XHR0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHsgc2VsZi5hYm9ydCgpOyB9LCB0aW1lb3V0KTtcblx0XHRoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG5cdH07XG5cblx0UmVxdWVzdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHN0YXR1c0NvZGUpIHtcblx0XHRoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcblx0XHRpZighdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcblx0XHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcblx0XHRcdHZhciBjb250ZW50VHlwZTtcblx0XHRcdGlmKGJvZHkpIHtcblx0XHRcdFx0Y29udGVudFR5cGUgPSAodHlwZW9mKGJvZHkpID09ICdzdHJpbmcnKSA/ICd0ZXh0L3BsYWluJyA6ICdhcHBsaWNhdGlvbi9qc29uJztcblx0XHRcdFx0aGVhZGVyc1snY29udGVudC10eXBlJ10gPSBjb250ZW50VHlwZTtcblx0XHRcdFx0dGhpcy5lbWl0KCdkYXRhJywgYm9keSk7XG5cdFx0XHR9XG5cblx0XHRcdHRoaXMuZW1pdCgnY29tcGxldGUnLCBlcnIsIGJvZHksIGhlYWRlcnMsIC8qIHVucGFja2VkOiAqLyB0cnVlLCBzdGF0dXNDb2RlKTtcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xuXHRcdH1cblx0fTtcblxuXHRSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuZGlzcG9zZSgpO1xuXHR9O1xuXG5cdFJlcXVlc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGltZXIgPSB0aGlzLnRpbWVyO1xuXHRcdGlmKHRpbWVyKSB7XG5cdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xuXHRcdFx0dGhpcy50aW1lciA9IG51bGw7XG5cdFx0fVxuXHRcdHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcblx0XHRpZihzY3JpcHQucGFyZW50Tm9kZSkgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcblx0XHRkZWxldGUgX1t0aGlzLmlkXTtcblx0XHR0aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG5cdH07XG5cblx0aWYocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5qc29ucFN1cHBvcnRlZCAmJiAhcGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJlcXVlc3QpIHtcblx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uUmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XG5cdFx0XHR2YXIgcmVxID0gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUkVRX1NFTkQsIHJlc3QgJiYgcmVzdC5vcHRpb25zLnRpbWVvdXRzLCBtZXRob2QpO1xuXHRcdFx0cmVxLm9uY2UoJ2NvbXBsZXRlJywgY2FsbGJhY2spO1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXEuZXhlYygpO1xuXHRcdFx0fSk7XG5cdFx0XHRyZXR1cm4gcmVxO1xuXHRcdH07XG5cblx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdFx0dmFyIHVwVXJsID0gX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmpzb25wSW50ZXJuZXRVcFVybDtcblxuXHRcdFx0aWYoY2hlY2tzSW5Qcm9ncmVzcykge1xuXHRcdFx0XHRjaGVja3NJblByb2dyZXNzLnB1c2goY2FsbGJhY2spO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRjaGVja3NJblByb2dyZXNzID0gW2NhbGxiYWNrXTtcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnKEpTT05QKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdTZW5kaW5nOyAnICsgdXBVcmwpO1xuXG5cdFx0XHR2YXIgcmVxID0gbmV3IFJlcXVlc3QoJ2lzVGhlSW50ZXJuZXRVcCcsIHVwVXJsLCBudWxsLCBudWxsLCBudWxsLCBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SRVFfU0VORCwgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRJTUVPVVRTKTtcblx0XHRcdHJlcS5vbmNlKCdjb21wbGV0ZScsIGZ1bmN0aW9uKGVyciwgcmVzcG9uc2UpIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9ICFlcnIgJiYgcmVzcG9uc2U7XG5cdFx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnKEpTT05QKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdSZXN1bHQ6ICcgKyByZXN1bHQpO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY2hlY2tzSW5Qcm9ncmVzcy5sZW5ndGg7IGkrKykgY2hlY2tzSW5Qcm9ncmVzc1tpXShudWxsLCByZXN1bHQpO1xuXHRcdFx0XHRjaGVja3NJblByb2dyZXNzID0gbnVsbDtcblx0XHRcdH0pO1xuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXEuZXhlYygpO1xuXHRcdFx0fSk7XG5cdFx0fTtcblx0fVxuXG5cdHJldHVybiBKU09OUFRyYW5zcG9ydDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoSlNPTlBUcmFuc3BvcnQpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjApO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cblxuXG5cblxuXG5cblxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG5cdHZhciBXZWJTb2NrZXQgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLldlYlNvY2tldDtcblx0dmFyIHNob3J0TmFtZSA9ICd3ZWJfc29ja2V0JztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcblx0XHQvKiBJZiBpcyBhIGJyb3dzZXIsIGNhbid0IGRldGVjdCBwaW5ncywgc28gcmVxdWVzdCBwcm90b2NvbCBoZWFydGJlYXRzICovXG5cdFx0cGFyYW1zLmhlYXJ0YmVhdHMgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnVzZVByb3RvY29sSGVhcnRiZWF0cztcblx0XHRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR0aGlzLndzSG9zdCA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0SG9zdChwYXJhbXMub3B0aW9ucywgcGFyYW1zLmhvc3QsIHRydWUpO1xuXHR9XG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoV2ViU29ja2V0VHJhbnNwb3J0LCBfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIVdlYlNvY2tldDtcblx0fTtcblxuXHRpZihXZWJTb2NrZXRUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSlcblx0XHRjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgV2ViU29ja2V0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xuXHRcdHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0dHJhbnNwb3J0Lm9uKCd3c29wZW4nLCBmdW5jdGlvbigpIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHR0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdFx0dHJhbnNwb3J0LmNvbm5lY3QoKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVdlYlNvY2tldCA9IGZ1bmN0aW9uKHVyaSwgY29ubmVjdFBhcmFtcykge1xuXHRcdHRoaXMudXJpID0gdXJpICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpXG5cdFx0cmV0dXJuIG5ldyBXZWJTb2NrZXQodGhpcy51cmkpO1xuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gJ1dlYlNvY2tldFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLnVyaTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuXHRcdF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuXHRcdHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcblx0XHR2YXIgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/ICd3c3M6Ly8nIDogJ3dzOi8vJztcblx0XHR2YXIgd3NVcmkgPSB3c1NjaGVtZSArIHRoaXMud3NIb3N0ICsgJzonICsgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRQb3J0KG9wdGlvbnMpICsgJy8nO1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3VyaTogJyArIHdzVXJpKTtcblx0XHR0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcblx0XHRcdGlmKHNlbGYuaXNEaXNwb3NlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgcGFyYW1TdHIgPSAnJzsgZm9yKHZhciBwYXJhbSBpbiBhdXRoUGFyYW1zKSBwYXJhbVN0ciArPSAnICcgKyBwYXJhbSArICc6ICcgKyBhdXRoUGFyYW1zW3BhcmFtXSArICc7Jztcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ2F1dGhQYXJhbXM6JyArIHBhcmFtU3RyICsgJyBlcnI6ICcgKyBlcnIpO1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHR2YXIgY29ubmVjdFBhcmFtcyA9IHBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dmFyIHdzQ29ubmVjdGlvbiA9IHNlbGYud3NDb25uZWN0aW9uID0gc2VsZi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpO1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24uYmluYXJ5VHlwZSA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmluYXJ5VHlwZTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLm9ub3BlbiA9IGZ1bmN0aW9uKCkgeyBzZWxmLm9uV3NPcGVuKCk7IH07XG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oZXYpIHsgc2VsZi5vbldzQ2xvc2UoZXYpOyB9O1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24oZXYpIHsgc2VsZi5vbldzRGF0YShldi5kYXRhKTsgfTtcblx0XHRcdFx0d3NDb25uZWN0aW9uLm9uZXJyb3IgPSBmdW5jdGlvbihldikgeyBzZWxmLm9uV3NFcnJvcihldik7IH07XG5cdFx0XHRcdGlmKHdzQ29ubmVjdGlvbi5vbikge1xuXHRcdFx0XHRcdC8qIG5vZGU7IGJyb3dzZXJzIGN1cnJlbnRseSBkb24ndCBoYXZlIGEgZ2VuZXJhbCBldmVudGVtaXR0ZXIgYW5kIGNhbid0IGRldGVjdFxuXHRcdFx0XHRcdCAqIHBpbmdzLiBBbHNvLCBubyBuZWVkIHRvIHJlcGx5IHdpdGggYSBwb25nIGV4cGxpY2l0bHksIHdzIGxpYiBoYW5kbGVzIHRoYXQgKi9cblx0XHRcdFx0XHR3c0Nvbm5lY3Rpb24ub24oJ3BpbmcnLCBmdW5jdGlvbigpIHsgc2VsZi5vbkFjdGl2aXR5KCk7IH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gY3JlYXRpbmcgd2Vic29ja2V0OiBlcnIgPSAnICsgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKSk7XG5cdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dmFyIHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdGlmKCF3c0Nvbm5lY3Rpb24pIHtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgJ05vIHNvY2tldCBjb25uZWN0aW9uJyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRyeSB7XG5cdFx0XHR3c0Nvbm5lY3Rpb24uc2VuZChfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2VyaWFsaXplKG1lc3NhZ2UsIHRoaXMucGFyYW1zLmZvcm1hdCkpO1xuXHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdHZhciBtc2cgPSAnRXhjZXB0aW9uIGZyb20gd3MgY29ubmVjdGlvbiB3aGVuIHRyeWluZyB0byBzZW5kOiAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZSk7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LnNlbmQoKScsIG1zZyk7XG5cdFx0XHQvKiBEb24ndCB0cnkgdG8gcmVxdWVzdCBhIGRpc2Nvbm5lY3QsIHRoYXQnbGwganVzdCBpbnZvbHZlIHNlbmRpbmcgZGF0YVxuXHRcdFx0ICogZG93biB0aGUgd2Vic29ja2V0IGFnYWluLiBKdXN0IGZpbmlzaCB0aGUgdHJhbnNwb3J0LiAqL1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA1MDAwMCwgNTAwKSk7XG5cdFx0fVxuXHR9O1xuXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0RhdGEgPSBmdW5jdGlvbihkYXRhKSB7XG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ2RhdGEgcmVjZWl2ZWQ7IGxlbmd0aCA9ICcgKyBkYXRhLmxlbmd0aCArICc7IHR5cGUgPSAnICsgdHlwZW9mKGRhdGEpKTtcblx0XHR0cnkge1xuXHRcdFx0dGhpcy5vblByb3RvY29sTWVzc2FnZShfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVzZXJpYWxpemUoZGF0YSwgdGhpcy5mb3JtYXQpKTtcblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIG1lc3NhZ2U6ICcgKyBlLnN0YWNrKTtcblx0XHR9XG5cdH07XG5cblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzT3BlbiA9IGZ1bmN0aW9uKCkge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKScsICdvcGVuZWQgV2ViU29ja2V0Jyk7XG5cdFx0dGhpcy5lbWl0KCd3c29wZW4nKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NDbG9zZSA9IGZ1bmN0aW9uKGV2KSB7XG5cdFx0dmFyIHdhc0NsZWFuLCBjb2RlLCByZWFzb247XG5cdFx0aWYodHlwZW9mKGV2KSA9PSAnb2JqZWN0Jykge1xuXHRcdFx0LyogVzNDIHNwZWMtY29tcGF0aWJsZSAqL1xuXHRcdFx0d2FzQ2xlYW4gPSBldi53YXNDbGVhbjtcblx0XHRcdGNvZGUgPSBldi5jb2RlO1xuXHRcdH0gZWxzZSAvKmlmKHR5cGVvZihldikgPT0gJ251bWJlcicpKi8ge1xuXHRcdFx0Lyogd3MgaW4gbm9kZSAqL1xuXHRcdFx0Y29kZSA9IGV2O1xuXHRcdFx0d2FzQ2xlYW4gPSAoY29kZSA9PSAxMDAwKTtcblx0XHR9XG5cdFx0ZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdGlmKHdhc0NsZWFuKSB7XG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpJywgJ0NsZWFubHkgY2xvc2VkIFdlYlNvY2tldCcpO1xuXHRcdFx0dmFyIGVyciA9IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1dlYnNvY2tldCBjbG9zZWQnLCA4MDAwMywgNDAwKTtcblx0XHRcdHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbXNnID0gJ1VuY2xlYW4gZGlzY29ubmVjdGlvbiBvZiBXZWJTb2NrZXQgOyBjb2RlID0gJyArIGNvZGUsXG5cdFx0XHRcdGVyciA9IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAwMywgNDAwKTtcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0Nsb3NlKCknLCBtc2cpO1xuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG5cdFx0fVxuXHRcdHRoaXMuZW1pdCgnZGlzcG9zZWQnKTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NFcnJvciA9IGZ1bmN0aW9uKGVycikge1xuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpJywgJ0Vycm9yIGZyb20gV2ViU29ja2V0OiAnICsgZXJyLm1lc3NhZ2UpO1xuXHRcdC8qIFdhaXQgYSB0aWNrIGJlZm9yZSBhYm9ydGluZzogaWYgdGhlIHdlYnNvY2tldCB3YXMgY29ubmVjdGVkLCB0aGlzIGV2ZW50XG5cdFx0ICogd2lsbCBiZSBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBhbiBvbmNsb3NlIGV2ZW50IHdpdGggYSBjbG9zZSBjb2RlLiBBbGxvd1xuXHRcdCAqIHRoYXQgdG8gY2xvc2UgaXQgKHNvIHdlIHNlZSB0aGUgY2xvc2UgY29kZSkgcmF0aGVyIHRoYW4gYW50aWNpcGF0aW5nIGl0ICovXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcblx0XHR9KTtcblx0fTtcblxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcblx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuXHRcdHZhciB3c0Nvbm5lY3Rpb24gPSB0aGlzLndzQ29ubmVjdGlvbjtcblx0XHRpZih3c0Nvbm5lY3Rpb24pIHtcblx0XHRcdC8qIElnbm9yZSBhbnkgbWVzc2FnZXMgdGhhdCBjb21lIHRocm91Z2ggYWZ0ZXIgZGlzcG9zZSgpIGlzIGNhbGxlZCBidXQgYmVmb3JlXG5cdFx0XHQgKiB3ZWJzb2NrZXQgaXMgYWN0dWFsbHkgY2xvc2VkLiAobW9zdGx5IHdvdWxkIGJlIGhhcm1sZXNzLCBidXQgaWYgaXQncyBhXG5cdFx0XHQgKiBDT05ORUNURUQsIGl0J2xsIHJlLXRpY2sgaXNDb25uZWN0ZWQgYW5kIGNhdXNlIGFsbCBzb3J0cyBvZiBoYXZvYykgKi9cblx0XHRcdHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHt9O1xuXHRcdFx0ZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xuXHRcdFx0LyogZGVmZXIgdW50aWwgdGhlIG5leHQgZXZlbnQgbG9vcCBjeWNsZSBiZWZvcmUgY2xvc2luZyB0aGUgc29ja2V0LFxuXHRcdFx0ICogZ2l2aW5nIHNvbWUgaW1wbGVtZW50YXRpb25zIHRoZSBvcHBvcnR1bml0eSB0byBzZW5kIGFueSBvdXRzdGFuZGluZyBjbG9zZSBtZXNzYWdlICovXG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdjbG9zaW5nIHdlYnNvY2tldCcpO1xuXHRcdFx0XHR3c0Nvbm5lY3Rpb24uY2xvc2UoKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChXZWJTb2NrZXRUcmFuc3BvcnQpO1xuXG5cbi8qKiovIH0pLFxuLyogNDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQvanNvbnB0cmFuc3BvcnQuanNcbnZhciBqc29ucHRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL3V0aWxzLmpzXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2xvZ2dlci5qc1xudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXG52YXIgcGxhdGZvcm1fYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3RyYW5zcG9ydC9jb21ldHRyYW5zcG9ydC5qc1xudmFyIGNvbWV0dHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQveGhycmVxdWVzdC5qc1xudmFyIHhocnJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQveGhycG9sbGluZ3RyYW5zcG9ydC5qc1xuXG5cblxuXG5cblxudmFyIHhocnBvbGxpbmd0cmFuc3BvcnRfWEhSUG9sbGluZ1RyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG5cdHZhciBzaG9ydE5hbWUgPSAneGhyX3BvbGxpbmcnO1xuXG5cdGZ1bmN0aW9uIFhIUlBvbGxpbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xuXHRcdHBhcmFtcy5zdHJlYW0gPSBmYWxzZTtcblx0XHRjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFhIUlBvbGxpbmdUcmFuc3BvcnQsIGNvbWV0dHJhbnNwb3J0W1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ueGhyU3VwcG9ydGVkICYmIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsb3dDb21ldDtcblx0fTtcblxuXHRYSFJQb2xsaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgWEhSUG9sbGluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcblx0XHR2YXIgZXJyb3JDYiA9IGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayh7ZXZlbnQ6IHRoaXMuZXZlbnQsIGVycm9yOiBlcnJ9KTsgfTtcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnWEhSUG9sbGluZ1RyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcblx0XHR9KTtcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xuXHR9O1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdYSFJQb2xsaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuXHR9O1xuXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpIHtcblx0XHRyZXR1cm4geGhycmVxdWVzdFtcImFcIiAvKiBkZWZhdWx0ICovXS5jcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGhpcy50aW1lb3V0cyk7XG5cdH07XG5cblx0aWYodHlwZW9mKGNvbm5lY3Rpb25NYW5hZ2VyKSAhPT0gJ3VuZGVmaW5lZCcgJiYgWEhSUG9sbGluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gWEhSUG9sbGluZ1RyYW5zcG9ydDtcblx0fVxuXG5cdHJldHVybiBYSFJQb2xsaW5nVHJhbnNwb3J0O1xufTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhycG9sbGluZ3RyYW5zcG9ydCA9ICh4aHJwb2xsaW5ndHJhbnNwb3J0X1hIUlBvbGxpbmdUcmFuc3BvcnQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3RyYW5zcG9ydC94aHJzdHJlYW1pbmd0cmFuc3BvcnQuanNcblxuXG5cblxuXG5cbnZhciB4aHJzdHJlYW1pbmd0cmFuc3BvcnRfWEhSU3RyZWFtaW5nVHJhbnNwb3J0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIpIHtcblx0dmFyIHNob3J0TmFtZSA9ICd4aHJfc3RyZWFtaW5nJztcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gWEhSU3RyZWFtaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcblx0XHRjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFhIUlN0cmVhbWluZ1RyYW5zcG9ydCwgY29tZXR0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN0cmVhbWluZ1N1cHBvcnRlZCAmJiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbG93Q29tZXQ7XG5cdH07XG5cblx0WEhSU3RyZWFtaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgWEhSU3RyZWFtaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xuXHRcdHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG5cdFx0dHJhbnNwb3J0Lm9uKCdwcmVjb25uZWN0JywgZnVuY3Rpb24oKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdYSFJTdHJlYW1pbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XG5cdFx0XHR0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG5cdFx0fSk7XG5cdFx0dHJhbnNwb3J0LmNvbm5lY3QoKTtcblx0fTtcblxuXHRYSFJTdHJlYW1pbmdUcmFuc3BvcnQucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICdYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy5iYXNlVXJpICsgJzsgaXNDb25uZWN0ZWQ9JyArIHRoaXMuaXNDb25uZWN0ZWQ7XG5cdH07XG5cblx0WEhSU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG5cdFx0cmV0dXJuIHhocnJlcXVlc3RbXCJhXCIgLyogZGVmYXVsdCAqL10uY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMpO1xuXHR9O1xuXG5cdGlmKHR5cGVvZihjb25uZWN0aW9uTWFuYWdlcikgIT09ICd1bmRlZmluZWQnICYmIFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gWEhSU3RyZWFtaW5nVHJhbnNwb3J0O1xuXHR9XG5cblx0cmV0dXJuIFhIUlN0cmVhbWluZ1RyYW5zcG9ydDtcbn07XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocnN0cmVhbWluZ3RyYW5zcG9ydCA9ICh4aHJzdHJlYW1pbmd0cmFuc3BvcnRfWEhSU3RyZWFtaW5nVHJhbnNwb3J0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQvaW5kZXguanNcblxuXG5cblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGliX3RyYW5zcG9ydCA9IF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFtcbiAganNvbnB0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10sXG4gIHhocnBvbGxpbmd0cmFuc3BvcnQsXG4gIHhocnN0cmVhbWluZ3RyYW5zcG9ydFxuXSk7XG5cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7dmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3Rcbl9fd2VicGFja19yZXF1aXJlX18oNDMpO1xuLy8gT24gc29tZSBleG90aWMgZW52aXJvbm1lbnRzLCBpdCdzIG5vdCBjbGVhciB3aGljaCBvYmplY3QgYHNldGltbWVkaWF0ZWAgd2FzXG4vLyBhYmxlIHRvIGluc3RhbGwgb250by4gIFNlYXJjaCBlYWNoIHBvc3NpYmlsaXR5IGluIHRoZSBzYW1lIG9yZGVyIGFzIHRoZVxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cbmV4cG9ydHMuc2V0SW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuc2V0SW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XG5leHBvcnRzLmNsZWFySW1tZWRpYXRlID0gKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xuXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxuXG4vKioqLyB9KSxcbi8qIDQzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIHByb2Nlc3MpIHsoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NCkpKVxuXG4vKioqLyB9KSxcbi8qIDQ0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XG5cbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuLyoqKi8gfSksXG4vKiA0NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgQkUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGYxNkJFID0gQ19lbmMuVXRmMTYgPSBDX2VuYy5VdGYxNkJFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmY7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBCRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNi5wYXJzZSh1dGYxNlN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgQ19lbmMuVXRmMTZMRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBzd2FwRW5kaWFuKCh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZik7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnBhcnNlKHV0ZjE2U3RyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHN3YXBFbmRpYW4odXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHN3YXBFbmRpYW4od29yZCkge1xuXHQgICAgICAgIHJldHVybiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmMTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0NyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMxKSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4O1xuXHQgICAgdmFyIENfZm9ybWF0ID0gQy5mb3JtYXQ7XG5cblx0ICAgIHZhciBIZXhGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhlIGNpcGhlcnRleHQgb2YgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc30gY2lwaGVyUGFyYW1zIFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgY2lwaGVydGV4dCBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0LkhleC5wYXJzZShoZXhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoaW5wdXQpIHtcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBIZXgucGFyc2UoaW5wdXQpO1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5mb3JtYXQuSGV4O1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygxOCksIF9fd2VicGFja19yZXF1aXJlX18oNDkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMSkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXI7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvLyBMb29rdXAgdGFibGVzXG5cdCAgICB2YXIgU0JPWCA9IFtdO1xuXHQgICAgdmFyIElOVl9TQk9YID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8wID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgU1VCX01JWF8zID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzEgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8yID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGxvb2t1cCB0YWJsZXNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgLy8gQ29tcHV0ZSBkb3VibGUgdGFibGVcblx0ICAgICAgICB2YXIgZCA9IFtdO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgaWYgKGkgPCAxMjgpIHtcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSBpIDw8IDE7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gKGkgPDwgMSkgXiAweDExYjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIC8vIFdhbGsgR0YoMl44KVxuXHQgICAgICAgIHZhciB4ID0gMDtcblx0ICAgICAgICB2YXIgeGkgPSAwO1xuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XG5cdCAgICAgICAgICAgIHZhciBzeCA9IHhpIF4gKHhpIDw8IDEpIF4gKHhpIDw8IDIpIF4gKHhpIDw8IDMpIF4gKHhpIDw8IDQpO1xuXHQgICAgICAgICAgICBzeCA9IChzeCA+Pj4gOCkgXiAoc3ggJiAweGZmKSBeIDB4NjM7XG5cdCAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcblx0ICAgICAgICAgICAgSU5WX1NCT1hbc3hdID0geDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXG5cdCAgICAgICAgICAgIHZhciB4MiA9IGRbeF07XG5cdCAgICAgICAgICAgIHZhciB4NCA9IGRbeDJdO1xuXHQgICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIHN1YiBieXRlcywgbWl4IGNvbHVtbnMgdGFibGVzXG5cdCAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgU1VCX01JWF8wW3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzFbeF0gPSAodCA8PCAxNikgfCAodCA+Pj4gMTYpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBTVUJfTUlYXzNbeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9ICh4OCAqIDB4MTAxMDEwMSkgXiAoeDQgKiAweDEwMDAxKSBeICh4MiAqIDB4MTAxKSBeICh4ICogMHgxMDEwMTAwKTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMFtzeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfMltzeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8zW3N4XSA9IHQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBuZXh0IGNvdW50ZXJcblx0ICAgICAgICAgICAgaWYgKCF4KSB7XG5cdCAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgeCA9IHgyIF4gZFtkW2RbeDggXiB4Ml1dXTtcblx0ICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLy8gUHJlY29tcHV0ZWQgUmNvbiBsb29rdXBcblx0ICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgQUVTID0gQ19hbGdvLkFFUyA9IEJsb2NrQ2lwaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIHQ7XG5cblx0ICAgICAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxuXHQgICAgICAgICAgICBpZiAodGhpcy5fblJvdW5kcyAmJiB0aGlzLl9rZXlQcmlvclJlc2V0ID09PSB0aGlzLl9rZXkpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybjtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcblx0ICAgICAgICAgICAgdmFyIGtleVdvcmRzID0ga2V5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGtleS5zaWdCeXRlcyAvIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Ygcm91bmRzXG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcyA9IGtleVNpemUgKyA2O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIGtleSBzY2hlZHVsZSByb3dzXG5cdCAgICAgICAgICAgIHZhciBrc1Jvd3MgPSAoblJvdW5kcyArIDEpICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIga2V5U2NoZWR1bGUgPSB0aGlzLl9rZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoa3NSb3cgPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5V29yZHNba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ID0ga2V5U2NoZWR1bGVba3NSb3cgLSAxXTtcblxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gUm90IHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9ICh0IDw8IDgpIHwgKHQgPj4+IDI0KTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0ID0gKFNCT1hbdCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyh0ID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsodCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbdCAmIDB4ZmZdO1xuXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIE1peCBSY29uXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgXj0gUkNPTlsoa3NSb3cgLyBrZXlTaXplKSB8IDBdIDw8IDI0O1xuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgICAgICBrZXlTY2hlZHVsZVtrc1Jvd10gPSBrZXlTY2hlZHVsZVtrc1JvdyAtIGtleVNpemVdIF4gdDtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxuXHQgICAgICAgICAgICB2YXIgaW52S2V5U2NoZWR1bGUgPSB0aGlzLl9pbnZLZXlTY2hlZHVsZSA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpbnZLc1JvdyA9IDA7IGludktzUm93IDwga3NSb3dzOyBpbnZLc1JvdysrKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcblxuXHQgICAgICAgICAgICAgICAgaWYgKGludktzUm93ICUgNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gNF07XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyA8IDQgfHwga3NSb3cgPD0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IElOVl9TVUJfTUlYXzBbU0JPWFt0ID4+PiAyNF1dIF4gSU5WX1NVQl9NSVhfMVtTQk9YWyh0ID4+PiAxNikgJiAweGZmXV0gXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBlbmNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xuXHQgICAgICAgICAgICAvLyBTd2FwIDJuZCBhbmQgNHRoIHJvd3Ncblx0ICAgICAgICAgICAgdmFyIHQgPSBNW29mZnNldCArIDFdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQ7XG5cblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcblxuXHQgICAgICAgICAgICAvLyBJbnYgc3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9DcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0LCBrZXlTY2hlZHVsZSwgU1VCX01JWF8wLCBTVUJfTUlYXzEsIFNVQl9NSVhfMiwgU1VCX01JWF8zLCBTQk9YKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBuUm91bmRzID0gdGhpcy5fblJvdW5kcztcblxuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHMwID0gTVtvZmZzZXRdICAgICBeIGtleVNjaGVkdWxlWzBdO1xuXHQgICAgICAgICAgICB2YXIgczEgPSBNW29mZnNldCArIDFdIF4ga2V5U2NoZWR1bGVbMV07XG5cdCAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcblx0ICAgICAgICAgICAgdmFyIHMzID0gTVtvZmZzZXQgKyAzXSBeIGtleVNjaGVkdWxlWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxuXHQgICAgICAgICAgICB2YXIga3NSb3cgPSA0O1xuXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xuXHQgICAgICAgICAgICBmb3IgKHZhciByb3VuZCA9IDE7IHJvdW5kIDwgblJvdW5kczsgcm91bmQrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBtaXggY29sdW1ucywgYWRkIHJvdW5kIGtleVxuXHQgICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gU1VCX01JWF8wW3MxID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMyID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczMgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczAgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQyID0gU1VCX01JWF8wW3MyID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMzID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczAgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczEgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBVcGRhdGUgc3RhdGVcblx0ICAgICAgICAgICAgICAgIHMwID0gdDA7XG5cdCAgICAgICAgICAgICAgICBzMSA9IHQxO1xuXHQgICAgICAgICAgICAgICAgczIgPSB0Mjtcblx0ICAgICAgICAgICAgICAgIHMzID0gdDM7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgdmFyIHQwID0gKChTQk9YW3MwID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMxID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczIgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MzICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MSA9ICgoU0JPWFtzMSA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMiA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMzID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMCAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQzID0gKChTQk9YW3MzID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMwID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczEgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MyICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxuXHQgICAgICAgICAgICBNW29mZnNldF0gICAgID0gdDA7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSB0MTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDI1Ni8zMlxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb25zIHRvIHRoZSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBleGFtcGxlXG5cdCAgICAgKlxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xuXHQgICAgICogICAgIHZhciBwbGFpbnRleHQgID0gQ3J5cHRvSlMuQUVTLmRlY3J5cHQoY2lwaGVydGV4dCwga2V5LCBjZmcpO1xuXHQgICAgICovXG5cdCAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5BRVM7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXG52YXIgcGxhdGZvcm1fYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbG9nZ2VyLmpzXG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9kZWZhdWx0cy5qcyArIDEgbW9kdWxlc1xudmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2F1dGguanMgKyAxIG1vZHVsZXNcbnZhciBhdXRoID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9kZXZpY2VkZXRhaWxzLmpzXG5cblxudmFyIGRldmljZWRldGFpbHNfRGV2aWNlRGV0YWlscyA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBEZXZpY2VEZXRhaWxzKCkge1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kZXZpY2VTZWNyZXQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wbGF0Zm9ybSA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmZvcm1GYWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLm1ldGFkYXRhID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbiA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLnB1c2ggPSB7XG5cdFx0XHRyZWNpcGllbnQ6IHVuZGVmaW5lZCxcblx0XHRcdHN0YXRlOiB1bmRlZmluZWQsXG5cdFx0XHRlcnJvcjogdW5kZWZpbmVkXG5cdFx0fTtcblx0fVxuXG5cdC8qKlxuXHQgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuXHQgKiBAcmV0dXJuIHsqfVxuXHQgKi9cblx0RGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGlkOiB0aGlzLmlkLFxuXHRcdFx0ZGV2aWNlU2VjcmV0OiB0aGlzLmRldmljZVNlY3JldCxcblx0XHRcdHBsYXRmb3JtOiB0aGlzLnBsYXRmb3JtLFxuXHRcdFx0Zm9ybUZhY3RvcjogdGhpcy5mb3JtRmFjdG9yLFxuXHRcdFx0Y2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG5cdFx0XHRtZXRhZGF0YTogdGhpcy5tZXRhZGF0YSxcblx0XHRcdGRldmljZUlkZW50aXR5VG9rZW46IHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbixcblx0XHRcdHB1c2g6IHtcblx0XHRcdFx0cmVjaXBpZW50OiB0aGlzLnB1c2gucmVjaXBpZW50LFxuXHRcdFx0XHRzdGF0ZTogdGhpcy5wdXNoLnN0YXRlLFxuXHRcdFx0XHRlcnJvcjogdGhpcy5wdXNoLmVycm9yXG5cdFx0XHR9XG5cdFx0fTtcblx0fTtcblxuXHREZXZpY2VEZXRhaWxzLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnW0RldmljZURldGFpbHMnO1xuXHRcdGlmKHRoaXMuaWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgaWQ9JyArIHRoaXMuaWQ7XG5cdFx0aWYodGhpcy5wbGF0Zm9ybSlcblx0XHRcdHJlc3VsdCArPSAnOyBwbGF0Zm9ybT0nICsgdGhpcy5wbGF0Zm9ybTtcblx0XHRpZih0aGlzLmZvcm1GYWN0b3IpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZm9ybUZhY3Rvcj0nICsgdGhpcy5mb3JtRmFjdG9yO1xuXHRcdGlmKHRoaXMuY2xpZW50SWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG5cdFx0aWYodGhpcy5tZXRhZGF0YSlcblx0XHRcdHJlc3VsdCArPSAnOyBtZXRhZGF0YT0nICsgdGhpcy5tZXRhZGF0YTtcblx0XHRpZih0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pXG5cdFx0XHRyZXN1bHQgKz0gJzsgZGV2aWNlSWRlbnRpdHlUb2tlbj0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKTtcblx0XHRpZih0aGlzLnB1c2gucmVjaXBpZW50KVxuXHRcdFx0cmVzdWx0ICs9ICc7IHB1c2gucmVjaXBpZW50PScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2gucmVjaXBpZW50KTtcblx0XHRpZih0aGlzLnB1c2guc3RhdGUpXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHVzaC5zdGF0ZT0nICsgdGhpcy5wdXNoLnN0YXRlO1xuXHRcdGlmKHRoaXMucHVzaC5lcnJvcilcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLmVycm9yPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2guZXJyb3IpO1xuXHRcdGlmKHRoaXMucHVzaC5tZXRhZGF0YSlcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLm1ldGFkYXRhPScgKyB0aGlzLnB1c2gubWV0YWRhdGE7XG5cdFx0cmVzdWx0ICs9ICddJztcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdERldmljZURldGFpbHMudG9SZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUJvZHk7XG5cblx0RGV2aWNlRGV0YWlscy5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSwgZm9ybWF0KSB7XG5cdFx0aWYoZm9ybWF0KSB7XG5cdFx0XHRib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xuXHRcdH1cblxuXHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkoYm9keSkpIHtcblx0XHRcdHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheShib2R5KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIERldmljZURldGFpbHMuZnJvbVZhbHVlcyhib2R5KTtcblx0XHR9XG5cdH07XG5cblx0RGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFsdWVzLmVycm9yID0gdmFsdWVzLmVycm9yICYmIEVycm9ySW5mby5mcm9tVmFsdWVzKHZhbHVlcy5lcnJvcik7IFxuXHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihuZXcgRGV2aWNlRGV0YWlscygpLCB2YWx1ZXMpO1xuXHR9O1xuXG5cdERldmljZURldGFpbHMuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24odmFsdWVzKSB7XG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgcmVzdWx0W2ldID0gRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRyZXR1cm4gRGV2aWNlRGV0YWlscztcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGRldmljZWRldGFpbHMgPSAoZGV2aWNlZGV0YWlsc19EZXZpY2VEZXRhaWxzKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvaHR0cC5qc1xudmFyIGh0dHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9idWZmZXJ1dGlscy5qc1xudmFyIGJ1ZmZlcnV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZXNvdXJjZS5qc1xuXG5cblxuXG5cblxuXG52YXIgcmVzb3VyY2VfUmVzb3VyY2UgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5tc2dwYWNrO1xuXG5cdGZ1bmN0aW9uIFJlc291cmNlKCkge31cblxuXHRmdW5jdGlvbiB3aXRoQXV0aERldGFpbHMocmVzdCwgaGVhZGVycywgcGFyYW1zLCBlcnJDYWxsYmFjaywgb3BDYWxsYmFjaykge1xuXHRcdGlmIChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzQXV0aEhlYWRlcnMpIHtcblx0XHRcdHJlc3QuYXV0aC5nZXRBdXRoSGVhZGVycyhmdW5jdGlvbihlcnIsIGF1dGhIZWFkZXJzKSB7XG5cdFx0XHRcdGlmKGVycilcblx0XHRcdFx0XHRlcnJDYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0b3BDYWxsYmFjayh1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihhdXRoSGVhZGVycywgaGVhZGVycyksIHBhcmFtcyk7XG5cdFx0XHR9KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVzdC5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24oZXJyLCBhdXRoUGFyYW1zKSB7XG5cdFx0XHRcdGlmKGVycilcblx0XHRcdFx0XHRlcnJDYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0b3BDYWxsYmFjayhoZWFkZXJzLCB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihhdXRoUGFyYW1zLCBwYXJhbXMpKTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGZvcm1hdCkge1xuXHRcdHJldHVybiBmdW5jdGlvbihlcnIsIGJvZHksIG91dGVySGVhZGVycywgdW5wYWNrZWQsIG91dGVyU3RhdHVzQ29kZSkge1xuXHRcdFx0aWYoZXJyICYmICFib2R5KSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYoIXVucGFja2VkKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ym9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcblx0XHRcdFx0fSBjYXRjaChlKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZSk7XG5cdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmKGJvZHkuc3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdC8qIEVudmVsb3BlIGFscmVhZHkgdW53cmFwcGVkIGJ5IHRoZSB0cmFuc3BvcnQgKi9cblx0XHRcdFx0Y2FsbGJhY2soZXJyLCBib2R5LCBvdXRlckhlYWRlcnMsIHRydWUsIG91dGVyU3RhdHVzQ29kZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0dmFyIHdyYXBwZWRTdGF0dXNDb2RlID0gYm9keS5zdGF0dXNDb2RlLFxuXHRcdFx0XHRyZXNwb25zZSA9IGJvZHkucmVzcG9uc2UsXG5cdFx0XHRcdHdyYXBwZWRIZWFkZXJzID0gYm9keS5oZWFkZXJzO1xuXG5cdFx0XHRpZih3cmFwcGVkU3RhdHVzQ29kZSA8IDIwMCB8fCB3cmFwcGVkU3RhdHVzQ29kZSA+PSAzMDApIHtcblx0XHRcdFx0LyogaGFuZGxlIHdyYXBwZWQgZXJyb3JzICovXG5cdFx0XHRcdHZhciB3cmFwcGVkRXJyID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yKSB8fCBlcnI7XG5cdFx0XHRcdGlmKCF3cmFwcGVkRXJyKSB7XG5cdFx0XHRcdFx0d3JhcHBlZEVyciA9IG5ldyBFcnJvcihcIkVycm9yIGluIHVuZW52ZWxvcGluZyBcIiArIGJvZHkpO1xuXHRcdFx0XHRcdHdyYXBwZWRFcnIuc3RhdHVzQ29kZSA9IHdyYXBwZWRTdGF0dXNDb2RlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrKHdyYXBwZWRFcnIsIHJlc3BvbnNlLCB3cmFwcGVkSGVhZGVycywgdHJ1ZSwgd3JhcHBlZFN0YXR1c0NvZGUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHdyYXBwZWRIZWFkZXJzLCB0cnVlLCB3cmFwcGVkU3RhdHVzQ29kZSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIHBhcmFtU3RyaW5nKHBhcmFtcykge1xuXHRcdHZhciBwYXJhbVBhaXJzID0gW107XG5cdFx0aWYgKHBhcmFtcykge1xuXHRcdFx0Zm9yICh2YXIgbmVlZGxlIGluIHBhcmFtcykge1xuXHRcdFx0XHRwYXJhbVBhaXJzLnB1c2gobmVlZGxlICsgJz0nICsgcGFyYW1zW25lZWRsZV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGFyYW1QYWlycy5qb2luKCcmJyk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpIHtcblx0XHRyZXR1cm4gcGF0aCArIChwYXJhbXMgPyAnPycgOiAnJykgKyBwYXJhbVN0cmluZyhwYXJhbXMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIHBhcmFtcykge1xuXHRcdHJldHVybiBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnUmVjZWl2ZWQgRXJyb3I7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgRXJyb3I6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJyxcblx0XHRcdFx0XHQnUmVjZWl2ZWQ7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgSGVhZGVyczogJyArIHBhcmFtU3RyaW5nKGhlYWRlcnMpICsgJzsgU3RhdHVzQ29kZTogJyArIHN0YXR1c0NvZGUgKyAnOyBCb2R5OiAnICsgKGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQnVmZmVyKGJvZHkpID8gYm9keS50b1N0cmluZygpIDogYm9keSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpOyB9XG5cdFx0fVxuXHR9XG5cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRob3V0Qm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0UmVzb3VyY2VbbWV0aG9kXSA9IGZ1bmN0aW9uKHJlc3QsIHBhdGgsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcblx0XHRcdFJlc291cmNlWydkbyddKG1ldGhvZCwgcmVzdCwgcGF0aCwgbnVsbCwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0fSk7XG5cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRoQm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XG5cdFx0UmVzb3VyY2VbbWV0aG9kXSA9IGZ1bmN0aW9uKHJlc3QsIHBhdGgsIGJvZHksIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcblx0XHRcdFJlc291cmNlWydkbyddKG1ldGhvZCwgcmVzdCwgcGF0aCwgYm9keSwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG5cdFx0fTtcblx0fSk7XG5cblx0UmVzb3VyY2VbJ2RvJ10gPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHBhdGgsIGJvZHksIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcblx0XHRpZiAobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNob3VsZExvZyhsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPKSkge1xuXHRcdFx0Y2FsbGJhY2sgPSBsb2dSZXNwb25zZUhhbmRsZXIoY2FsbGJhY2ssIG1ldGhvZCwgcGF0aCwgb3JpZ3BhcmFtcyk7XG5cdFx0fVxuXG5cdFx0aWYoZW52ZWxvcGUpIHtcblx0XHRcdGNhbGxiYWNrID0gKGNhbGxiYWNrICYmIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGVudmVsb3BlKSk7XG5cdFx0XHQob3JpZ3BhcmFtcyA9IChvcmlncGFyYW1zIHx8IHt9KSlbJ2VudmVsb3BlJ10gPSBlbnZlbG9wZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBkb1JlcXVlc3QoaGVhZGVycywgcGFyYW1zKSB7XG5cdFx0XHRpZiAobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNob3VsZExvZyhsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPKSkge1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmc7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpKTtcblx0XHRcdH1cblxuXHRcdFx0dmFyIGFyZ3MgPSBbcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBmdW5jdGlvbihlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcblx0XHRcdFx0aWYoZXJyICYmIGF1dGhbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNUb2tlbkVycihlcnIpKSB7XG5cdFx0XHRcdFx0LyogdG9rZW4gaGFzIGV4cGlyZWQsIHNvIGdldCBhIG5ldyBvbmUgKi9cblx0XHRcdFx0XHRyZXN0LmF1dGguYXV0aG9yaXplKG51bGwsIG51bGwsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdC8qIHJldHJ5IC4uLiAqL1xuXHRcdFx0XHRcdFx0d2l0aEF1dGhEZXRhaWxzKHJlc3QsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBjYWxsYmFjaywgZG9SZXF1ZXN0KTtcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2soZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcblx0XHRcdH1dO1xuXHRcdFx0aWYgKCFib2R5KSB7XG5cdFx0XHRcdGFyZ3Muc3BsaWNlKDMsIDEpO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNob3VsZExvZyhsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPKSkge1xuXHRcdFx0XHR2YXIgZGVjb2RlZEJvZHkgPSBib2R5O1xuXHRcdFx0XHRpZiAoKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnKS5pbmRleE9mKCdtc2dwYWNrJykgPiAwKSB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdGRlY29kZWRCb2R5ID0gbXNncGFjay5kZWNvZGUoYm9keSk7XG5cdFx0XHRcdFx0fSBjYXRjaCAoZGVjb2RlRXJyKSB7XG5cdFx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmcgTXNnUGFjayBEZWNvZGluZyBFcnJvcjogJyArIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluc3BlY3RFcnJvcihkZWNvZGVFcnIpKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEJvZHk6ICcgKyBkZWNvZGVkQm9keSk7XG5cdFx0XHR9XG5cdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XG5cdFx0fVxuXG5cdFx0d2l0aEF1dGhEZXRhaWxzKHJlc3QsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBjYWxsYmFjaywgZG9SZXF1ZXN0KTtcblx0fTtcblxuXHRyZXR1cm4gUmVzb3VyY2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcmVzb3VyY2UgPSAocmVzb3VyY2VfUmVzb3VyY2UpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3BhZ2luYXRlZHJlc291cmNlLmpzXG5cblxuXG5cblxudmFyIHBhZ2luYXRlZHJlc291cmNlX1BhZ2luYXRlZFJlc291cmNlID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldFJlbFBhcmFtcyhsaW5rVXJsKSB7XG5cdFx0dmFyIHVybE1hdGNoID0gbGlua1VybC5tYXRjaCgvXlxcLlxcLyhcXHcrKVxcPyguKikkLyk7XG5cdFx0cmV0dXJuIHVybE1hdGNoICYmIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnBhcnNlUXVlcnlTdHJpbmcodXJsTWF0Y2hbMl0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKSB7XG5cdFx0aWYodHlwZW9mKGxpbmtIZWFkZXIpID09ICdzdHJpbmcnKVxuXHRcdFx0bGlua0hlYWRlciA9IGxpbmtIZWFkZXIuc3BsaXQoJywnKTtcblxuXHRcdHZhciByZWxQYXJhbXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGlua0hlYWRlci5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGxpbmtNYXRjaCA9IGxpbmtIZWFkZXJbaV0ubWF0Y2goL15cXHMqPCguKyk+O1xccypyZWw9XCIoXFx3KylcIiQvKTtcblx0XHRcdGlmKGxpbmtNYXRjaCkge1xuXHRcdFx0XHR2YXIgcGFyYW1zID0gZ2V0UmVsUGFyYW1zKGxpbmtNYXRjaFsxXSk7XG5cdFx0XHRcdGlmKHBhcmFtcylcblx0XHRcdFx0XHRyZWxQYXJhbXNbbGlua01hdGNoWzJdXSA9IHBhcmFtcztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlbFBhcmFtcztcblx0fVxuXG5cdGZ1bmN0aW9uIFBhZ2luYXRlZFJlc291cmNlKHJlc3QsIHBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBib2R5SGFuZGxlciwgdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xuXHRcdHRoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG5cdFx0dGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlO1xuXHRcdHRoaXMuYm9keUhhbmRsZXIgPSBib2R5SGFuZGxlcjtcblx0XHR0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IHVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSB8fCBmYWxzZTtcblx0fVxuXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzV2l0aG91dEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0Y2xpZW50X3Jlc291cmNlW21ldGhvZF0oc2VsZi5yZXN0LCBzZWxmLnBhdGgsIHNlbGYuaGVhZGVycywgcGFyYW1zLCBzZWxmLmVudmVsb3BlLCBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHRcdHNlbGYuaGFuZGxlUGFnZShlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjayk7XG5cdFx0XHR9KTtcblx0XHR9O1xuXHR9KVxuXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzV2l0aEJvZHksIGZ1bmN0aW9uKG1ldGhvZCkge1xuXHRcdFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24ocGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdFx0Y2xpZW50X3Jlc291cmNlW21ldGhvZF0oc2VsZi5yZXN0LCBzZWxmLnBhdGgsIGJvZHksIHNlbGYuaGVhZGVycywgcGFyYW1zLCBzZWxmLmVudmVsb3BlLCBmdW5jdGlvbihlcnIsIHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG5cdFx0XHRcdGlmKGNhbGxiYWNrKSB7XG5cdFx0XHRcdFx0c2VsZi5oYW5kbGVQYWdlKGVyciwgcmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fTtcblx0fSk7XG5cblx0ZnVuY3Rpb24gcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHVzZUhQUikge1xuXHRcdC8qIElmIHVzaW5nIGh0dHBQYWdpbmF0ZWRSZXNwb25zZSwgZXJyb3JzIGZyb20gQWJseSBhcmUgcmV0dXJuZWQgYXMgcGFydCBvZlxuXHRcdCAqIHRoZSBIUFIsIG9ubHkgZG8gY2FsbGJhY2soZXJyKSBmb3IgbmV0d29yayBlcnJvcnMgZXRjLiB3aGljaCBkb24ndFxuXHRcdCAqIHJldHVybiBhIGJvZHkgYW5kL29yIGhhdmUgbm8gYWJseS1vcmlnaW5hdGVkIGVycm9yIGNvZGUgKG5vbi1udW1lcmljXG5cdFx0ICogZXJyb3IgY29kZXMgb3JpZ2luYXRlIGZyb20gbm9kZSkgKi9cblx0XHRyZXR1cm4gISh1c2VIUFIgJiYgKGJvZHkgfHwgdHlwZW9mIGVyci5jb2RlID09PSAnbnVtYmVyJykpO1xuXHR9XG5cblx0UGFnaW5hdGVkUmVzb3VyY2UucHJvdG90eXBlLmhhbmRsZVBhZ2UgPSBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlLCBjYWxsYmFjaykge1xuXHRcdGlmKGVyciAmJiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdQYWdpbmF0ZWRSZXNvdXJjZS5oYW5kbGVQYWdlKCknLCAnVW5leHBlY3RlZCBlcnJvciBnZXR0aW5nIHJlc291cmNlOiBlcnIgPSAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGl0ZW1zLCBsaW5rSGVhZGVyLCByZWxQYXJhbXM7XG5cdFx0dHJ5IHtcblx0XHRcdGl0ZW1zID0gdGhpcy5ib2R5SGFuZGxlcihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCk7XG5cdFx0fSBjYXRjaChlKSB7XG5cdFx0XHQvKiBJZiB3ZSBnb3QgYW4gZXJyb3IsIHRoZSBmYWlsdXJlIHRvIHBhcnNlIHRoZSBib2R5IGlzIGFsbW9zdCBjZXJ0YWlubHlcblx0XHRcdCAqIGR1ZSB0byB0aGF0LCBzbyBjYiB3aXRoIHRoYXQgaW4gcHJlZmVyZW5jZSB0byB0aGUgcGFyc2UgZXJyb3IgKi9cblx0XHRcdGNhbGxiYWNrKGVyciB8fCBlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihoZWFkZXJzICYmIChsaW5rSGVhZGVyID0gKGhlYWRlcnNbJ0xpbmsnXSB8fCBoZWFkZXJzWydsaW5rJ10pKSkge1xuXHRcdFx0cmVsUGFyYW1zID0gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKTtcblx0XHR9XG5cblx0XHRpZih0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgbmV3IEh0dHBQYWdpbmF0ZWRSZXNwb25zZSh0aGlzLCBpdGVtcywgaGVhZGVycywgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgbmV3IFBhZ2luYXRlZFJlc3VsdCh0aGlzLCBpdGVtcywgcmVsUGFyYW1zKSk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIFBhZ2luYXRlZFJlc3VsdChyZXNvdXJjZSwgaXRlbXMsIHJlbFBhcmFtcykge1xuXHRcdHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcblx0XHR0aGlzLml0ZW1zID0gaXRlbXM7XG5cblx0XHRpZihyZWxQYXJhbXMpIHtcblx0XHRcdHZhciBzZWxmID0gdGhpcztcblx0XHRcdGlmKCdmaXJzdCcgaW4gcmVsUGFyYW1zKSB7XG5cdFx0XHRcdHRoaXMuZmlyc3QgPSBmdW5jdGlvbihjYikge1xuXHRcdFx0XHRcdGlmKCFjYiAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeShzZWxmLCAnZmlyc3QnLCBbXSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlbGYuZ2V0KHJlbFBhcmFtcy5maXJzdCwgY2IpO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYoJ2N1cnJlbnQnIGluIHJlbFBhcmFtcykge1xuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSBmdW5jdGlvbihjYikge1xuXHRcdFx0XHRcdGlmKCFjYiAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeShzZWxmLCAnY3VycmVudCcsIFtdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5nZXQocmVsUGFyYW1zLmN1cnJlbnQsIGNiKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdHRoaXMubmV4dCA9IGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRcdGlmKCFjYiAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkoc2VsZiwgJ25leHQnLCBbXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoJ25leHQnIGluIHJlbFBhcmFtcykge1xuXHRcdFx0XHRcdHNlbGYuZ2V0KHJlbFBhcmFtcy5uZXh0LCBjYik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y2IobnVsbCwgbnVsbCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRcdHRoaXMuaGFzTmV4dCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gKCduZXh0JyBpbiByZWxQYXJhbXMpIH07XG5cdFx0XHR0aGlzLmlzTGFzdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gIXRoaXMuaGFzTmV4dCgpOyB9XG5cdFx0fVxuXHR9XG5cblx0LyogV2UgYXNzdW1lIHRoYXQgb25seSB0aGUgaW5pdGlhbCByZXF1ZXN0IGNhbiBiZSBhIFBPU1QsIGFuZCB0aGF0IGFjY2Vzc2luZ1xuXHQgKiB0aGUgcmVzdCBvZiBhIG11bHRpcGFnZSBzZXQgb2YgcmVzdWx0cyBjYW4gYWx3YXlzIGJlIGRvbmUgd2l0aCBHRVQgKi9cblx0UGFnaW5hdGVkUmVzdWx0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMucmVzb3VyY2U7XG5cdFx0Y2xpZW50X3Jlc291cmNlLmdldChyZXMucmVzdCwgcmVzLnBhdGgsIHJlcy5oZWFkZXJzLCBwYXJhbXMsIHJlcy5lbnZlbG9wZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuXHRcdFx0cmVzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuXHRcdH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIEh0dHBQYWdpbmF0ZWRSZXNwb25zZShyZXNvdXJjZSwgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSB7XG5cdFx0UGFnaW5hdGVkUmVzdWx0LmNhbGwodGhpcywgcmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdFx0dGhpcy5zdWNjZXNzID0gc3RhdHVzQ29kZSA8IDMwMCAmJiBzdGF0dXNDb2RlID49IDIwMDtcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuZXJyb3JDb2RlID0gZXJyICYmIGVyci5jb2RlO1xuXHRcdHRoaXMuZXJyb3JNZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKEh0dHBQYWdpbmF0ZWRSZXNwb25zZSwgUGFnaW5hdGVkUmVzdWx0KTtcblxuXHRyZXR1cm4gUGFnaW5hdGVkUmVzb3VyY2U7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwYWdpbmF0ZWRyZXNvdXJjZSA9IChwYWdpbmF0ZWRyZXNvdXJjZV9QYWdpbmF0ZWRSZXNvdXJjZSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL2Vycm9yaW5mby5qc1xudmFyIGVycm9yaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9wdXNoY2hhbm5lbHN1YnNjcmlwdGlvbi5qc1xuXG5cbnZhciBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbiA9IChmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbigpIHtcblx0XHR0aGlzLmNoYW5uZWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5kZXZpY2VJZCA9IHVuZGVmaW5lZDtcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIE92ZXJsb2FkIHRvSlNPTigpIHRvIGludGVyY2VwdCBKU09OLnN0cmluZ2lmeSgpXG5cdCAqIEByZXR1cm4geyp9XG5cdCAqL1xuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcblx0XHRcdGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuXHRcdFx0Y2xpZW50SWQ6IHRoaXMuY2xpZW50SWRcblx0XHR9O1xuXHR9O1xuXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZXN1bHQgPSAnW1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uJztcblx0XHRpZih0aGlzLmNoYW5uZWwpXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2hhbm5lbD0nICsgdGhpcy5jaGFubmVsO1xuXHRcdGlmKHRoaXMuZGV2aWNlSWQpXG5cdFx0XHRyZXN1bHQgKz0gJzsgZGV2aWNlSWQ9JyArIHRoaXMuZGV2aWNlSWQ7XG5cdFx0aWYodGhpcy5jbGllbnRJZClcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcblx0XHRyZXN1bHQgKz0gJ10nO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24udG9SZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUJvZHk7XG5cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHksIGZvcm1hdCkge1xuXHRcdGlmKGZvcm1hdCkge1xuXHRcdFx0Ym9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcblx0XHR9XG5cblx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0FycmF5KGJvZHkpKSB7XG5cdFx0XHRyZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlc0FycmF5KGJvZHkpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyhib2R5KTtcblx0XHR9XG5cdH07XG5cblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuXHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihuZXcgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSwgdmFsdWVzKTtcblx0fTtcblxuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHR2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fTtcblxuXHRyZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbiA9IChwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbik7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcHVzaC5qc1xuXG5cblxuXG5cblxuXG5cbnZhciBwdXNoX1B1c2ggPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuXHRmdW5jdGlvbiBQdXNoKHJlc3QpIHtcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xuXHRcdHRoaXMuYWRtaW4gPSBuZXcgQWRtaW4ocmVzdCk7XG5cdH1cblxuXHRmdW5jdGlvbiBBZG1pbihyZXN0KSB7XG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcblx0XHR0aGlzLmRldmljZVJlZ2lzdHJhdGlvbnMgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9ucyhyZXN0KTtcblx0XHR0aGlzLmNoYW5uZWxTdWJzY3JpcHRpb25zID0gbmV3IENoYW5uZWxTdWJzY3JpcHRpb25zKHJlc3QpO1xuXHR9XG5cblx0QWRtaW4ucHJvdG90eXBlLnB1Ymxpc2ggPSBmdW5jdGlvbihyZWNpcGllbnQsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG5cdFx0dmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdHJlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oe3JlY2lwaWVudDogcmVjaXBpZW50fSwgcGF5bG9hZCksXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRwYXJhbXMgPSB7fTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5LCBmb3JtYXQpO1xuXHRcdGNsaWVudF9yZXNvdXJjZS5wb3N0KHJlc3QsICcvcHVzaC9wdWJsaXNoJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVycikgeyBjYWxsYmFjayhlcnIpOyB9KTtcblx0fTtcblxuXHRmdW5jdGlvbiBEZXZpY2VSZWdpc3RyYXRpb25zKHJlc3QpIHtcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xuXHR9XG5cblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uKGRldmljZSwgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdDtcblx0XHR2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0cmVxdWVzdEJvZHkgPSBkZXZpY2VkZXRhaWxzLmZyb21WYWx1ZXMoZGV2aWNlKSxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KSxcblx0XHRcdHBhcmFtcyA9IHt9O1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzYXZlJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRyZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUJvZHkocmVxdWVzdEJvZHksIGZvcm1hdCk7XG5cdFx0Y2xpZW50X3Jlc291cmNlLnB1dChyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZS5pZCksIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHRjYWxsYmFjayhlcnIsICFlcnIgJiYgZGV2aWNlZGV0YWlscy5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpKTtcblx0XHR9KTtcblx0fTtcblxuXHREZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihkZXZpY2VJZE9yRGV0YWlscywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0ZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgZGV2aWNlSWQgIT09ICdzdHJpbmcnIHx8ICFkZXZpY2VJZC5sZW5ndGgpIHtcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0ZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjZ2V0IG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlscycsIDQwMDAwLCA0MDApKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGNsaWVudF9yZXNvdXJjZS5nZXQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksIGhlYWRlcnMsIHt9LCBmYWxzZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0Y2FsbGJhY2soZXJyLCAhZXJyICYmIGRldmljZWRldGFpbHMuZnJvbVJlc3BvbnNlQm9keShib2R5LCAhdW5wYWNrZWQgJiYgZm9ybWF0KSk7XG5cdFx0fSk7XG5cdH07XG5cblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2xpc3QnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIGRldmljZWRldGFpbHMuZnJvbVJlc3BvbnNlQm9keShib2R5LCAhdW5wYWNrZWQgJiYgZm9ybWF0KTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGRldmljZUlkT3JEZXRhaWxzLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRwYXJhbXMgPSB7fSxcblx0XHRcdGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGRldmljZUlkICE9PSAnc3RyaW5nJyB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI3JlbW92ZSBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHMnLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xuXG5cdFx0Y2xpZW50X3Jlc291cmNlWydkZWxldGUnXShyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKGVycik7IH0pO1xuXHR9O1xuXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XG5cblx0XHRjbGllbnRfcmVzb3VyY2VbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zJywgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKGVycik7IH0pO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIENoYW5uZWxTdWJzY3JpcHRpb25zKHJlc3QpIHtcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xuXHR9XG5cblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihzdWJzY3JpcHRpb24sIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG5cdFx0dmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdHJlcXVlc3RCb2R5ID0gcHVzaGNoYW5uZWxzdWJzY3JpcHRpb24uZnJvbVZhbHVlcyhzdWJzY3JpcHRpb24pLFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpLFxuXHRcdFx0cGFyYW1zID0ge307XG5cblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3NhdmUnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdHJlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keShyZXF1ZXN0Qm9keSwgZm9ybWF0KTtcblx0XHRjbGllbnRfcmVzb3VyY2UucG9zdChyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0Y2FsbGJhY2soZXJyLCAhZXJyICYmIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCkpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnbGlzdCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsICcvcHVzaC9jaGFubmVsU3Vic2NyaXB0aW9ucycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncmVtb3ZlV2hlcmUnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdGNsaWVudF9yZXNvdXJjZVsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKGVycik7IH0pO1xuXHR9O1xuXG5cdC8qIENoYW5uZWxTdWJzY3JpcHRpb25zIGhhdmUgbm8gdW5pcXVlIGlkOyByZW1vdmluZyBvbmUgaXMgZXF1aXZhbGVudCB0byByZW1vdmVXaGVyZSBieSBpdHMgcHJvcGVydGllcyAqL1xuXHRDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUucmVtb3ZlID0gQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlO1xuXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5saXN0Q2hhbm5lbHMgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsaXN0Q2hhbm5lbHMnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcblxuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UocmVzdCwgJy9wdXNoL2NoYW5uZWxzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHR2YXIgZiA9ICF1bnBhY2tlZCAmJiBmb3JtYXQ7XG5cblx0XHRcdGlmKGYpIHtcblx0XHRcdFx0Ym9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcblx0XHRcdH1cblxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0Ym9keVtpXSA9IFN0cmluZyhib2R5W2ldKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib2R5O1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0cmV0dXJuIFB1c2g7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwdXNoID0gKHB1c2hfUHVzaCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvZXZlbnRlbWl0dGVyLmpzXG52YXIgZXZlbnRlbWl0dGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvcHJlc2VuY2VtZXNzYWdlLmpzXG52YXIgcHJlc2VuY2VtZXNzYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcHJlc2VuY2UuanNcblxuXG5cblxuXG5cblxudmFyIHByZXNlbmNlX1ByZXNlbmNlID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBub29wKCkge31cblx0ZnVuY3Rpb24gUHJlc2VuY2UoY2hhbm5lbCkge1xuXHRcdHRoaXMuY2hhbm5lbCA9IGNoYW5uZWw7XG5cdFx0dGhpcy5iYXNlUGF0aCA9IGNoYW5uZWwuYmFzZVBhdGggKyAnL3ByZXNlbmNlJztcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhQcmVzZW5jZSwgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcblxuXHRQcmVzZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1ByZXNlbmNlLmdldCgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciByZXN0ID0gdGhpcy5jaGFubmVsLnJlc3QsXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsIHRoaXMuYmFzZVBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0cmV0dXJuIHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xuXHRcdH0pKS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UHJlc2VuY2UucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUHJlc2VuY2UuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUpO1xuXHRcdHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UHJlc2VuY2UucHJvdG90eXBlLl9oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnX2hpc3RvcnknLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIHJlc3QgPSB0aGlzLmNoYW5uZWwucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRjaGFubmVsID0gdGhpcy5jaGFubmVsO1xuXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG5cblx0XHR2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL2hpc3RvcnknLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCAhdW5wYWNrZWQgJiYgZm9ybWF0KTtcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdHJldHVybiBQcmVzZW5jZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudF9wcmVzZW5jZSA9IChwcmVzZW5jZV9QcmVzZW5jZSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2NyeXB0by5qc1xudmFyIHV0aWxfY3J5cHRvID0gX193ZWJwYWNrX3JlcXVpcmVfXygxOSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL21lc3NhZ2UuanNcbnZhciB0eXBlc19tZXNzYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9jaGFubmVsLmpzXG5cblxuXG5cblxuXG5cblxuXG5cblxudmFyIGNoYW5uZWxfQ2hhbm5lbCA9IChmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XG5cdHZhciBNU0dfSURfRU5UUk9QWV9CWVRFUyA9IDk7XG5cblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXG5cdGZ1bmN0aW9uIENoYW5uZWwocmVzdCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdDaGFubmVsKCknLCAnc3RhcnRlZDsgbmFtZSA9ICcgKyBuYW1lKTtcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xuXHRcdHRoaXMubmFtZSA9IG5hbWU7XG5cdFx0dGhpcy5iYXNlUGF0aCA9ICcvY2hhbm5lbHMvJyArIGVuY29kZVVSSUNvbXBvbmVudChuYW1lKTtcblx0XHR0aGlzLnByZXNlbmNlID0gbmV3IGNsaWVudF9wcmVzZW5jZSh0aGlzKTtcblx0XHR0aGlzLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKENoYW5uZWwsIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR0aGlzLmNoYW5uZWxPcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0aWYob3B0aW9ucy5jaXBoZXIpIHtcblx0XHRcdGlmKCF1dGlsX2NyeXB0b1tcImFcIiAvKiBkZWZhdWx0ICovXSkgdGhyb3cgbmV3IEVycm9yKCdFbmNyeXB0aW9uIG5vdCBlbmFibGVkOyB1c2UgYWJseS5lbmNyeXB0aW9uLmpzIGluc3RlYWQnKTtcblx0XHRcdHZhciBjaXBoZXIgPSB1dGlsX2NyeXB0b1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIpO1xuXHRcdFx0b3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xuXHRcdFx0b3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcblx0XHR9IGVsc2UgaWYoJ2NpcGhlcicgaW4gb3B0aW9ucykge1xuXHRcdFx0LyogRG9uJ3QgZGVhY3RpdmF0ZSBhbiBleGlzdGluZyBjaXBoZXIgdW5sZXNzIG9wdGlvbnNcblx0XHRcdCAqIGhhcyBhICdjaXBoZXInIGtleSB0aGF0J3MgZmFsc2V5ICovXG5cdFx0XHRvcHRpb25zLmNpcGhlciA9IG51bGw7XG5cdFx0XHRvcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBudWxsO1xuXHRcdH1cblx0fTtcblxuXHRDaGFubmVsLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0NoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdoaXN0b3J5JywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dGhpcy5faGlzdG9yeShwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRDaGFubmVsLnByb3RvdHlwZS5faGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCksXG5cdFx0XHRjaGFubmVsID0gdGhpcztcblxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UocmVzdCwgdGhpcy5iYXNlUGF0aCArICcvbWVzc2FnZXMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgIXVucGFja2VkICYmIGZvcm1hdCk7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRmdW5jdGlvbiBhbGxFbXB0eUlkcyhtZXNzYWdlcykge1xuXHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJFdmVyeShtZXNzYWdlcywgZnVuY3Rpb24obWVzc2FnZSkge1xuXHRcdFx0cmV0dXJuICFtZXNzYWdlLmlkO1xuXHRcdH0pO1xuXHR9XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGgsXG5cdFx0XHRmaXJzdCA9IGFyZ3VtZW50c1swXSxcblx0XHRcdHNlY29uZCA9IGFyZ3VtZW50c1sxXSxcblx0XHRcdGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ0NvdW50IC0gMV0sXG5cdFx0XHRtZXNzYWdlcyxcblx0XHRcdHBhcmFtcyxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGZpcnN0ID09PSAnc3RyaW5nJyB8fCBmaXJzdCA9PT0gbnVsbCkge1xuXHRcdFx0LyogKG5hbWUsIGRhdGEsIC4uLikgKi9cblx0XHRcdG1lc3NhZ2VzID0gW3R5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7bmFtZTogZmlyc3QsIGRhdGE6IHNlY29uZH0pXTtcblx0XHRcdHBhcmFtcyA9IGFyZ3VtZW50c1syXTtcblx0XHR9IGVsc2UgaWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPYmplY3QoZmlyc3QpKSB7XG5cdFx0XHRtZXNzYWdlcyA9IFt0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoZmlyc3QpXTtcblx0XHRcdHBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcblx0XHR9IGVsc2UgaWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShmaXJzdCkpIHtcblx0XHRcdG1lc3NhZ2VzID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzQXJyYXkoZmlyc3QpO1xuXHRcdFx0cGFyYW1zID0gYXJndW1lbnRzWzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUaGUgc2luZ2xlLWFyZ3VtZW50IGZvcm0gb2YgcHVibGlzaCgpIGV4cGVjdHMgYSBtZXNzYWdlIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHMnLCA0MDAxMywgNDAwKTtcblx0XHR9XG5cblx0XHRpZih0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyB8fCAhcGFyYW1zKSB7XG5cdFx0XHQvKiBObyBwYXJhbXMgc3VwcGxpZWQgKHNvIGFmdGVyLW1lc3NhZ2UgYXJndW1lbnQgaXMganVzdCB0aGUgY2FsbGJhY2sgb3IgdW5kZWZpbmVkKSAqL1xuXHRcdFx0cGFyYW1zID0ge307XG5cdFx0fVxuXG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXG5cdFx0XHRvcHRpb25zID0gcmVzdC5vcHRpb25zLFxuXHRcdFx0Zm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHJlc3Qub3B0aW9ucy5pZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcsXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCk7XG5cblx0XHRpZihvcHRpb25zLmhlYWRlcnMpXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0aWYoaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nICYmIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSkge1xuXHRcdFx0dmFyIG1zZ0lkQmFzZSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJhbmRvbVN0cmluZyhNU0dfSURfRU5UUk9QWV9CWVRFUyk7XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKG1lc3NhZ2VzLCBmdW5jdGlvbihtZXNzYWdlLCBpbmRleCkge1xuXHRcdFx0XHRtZXNzYWdlLmlkID0gbXNnSWRCYXNlICsgJzonICsgaW5kZXgudG9TdHJpbmcoKTtcblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0LyogUlNMMWkgKi9cblx0XHRcdHZhciBzaXplID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRNZXNzYWdlc1NpemUobWVzc2FnZXMpLFxuXHRcdFx0XHRtYXhNZXNzYWdlU2l6ZSA9IG9wdGlvbnMubWF4TWVzc2FnZVNpemU7XG5cdFx0XHRpZihzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICggd2FzICcgKyBzaXplICsgJyBieXRlczsgbGltaXQgaXMgJyArIG1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknLCA0MDAwOSwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0c2VsZi5fcHVibGlzaCh0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNlcmlhbGl6ZShtZXNzYWdlcywgZm9ybWF0KSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjayk7XG5cdFx0fSk7XG5cdH07XG5cblx0Q2hhbm5lbC5wcm90b3R5cGUuX3B1Ymxpc2ggPSBmdW5jdGlvbihyZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGNsaWVudF9yZXNvdXJjZS5wb3N0KHRoaXMucmVzdCwgdGhpcy5iYXNlUGF0aCArICcvbWVzc2FnZXMnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdHJldHVybiBDaGFubmVsO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50X2NoYW5uZWwgPSAoY2hhbm5lbF9DaGFubmVsKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL3N0YXRzLmpzXG5cblxudmFyIHN0YXRzX1N0YXRzID0gKGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIE1lc3NhZ2VDb3VudCh2YWx1ZXMpIHtcblx0XHR0aGlzLmNvdW50ID0gKHZhbHVlcyAmJiB2YWx1ZXMuY291bnQpIHx8IDA7XG5cdFx0dGhpcy5kYXRhID0gKHZhbHVlcyAmJiB2YWx1ZXMuZGF0YSkgfHwgMDtcblx0XHR0aGlzLnVuY29tcHJlc3NlZERhdGEgPSAodmFsdWVzICYmIHZhbHVlcy51bmNvbXByZXNzZWREYXRhKSB8fCAwO1xuXHRcdHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuXHRcdHRoaXMucmVmdXNlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnJlZnVzZWQpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdE1lc3NhZ2VDb3VudC5jYWxsKHRoaXMsIHZhbHVlcyk7XG5cdFx0dGhpcy5jYXRlZ29yeSA9IHVuZGVmaW5lZDtcblx0XHRpZiAodmFsdWVzICYmIHZhbHVlcy5jYXRlZ29yeSkge1xuXHRcdFx0dGhpcy5jYXRlZ29yeSA9IHsgfTtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZvckluT3duTm9uTnVsbFByb3BzKHZhbHVlcy5jYXRlZ29yeSwgZnVuY3Rpb24ocHJvcCkge1xuXHRcdFx0XHRzZWxmLmNhdGVnb3J5W3Byb3BdID0gbmV3IE1lc3NhZ2VDb3VudCh2YWx1ZXMuY2F0ZWdvcnlbcHJvcF0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gUmVzb3VyY2VDb3VudCh2YWx1ZXMpIHtcblx0XHR0aGlzLnBlYWsgPSAodmFsdWVzICYmIHZhbHVlcy5wZWFrKSB8fCAwO1xuXHRcdHRoaXMubWluID0gKHZhbHVlcyAmJiB2YWx1ZXMubWluKSB8fCAwO1xuXHRcdHRoaXMubWVhbiA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1lYW4pIHx8IDA7XG5cdFx0dGhpcy5vcGVuZWQgPSAodmFsdWVzICYmIHZhbHVlcy5vcGVuZWQpIHx8IDA7XG5cdFx0dGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcblx0fVxuXG5cdGZ1bmN0aW9uIFJlcXVlc3RDb3VudCh2YWx1ZXMpIHtcblx0XHR0aGlzLnN1Y2NlZWRlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnN1Y2NlZWRlZCkgfHwgMDtcblx0XHR0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcblx0XHR0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gQ29ubmVjdGlvblR5cGVzKHZhbHVlcykge1xuXHRcdHRoaXMucGxhaW4gPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnBsYWluKTtcblx0XHR0aGlzLnRscyA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMudGxzKTtcblx0XHR0aGlzLmFsbCA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lc3NhZ2VUeXBlcyh2YWx1ZXMpIHtcblx0XHR0aGlzLm1lc3NhZ2VzID0gbmV3IE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMgJiYgdmFsdWVzLm1lc3NhZ2VzKTtcblx0XHR0aGlzLnByZXNlbmNlID0gbmV3IE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMgJiYgdmFsdWVzLnByZXNlbmNlKTtcblx0XHR0aGlzLmFsbCA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuXHR9XG5cblx0ZnVuY3Rpb24gTWVzc2FnZVRyYWZmaWModmFsdWVzKSB7XG5cdFx0dGhpcy5yZWFsdGltZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5yZWFsdGltZSk7XG5cdFx0dGhpcy5yZXN0ID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnJlc3QpO1xuXHRcdHRoaXMud2ViaG9vayA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy53ZWJob29rKTtcblx0XHR0aGlzLnNoYXJlZFF1ZXVlID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnNoYXJlZFF1ZXVlKTtcblx0XHR0aGlzLmV4dGVybmFsUXVldWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuZXh0ZXJuYWxRdWV1ZSk7XG5cdFx0dGhpcy5odHRwRXZlbnQgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuaHR0cEV2ZW50KTtcblx0XHR0aGlzLnB1c2ggPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucHVzaCk7XG5cdFx0dGhpcy5hbGwgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0fVxuXG5cdGZ1bmN0aW9uIE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcykge1xuXHRcdHRoaXMuYWxsICAgICAgICAgICA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuXHRcdHRoaXMuaW5ib3VuZCAgICAgICA9IG5ldyBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMgJiYgdmFsdWVzLmluYm91bmQpO1xuXHRcdHRoaXMub3V0Ym91bmQgICAgICA9IG5ldyBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMgJiYgdmFsdWVzLm91dGJvdW5kKTtcblx0fVxuXG5cdGZ1bmN0aW9uIFhjaGdNZXNzYWdlcyh2YWx1ZXMpIHtcblx0XHR0aGlzLmFsbCAgICAgICAgICAgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcblx0XHR0aGlzLnByb2R1Y2VyUGFpZCAgPSBuZXcgTWVzc2FnZURpcmVjdGlvbnModmFsdWVzICYmIHZhbHVlcy5wcm9kdWNlclBhaWQpO1xuXHRcdHRoaXMuY29uc3VtZXJQYWlkICA9IG5ldyBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMgJiYgdmFsdWVzLmNvbnN1bWVyUGFpZCk7XG5cdH1cblxuXHRmdW5jdGlvbiBQdXNoU3RhdHModmFsdWVzKSB7XG5cdFx0dGhpcy5tZXNzYWdlcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1lc3NhZ2VzKSB8fCAwO1xuXHRcdHZhciBub3RpZmljYXRpb25zID0gdmFsdWVzICYmIHZhbHVlcy5ub3RpZmljYXRpb25zO1xuXHRcdHRoaXMubm90aWZpY2F0aW9ucyA9IHtcblx0XHRcdGludmFsaWQ6IG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5pbnZhbGlkIHx8IDAsXG5cdFx0XHRhdHRlbXB0ZWQ6IG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5hdHRlbXB0ZWQgfHwgMCxcblx0XHRcdHN1Y2Nlc3NmdWw6IG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5zdWNjZXNzZnVsIHx8IDAsXG5cdFx0XHRmYWlsZWQ6IG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5mYWlsZWQgfHwgMFxuXHRcdH07XG5cdFx0dGhpcy5kaXJlY3RQdWJsaXNoZXMgPSAodmFsdWVzICYmIHZhbHVlcy5kaXJlY3RQdWJsaXNoZXMpIHx8IDA7XG5cdH1cblxuXHRmdW5jdGlvbiBQcm9jZXNzZWRDb3VudCh2YWx1ZXMpIHtcblx0XHR0aGlzLnN1Y2NlZWRlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnN1Y2NlZWRlZCkgfHwgMDtcblx0XHR0aGlzLnNraXBwZWQgPSAodmFsdWVzICYmIHZhbHVlcy5za2lwcGVkKSB8fCAwO1xuXHRcdHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuXHR9XG5cblx0ZnVuY3Rpb24gUHJvY2Vzc2VkTWVzc2FnZXModmFsdWVzKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHRoaXMuZGVsdGEgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHZhbHVlcyAmJiB2YWx1ZXMuZGVsdGEpIHtcblx0XHRcdHRoaXMuZGVsdGEgPSB7IH07XG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5mb3JJbk93bk5vbk51bGxQcm9wcyh2YWx1ZXMuZGVsdGEsIGZ1bmN0aW9uKHByb3ApIHtcblx0XHRcdFx0c2VsZi5kZWx0YVtwcm9wXSA9IG5ldyBQcm9jZXNzZWRDb3VudCh2YWx1ZXMuZGVsdGFbcHJvcF0pO1xuXHRcdFx0fSk7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gU3RhdHModmFsdWVzKSB7XG5cdFx0TWVzc2FnZURpcmVjdGlvbnMuY2FsbCh0aGlzLCB2YWx1ZXMpO1xuXHRcdHRoaXMucGVyc2lzdGVkICAgICA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5wZXJzaXN0ZWQpO1xuXHRcdHRoaXMuY29ubmVjdGlvbnMgICA9IG5ldyBDb25uZWN0aW9uVHlwZXModmFsdWVzICYmIHZhbHVlcy5jb25uZWN0aW9ucyk7XG5cdFx0dGhpcy5jaGFubmVscyAgICAgID0gbmV3IFJlc291cmNlQ291bnQodmFsdWVzICYmIHZhbHVlcy5jaGFubmVscyk7XG5cdFx0dGhpcy5hcGlSZXF1ZXN0cyAgID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFwaVJlcXVlc3RzKTtcblx0XHR0aGlzLnRva2VuUmVxdWVzdHMgPSBuZXcgUmVxdWVzdENvdW50KHZhbHVlcyAmJiB2YWx1ZXMudG9rZW5SZXF1ZXN0cyk7XG5cdFx0dGhpcy54Y2hnUHJvZHVjZXIgID0gbmV3IFhjaGdNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnhjaGdQcm9kdWNlcik7XG5cdFx0dGhpcy54Y2hnQ29uc3VtZXIgID0gbmV3IFhjaGdNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnhjaGdDb25zdW1lcik7XG5cdFx0dGhpcy5wdXNoICAgICAgICAgID0gbmV3IFB1c2hTdGF0cyh2YWx1ZXMgJiYgdmFsdWVzLnB1c2hTdGF0cyk7XG5cdFx0dGhpcy5wcm9jZXNzZWQgICAgID0gbmV3IFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMucHJvY2Vzc2VkKTtcblx0XHR0aGlzLmluUHJvZ3Jlc3MgICAgPSAodmFsdWVzICYmIHZhbHVlcy5pblByb2dyZXNzKSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy51bml0ICAgICAgICAgID0gKHZhbHVlcyAmJiB2YWx1ZXMudW5pdCkgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuaW50ZXJ2YWxJZCAgICA9ICh2YWx1ZXMgJiYgdmFsdWVzLmludGVydmFsSWQpIHx8IHVuZGVmaW5lZDtcblx0fVxuXG5cdFN0YXRzLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcblx0XHRyZXR1cm4gbmV3IFN0YXRzKHZhbHVlcyk7XG5cdH07XG5cblx0cmV0dXJuIFN0YXRzO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RhdHMgPSAoc3RhdHNfU3RhdHMpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3Jlc3QuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciByZXN0X1Jlc3QgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblx0dmFyIG1zZ3BhY2sgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1zZ3BhY2s7XG5cblx0ZnVuY3Rpb24gUmVzdChvcHRpb25zKSB7XG5cdFx0aWYoISh0aGlzIGluc3RhbmNlb2YgUmVzdCkpe1xuXHRcdFx0cmV0dXJuIG5ldyBSZXN0KG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdC8qIG5vcm1hbGlzZSBvcHRpb25zICovXG5cdFx0aWYoIW9wdGlvbnMpIHtcblx0XHRcdHZhciBtc2cgPSAnbm8gb3B0aW9ucyBwcm92aWRlZCc7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZXN0KCknLCBtc2cpO1xuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0fVxuXHRcdG9wdGlvbnMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xuXG5cdFx0aWYob3B0aW9ucy5sb2cpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zZXRMb2cob3B0aW9ucy5sb2cubGV2ZWwsIG9wdGlvbnMubG9nLmhhbmRsZXIpO1xuXHRcdH1cblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXN0KCknLCAnaW5pdGlhbGl6ZWQgd2l0aCBjbGllbnRPcHRpb25zICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0KG9wdGlvbnMpKTtcblxuXHRcdHRoaXMub3B0aW9ucyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucyk7XG5cblx0XHQvKiBwcm9jZXNzIG9wdGlvbnMgKi9cblx0XHRpZihvcHRpb25zLmtleSkge1xuXHRcdFx0dmFyIGtleU1hdGNoID0gb3B0aW9ucy5rZXkubWF0Y2goL14oW146XFxzXSspOihbXjouXFxzXSspJC8pO1xuXHRcdFx0aWYoIWtleU1hdGNoKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnaW52YWxpZCBrZXkgcGFyYW1ldGVyJztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVzdCgpJywgbXNnKTtcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XG5cdFx0XHR9XG5cdFx0XHRvcHRpb25zLmtleU5hbWUgPSBrZXlNYXRjaFsxXTtcblx0XHRcdG9wdGlvbnMua2V5U2VjcmV0ID0ga2V5TWF0Y2hbMl07XG5cdFx0fVxuXG5cdFx0aWYoJ2NsaWVudElkJyBpbiBvcHRpb25zKSB7XG5cdFx0XHRpZighKHR5cGVvZihvcHRpb25zLmNsaWVudElkKSA9PT0gJ3N0cmluZycgfHwgb3B0aW9ucy5jbGllbnRJZCA9PT0gbnVsbCkpXG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGwnLCA0MDAxMiwgNDAwKTtcblx0XHRcdGVsc2UgaWYob3B0aW9ucy5jbGllbnRJZCA9PT0gJyonKVxuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDYW7igJl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCB1c2Uge2RlZmF1bHRUb2tlblBhcmFtczoge2NsaWVudElkOiBcIipcIn19KScsIDQwMDEyLCA0MDApO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1Jlc3QoKScsICdzdGFydGVkOyB2ZXJzaW9uID0gJyArIGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxpYnN0cmluZyk7XG5cblx0XHR0aGlzLmJhc2VVcmkgPSB0aGlzLmF1dGhvcml0eSA9IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldEh0dHBTY2hlbWUob3B0aW9ucykgKyBob3N0ICsgJzonICsgZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0UG9ydChvcHRpb25zLCBmYWxzZSk7IH07XG5cdFx0dGhpcy5fY3VycmVudEZhbGxiYWNrID0gbnVsbDtcblxuXHRcdHRoaXMuc2VydmVyVGltZU9mZnNldCA9IG51bGw7XG5cdFx0dGhpcy5hdXRoID0gbmV3IGF1dGhbXCJhXCIgLyogZGVmYXVsdCAqL10odGhpcywgb3B0aW9ucyk7XG5cdFx0dGhpcy5jaGFubmVscyA9IG5ldyBDaGFubmVscyh0aGlzKTtcblx0XHR0aGlzLnB1c2ggPSBuZXcgcHVzaCh0aGlzKTtcblx0fVxuXG5cdFJlc3QucHJvdG90eXBlLnN0YXRzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzdGF0cycsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgaGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKCksXG5cdFx0XHRmb3JtYXQgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdDtcblxuXHRcdGlmKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuXG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZSh0aGlzLCAnL3N0YXRzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG5cdFx0XHR2YXIgc3RhdHNWYWx1ZXMgPSAodW5wYWNrZWQgPyBib2R5IDogSlNPTi5wYXJzZShib2R5KSk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgc3RhdHNWYWx1ZXMubGVuZ3RoOyBpKyspIHN0YXRzVmFsdWVzW2ldID0gc3RhdHMuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG5cdFx0XHRyZXR1cm4gc3RhdHNWYWx1ZXM7XG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZXN0LnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICd0aW1lJywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoKTtcblx0XHRpZih0aGlzLm9wdGlvbnMuaGVhZGVycylcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dmFyIHRpbWVVcmkgPSBmdW5jdGlvbihob3N0KSB7IHJldHVybiBzZWxmLmF1dGhvcml0eShob3N0KSArICcvdGltZScgfTtcblx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldCh0aGlzLCB0aW1lVXJpLCBoZWFkZXJzLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuXHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCF1bnBhY2tlZCkgcmVzID0gSlNPTi5wYXJzZShyZXMpO1xuXHRcdFx0dmFyIHRpbWUgPSByZXNbMF07XG5cdFx0XHRpZighdGltZSkge1xuXHRcdFx0XHRlcnIgPSBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yICh1bmV4cGVjdGVkIHJlc3VsdCB0eXBlIGZyb20gR0VUIC90aW1lKScpO1xuXHRcdFx0XHRlcnIuc3RhdHVzQ29kZSA9IDUwMDtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0LyogY2FsY3VsYXRlIHRpbWUgb2Zmc2V0IG9ubHkgb25jZSBmb3IgdGhpcyBkZXZpY2UgYnkgYWRkaW5nIHRvIHRoZSBwcm90b3R5cGUgKi9cblx0XHRcdHNlbGYuc2VydmVyVGltZU9mZnNldCA9ICh0aW1lIC0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubm93KCkpO1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdGltZSk7XG5cdFx0fSk7XG5cdH07XG5cblx0UmVzdC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcGF0aCwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzLCBjYWxsYmFjaykge1xuXHRcdHZhciB1c2VCaW5hcnkgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wsXG5cdFx0XHRlbmNvZGVyID0gdXNlQmluYXJ5ID8gbXNncGFjay5lbmNvZGU6IEpTT04uc3RyaW5naWZ5LFxuXHRcdFx0ZGVjb2RlciA9IHVzZUJpbmFyeSA/IG1zZ3BhY2suZGVjb2RlIDogSlNPTi5wYXJzZSxcblx0XHRcdGZvcm1hdCA9IHVzZUJpbmFyeSA/ICdtc2dwYWNrJyA6ICdqc29uJyxcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0O1xuXHRcdHBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcblx0XHRtZXRob2QgPSBtZXRob2QudG9Mb3dlckNhc2UoKTtcblx0XHR2YXIgaGVhZGVycyA9IG1ldGhvZCA9PSAnZ2V0JyA/IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCkgOiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KTtcblxuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZXF1ZXN0JywgW21ldGhvZCwgcGF0aCwgcGFyYW1zLCBib2R5LCBjdXN0b21IZWFkZXJzXSk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYodHlwZW9mIGJvZHkgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRib2R5ID0gZW5jb2Rlcihib2R5KTtcblx0XHR9XG5cdFx0aWYodGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcblx0XHR9XG5cdFx0aWYoY3VzdG9tSGVhZGVycykge1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgY3VzdG9tSGVhZGVycyk7XG5cdFx0fVxuXHRcdHZhciBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZSh0aGlzLCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24ocmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcblx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbnN1cmVBcnJheSh1bnBhY2tlZCA/IHJlc2JvZHkgOiBkZWNvZGVyKHJlc2JvZHkpKTtcblx0XHR9LCAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovIHRydWUpO1xuXG5cdFx0aWYoIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckluKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kcywgbWV0aG9kKSkge1xuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5zdXBwb3J0ZWQgbWV0aG9kICcgKyBtZXRob2QsIDQwNTAwLCA0MDUpO1xuXHRcdH1cblxuXHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckluKGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10ubWV0aG9kc1dpdGhCb2R5LCBtZXRob2QpKSB7XG5cdFx0XHRwYWdpbmF0ZWRSZXNvdXJjZVttZXRob2RdKHBhcmFtcywgYm9keSwgY2FsbGJhY2spO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYWdpbmF0ZWRSZXNvdXJjZVttZXRob2RdKHBhcmFtcywgY2FsbGJhY2spO1xuXHRcdH1cblx0fTtcblxuXHRSZXN0LnByb3RvdHlwZS5zZXRMb2cgPSBmdW5jdGlvbihsb2dPcHRpb25zKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnNldExvZyhsb2dPcHRpb25zLmxldmVsLCBsb2dPcHRpb25zLmhhbmRsZXIpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIENoYW5uZWxzKHJlc3QpIHtcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xuXHRcdHRoaXMuYWxsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0fVxuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lLCBjaGFubmVsT3B0aW9ucykge1xuXHRcdG5hbWUgPSBTdHJpbmcobmFtZSk7XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcblx0XHRpZighY2hhbm5lbCkge1xuXHRcdFx0dGhpcy5hbGxbbmFtZV0gPSBjaGFubmVsID0gbmV3IGNsaWVudF9jaGFubmVsKHRoaXMucmVzdCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuXHRcdH0gZWxzZSBpZihjaGFubmVsT3B0aW9ucykge1xuXHRcdFx0Y2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gY2hhbm5lbDtcblx0fTtcblxuXHQvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cblx0ICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cblx0Q2hhbm5lbHMucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbihuYW1lKSB7XG5cdFx0ZGVsZXRlIHRoaXMuYWxsW1N0cmluZyhuYW1lKV07XG5cdH07XG5cblx0cmV0dXJuIFJlc3Q7XG59KSgpO1xuXG5yZXN0X1Jlc3QuUHJvbWlzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0b3B0aW9ucyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucyk7XG5cdG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuXHRyZXR1cm4gbmV3IHJlc3RfUmVzdChvcHRpb25zKTtcbn07XG5cbnJlc3RfUmVzdC5DYWxsYmFja3MgPSByZXN0X1Jlc3Q7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNsaWVudF9yZXN0ID0gKHJlc3RfUmVzdCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3RyYW5zcG9ydC9jb25uZWN0aW9ubWFuYWdlci5qc1xudmFyIGNvbm5lY3Rpb25tYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uc3RhdGVjaGFuZ2UuanNcbnZhciBjb25uZWN0aW9uc3RhdGVjaGFuZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9jb25uZWN0aW9uLmpzXG5cblxuXG5cblxuXG52YXIgY29ubmVjdGlvbl9Db25uZWN0aW9uID0gKGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBub29wKCkge31cblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ29ubmVjdGlvbihhYmx5LCBvcHRpb25zKSB7XG5cdFx0ZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5hYmx5ID0gYWJseTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IGNvbm5lY3Rpb25tYW5hZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKGFibHksIG9wdGlvbnMpO1xuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlO1xuXHRcdHRoaXMua2V5ID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5zZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy50aW1lU2VyaWFsID0gdW5kZWZpbmVkO1xuXHRcdHRoaXMucmVjb3ZlcnlLZXkgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5lcnJvclJlYXNvbiA9IG51bGw7XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbignY29ubmVjdGlvbnN0YXRlJywgZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdHZhciBzdGF0ZSA9IHNlbGYuc3RhdGUgPSBzdGF0ZUNoYW5nZS5jdXJyZW50O1xuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubmV4dFRpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZW1pdChzdGF0ZSwgc3RhdGVDaGFuZ2UpO1xuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbigndXBkYXRlJywgZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ3VwZGF0ZScsIHN0YXRlQ2hhbmdlKTtcblx0XHRcdH0pO1xuXHRcdH0pO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKENvbm5lY3Rpb24sIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIGxpc3RlbmVyKSB7XG5cdFx0cmV0dXJuIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5wcm90b3R5cGUud2hlblN0YXRlLmNhbGwodGhpcywgc3RhdGUsIHRoaXMuc3RhdGUsIGxpc3RlbmVyLCBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dKHVuZGVmaW5lZCwgc3RhdGUpKTtcblx0fVxuXG5cdENvbm5lY3Rpb24ucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uLmNvbm5lY3QoKScsICcnKTtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xuXHR9O1xuXG5cdENvbm5lY3Rpb24ucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24ucGluZygpJywgJycpO1xuXHRcdGlmKCFjYWxsYmFjaykge1xuXHRcdFx0aWYodGhpcy5hYmx5Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncGluZycsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucGluZyhudWxsLCBjYWxsYmFjayk7XG5cdH07XG5cblx0Q29ubmVjdGlvbi5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uLmNsb3NlKCknLCAnY29ubmVjdGlvbktleSA9ICcgKyB0aGlzLmtleSk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY2xvc2luZyd9KTtcblx0fTtcblxuXHRyZXR1cm4gQ29ubmVjdGlvbjtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNvbm5lY3Rpb24gPSAoY29ubmVjdGlvbl9Db25uZWN0aW9uKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvcHJvdG9jb2xtZXNzYWdlLmpzXG52YXIgcHJvdG9jb2xtZXNzYWdlID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHJhbnNwb3J0L2Nvbm5lY3Rpb25lcnJvci5qc1xudmFyIGNvbm5lY3Rpb25lcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL211bHRpY2FzdGVyLmpzXG52YXIgdXRpbF9tdWx0aWNhc3RlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjIpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2NoYW5uZWxzdGF0ZWNoYW5nZS5qc1xudmFyIENoYW5uZWxTdGF0ZUNoYW5nZSA9IChmdW5jdGlvbigpIHtcblxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cblx0ZnVuY3Rpb24gQ2hhbm5lbFN0YXRlQ2hhbmdlKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCByZWFzb24pIHtcblx0XHR0aGlzLnByZXZpb3VzID0gcHJldmlvdXM7XG5cdFx0dGhpcy5jdXJyZW50ID0gY3VycmVudDtcblx0XHRpZihjdXJyZW50ID09PSAnYXR0YWNoZWQnKSB0aGlzLnJlc3VtZWQgPSByZXN1bWVkO1xuXHRcdGlmKHJlYXNvbikgdGhpcy5yZWFzb24gPSByZWFzb247XG5cdH1cblxuXHRyZXR1cm4gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xufSkoKTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2hhbm5lbHN0YXRlY2hhbmdlID0gKENoYW5uZWxTdGF0ZUNoYW5nZSk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcmVhbHRpbWVwcmVzZW5jZS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciByZWFsdGltZXByZXNlbmNlX1JlYWx0aW1lUHJlc2VuY2UgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblxuXHRmdW5jdGlvbiBtZW1iZXJLZXkoaXRlbSkge1xuXHRcdHJldHVybiBpdGVtLmNsaWVudElkICsgJzonICsgaXRlbS5jb25uZWN0aW9uSWQ7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDbGllbnRJZChyZWFsdGltZVByZXNlbmNlKSB7XG5cdFx0cmV0dXJuIHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZS5hdXRoLmNsaWVudElkO1xuXHR9XG5cblx0ZnVuY3Rpb24gaXNBbm9ueW1vdXNPcldpbGRjYXJkKHJlYWx0aW1lUHJlc2VuY2UpIHtcblx0XHR2YXIgcmVhbHRpbWUgPSByZWFsdGltZVByZXNlbmNlLmNoYW5uZWwucmVhbHRpbWU7XG5cdFx0LyogSWYgbm90IGN1cnJlbnRseSBjb25uZWN0ZWQsIHdlIGNhbid0IGFzc3VtZSB0aGF0IHdlJ3JlIGFuIGFub255bW91c1xuXHRcdCAqIGNsaWVudCwgYXMgcmVhbHRpbWUgbWF5IGluZm9ybSB1cyBvZiBvdXIgY2xpZW50SWQgaW4gdGhlIENPTk5FQ1RFRFxuXHRcdCAqIG1lc3NhZ2UuIFNvIGFzc3VtZSB3ZSdyZSBub3QgYW5vbnltb3VzIGFuZCBsZWF2ZSBpdCB0byByZWFsdGltZSB0b1xuXHRcdCAqIHJldHVybiBhbiBlcnJvciBpZiB3ZSBhcmUgKi9cblx0XHR2YXIgY2xpZW50SWQgPSByZWFsdGltZS5hdXRoLmNsaWVudElkO1xuXHRcdHJldHVybiAoIWNsaWVudElkIHx8IChjbGllbnRJZCA9PT0gJyonKSkgJiYgcmVhbHRpbWUuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG5cdH1cblxuXHQvKiBDYWxsYmFjayBpcyBjYWxsZWQgb25seSBpbiB0aGUgZXZlbnQgb2YgYW4gZXJyb3IgKi9cblx0ZnVuY3Rpb24gd2FpdEF0dGFjaGVkKGNoYW5uZWwsIGNhbGxiYWNrLCBhY3Rpb24pIHtcblx0XHRzd2l0Y2goY2hhbm5lbC5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcblx0XHRcdFx0YWN0aW9uKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaW5pdGlhbGl6ZWQnOlxuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XG5cdFx0XHRcdGNoYW5uZWwuYXR0YWNoKGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRcdGlmKGVycikgY2FsbGJhY2soZXJyKTtcblx0XHRcdFx0XHRlbHNlIGFjdGlvbigpO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhyZWFsdGltZWNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoY2hhbm5lbC5zdGF0ZSkpKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBSZWFsdGltZVByZXNlbmNlKGNoYW5uZWwsIG9wdGlvbnMpIHtcblx0XHRjbGllbnRfcHJlc2VuY2UuY2FsbCh0aGlzLCBjaGFubmVsKTtcblx0XHR0aGlzLnN5bmNDb21wbGV0ZSA9IGZhbHNlO1xuXHRcdHRoaXMubWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcCh0aGlzKTtcblx0XHR0aGlzLl9teU1lbWJlcnMgPSBuZXcgUHJlc2VuY2VNYXAodGhpcyk7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG5cdH1cblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUmVhbHRpbWVQcmVzZW5jZSwgY2xpZW50X3ByZXNlbmNlKTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0aWYoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byBlbnRlciBhIHByZXNlbmNlIGNoYW5uZWwnLCA0MDAxMiwgNDAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCAnZW50ZXInLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcblx0XHRpZihpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIHVwZGF0ZSBwcmVzZW5jZSBkYXRhJywgNDAwMTIsIDQwMCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgZGF0YSwgJ3VwZGF0ZScsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5lbnRlckNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuXHRcdHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGNsaWVudElkLCBkYXRhLCAnZW50ZXInLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudXBkYXRlQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEsICd1cGRhdGUnLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2VudGVyT3JVcGRhdGVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgYWN0aW9uLCBjYWxsYmFjaykge1xuXHRcdGlmICghY2FsbGJhY2spIHtcblx0XHRcdGlmICh0eXBlb2YoZGF0YSk9PT0nZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdFx0ZGF0YSA9IG51bGw7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ19lbnRlck9yVXBkYXRlQ2xpZW50JywgW2NsaWVudElkLCBkYXRhLCBhY3Rpb25dKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG5cdFx0aWYoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0Y2FsbGJhY2soY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLicgKyBhY3Rpb24gKyAnQ2xpZW50KCknLFxuXHRcdCAgJ2NoYW5uZWwgPSAnICsgY2hhbm5lbC5uYW1lICsgJywgY2xpZW50ID0gJyArIChjbGllbnRJZCB8fCAnKGltcGxpY2l0KSAnICsgZ2V0Q2xpZW50SWQodGhpcykpKTtcblxuXHRcdHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtcblx0XHRcdGFjdGlvbiA6IGFjdGlvbixcblx0XHRcdGRhdGEgICA6IGRhdGFcblx0XHR9KTtcblx0XHRpZiAoY2xpZW50SWQpIHtcblx0XHRcdHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG5cdFx0fVxuXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGUocHJlc2VuY2UsIGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzd2l0Y2goY2hhbm5lbC5zdGF0ZSkge1xuXHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0Y2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnaW5pdGlhbGl6ZWQnOlxuXHRcdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdFx0Y2hhbm5lbC5hdHRhY2goKTtcblx0XHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0XHRzZWxmLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcblx0XHRcdFx0XHRcdHByZXNlbmNlIDogcHJlc2VuY2UsXG5cdFx0XHRcdFx0XHRjYWxsYmFjayA6IGNhbGxiYWNrXG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdFx0ZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvICcgKyBhY3Rpb24gKyAnIHByZXNlbmNlIGNoYW5uZWwgd2hpbGUgaW4gJyArIGNoYW5uZWwuc3RhdGUgKyAnIHN0YXRlJywgOTAwMDEpO1xuXHRcdFx0XHRcdGVyci5jb2RlID0gOTAwMDE7XG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0aWYoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGhhdmUgYmVlbiBzcGVjaWZpZWQgdG8gZW50ZXIgb3IgbGVhdmUgYSBwcmVzZW5jZSBjaGFubmVsJywgNDAwMTIsIDQwMCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmxlYXZlQ2xpZW50KHVuZGVmaW5lZCwgZGF0YSwgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmxlYXZlQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XG5cdFx0aWYgKCFjYWxsYmFjaykge1xuXHRcdFx0aWYgKHR5cGVvZihkYXRhKT09PSdmdW5jdGlvbicpIHtcblx0XHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0XHRkYXRhID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnbGVhdmVDbGllbnQnLCBbY2xpZW50SWQsIGRhdGFdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG5cdFx0aWYoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0Y2FsbGJhY2soY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLmxlYXZlQ2xpZW50KCknLCAnbGVhdmluZzsgY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGNsaWVudCA9ICcgKyBjbGllbnRJZCk7XG5cdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xuXHRcdFx0YWN0aW9uIDogJ2xlYXZlJyxcblx0XHRcdGRhdGEgICA6IGRhdGFcblx0XHR9KTtcblx0XHRpZiAoY2xpZW50SWQpIHsgcHJlc2VuY2UuY2xpZW50SWQgPSBjbGllbnRJZDsgfVxuXG5cdFx0c3dpdGNoKGNoYW5uZWwuc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcblx0XHRcdFx0Y2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHR0aGlzLnBlbmRpbmdQcmVzZW5jZS5wdXNoKHtcblx0XHRcdFx0XHRwcmVzZW5jZSA6IHByZXNlbmNlLFxuXHRcdFx0XHRcdGNhbGxiYWNrIDogY2FsbGJhY2tcblx0XHRcdFx0fSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnaW5pdGlhbGl6ZWQnOlxuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcblx0XHRcdFx0Lyogd2UncmUgbm90IGF0dGFjaGVkOyB0aGVyZWZvcmUgd2UgbGV0IGFueSBlbnRlcmVkIHN0YXR1c1xuXHRcdFx0XHQgKiB0aW1lb3V0IGJ5IGl0c2VsZiBpbnN0ZWFkIG9mIGF0dGFjaGluZyBqdXN0IGluIG9yZGVyIHRvIGxlYXZlICovXG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gbGVhdmUgcHJlc2VuY2UgY2hhbm5lbCAoaW5jb21wYXRpYmxlIHN0YXRlKScsIDkwMDAxKTtcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHQvKiB0aGVyZSBpcyBubyBjb25uZWN0aW9uOyB0aGVyZWZvcmUgd2UgbGV0XG5cdFx0XHRcdCAqIGFueSBlbnRlcmVkIHN0YXR1cyB0aW1lb3V0IGJ5IGl0c2VsZiAqL1xuXHRcdFx0XHRjYWxsYmFjayhjb25uZWN0aW9uZXJyb3JbXCJhXCIgLyogZGVmYXVsdCAqL10uZmFpbGVkKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oLyogcGFyYW1zLCBjYWxsYmFjayAqLykge1xuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcblx0XHRpZihhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZihhcmdzWzBdKSA9PSAnZnVuY3Rpb24nKVxuXHRcdFx0YXJncy51bnNoaWZ0KG51bGwpO1xuXG5cdFx0dmFyIHBhcmFtcyA9IGFyZ3NbMF0sXG5cdFx0XHRjYWxsYmFjayA9IGFyZ3NbMV0sXG5cdFx0XHR3YWl0Rm9yU3luYyA9ICFwYXJhbXMgfHwgKCd3YWl0Rm9yU3luYycgaW4gcGFyYW1zID8gcGFyYW1zLndhaXRGb3JTeW5jIDogdHJ1ZSk7XG5cblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3MpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJldHVybk1lbWJlcnMobWVtYmVycykge1xuXHRcdFx0Y2FsbGJhY2sobnVsbCwgcGFyYW1zID8gbWVtYmVycy5saXN0KHBhcmFtcykgOiBtZW1iZXJzLnZhbHVlcygpKTtcblx0XHR9XG5cblx0XHQvKiBTcGVjaWFsLWNhc2UgdGhlIHN1c3BlbmRlZCBzdGF0ZTogY2FuIHN0aWxsIGdldCAoc3RhbGUpIHByZXNlbmNlIHNldCBpZiB3YWl0Rm9yU3luYyBpcyBmYWxzZSAqL1xuXHRcdGlmKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcblx0XHRcdGlmKHdhaXRGb3JTeW5jKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtcblx0XHRcdFx0XHRzdGF0dXNDb2RlOiA0MDAsXG5cdFx0XHRcdFx0Y29kZTogOTEwMDUsXG5cdFx0XHRcdFx0bWVzc2FnZTogJ1ByZXNlbmNlIHN0YXRlIGlzIG91dCBvZiBzeW5jIGR1ZSB0byBjaGFubmVsIGJlaW5nIGluIHRoZSBTVVNQRU5ERUQgc3RhdGUnXG5cdFx0XHRcdH0pKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJldHVybk1lbWJlcnModGhpcy5tZW1iZXJzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0d2FpdEF0dGFjaGVkKHRoaXMuY2hhbm5lbCwgY2FsbGJhY2ssIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG1lbWJlcnMgPSBzZWxmLm1lbWJlcnM7XG5cdFx0XHRpZih3YWl0Rm9yU3luYykge1xuXHRcdFx0XHRtZW1iZXJzLndhaXRTeW5jKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybk1lbWJlcnMobWVtYmVycyk7XG5cdFx0XHRcdH0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcblx0XHRcdH1cblx0XHR9KTtcblx0fTtcblxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdoaXN0b3J5JywgYXJndW1lbnRzKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuXHRcdFx0aWYodGhpcy5jaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG5cdFx0XHRcdHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMuY2hhbm5lbC5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWQsIHdhczogXCIgKyB0aGlzLmNoYW5uZWwuc3RhdGUsIDQwMDAwLCA0MDApKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjbGllbnRfcHJlc2VuY2UucHJvdG90eXBlLl9oaXN0b3J5LmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc2V0UHJlc2VuY2UgPSBmdW5jdGlvbihwcmVzZW5jZVNldCwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2Uuc2V0UHJlc2VuY2UoKScsICdyZWNlaXZlZCBwcmVzZW5jZSBmb3IgJyArIHByZXNlbmNlU2V0Lmxlbmd0aCArICcgcGFydGljaXBhbnRzOyBzeW5jQ2hhbm5lbFNlcmlhbCA9ICcgKyBzeW5jQ2hhbm5lbFNlcmlhbCk7XG5cdFx0dmFyIHN5bmNDdXJzb3IsIG1hdGNoLCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsXG5cdFx0XHRicm9hZGNhc3RNZXNzYWdlcyA9IFtdLCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuXG5cdFx0aWYoaXNTeW5jKSB7XG5cdFx0XHR0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG5cdFx0XHRpZihzeW5jQ2hhbm5lbFNlcmlhbCAmJiAobWF0Y2ggPSBzeW5jQ2hhbm5lbFNlcmlhbC5tYXRjaCgvXltcXHdcXC1dKzooLiopJC8pKSkge1xuXHRcdFx0XHRzeW5jQ3Vyc29yID0gbWF0Y2hbMV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IHByZXNlbmNlU2V0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhwcmVzZW5jZVNldFtpXSk7XG5cdFx0XHRzd2l0Y2gocHJlc2VuY2UuYWN0aW9uKSB7XG5cdFx0XHRcdGNhc2UgJ2xlYXZlJzpcblx0XHRcdFx0XHRpZihtZW1iZXJzLnJlbW92ZShwcmVzZW5jZSkpIHtcblx0XHRcdFx0XHRcdGJyb2FkY2FzdE1lc3NhZ2VzLnB1c2gocHJlc2VuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZihwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCgpKSB7XG5cdFx0XHRcdFx0XHRteU1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2VudGVyJzpcblx0XHRcdFx0Y2FzZSAncHJlc2VudCc6XG5cdFx0XHRcdGNhc2UgJ3VwZGF0ZSc6XG5cdFx0XHRcdFx0aWYobWVtYmVycy5wdXQocHJlc2VuY2UpKSB7XG5cdFx0XHRcdFx0XHRicm9hZGNhc3RNZXNzYWdlcy5wdXNoKHByZXNlbmNlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQpIHtcblx0XHRcdFx0XHRcdG15TWVtYmVycy5wdXQocHJlc2VuY2UpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0LyogaWYgdGhpcyBpcyB0aGUgbGFzdCAob3Igb25seSkgbWVzc2FnZSBpbiBhIHNlcXVlbmNlIG9mIHN5bmMgdXBkYXRlcywgZW5kIHRoZSBzeW5jICovXG5cdFx0aWYoaXNTeW5jICYmICFzeW5jQ3Vyc29yKSB7XG5cdFx0XHRtZW1iZXJzLmVuZFN5bmMoKTtcblx0XHRcdC8qIFJUUDVjMjogcmUtZW50ZXIgb3VyIG93biBtZW1iZXJzIGlmIHRoZXkgaGF2ZW4ndCBzaG93biB1cCBpbiB0aGUgc3luYyAqL1xuXHRcdFx0dGhpcy5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpO1xuXHRcdFx0dGhpcy5jaGFubmVsLnNldEluUHJvZ3Jlc3MocmVhbHRpbWVjaGFubmVsLnByb2dyZXNzT3BzLnN5bmMsIGZhbHNlKTtcblx0XHRcdHRoaXMuY2hhbm5lbC5zeW5jQ2hhbm5lbFNlcmlhbCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0LyogYnJvYWRjYXN0IHRvIGxpc3RlbmVycyAqL1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBicm9hZGNhc3RNZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIHByZXNlbmNlID0gYnJvYWRjYXN0TWVzc2FnZXNbaV07XG5cdFx0XHR0aGlzLnN1YnNjcmlwdGlvbnMuZW1pdChwcmVzZW5jZS5hY3Rpb24sIHByZXNlbmNlKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub25BdHRhY2hlZCA9IGZ1bmN0aW9uKGhhc1ByZXNlbmNlKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGhhc1ByZXNlbmNlID0gJyArIGhhc1ByZXNlbmNlKTtcblxuXHRcdGlmKGhhc1ByZXNlbmNlKSB7XG5cdFx0XHR0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3N5bnRoZXNpemVMZWF2ZXModGhpcy5tZW1iZXJzLnZhbHVlcygpKTtcblx0XHRcdHRoaXMubWVtYmVycy5jbGVhcigpO1xuXHRcdFx0dGhpcy5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpO1xuXHRcdH1cblxuXHRcdC8qIE5CIHRoaXMgbXVzdCBiZSBhZnRlciB0aGUgX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQgY2FsbCwgd2hpY2ggbWF5IGFkZCBpdGVtcyB0byBwZW5kaW5nUHJlc2VuY2UgKi9cblx0XHR2YXIgcGVuZGluZ1ByZXNlbmNlID0gdGhpcy5wZW5kaW5nUHJlc2VuY2UsXG5cdFx0XHRwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcblxuXHRcdGlmKHBlbmRpbmdQcmVzQ291bnQpIHtcblx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG5cdFx0XHR2YXIgcHJlc2VuY2VBcnJheSA9IFtdO1xuXHRcdFx0dmFyIG11bHRpY2FzdGVyID0gT2JqZWN0KHV0aWxfbXVsdGljYXN0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pKCk7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQnLCAnc2VuZGluZyAnICsgcGVuZGluZ1ByZXNDb3VudCArICcgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzJyk7XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcGVuZGluZ1ByZXNDb3VudDsgaSsrKSB7XG5cdFx0XHRcdHZhciBldmVudCA9IHBlbmRpbmdQcmVzZW5jZVtpXTtcblx0XHRcdFx0cHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50LnByZXNlbmNlKTtcblx0XHRcdFx0bXVsdGljYXN0ZXIucHVzaChldmVudC5jYWxsYmFjayk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXksIG11bHRpY2FzdGVyKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuYWN0T25DaGFubmVsU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgaGFzUHJlc2VuY2UsIGVycikge1xuXHRcdHN3aXRjaChzdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHR0aGlzLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdHRoaXMuX2NsZWFyTXlNZW1iZXJzKCk7XG5cdFx0XHRcdHRoaXMubWVtYmVycy5jbGVhcigpO1xuXHRcdFx0XHQvKiBmYWxscyB0aHJvdWdoICovXG5cdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHR0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmZhaWxQZW5kaW5nUHJlc2VuY2UgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRpZih0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGgpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5mYWlsUGVuZGluZ1ByZXNlbmNlJywgJ2NoYW5uZWw7IG5hbWUgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBlcnIgPSAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aDsgaSsrKVxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlW2ldLmNhbGxiYWNrKGVycik7XG5cdFx0XHRcdH0gY2F0Y2goZSkge31cblx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9jbGVhck15TWVtYmVycyA9IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX215TWVtYmVycy5jbGVhcigpO1xuXHR9O1xuXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50ID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsXG5cdFx0XHRyZWVudGVyQ2IgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0dmFyIG1zZyA9ICdQcmVzZW5jZSBhdXRvLXJlLWVudGVyIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpO1xuXHRcdFx0XHRcdHZhciB3cmFwcGVkRXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDkxMDA0LCA0MDApO1xuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKScsIG1zZyk7XG5cdFx0XHRcdFx0dmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2Uoc2VsZi5jaGFubmVsLnN0YXRlLCBzZWxmLmNoYW5uZWwuc3RhdGUsIHRydWUsIHdyYXBwZWRFcnIpO1xuXHRcdFx0XHRcdHNlbGYuY2hhbm5lbC5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Zm9yKHZhciBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuXHRcdFx0aWYoIShtZW1iZXJLZXkgaW4gbWVtYmVycy5tYXApKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IG15TWVtYmVycy5tYXBbbWVtYmVyS2V5XTtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCgpJywgJ0F1dG8tcmVlbnRlcmluZyBjbGllbnRJZCBcIicgKyBlbnRyeS5jbGllbnRJZCArICdcIiBpbnRvIHRoZSBwcmVzZW5jZSBzZXQnKTtcblx0XHRcdFx0dGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgJ2VudGVyJywgcmVlbnRlckNiKTtcblx0XHRcdFx0ZGVsZXRlIG15TWVtYmVycy5tYXBbbWVtYmVyS2V5XTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX3N5bnRoZXNpemVMZWF2ZXMgPSBmdW5jdGlvbihpdGVtcykge1xuXHRcdHZhciBzdWJzY3JpcHRpb25zID0gdGhpcy5zdWJzY3JpcHRpb25zO1xuXHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goaXRlbXMsIGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtcblx0XHRcdFx0YWN0aW9uOiAnbGVhdmUnLFxuXHRcdFx0XHRjb25uZWN0aW9uSWQ6IGl0ZW0uY29ubmVjdGlvbklkLFxuXHRcdFx0XHRjbGllbnRJZDogaXRlbS5jbGllbnRJZCxcblx0XHRcdFx0ZGF0YTogaXRlbS5kYXRhLFxuXHRcdFx0XHRlbmNvZGluZzogaXRlbS5lbmNvZGluZyxcblx0XHRcdFx0dGltZXN0YW1wOiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3coKVxuXHRcdFx0fSk7XG5cdFx0XHRzdWJzY3JpcHRpb25zLmVtaXQoJ2xlYXZlJywgcHJlc2VuY2UpO1xuXHRcdH0pO1xuXHR9O1xuXG5cdC8qIERlcHJlY2F0ZWQgKi9cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgncHJlc2VuY2Uub24nLCAncHJlc2VuY2Uuc3Vic2NyaWJlJyk7XG5cdFx0dGhpcy5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fTtcblxuXHQvKiBEZXByZWNhdGVkICovXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uKCkge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdwcmVzZW5jZS5vZmYnLCAncHJlc2VuY2UudW5zdWJzY3JpYmUnKTtcblx0XHR0aGlzLnVuc3Vic2NyaWJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi8pIHtcblx0XHR2YXIgYXJncyA9IHJlYWx0aW1lY2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xuXHRcdHZhciBjYWxsYmFjayA9IGFyZ3NbMl07XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzdWJzY3JpYmUnLCBbZXZlbnQsIGxpc3RlbmVyXSk7XG5cdFx0XHR9XG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XG5cdFx0fVxuXG5cdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcblx0XHRcdGNhbGxiYWNrKGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHJlYWx0aW1lY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcignZmFpbGVkJykpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcblx0XHRjaGFubmVsLmF0dGFjaChjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLykge1xuXHRcdHZhciBhcmdzID0gcmVhbHRpbWVjaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLm9mZihldmVudCwgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdGZ1bmN0aW9uIFByZXNlbmNlTWFwKHByZXNlbmNlKSB7XG5cdFx0ZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcyk7XG5cdFx0dGhpcy5wcmVzZW5jZSA9IHByZXNlbmNlO1xuXHRcdHRoaXMubWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR0aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG5cdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFByZXNlbmNlTWFwLCBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihrZXkpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXBba2V5XTtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuZ2V0Q2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcblx0XHRcdGlmKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9O1xuXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLFxuXHRcdFx0Y2xpZW50SWQgPSBwYXJhbXMgJiYgcGFyYW1zLmNsaWVudElkLFxuXHRcdFx0Y29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsXG5cdFx0XHRyZXN1bHQgPSBbXTtcblxuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcblx0XHRcdGlmKGl0ZW0uYWN0aW9uID09PSAnYWJzZW50JykgY29udGludWU7XG5cdFx0XHRpZihjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKSBjb250aW51ZTtcblx0XHRcdGlmKGNvbm5lY3Rpb25JZCAmJiBjb25uZWN0aW9uSWQgIT0gaXRlbS5jb25uZWN0aW9uSWQpIGNvbnRpbnVlO1xuXHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0ZnVuY3Rpb24gbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nKSB7XG5cdFx0LyogUlRQMmIxOiBpZiBlaXRoZXIgaXMgc3ludGhlc2lzZWQsIGNvbXBhcmUgYnkgdGltZXN0YW1wICovXG5cdFx0aWYoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XG5cdFx0XHRyZXR1cm4gaXRlbS50aW1lc3RhbXAgPiBleGlzdGluZy50aW1lc3RhbXA7XG5cdFx0fVxuXG5cdFx0LyogUlRQMmIyICovXG5cdFx0dmFyIGl0ZW1PcmRlcmluZ3MgPSBpdGVtLnBhcnNlSWQoKSxcblx0XHRcdGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xuXHRcdGlmKGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID09PSBleGlzdGluZ09yZGVyaW5ncy5tc2dTZXJpYWwpIHtcblx0XHRcdHJldHVybiBpdGVtT3JkZXJpbmdzLmluZGV4ID4gZXhpc3RpbmdPcmRlcmluZ3MuaW5kZXg7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiBpdGVtT3JkZXJpbmdzLm1zZ1NlcmlhbCA+IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbDtcblx0XHR9XG5cdH1cblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUucHV0ID0gZnVuY3Rpb24oaXRlbSkge1xuXHRcdGlmKGl0ZW0uYWN0aW9uID09PSAnZW50ZXInIHx8IGl0ZW0uYWN0aW9uID09PSAndXBkYXRlJykge1xuXHRcdFx0aXRlbSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKGl0ZW0pO1xuXHRcdFx0aXRlbS5hY3Rpb24gPSAncHJlc2VudCc7XG5cdFx0fVxuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwga2V5ID0gbWVtYmVyS2V5KGl0ZW0pO1xuXHRcdC8qIHdlJ3ZlIHNlZW4gdGhpcyBtZW1iZXIsIHNvIGRvIG5vdCByZW1vdmUgaXQgYXQgdGhlIGVuZCBvZiBzeW5jICovXG5cdFx0aWYodGhpcy5yZXNpZHVhbE1lbWJlcnMpXG5cdFx0XHRkZWxldGUgdGhpcy5yZXNpZHVhbE1lbWJlcnNba2V5XTtcblxuXHRcdC8qIGNvbXBhcmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbmV3IGl0ZW0gd2l0aCBhbnkgZXhpc3RpbmcgbWVtYmVyIChvciBBQlNFTlQgd2l0bmVzcykgKi9cblx0XHR2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG5cdFx0aWYoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRtYXBba2V5XSA9IGl0ZW07XG5cdFx0cmV0dXJuIHRydWU7XG5cblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcblx0XHRmb3IodmFyIGtleSBpbiBtYXApIHtcblx0XHRcdHZhciBpdGVtID0gbWFwW2tleV07XG5cdFx0XHRpZihpdGVtLmFjdGlvbiAhPSAnYWJzZW50Jylcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIGtleSA9IG1lbWJlcktleShpdGVtKTtcblx0XHR2YXIgZXhpc3RpbmdJdGVtID0gbWFwW2tleV07XG5cblx0XHRpZihleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0LyogUlRQMmYgKi9cblx0XHRpZih0aGlzLnN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHRpdGVtID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoaXRlbSk7XG5cdFx0XHRpdGVtLmFjdGlvbiA9ICdhYnNlbnQnO1xuXHRcdFx0bWFwW2tleV0gPSBpdGVtO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgbWFwW2tleV07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnN0YXJ0U3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLnN0YXJ0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG5cdFx0Lyogd2UgbWlnaHQgYmUgY2FsbGVkIG11bHRpcGxlIHRpbWVzIHdoaWxlIGEgc3luYyBpcyBpbiBwcm9ncmVzcyAqL1xuXHRcdGlmKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG5cdFx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNvcHkobWFwKTtcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcblx0XHR9XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmVuZFN5bmMgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdQcmVzZW5jZU1hcC5lbmRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcblx0XHRpZihzeW5jSW5Qcm9ncmVzcykge1xuXHRcdFx0Lyogd2UgY2FuIG5vdyBzdHJpcCBvdXQgdGhlIEFCU0VOVCBtZW1iZXJzLCBhcyB3ZSBoYXZlXG5cdFx0XHQgKiByZWNlaXZlZCBhbGwgb2YgdGhlIG91dC1vZi1vcmRlciBzeW5jIG1lc3NhZ2VzICovXG5cdFx0XHRmb3IodmFyIG1lbWJlcktleSBpbiBtYXApIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gbWFwW21lbWJlcktleV07XG5cdFx0XHRcdGlmKGVudHJ5LmFjdGlvbiA9PT0gJ2Fic2VudCcpIHtcblx0XHRcdFx0XHRkZWxldGUgbWFwW21lbWJlcktleV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdC8qIGFueSBtZW1iZXJzIHRoYXQgd2VyZSBwcmVzZW50IGF0IHRoZSBzdGFydCBvZiB0aGUgc3luYyxcblx0XHRcdCAqIGFuZCBoYXZlIG5vdCBiZWVuIHNlZW4gaW4gc3luYywgY2FuIGJlIHJlbW92ZWQsIGFuZCBsZWF2ZSBldmVudHMgZW1pdHRlZCAqL1xuXHRcdFx0dGhpcy5wcmVzZW5jZS5fc3ludGhlc2l6ZUxlYXZlcyh1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS52YWx1ZXNBcnJheSh0aGlzLnJlc2lkdWFsTWVtYmVycykpO1xuXHRcdFx0Zm9yKHZhciBtZW1iZXJLZXkgaW4gdGhpcy5yZXNpZHVhbE1lbWJlcnMpIHtcblx0XHRcdFx0ZGVsZXRlIG1hcFttZW1iZXJLZXldO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuXG5cdFx0XHQvKiBmaW5pc2gsIG5vdGlmeWluZyBhbnkgd2FpdGVycyAqL1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcblx0XHR9XG5cdFx0dGhpcy5lbWl0KCdzeW5jJyk7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLndhaXRTeW5jID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcblx0XHR2YXIgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLndhaXRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcblx0XHRpZighc3luY0luUHJvZ3Jlc3MpIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHRoaXMub25jZSgnc3luYycsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbihjYWxsYmFjaykge1xuXHRcdHRoaXMubWFwID0ge307XG5cdFx0dGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcblx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG5cdH07XG5cblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnNldEluUHJvZ3Jlc3MgPSBmdW5jdGlvbihpblByb2dyZXNzKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUHJlc2VuY2VNYXAuc2V0SW5Qcm9ncmVzcygpJywgJ2luUHJvZ3Jlc3MgPSAnICsgaW5Qcm9ncmVzcyk7XG5cdFx0dGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGluUHJvZ3Jlc3M7XG5cdFx0dGhpcy5wcmVzZW5jZS5zeW5jQ29tcGxldGUgPSAhaW5Qcm9ncmVzcztcblx0fTtcblxuXHRyZXR1cm4gUmVhbHRpbWVQcmVzZW5jZTtcbn0pKCk7XG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlYWx0aW1lcHJlc2VuY2UgPSAocmVhbHRpbWVwcmVzZW5jZV9SZWFsdGltZVByZXNlbmNlKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZWNoYW5uZWwuanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cbnZhciByZWFsdGltZWNoYW5uZWxfUmVhbHRpbWVDaGFubmVsID0gKGZ1bmN0aW9uKCkge1xuXHR2YXIgYWN0aW9ucyA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5BY3Rpb247XG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcblx0dmFyIHN0YXRlY2hhbmdlT3AgPSAnc3RhdGVjaGFuZ2UnO1xuXHR2YXIgc3luY09wID0gJ3N5bmMnO1xuXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xuXHRmdW5jdGlvbiBSZWFsdGltZUNoYW5uZWwocmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwoKScsICdzdGFydGVkOyBuYW1lID0gJyArIG5hbWUpO1xuXHRcdGNsaWVudF9jaGFubmVsLmNhbGwodGhpcywgcmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcblx0XHR0aGlzLnByZXNlbmNlID0gbmV3IHJlYWx0aW1lcHJlc2VuY2UodGhpcywgcmVhbHRpbWUub3B0aW9ucyk7XG5cdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG5cdFx0dGhpcy5zdGF0ZSA9ICdpbml0aWFsaXplZCc7XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXHRcdHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xuXHRcdFx0YXR0YWNoU2VyaWFsOiB1bmRlZmluZWRcblx0XHR9O1xuXHRcdHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHR0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcblx0XHR0aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IG51bGw7XG5cdFx0dGhpcy5fbW9kZSA9IG51bGw7XG5cdFx0LyogVGVtcG9yYXJ5OyBvbmx5IHVzZWQgZm9yIHRoZSBjaGVja0NoYW5uZWxzT25SZXN1bWUgb3B0aW9uICovXG5cdFx0dGhpcy5fYXR0YWNoZWRNc2dJbmRpY2F0b3IgPSBmYWxzZTtcblx0XHR0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcblx0XHR0aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG5cdFx0XHRjaGFubmVsT3B0aW9uczogdGhpcy5jaGFubmVsT3B0aW9ucyxcblx0XHRcdHBsdWdpbnM6IHJlYWx0aW1lLm9wdGlvbnMucGx1Z2lucyB8fCB7IH0sXG5cdFx0XHRiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdW5kZWZpbmVkXG5cdFx0fTtcblx0XHR0aGlzLl9sYXN0UGF5bG9hZCA9IHtcblx0XHRcdG1lc3NhZ2VJZDogbnVsbCxcblx0XHRcdHByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw6IG51bGwsXG5cdFx0XHRkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsXG5cdFx0fTtcblx0XHQvKiBPbmx5IGRpZmZlcmVuY2VzIGJldHdlZW4gdGhpcyBhbmQgdGhlIHB1YmxpYyBldmVudCBlbWl0dGVyIGlzIHRoYXQgdGhpcyBlbWl0cyBhblxuXHRcdCAqIHVwZGF0ZSBldmVudCBmb3IgYWxsIEFUVEFDSEVEcywgd2hldGhlciByZXN1bWVkIG9yIG5vdCAqL1xuXHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzID0gbmV3IGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFJlYWx0aW1lQ2hhbm5lbCwgY2xpZW50X2NoYW5uZWwpO1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uKHN0YXRlKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHN0YXR1c0NvZGU6IDQwMCxcblx0XHRcdGNvZGU6IDkwMDAxLFxuXHRcdFx0bWVzc2FnZTogJ0NoYW5uZWwgb3BlcmF0aW9uIGZhaWxlZCBhcyBjaGFubmVsIHN0YXRlIGlzICcgKyBzdGF0ZVxuXHRcdH07XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb2dyZXNzT3BzID0ge1xuXHRcdHN0YXRlY2hhbmdlOiBzdGF0ZWNoYW5nZU9wLFxuXHRcdHN5bmM6IHN5bmNPcFxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzID0gZnVuY3Rpb24oYXJncykge1xuXHRcdC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG5cdFx0YXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpO1xuXHRcdGlmKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRhcmdzLnVuc2hpZnQobnVsbCk7XG5cdFx0fVxuXHRcdGlmKGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PSB1bmRlZmluZWQpIHtcblx0XHRcdGFyZ3MucG9wKCk7XG5cdFx0fVxuXHRcdHJldHVybiBhcmdzO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc2V0T3B0aW9ucycsIGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cblx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKXtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKScsICdTZXQgb3B0aW9ucyBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdHZhciBlcnIgPSB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xuXHRcdGlmKGVycikge1xuXHRcdFx0Y2FsbGJhY2soZXJyKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0Y2xpZW50X2NoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHRpZiAodGhpcy5fZGVjb2RpbmdDb250ZXh0KVxuXHRcdFx0dGhpcy5fZGVjb2RpbmdDb250ZXh0LmNoYW5uZWxPcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcblx0XHRpZih0aGlzLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhvcHRpb25zKSkge1xuXHRcdFx0LyogVGhpcyBkb2VzIG5vdCBqdXN0IGRvIF9hdHRhY2godHJ1ZSwgbnVsbCwgY2FsbGJhY2spIGJlY2F1c2UgdGhhdCB3b3VsZCBwdXQgdXNcblx0XHRcdCAqIGludG8gdGhlICdhdHRhY2hpbmcnIHN0YXRlIHVudGlsIHdlIHJlY2VpdmUgdGhlIG5ldyBhdHRhY2hlZCwgd2hpY2ggaXNcblx0XHRcdCAqIGNvbmNlcHR1YWxseSBpbmNvcnJlY3Q6IHdlIGFyZSBzdGlsbCBhdHRhY2hlZCwgd2UganVzdCBoYXZlIGEgcGVuZGluZyByZXF1ZXN0IHRvXG5cdFx0XHQgKiBjaGFuZ2Ugc29tZSBjaGFubmVsIHBhcmFtcy4gUGVyIFJUTDE3IGdvaW5nIGludG8gdGhlIGF0dGFjaGluZyBzdGF0ZSB3b3VsZCBtZWFuXG5cdFx0XHQgKiByZWplY3RpbmcgbWVzc2FnZXMgdW50aWwgd2UgaGF2ZSBjb25maXJtYXRpb24gdGhhdCB0aGUgb3B0aW9ucyBoYXZlIGNoYW5nZWQsXG5cdFx0XHQgKiB3aGljaCB3b3VsZCB1bm5lY2Vzc2FyaWx5IGxvc2UgbWVzc2FnZSBjb250aW51aXR5LiAqL1xuXHRcdFx0dGhpcy5hdHRhY2hJbXBsKCk7XG5cdFx0XHR0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRcdHN3aXRjaCh0aGlzLmV2ZW50KSB7XG5cdFx0XHRcdFx0Y2FzZSAndXBkYXRlJzpcblx0XHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0XHRjYWxsYmFjayhudWxsKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uKTtcblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmKG9wdGlvbnMgJiYgJ3BhcmFtcycgaW4gb3B0aW9ucyAmJiAhdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPYmplY3Qob3B0aW9ucy5wYXJhbXMpKSB7XG5cdFx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnb3B0aW9ucy5wYXJhbXMgbXVzdCBiZSBhbiBvYmplY3QnLCA0MDAwMCwgNDAwKTtcblx0XHR9XG5cdFx0aWYob3B0aW9ucyAmJiAnbW9kZXMnIGluIG9wdGlvbnMpe1xuXHRcdFx0aWYoIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkob3B0aW9ucy5tb2Rlcykpe1xuXHRcdFx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnb3B0aW9ucy5tb2RlcyBtdXN0IGJlIGFuIGFycmF5JywgNDAwMDAsIDQwMCk7XG5cdFx0XHR9XG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgb3B0aW9ucy5tb2Rlcy5sZW5ndGg7IGkrKyl7XG5cdFx0XHRcdHZhciBjdXJyZW50TW9kZSA9IG9wdGlvbnMubW9kZXNbaV07XG5cdFx0XHRcdGlmKCFjdXJyZW50TW9kZSB8fCB0eXBlb2YgY3VycmVudE1vZGUgIT09ICdzdHJpbmcnIHx8ICF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uY2hhbm5lbE1vZGVzLCBTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlLmNhbGwoY3VycmVudE1vZGUpKSl7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0ludmFsaWQgY2hhbm5lbCBtb2RlOiAnICsgY3VycmVudE1vZGUsIDQwMDAwLCA0MDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuICh0aGlzLnN0YXRlID09PSAnYXR0YWNoZWQnIHx8IHRoaXMuc3RhdGUgPT09ICdhdHRhY2hpbmcnKSAmJiAob3B0aW9ucy5wYXJhbXMgfHwgb3B0aW9ucy5tb2Rlcyk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5wdWJsaXNoID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdG1lc3NhZ2VzID0gYXJndW1lbnRzWzBdLFxuXHRcdFx0Y2FsbGJhY2sgPSBhcmd1bWVudHNbYXJnQ291bnQgLSAxXTtcblxuXHRcdGlmKHR5cGVvZihjYWxsYmFjaykgIT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHRcdCsrYXJnQ291bnQ7XG5cdFx0fVxuXHRcdGlmKCF0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcblx0XHRcdGNhbGxiYWNrKHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGlmKGFyZ0NvdW50ID09IDIpIHtcblx0XHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzT2JqZWN0KG1lc3NhZ2VzKSlcblx0XHRcdFx0bWVzc2FnZXMgPSBbdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKG1lc3NhZ2VzKV07XG5cdFx0XHRlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkobWVzc2FnZXMpKVxuXHRcdFx0XHRtZXNzYWdlcyA9IHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlc0FycmF5KG1lc3NhZ2VzKTtcblx0XHRcdGVsc2Vcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1lc3NhZ2VzID0gW3R5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7bmFtZTogYXJndW1lbnRzWzBdLCBkYXRhOiBhcmd1bWVudHNbMV19KV07XG5cdFx0fVxuXHRcdHZhciBzZWxmID0gdGhpcyxcblx0XHRcdG1heE1lc3NhZ2VTaXplID0gdGhpcy5yZWFsdGltZS5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuXHRcdHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xuXHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHQvKiBSU0wxaSAqL1xuXHRcdFx0dmFyIHNpemUgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyk7XG5cdFx0XHRpZihzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICggd2FzICcgKyBzaXplICsgJyBieXRlczsgbGltaXQgaXMgJyArIG1heE1lc3NhZ2VTaXplICsgJyBieXRlcyknLCA0MDAwOSwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNlbGYuX3B1Ymxpc2gobWVzc2FnZXMsIGNhbGxiYWNrKTtcblx0XHR9KTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24obWVzc2FnZXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdtZXNzYWdlIGNvdW50ID0gJyArIG1lc3NhZ2VzLmxlbmd0aCk7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcblx0XHRzd2l0Y2goc3RhdGUpIHtcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3Ioc3RhdGUpKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdzZW5kaW5nIG1lc3NhZ2U7IGNoYW5uZWwgc3RhdGUgaXMgJyArIHN0YXRlKTtcblx0XHRcdFx0dmFyIG1zZyA9IG5ldyBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10oKTtcblx0XHRcdFx0bXNnLmFjdGlvbiA9IGFjdGlvbnMuTUVTU0FHRTtcblx0XHRcdFx0bXNnLmNoYW5uZWwgPSB0aGlzLm5hbWU7XG5cdFx0XHRcdG1zZy5tZXNzYWdlcyA9IG1lc3NhZ2VzO1xuXHRcdFx0XHR0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbkV2ZW50ID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwub25FdmVudCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2UnKTtcblx0XHR2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG5cdFx0XHRzdWJzY3JpcHRpb25zLmVtaXQobWVzc2FnZS5uYW1lLCBtZXNzYWdlKTtcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbihmbGFncywgY2FsbGJhY2spIHtcblx0XHRpZih0eXBlb2YoZmxhZ3MpID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjYWxsYmFjayA9IGZsYWdzO1xuXHRcdFx0ZmxhZ3MgPSBudWxsO1xuXHRcdH1cblx0XHRpZighY2FsbGJhY2spIHtcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdhdHRhY2gnLCBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbihlcnIpIHtcblx0XHRcdFx0aWYoZXJyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaCgpJywgJ0NoYW5uZWwgYXR0YWNoIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZihmbGFncykge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ2NoYW5uZWwuYXR0YWNoKCkgd2l0aCBmbGFncycsICdjaGFubmVsLnNldE9wdGlvbnMoKSB3aXRoIGNoYW5uZWxPcHRpb25zLnBhcmFtcycpO1xuXHRcdFx0LyogSWYgZmxhZ3MgcmVxdWVzdGVkLCBhbHdheXMgZG8gYSByZS1hdHRhY2guIFRPRE8gb25seSBkbyB0aGlzIGlmXG5cdFx0XHQgKiBjdXJyZW50IG1vZGUgZGlmZmVycyBmcm9tIHJlcXVlc3RlZCBtb2RlICovXG5cdFx0XHR0aGlzLl9yZXF1ZXN0ZWRGbGFncyA9IGZsYWdzO1xuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl9hdHRhY2goZmFsc2UsIG51bGwsIGNhbGxiYWNrKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9hdHRhY2ggPSBmdW5jdGlvbihmb3JjZVJlYXR0YWNoLCBhdHRhY2hSZWFzb24sIGNhbGxiYWNrKSB7XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKGVycikge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLl9hdHRhY2goKScsICdDaGFubmVsIGF0dGFjaCBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHRjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGluZycgfHwgZm9yY2VSZWF0dGFjaCkge1xuXHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGF0dGFjaFJlYXNvbik7XG5cdFx0fVxuXG5cdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XG5cdFx0XHRzd2l0Y2godGhpcy5ldmVudCkge1xuXHRcdFx0XHRjYXNlICdhdHRhY2hlZCc6XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxuXHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxuXHRcdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byBhdHRhY2g7IHJlYXNvbiB1bmtub3duOyBzdGF0ZSA9ICcgKyB0aGlzLmV2ZW50LCA5MDAwMCwgNTAwKSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQXR0YWNoIHJlcXVlc3Qgc3VwZXJzZWRlZCBieSBhIHN1YnNlcXVlbnQgZGV0YWNoIHJlcXVlc3QnLCA5MDAwMCwgNDA5KSk7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5hdHRhY2hJbXBsID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaEltcGwoKScsICdzZW5kaW5nIEFUVEFDSCBtZXNzYWdlJyk7XG5cdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIHRydWUpO1xuXHRcdHZhciBhdHRhY2hNc2cgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7YWN0aW9uOiBhY3Rpb25zLkFUVEFDSCwgY2hhbm5lbDogdGhpcy5uYW1lLCBwYXJhbXM6IHRoaXMuY2hhbm5lbE9wdGlvbnMucGFyYW1zfSk7XG5cdFx0aWYodGhpcy5fcmVxdWVzdGVkRmxhZ3MpIHtcblx0XHRcdGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3ModGhpcy5fcmVxdWVzdGVkRmxhZ3MpO1xuXHRcdH0gZWxzZSBpZih0aGlzLmNoYW5uZWxPcHRpb25zLm1vZGVzKSB7XG5cdFx0XHRhdHRhY2hNc2cuZW5jb2RlTW9kZXNUb0ZsYWdzKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbFRvVXBwZXJDYXNlKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpKTtcblx0XHR9XG5cdFx0aWYodGhpcy5fYXR0YWNoUmVzdW1lKSB7XG5cdFx0XHRhdHRhY2hNc2cuc2V0RmxhZygnQVRUQUNIX1JFU1VNRScpO1xuXHRcdH1cblx0XHRpZih0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG5cdFx0XHRhdHRhY2hNc2cuY2hhbm5lbFNlcmlhbCA9IHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw7XG5cdFx0fVxuXHRcdHRoaXMuc2VuZE1lc3NhZ2UoYXR0YWNoTXNnLCBub29wKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnZGV0YWNoJywgYXJndW1lbnRzKTtcblx0XHRcdH1cblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcblx0XHR9XG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcblx0XHRpZighY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xuXHRcdFx0Y2FsbGJhY2soY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdkZXRhY2hlZCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdmYWlsZWQnOlxuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gZGV0YWNoOyBjaGFubmVsIHN0YXRlID0gZmFpbGVkJywgOTAwMDEsIDQwMCkpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHRcdHRoaXMucmVxdWVzdFN0YXRlKCdkZXRhY2hpbmcnKTtcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XG5cdFx0XHRcdHRoaXMub25jZShmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xuXHRcdFx0XHRcdHN3aXRjaCh0aGlzLmV2ZW50KSB7XG5cdFx0XHRcdFx0XHRjYXNlICdkZXRhY2hlZCc6XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcblx0XHRcdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byBkZXRhY2g7IHJlYXNvbiB1bmtub3duOyBzdGF0ZSA9ICcgKyB0aGlzLmV2ZW50LCA5MDAwMCwgNTAwKSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnRGV0YWNoIHJlcXVlc3Qgc3VwZXJzZWRlZCBieSBhIHN1YnNlcXVlbnQgYXR0YWNoIHJlcXVlc3QnLCA5MDAwMCwgNDA5KSk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoSW1wbCA9IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmRldGFjaCgpJywgJ3NlbmRpbmcgREVUQUNIIG1lc3NhZ2UnKTtcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgdHJ1ZSk7XG5cdFx0dmFyIG1zZyA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWV9KTtcblx0XHR0aGlzLnNlbmRNZXNzYWdlKG1zZywgKGNhbGxiYWNrIHx8IG5vb3ApKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uKC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovKSB7XG5cdFx0dmFyIGFyZ3MgPSBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xuXHRcdHZhciBldmVudCA9IGFyZ3NbMF07XG5cdFx0dmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcblx0XHR2YXIgY2FsbGJhY2sgPSBhcmdzWzJdO1xuXG5cdFx0aWYoIWNhbGxiYWNrKSB7XG5cdFx0XHRpZih0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc3Vic2NyaWJlJywgW2V2ZW50LCBsaXN0ZW5lcl0pO1xuXHRcdFx0fVxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdH1cblxuXHRcdGlmKHRoaXMuc3RhdGUgPT09ICdmYWlsZWQnKSB7XG5cdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoJ2ZhaWxlZCcpKSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG5cblx0XHRyZXR1cm4gdGhpcy5hdHRhY2goY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLykge1xuXHRcdHZhciBhcmdzID0gUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLm9mZihldmVudCwgbGlzdGVuZXIpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uKCkge1xuXHRcdC8qIGNoZWNrIHByZWNvbmRpdGlvbnMgKi9cblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnaW5pdGlhbGl6ZWQnOlxuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcIlVuYWJsZSB0byBzeW5jIHRvIGNoYW5uZWw7IG5vdCBhdHRhY2hlZFwiLCA0MDAwMCk7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdH1cblx0XHR2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG5cdFx0XHR0aHJvdyBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuXHRcdH1cblxuXHRcdC8qIHNlbmQgc3luYyByZXF1ZXN0ICovXG5cdFx0dmFyIHN5bmNNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWV9KTtcblx0XHRpZih0aGlzLnN5bmNDaGFubmVsU2VyaWFsKSB7XG5cdFx0XHRzeW5jTWVzc2FnZS5jaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbDtcblx0XHR9XG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc2VuZChzeW5jTWVzc2FnZSk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZywgY2FsbGJhY2spIHtcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQobXNnLCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMucXVldWVNZXNzYWdlcywgY2FsbGJhY2spO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2VuZFByZXNlbmNlID0gZnVuY3Rpb24ocHJlc2VuY2UsIGNhbGxiYWNrKSB7XG5cdFx0dmFyIG1zZyA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtcblx0XHRcdGFjdGlvbjogYWN0aW9ucy5QUkVTRU5DRSxcblx0XHRcdGNoYW5uZWw6IHRoaXMubmFtZSxcblx0XHRcdHByZXNlbmNlOiAodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShwcmVzZW5jZSkgP1xuXHRcdFx0XHRwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlc0FycmF5KHByZXNlbmNlKSA6XG5cdFx0XHRcdFtwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhwcmVzZW5jZSldKVxuXHRcdH0pO1xuXHRcdHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XG5cdFx0dmFyIHN5bmNDaGFubmVsU2VyaWFsLCBpc1N5bmMgPSBmYWxzZTtcblx0XHRzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcblx0XHRjYXNlIGFjdGlvbnMuQVRUQUNIRUQ6XG5cdFx0XHR0aGlzLl9hdHRhY2hlZE1zZ0luZGljYXRvciA9IHRydWU7XG5cdFx0XHR0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuXHRcdFx0dGhpcy5fbW9kZSA9IG1lc3NhZ2UuZ2V0TW9kZSgpO1xuXHRcdFx0dGhpcy5wYXJhbXMgPSBtZXNzYWdlLnBhcmFtcyB8fCB7fTtcblx0XHRcdHZhciBtb2Rlc0Zyb21GbGFncyA9IG1lc3NhZ2UuZGVjb2RlTW9kZXNGcm9tRmxhZ3MoKTtcblx0XHRcdHRoaXMubW9kZXMgPSAobW9kZXNGcm9tRmxhZ3MgJiYgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsVG9Mb3dlckNhc2UobW9kZXNGcm9tRmxhZ3MpKSB8fCB1bmRlZmluZWQ7XG5cdFx0XHR2YXIgcmVzdW1lZCA9IG1lc3NhZ2UuaGFzRmxhZygnUkVTVU1FRCcpO1xuXHRcdFx0dmFyIGhhc1ByZXNlbmNlID0gbWVzc2FnZS5oYXNGbGFnKCdIQVNfUFJFU0VOQ0UnKTtcblx0XHRcdGlmKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0LyogYXR0YWNoZWQgb3BlcmF0aW9ucyB0byBjaGFuZ2Ugb3B0aW9ucyBzZXQgdGhlIGlucHJvZ3Jlc3MgbXV0ZXgsIGJ1dCBsZWF2ZVxuXHRcdFx0XHQgKiBjaGFubmVsIGluIHRoZSBhdHRhY2hlZCBzdGF0ZSAqL1xuXHRcdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgZmFsc2UpO1xuXHRcdFx0XHRpZighcmVzdW1lZCkge1xuXHRcdFx0XHRcdC8qIE9uIGEgbG9zcyBvZiBjb250aW51aXR5LCB0aGUgcHJlc2VuY2Ugc2V0IG5lZWRzIHRvIGJlIHJlLXN5bmNlZCAqL1xuXHRcdFx0XHRcdHRoaXMucHJlc2VuY2Uub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2UodGhpcy5zdGF0ZSwgdGhpcy5zdGF0ZSwgcmVzdW1lZCwgbWVzc2FnZS5lcnJvcik7XG5cdFx0XHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG5cdFx0XHRcdGlmKCFyZXN1bWVkIHx8IHRoaXMuY2hhbm5lbE9wdGlvbnMudXBkYXRlT25BdHRhY2hlZCkge1xuXHRcdFx0XHRcdHRoaXMuZW1pdCgndXBkYXRlJywgY2hhbmdlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmKHRoaXMuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG5cdFx0XHRcdC8qIFJUTDVpOiByZS1zZW5kIERFVEFDSCBhbmQgcmVtYWluIGluIHRoZSAnZGV0YWNoaW5nJyBzdGF0ZSAqL1xuXHRcdFx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdhdHRhY2hlZCcsIG1lc3NhZ2UuZXJyb3IsIHJlc3VtZWQsIGhhc1ByZXNlbmNlKTtcblx0XHRcdH1cblx0XHRcdGJyZWFrO1xuXG5cdFx0Y2FzZSBhY3Rpb25zLkRFVEFDSEVEOlxuXHRcdFx0dmFyIGVyciA9IG1lc3NhZ2UuZXJyb3IgPyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhtZXNzYWdlLmVycm9yKSA6IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NoYW5uZWwgZGV0YWNoZWQnLCA5MDAwMSwgNDA0KTtcblx0XHRcdGlmKHRoaXMuc3RhdGUgPT09ICdkZXRhY2hpbmcnKSB7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2RldGFjaGVkJywgZXJyKTtcblx0XHRcdH0gZWxzZSBpZih0aGlzLnN0YXRlID09PSAnYXR0YWNoaW5nJykge1xuXHRcdFx0XHQvKiBPbmx5IHJldHJ5IGltbWVkaWF0ZWx5IGlmIHdlIHdlcmUgcHJldmlvdXNseSBhdHRhY2hlZC4gSWYgd2Ugd2VyZVxuXHRcdFx0XHQgKiBhdHRhY2hpbmcsIGdvIGludG8gc3VzcGVuZGVkLCBmYWlsIG1lc3NhZ2VzLCBhbmQgd2FpdCBhIGZldyBzZWNvbmRzXG5cdFx0XHRcdCAqIGJlZm9yZSByZXRyeWluZyAqL1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdzdXNwZW5kZWQnLCBlcnIpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGVycik7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgYWN0aW9ucy5TWU5DOlxuXHRcdFx0Lyogc3luY3MgY2FuIGhhdmUgY2hhbm5lbFNlcmlhbHMsIGJ1dCBtaWdodCBub3QgaWYgdGhlIHN5bmMgaXMgb25lIHBhZ2UgbG9uZyAqL1xuXHRcdFx0aXNTeW5jID0gdHJ1ZTtcblx0XHRcdHN5bmNDaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcblx0XHRcdC8qIHN5bmNzIGNhbiBoYXBwZW4gb24gY2hhbm5lbHMgd2l0aCBubyBwcmVzZW5jZSBkYXRhIGFzIHBhcnQgb2YgY29ubmVjdGlvblxuXHRcdFx0ICogcmVzdW1pbmcsIGluIHdoaWNoIGNhc2UgcHJvdG9jb2wgbWVzc2FnZSBoYXMgbm8gcHJlc2VuY2UgcHJvcGVydHkgKi9cblx0XHRcdGlmKCFtZXNzYWdlLnByZXNlbmNlKSBicmVhaztcblx0XHRjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6XG5cdFx0XHR2YXIgcHJlc2VuY2UgPSBtZXNzYWdlLnByZXNlbmNlLFxuXHRcdFx0XHRpZCA9IG1lc3NhZ2UuaWQsXG5cdFx0XHRcdGNvbm5lY3Rpb25JZCA9IG1lc3NhZ2UuY29ubmVjdGlvbklkLFxuXHRcdFx0XHR0aW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVzdGFtcDtcblxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dmFyIHByZXNlbmNlTXNnID0gcHJlc2VuY2VbaV07XG5cdFx0XHRcdFx0cHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZShwcmVzZW5jZU1zZywgb3B0aW9ucyk7XG5cdFx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKCFwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQpIHByZXNlbmNlTXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcblx0XHRcdFx0aWYoIXByZXNlbmNlTXNnLnRpbWVzdGFtcCkgcHJlc2VuY2VNc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuXHRcdFx0XHRpZighcHJlc2VuY2VNc2cuaWQpIHByZXNlbmNlTXNnLmlkID0gaWQgKyAnOicgKyBpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5wcmVzZW5jZS5zZXRQcmVzZW5jZShwcmVzZW5jZSwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgYWN0aW9ucy5NRVNTQUdFOlxuXG5cdFx0XHQvL1JUTDE3XG5cdFx0XHRpZih0aGlzLnN0YXRlICE9PSAnYXR0YWNoZWQnKSB7XG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NQUpPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsICdNZXNzYWdlIFwiJyArIG1lc3NhZ2UuaWQgKyAnXCIgc2tpcHBlZCBhcyB0aGlzIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiIHN0YXRlIGlzIG5vdCBcImF0dGFjaGVkXCIgKHN0YXRlIGlzIFwiJyArIHRoaXMuc3RhdGUgKyAnXCIpLicpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHZhciBtZXNzYWdlcyA9IG1lc3NhZ2UubWVzc2FnZXMsXG5cdFx0XHRcdGZpcnN0TWVzc2FnZSA9IG1lc3NhZ2VzWzBdLFxuXHRcdFx0XHRsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzW21lc3NhZ2VzLmxlbmd0aCAtIDFdLFxuXHRcdFx0XHRpZCA9IG1lc3NhZ2UuaWQsXG5cdFx0XHRcdGNvbm5lY3Rpb25JZCA9IG1lc3NhZ2UuY29ubmVjdGlvbklkLFxuXHRcdFx0XHR0aW1lc3RhbXAgPSBtZXNzYWdlLnRpbWVzdGFtcDtcblxuXHRcdFx0aWYoZmlyc3RNZXNzYWdlLmV4dHJhcyAmJiBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEuZnJvbSAhPT0gdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkKSB7XG5cdFx0XHRcdHZhciBtc2cgPSAnRGVsdGEgbWVzc2FnZSBkZWNvZGUgZmFpbHVyZSAtIHByZXZpb3VzIG1lc3NhZ2Ugbm90IGF2YWlsYWJsZSBmb3IgbWVzc2FnZSBcIicgKyBtZXNzYWdlLmlkICsgJ1wiIG9uIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIuJztcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgbXNnKTtcblx0XHRcdFx0dGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMDE4LCA0MDApKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHR2YXIgbXNnID0gbWVzc2FnZXNbaV07XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0dHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGUobXNnLCB0aGlzLl9kZWNvZGluZ0NvbnRleHQpO1xuXHRcdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdFx0LyogZGVjcnlwdCBmYWlsZWQgLi4gdGhlIG1vc3QgbGlrZWx5IGNhdXNlIGlzIHRoYXQgd2UgaGF2ZSB0aGUgd3Jvbmcga2V5ICovXG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgZS50b1N0cmluZygpKTtcblx0XHRcdFx0XHRzd2l0Y2goZS5jb2RlKSB7XG5cdFx0XHRcdFx0XHRjYXNlIDQwMDE4OlxuXHRcdFx0XHRcdFx0XHQvKiBkZWNvZGUgZmFpbHVyZSAqL1xuXHRcdFx0XHRcdFx0XHR0aGlzLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeShlKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0Y2FzZSA0MDAxOTpcblx0XHRcdFx0XHRcdFx0LyogTm8gdmNkaWZmIHBsdWdpbiBwYXNzZWQgaW4gLSBubyBwb2ludCByZWNvdmVyaW5nLCBnaXZlIHVwICovXG5cdFx0XHRcdFx0XHRjYXNlIDQwMDIxOlxuXHRcdFx0XHRcdFx0XHQvKiBCcm93c2VyIGRvZXMgbm90IHN1cHBvcnQgZGVsdGFzLCBzaW1pbGFybHkgbm8gcG9pbnQgcmVjb3ZlcmluZyAqL1xuXHRcdFx0XHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdmYWlsZWQnLCBlKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZighbXNnLmNvbm5lY3Rpb25JZCkgbXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcblx0XHRcdFx0aWYoIW1zZy50aW1lc3RhbXApIG1zZy50aW1lc3RhbXAgPSB0aW1lc3RhbXA7XG5cdFx0XHRcdGlmKCFtc2cuaWQpIG1zZy5pZCA9IGlkICsgJzonICsgaTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuXHRcdFx0dGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcblx0XHRcdHRoaXMub25FdmVudChtZXNzYWdlcyk7XG5cdFx0XHRicmVhaztcblxuXHRcdGNhc2UgYWN0aW9ucy5FUlJPUjpcblx0XHRcdC8qIHRoZXJlIHdhcyBhIGNoYW5uZWwtc3BlY2lmaWMgZXJyb3IgKi9cblx0XHRcdHZhciBlcnIgPSBtZXNzYWdlLmVycm9yO1xuXHRcdFx0aWYoZXJyICYmIGVyci5jb2RlID09IDgwMDE2KSB7XG5cdFx0XHRcdC8qIGF0dGFjaC9kZXRhY2ggb3BlcmF0aW9uIGF0dGVtcHRlZCBvbiBzdXBlcnNlZGVkIHRyYW5zcG9ydCBoYW5kbGUgKi9cblx0XHRcdFx0dGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnZmFpbGVkJywgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoZXJyKSk7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblxuXHRcdGRlZmF1bHQ6XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnRmF0YWwgcHJvdG9jb2wgZXJyb3I6IHVucmVjb2duaXNlZCBhY3Rpb24gKCcgKyBtZXNzYWdlLmFjdGlvbiArICcpJyk7XG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmFib3J0KGNvbm5lY3Rpb25lcnJvcltcImFcIiAvKiBkZWZhdWx0ICovXS51bmtub3duQ2hhbm5lbEVycik7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5ID0gZnVuY3Rpb24ocmVhc29uKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKCF0aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzKSB7XG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnU3RhcnRpbmcgZGVjb2RlIGZhaWx1cmUgcmVjb3ZlcnkgcHJvY2Vzcy4nKTtcblx0XHRcdHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRcdFx0dGhpcy5fYXR0YWNoKHRydWUsIHJlYXNvbiwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSBmYWxzZTtcblx0XHRcdH0pO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uQXR0YWNoZWQgPSBmdW5jdGlvbigpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwub25BdHRhY2hlZCcsICdhY3RpdmF0aW5nIGNoYW5uZWw7IG5hbWUgPSAnICsgdGhpcy5uYW1lKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm5vdGlmeVN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbiwgcmVzdW1lZCwgaGFzUHJlc2VuY2UpIHtcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwubm90aWZ5U3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBjdXJyZW50IHN0YXRlID0gJyArIHRoaXMuc3RhdGUgKyAnLCBub3RpZnlpbmcgc3RhdGUgJyArIHN0YXRlKTtcblx0XHR0aGlzLmNsZWFyU3RhdGVUaW1lcigpO1xuXG5cdFx0aWYoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dGhpcy5wcmVzZW5jZS5hY3RPbkNoYW5uZWxTdGF0ZShzdGF0ZSwgaGFzUHJlc2VuY2UsIHJlYXNvbik7XG5cdFx0aWYoc3RhdGUgPT09ICdzdXNwZW5kZWQnICYmIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0dGhpcy5zdGFydFJldHJ5VGltZXIoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG5cdFx0fVxuXHRcdGlmKHJlYXNvbikge1xuXHRcdFx0dGhpcy5lcnJvclJlYXNvbiA9IHJlYXNvbjtcblx0XHR9XG5cdFx0dmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2UodGhpcy5zdGF0ZSwgc3RhdGUsIHJlc3VtZWQsIHJlYXNvbik7XG5cdFx0dmFyIGxvZ0xldmVsID0gc3RhdGUgPT09ICdmYWlsZWQnID8gbG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiA6IGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUFKT1I7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dMZXZlbCwgJ0NoYW5uZWwgc3RhdGUgZm9yIGNoYW5uZWwgXCInICsgdGhpcy5uYW1lICsgJ1wiJywgc3RhdGUgKyAocmVhc29uID8gKCc7IHJlYXNvbjogJyArIHJlYXNvbikgOiAnJykpO1xuXG5cdFx0LyogTm90ZTogd2UgZG9uJ3Qgc2V0IGluUHJvZ3Jlc3MgZm9yIHBlbmRpbmcgc3RhdGVzIHVudGlsIHRoZSByZXF1ZXN0IGlzIGFjdHVhbGx5IGluIHByb2dyZXNzICovXG5cdFx0aWYoc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdHRoaXMub25BdHRhY2hlZCgpO1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN5bmNPcCwgaGFzUHJlc2VuY2UpO1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIGZhbHNlKTtcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT09ICdkZXRhY2hlZCcgfHwgc3RhdGUgPT09ICdmYWlsZWQnIHx8IHN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHN0YXRlY2hhbmdlT3AsIGZhbHNlKTtcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzeW5jT3AsIGZhbHNlKTtcblx0XHR9XG5cblx0XHRpZihzdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0dGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT09ICdkZXRhY2hpbmcnIHx8IHN0YXRlID09PSAnZmFpbGVkJykge1xuXHRcdFx0dGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdGF0ZSA9IHN0YXRlO1xuXHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG5cdFx0dGhpcy5lbWl0KHN0YXRlLCBjaGFuZ2UpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIHJlYXNvbikge1xuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5yZXF1ZXN0U3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBzdGF0ZSA9ICcgKyBzdGF0ZSk7XG5cdFx0dGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcblx0XHQvKiBzZW5kIHRoZSBldmVudCBhbmQgYXdhaXQgcmVzcG9uc2UgKi9cblx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jaGVja1BlbmRpbmdTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdC8qIGlmIGNhbid0IHNlbmQgZXZlbnRzLCBkbyBub3RoaW5nICovXG5cdFx0dmFyIGNtU3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlO1xuXHRcdC8qIEFsbG93IGF0dGFjaCBtZXNzYWdlcyB0byBxdWV1ZSB1cCB3aGVuIHN5bmNocm9uaXppbmcsIHNpbmNlIHRoaXMgd2lsbCBiZVxuXHRcdCAqIHRoZSBzdGF0ZSB3ZSdsbCBiZSBpbiB3aGVuIHVwZ3JhZGUgdHJhbnNwb3J0LmFjdGl2ZSB0cmlnZ2VycyBhIGNoZWNrcGVuZGluZ3N0YXRlICovXG5cdFx0aWYoIShjbVN0YXRlLnNlbmRFdmVudHMgfHwgY21TdGF0ZS5mb3JjZVF1ZXVlRXZlbnRzKSkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlJywgJ3NlbmRFdmVudHMgaXMgZmFsc2U7IHN0YXRlIGlzICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBzdGF0ZSA9ICcgKyB0aGlzLnN0YXRlKTtcblx0XHQvKiBPbmx5IHN0YXJ0IHRoZSBzdGF0ZSB0aW1lciBydW5uaW5nIHdoZW4gYWN0dWFsbHkgc2VuZGluZyB0aGUgZXZlbnQgKi9cblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcblx0XHRcdFx0dGhpcy5hdHRhY2hJbXBsKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0dGhpcy5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcoKTtcblx0XHRcdFx0dGhpcy5kZXRhY2hJbXBsKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxuXHRcdFx0XHQvKiByZXN1bWUgYW55IHN5bmMgb3BlcmF0aW9uIHRoYXQgd2FzIGluIHByb2dyZXNzICovXG5cdFx0XHRcdHRoaXMuc3luYygpO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUudGltZW91dFBlbmRpbmdTdGF0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxuXHRcdFx0XHR2YXIgZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2hhbm5lbCBhdHRhY2ggdGltZWQgb3V0JywgOTAwMDcsIDQwOCk7XG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ3N1c3BlbmRlZCcsIGVycik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcblx0XHRcdFx0dmFyIGVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NoYW5uZWwgZGV0YWNoIHRpbWVkIG91dCcsIDkwMDA3LCA0MDgpO1xuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdhdHRhY2hlZCcsIGVycik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0ZGVmYXVsdDpcblx0XHRcdFx0dGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0aWYoIXRoaXMuc3RhdGVUaW1lcikge1xuXHRcdFx0dGhpcy5zdGF0ZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZycsICd0aW1lciBleHBpcmVkJyk7XG5cdFx0XHRcdHNlbGYuc3RhdGVUaW1lciA9IG51bGw7XG5cdFx0XHRcdHNlbGYudGltZW91dFBlbmRpbmdTdGF0ZSgpO1xuXHRcdFx0fSwgdGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xuXHRcdH1cblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNsZWFyU3RhdGVUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdGF0ZVRpbWVyID0gdGhpcy5zdGF0ZVRpbWVyO1xuXHRcdGlmKHN0YXRlVGltZXIpIHtcblx0XHRcdGNsZWFyVGltZW91dChzdGF0ZVRpbWVyKTtcblx0XHRcdHRoaXMuc3RhdGVUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRSZXRyeVRpbWVyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xuXHRcdGlmKHRoaXMucmV0cnlUaW1lcikgcmV0dXJuO1xuXG5cdFx0dGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcblx0XHRcdC8qIElmIGNvbm5lY3Rpb24gaXMgbm90IGNvbm5lY3RlZCwganVzdCBsZWF2ZSBpbiBzdXNwZW5kZWQsIGEgcmVhdHRhY2hcblx0XHRcdCAqIHdpbGwgYmUgdHJpZ2dlcmVkIG9uY2UgaXQgY29ubmVjdHMgYWdhaW4gKi9cblx0XHRcdGlmKHNlbGYuc3RhdGUgPT09ICdzdXNwZW5kZWQnICYmIHNlbGYuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc2VuZEV2ZW50cykge1xuXHRcdFx0XHRzZWxmLnJldHJ5VGltZXIgPSBudWxsO1xuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwgcmV0cnkgdGltZXIgZXhwaXJlZCcsICdhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaCcpO1xuXHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJyk7XG5cdFx0XHR9XG5cdFx0fSwgdGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQpO1xuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2FuY2VsUmV0cnlUaW1lciA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmKHRoaXMucmV0cnlUaW1lcikge1xuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMucmV0cnlUaW1lcik7XG5cdFx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG5cdFx0fVxuXHR9O1xuXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2V0SW5Qcm9ncmVzcyA9IGZ1bmN0aW9uKG9wZXJhdGlvbiwgdmFsdWUpIHtcblx0XHR0aGlzLnJlc3QuY2hhbm5lbHMuc2V0SW5Qcm9ncmVzcyh0aGlzLCBvcGVyYXRpb24sIHZhbHVlKTtcblx0fTtcblxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2FsbGJhY2sgPSBub29wO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcblx0XHRcdGlmKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZFwiLCA0MDAwMCwgNDAwKSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdGlmKCF0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsKSB7XG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJ1bnRpbEF0dGFjaCB3YXMgc3BlY2lmaWVkIGFuZCBjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkXCIsIDQwMDAwLCA0MDApKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXHRcdFx0ZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcblx0XHRcdHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XG5cdFx0fVxuXG5cdFx0Y2xpZW50X2NoYW5uZWwucHJvdG90eXBlLl9oaXN0b3J5LmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XG5cdH07XG5cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS53aGVuU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbGlzdGVuZXIpIHtcblx0XHRyZXR1cm4gZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSwgbGlzdGVuZXIpO1xuXHR9XG5cblx0LyogQHJldHVybnMgbnVsbCAoaWYgY2FuIHNhZmVseSBiZSByZWxlYXNlZCkgfCBFcnJvckluZm8gKGlmIGNhbm5vdCkgKi9cblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5nZXRSZWxlYXNlRXJyID0gZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHMgPSB0aGlzLnN0YXRlO1xuXHRcdGlmKHMgPT09ICdpbml0aWFsaXplZCcgfHwgcyA9PT0gJ2RldGFjaGVkJyB8fCBzID09PSAnZmFpbGVkJykge1xuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDYW4gb25seSByZWxlYXNlIGEgY2hhbm5lbCBpbiBhIHN0YXRlIHdoZXJlIHRoZXJlIGlzIG5vIHBvc3NpYmlsaXR5IG9mIGZ1cnRoZXIgdXBkYXRlcyBmcm9tIHRoZSBzZXJ2ZXIgYmVpbmcgcmVjZWl2ZWQgKGluaXRpYWxpemVkLCBkZXRhY2hlZCwgb3IgZmFpbGVkKTsgd2FzICcgKyBzLCA5MDAwMSwgNDAwKTtcblx0fVxuXG5cdHJldHVybiBSZWFsdGltZUNoYW5uZWw7XG59KSgpO1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciByZWFsdGltZWNoYW5uZWwgPSAocmVhbHRpbWVjaGFubmVsX1JlYWx0aW1lQ2hhbm5lbCk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvZXJyb3JyZXBvcnRlci5qc1xudmFyIGVycm9ycmVwb3J0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZS5qc1xuXG5cblxuXG5cblxuXG5cblxuXG52YXIgcmVhbHRpbWVfUmVhbHRpbWUgPSAoZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gUmVhbHRpbWUob3B0aW9ucykge1xuXHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIFJlYWx0aW1lKSl7XG5cdFx0XHRyZXR1cm4gbmV3IFJlYWx0aW1lKG9wdGlvbnMpO1xuXHRcdH1cblxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lKCknLCAnJyk7XG5cdFx0Y2xpZW50X3Jlc3QuY2FsbCh0aGlzLCBvcHRpb25zKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24gPSBuZXcgY29ubmVjdGlvbih0aGlzLCB0aGlzLm9wdGlvbnMpO1xuXHRcdHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcyk7XG5cdFx0aWYob3B0aW9ucy5hdXRvQ29ubmVjdCAhPT0gZmFsc2UpXG5cdFx0XHR0aGlzLmNvbm5lY3QoKTtcblx0fVxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhSZWFsdGltZSwgY2xpZW50X3Jlc3QpO1xuXG5cdFJlYWx0aW1lLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWUuY29ubmVjdCgpJywgJycpO1xuXHRcdHRoaXMuY29ubmVjdGlvbi5jb25uZWN0KCk7XG5cdH07XG5cblx0UmVhbHRpbWUucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWUuY2xvc2UoKScsICcnKTtcblx0XHR0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcblx0fTtcblxuXHRmdW5jdGlvbiBDaGFubmVscyhyZWFsdGltZSkge1xuXHRcdGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcblx0XHR0aGlzLmFsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cdFx0dGhpcy5pblByb2dyZXNzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHR2YXIgc2VsZiA9IHRoaXM7XG5cdFx0cmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbigndHJhbnNwb3J0LmFjdGl2ZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0c2VsZi5vblRyYW5zcG9ydEFjdGl2ZSgpO1xuXHRcdH0pO1xuXHR9XG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKENoYW5uZWxzLCBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10pO1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5vbkNoYW5uZWxNZXNzYWdlID0gZnVuY3Rpb24obXNnKSB7XG5cdFx0dmFyIGNoYW5uZWxOYW1lID0gbXNnLmNoYW5uZWw7XG5cdFx0aWYoY2hhbm5lbE5hbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQ2hhbm5lbHMub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGV2ZW50IHVuc3BlY2lmaWVkIGNoYW5uZWwsIGFjdGlvbiA9ICcgKyBtc2cuYWN0aW9uKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG5cdFx0aWYoIWNoYW5uZWwpIHtcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCBmb3Igbm9uLWV4aXN0ZW50IGNoYW5uZWw6ICcgKyBjaGFubmVsTmFtZSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGNoYW5uZWwub25NZXNzYWdlKG1zZyk7XG5cdH07XG5cblx0LyogY2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgYmVjb21lcyBjb25uZWN0ZWQ7IHJlYXR0ZW1wdCBhdHRhY2gvZGV0YWNoXG5cdCAqIGZvciBjaGFubmVscyB0aGF0IGFyZSBhdHRhY2hpbmcgb3IgZGV0YWNoaW5nLlxuXHQgKiBOb3RlIHRoYXQgdGhpcyBkb2VzIG5vdCB1c2UgaW5Qcm9ncmVzcyBhcyBpblByb2dyZXNzIGlzIG9ubHkgY2hhbm5lbHMgd2hpY2ggaGF2ZSBhbHJlYWR5IG1hZGVcblx0KiBhdCBsZWFzdCBvbmUgYXR0ZW1wdCB0byBhdHRhY2gvZGV0YWNoICovXG5cdENoYW5uZWxzLnByb3RvdHlwZS5vblRyYW5zcG9ydEFjdGl2ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGZvcih2YXIgY2hhbm5lbE5hbWUgaW4gdGhpcy5hbGwpIHtcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbE5hbWVdO1xuXHRcdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGluZycgfHwgY2hhbm5lbC5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcblx0XHRcdFx0Y2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuXHRcdFx0fSBlbHNlIGlmKGNoYW5uZWwuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG5cdFx0XHRcdGNoYW5uZWwuYXR0YWNoKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZWF0dGFjaCA9IGZ1bmN0aW9uKHJlYXNvbikge1xuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG5cdFx0XHQvKiBOQiB0aGlzIHNob3VsZCBub3QgdHJpZ2dlciBmb3IgbWVyZWx5IGF0dGFjaGluZyBjaGFubmVscywgYXMgdGhleSB3aWxsXG5cdFx0XHQgKiBiZSByZWF0dGFjaGVkIGFueXdheSB0aHJvdWdoIHRoZSBvblRyYW5zcG9ydEFjdGl2ZSBjaGVja1BlbmRpbmdTdGF0ZSAqL1xuXHRcdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuXHRcdFx0XHRjaGFubmVsLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgcmVhc29uKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLnJlc2V0QXR0YWNoZWRNc2dJbmRpY2F0b3JzID0gZnVuY3Rpb24oKSB7XG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcblx0XHRcdGNoYW5uZWwuX2F0dGFjaGVkTXNnSW5kaWNhdG9yID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5jaGVja0F0dGFjaGVkTXNnSW5kaWNhdG9ycyA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25JZCkge1xuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XG5cdFx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxJZF07XG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnICYmIGNoYW5uZWwuX2F0dGFjaGVkTXNnSW5kaWNhdG9yID09PSBmYWxzZSkge1xuXHRcdFx0XHR2YXIgbXNnID0gJzMwcyBhZnRlciBhIHJlc3VtZSwgZm91bmQgY2hhbm5lbCB3aGljaCBoYXMgbm90IHJlY2VpdmVkIGFuIGF0dGFjaGVkOyBjaGFubmVsSWQgPSAnICsgY2hhbm5lbElkICsgJzsgY29ubmVjdGlvbklkID0gJyArIGNvbm5lY3Rpb25JZDtcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQ2hhbm5lbHMuY2hlY2tBdHRhY2hlZE1zZ0luZGljYXRvcnMoKScsIG1zZyk7XG5cdFx0XHRcdGVycm9ycmVwb3J0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ucmVwb3J0KCdlcnJvcicsIG1zZywgJ2NoYW5uZWwtbm8tYXR0YWNoZWQtYWZ0ZXItcmVzdW1lJyk7XG5cdFx0XHRcdGNoYW5uZWwucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcblx0XHRcdH07XG5cdFx0fVxuXHR9O1xuXG5cdC8qIENvbm5lY3Rpb24gaW50ZXJydXB0aW9ucyAoaWUgd2hlbiB0aGUgY29ubmVjdGlvbiB3aWxsIG5vIGxvbmdlciBxdWV1ZVxuXHQgKiBldmVudHMpIGltcGx5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBmb3IgYW55IGNoYW5uZWwgd2hpY2ggaXMgZWl0aGVyXG5cdCAqIGF0dGFjaGVkLCBwZW5kaW5nLCBvciB3aWxsIGF0dGVtcHQgdG8gYmVjb21lIGF0dGFjaGVkIGluIHRoZSBmdXR1cmUgKi9cblx0Q2hhbm5lbHMucHJvdG90eXBlLnByb3BvZ2F0ZUNvbm5lY3Rpb25JbnRlcnJ1cHRpb24gPSBmdW5jdGlvbihjb25uZWN0aW9uU3RhdGUsIHJlYXNvbikge1xuXHRcdHZhciBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZSA9IHtcblx0XHRcdCdjbG9zaW5nJyAgOiAnZGV0YWNoZWQnLFxuXHRcdFx0J2Nsb3NlZCcgICA6ICdkZXRhY2hlZCcsXG5cdFx0XHQnZmFpbGVkJyAgIDogJ2ZhaWxlZCcsXG5cdFx0XHQnc3VzcGVuZGVkJzogJ3N1c3BlbmRlZCdcblx0XHR9O1xuXHRcdHZhciBmcm9tQ2hhbm5lbFN0YXRlcyA9IFsnYXR0YWNoaW5nJywgJ2F0dGFjaGVkJywgJ2RldGFjaGluZycsICdzdXNwZW5kZWQnXTtcblx0XHR2YXIgdG9DaGFubmVsU3RhdGUgPSBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZVtjb25uZWN0aW9uU3RhdGVdO1xuXG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcblx0XHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckluKGZyb21DaGFubmVsU3RhdGVzLCBjaGFubmVsLnN0YXRlKSkge1xuXHRcdFx0XHQgY2hhbm5lbC5ub3RpZnlTdGF0ZSh0b0NoYW5uZWxTdGF0ZSwgcmVhc29uKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cblx0Q2hhbm5lbHMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuXHRcdGlmKCFjaGFubmVsKSB7XG5cdFx0XHRjaGFubmVsID0gdGhpcy5hbGxbbmFtZV0gPSBuZXcgcmVhbHRpbWVjaGFubmVsKHRoaXMucmVhbHRpbWUsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcblx0XHR9IGVsc2UgaWYoY2hhbm5lbE9wdGlvbnMpIHtcblx0XHRcdGlmIChjaGFubmVsLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucykpIHtcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcIkNoYW5uZWxzLmdldCgpIGNhbm5vdCBiZSB1c2VkIHRvIHNldCBjaGFubmVsIG9wdGlvbnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgY2hhbm5lbCB0byByZWF0dGFjaC4gUGxlYXNlLCB1c2UgUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKSBpbnN0ZWFkLlwiLCA0MDAwMCwgNDAwKTtcblx0XHRcdH1cblx0XHRcdGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG5cdFx0fVxuXHRcdHJldHVybiBjaGFubmVsO1xuXHR9O1xuXG5cdC8qIEluY2x1ZGVkIHRvIHN1cHBvcnQgY2VydGFpbiBuaWNoZSB1c2UtY2FzZXM7IG1vc3QgdXNlcnMgc2hvdWxkIGlnbm9yZSB0aGlzLlxuXHQgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xuXHRDaGFubmVscy5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRuYW1lID0gU3RyaW5nKG5hbWUpO1xuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG5cdFx0aWYoIWNoYW5uZWwpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHJlbGVhc2VFcnIgPSBjaGFubmVsLmdldFJlbGVhc2VFcnIoKTtcblx0XHRpZihyZWxlYXNlRXJyKSB7XG5cdFx0XHR0aHJvdyByZWxlYXNlRXJyO1xuXHRcdH1cblx0XHRkZWxldGUgdGhpcy5hbGxbbmFtZV07XG5cdFx0ZGVsZXRlIHRoaXMuaW5Qcm9ncmVzc1tuYW1lXTtcblx0fTtcblxuXHQvKiBSZWNvcmRzIG9wZXJhdGlvbnMgY3VycmVudGx5IHBlbmRpbmcgb24gYSB0cmFuc3BvcnQ7IHVzZWQgYnkgY29ubmVjdGlvbk1hbmFnZXIgdG8gZGVjaWRlIHdoZW5cblx0ICogaXQncyBzYWZlIHRvIHVwZ3JhZGUuIE5vdGUgdGhhdCBhIGNoYW5uZWwgbWlnaHQgYmUgaW4gdGhlIGF0dGFjaGluZyBzdGF0ZSB3aXRob3V0IGFueSBwZW5kaW5nXG5cdCAqIG9wZXJhdGlvbnMgKGVnIGlmIGF0dGFjaGVkIHdoaWxlIHRoZSBjb25uZWN0aW9uIHN0YXRlIGlzIGNvbm5lY3RpbmcpIC0gc3VjaCBhIGNoYW5uZWwgbXVzdCBub3Rcblx0ICogaG9sZCB1cCBhbiB1cGdyYWRlLCBzbyBpcyBub3QgY29uc2lkZXJlZCBpblByb2dyZXNzLlxuXHQgKiBPcGVyYXRpb24gaXMgY3VycmVudGx5IG9uZSBvZiBlaXRoZXIgJ3N0YXRlY2hhbmdlJyBvciAnc3luYycgKi9cblx0Q2hhbm5lbHMucHJvdG90eXBlLnNldEluUHJvZ3Jlc3MgPSBmdW5jdGlvbihjaGFubmVsLCBvcGVyYXRpb24sIGluUHJvZ3Jlc3MpIHtcblx0XHR0aGlzLmluUHJvZ3Jlc3NbY2hhbm5lbC5uYW1lXSA9IHRoaXMuaW5Qcm9ncmVzc1tjaGFubmVsLm5hbWVdIHx8IHt9O1xuXHRcdHRoaXMuaW5Qcm9ncmVzc1tjaGFubmVsLm5hbWVdW29wZXJhdGlvbl0gPSBpblByb2dyZXNzO1xuXHRcdGlmKCFpblByb2dyZXNzICYmIHRoaXMuaGFzTm9wZW5kaW5nKCkpIHtcblx0XHRcdHRoaXMuZW1pdCgnbm9wZW5kaW5nJyk7XG5cdFx0fVxuXHR9O1xuXG5cdENoYW5uZWxzLnByb3RvdHlwZS5vbmNlTm9wZW5kaW5nID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcblx0XHRpZih0aGlzLmhhc05vcGVuZGluZygpKSB7XG5cdFx0XHRsaXN0ZW5lcigpO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHR0aGlzLm9uY2UoJ25vcGVuZGluZycsIGxpc3RlbmVyKTtcblx0fTtcblxuXHRDaGFubmVscy5wcm90b3R5cGUuaGFzTm9wZW5kaW5nID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckV2ZXJ5KHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnZhbHVlc0FycmF5KHRoaXMuaW5Qcm9ncmVzcywgdHJ1ZSksIGZ1bmN0aW9uKG9wZXJhdGlvbnMpIHtcblx0XHRcdHJldHVybiAhdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uY29udGFpbnNWYWx1ZShvcGVyYXRpb25zLCB0cnVlKTtcblx0XHR9KTtcblx0fTtcblxuXHRyZXR1cm4gUmVhbHRpbWU7XG59KSgpO1xuXG5yZWFsdGltZV9SZWFsdGltZS5Qcm9taXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xuXHRvcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcblx0b3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG5cdHJldHVybiBuZXcgcmVhbHRpbWVfUmVhbHRpbWUob3B0aW9ucyk7XG59O1xuXG5yZWFsdGltZV9SZWFsdGltZS5DYWxsYmFja3MgPSByZWFsdGltZV9SZWFsdGltZTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY2xpZW50X3JlYWx0aW1lID0gKHJlYWx0aW1lX1JlYWx0aW1lKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvbXNncGFjay5qc1xudmFyIHV0aWxfbXNncGFjayA9IF9fd2VicGFja19yZXF1aXJlX18oMjQpO1xuXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvaW5kZXguanNcblxuXG5cblxuXG5cblxuXG5cblxuXG5cblxuXG5jbGllbnRfcmVzdC5VdGlscyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuQnVmZmVyVXRpbHMgPSBidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZXN0LkNyeXB0byA9IHV0aWxfY3J5cHRvW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuRGVmYXVsdHMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZXN0Lkh0dHAgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3Jlc3QuUmVzb3VyY2UgPSBjbGllbnRfcmVzb3VyY2U7XG5jbGllbnRfcmVzdC5NZXNzYWdlID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZXN0LlByZXNlbmNlTWVzc2FnZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcblxuY2xpZW50X3JlYWx0aW1lLlV0aWxzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuQnVmZmVyVXRpbHMgPSBidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5DcnlwdG8gPSB1dGlsX2NyeXB0b1tcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5EZWZhdWx0cyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLkh0dHAgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLk1lc3NhZ2UgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xuY2xpZW50X3JlYWx0aW1lLlByZXNlbmNlTWVzc2FnZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcbmNsaWVudF9yZWFsdGltZS5Qcm90b2NvbE1lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL107XG5jbGllbnRfcmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9ubWFuYWdlcltcImFcIiAvKiBkZWZhdWx0ICovXTtcblxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgbGliID0gX193ZWJwYWNrX2V4cG9ydHNfX1tcImRlZmF1bHRcIl0gPSAoe1xuICBSZXN0OiBjbGllbnRfcmVzdCxcbiAgUmVhbHRpbWU6IGNsaWVudF9yZWFsdGltZSxcbiAgbXNncGFjazogdXRpbF9tc2dwYWNrW1wiYVwiIC8qIGRlZmF1bHQgKi9dXG59KTtcblxuXG4vKioqLyB9KVxuLyoqKioqKi8gXSlbXCJkZWZhdWx0XCJdO1xufSk7IiwiXCJ1c2Ugc3RyaWN0XCI7XG5mdW5jdGlvbiBwcm9taXNpZnlPcHRpb25zKG9wdGlvbnMpIHtcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcbiAgICBvcHRpb25zID0gKG9wdGlvbnMuaW5kZXhPZignOicpID09IC0xKSA/IHt0b2tlbjogb3B0aW9uc30gOiB7a2V5OiBvcHRpb25zfTtcbiAgfVxuICBvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcbiAgcmV0dXJuIG9wdGlvbnM7XG59XG5cbi8qIFBsZWFzZSBub3RlIHRoYXQgdGhlIGZpbGUgaW1wb3J0ZWQgYmVsb3cgaXMgb25seSBnZW5lcmF0ZWQgYWZ0ZXIgcnVubmluZyBcbiAqIHRoZSBidWlsZCB0YXNrLiAqL1xudmFyIEFibHkgPSByZXF1aXJlKCcuL2Jyb3dzZXIvc3RhdGljL2FibHktbm9kZScpO1xuXG52YXIgUmVzdFByb21pc2UgPSBmdW5jdGlvbihvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgQWJseS5SZXN0KHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykpO1xufVxuT2JqZWN0LmFzc2lnbihSZXN0UHJvbWlzZSwgQWJseS5SZXN0KTtcblxudmFyIFJlYWx0aW1lUHJvbWlzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBBYmx5LlJlYWx0aW1lKHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykpO1xufVxuT2JqZWN0LmFzc2lnbihSZWFsdGltZVByb21pc2UsIEFibHkuUmVhbHRpbWUpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgUmVzdDogUmVzdFByb21pc2UsXG4gIFJlYWx0aW1lOiBSZWFsdGltZVByb21pc2Vcbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbnZhciBjdXN0b21JbnNwZWN0U3ltYm9sID1cbiAgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5mb3IgPT09ICdmdW5jdGlvbicpXG4gICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXG4gICAgOiBudWxsXG5cbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXG5leHBvcnRzLlNsb3dCdWZmZXIgPSBTbG93QnVmZmVyXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcblxudmFyIEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIHZhciBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIHZhciBwcm90byA9IHsgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9IH1cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihhcnIsIHByb3RvKVxuICAgIHJldHVybiBhcnIuZm9vKCkgPT09IDQyXG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ3BhcmVudCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcbiAgfVxufSlcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdvZmZzZXQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnl0ZU9mZnNldFxuICB9XG59KVxuXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAobGVuZ3RoID4gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBsZW5ndGggKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcbiAgfVxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZSh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICB2YXIgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdmFyIGIgPSBmcm9tT2JqZWN0KHZhbHVlKVxuICBpZiAoYikgcmV0dXJuIGJcblxuICBpZiAodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvUHJpbWl0aXZlICE9IG51bGwgJiZcbiAgICAgIHR5cGVvZiB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxuICAgICAgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aFxuICAgIClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xuICAgICAgPyBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcbiAgfVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxuICoqL1xuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcbn1cblxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG4vKipcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICovXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXG59XG5cbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycgfHwgZW5jb2RpbmcgPT09ICcnKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgfVxuXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICB9XG5cbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIHZhciBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmoubGVuZ3RoICE9PSB1bmRlZmluZWQpIHtcbiAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgfVxuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcbiAgfVxuXG4gIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWUgJiZcbiAgICBiICE9PSBCdWZmZXIucHJvdG90eXBlIC8vIHNvIEJ1ZmZlci5pc0J1ZmZlcihCdWZmZXIucHJvdG90eXBlKSB3aWxsIGJlIGZhbHNlXG59XG5cbkJ1ZmZlci5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAoYSwgYikge1xuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXG4gIGlmIChpc0luc3RhbmNlKGIsIFVpbnQ4QXJyYXkpKSBiID0gQnVmZmVyLmZyb20oYiwgYi5vZmZzZXQsIGIuYnl0ZUxlbmd0aClcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheSdcbiAgICApXG4gIH1cblxuICBpZiAoYSA9PT0gYikgcmV0dXJuIDBcblxuICB2YXIgeCA9IGEubGVuZ3RoXG4gIHZhciB5ID0gYi5sZW5ndGhcblxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xuICAgIGlmIChhW2ldICE9PSBiW2ldKSB7XG4gICAgICB4ID0gYVtpXVxuICAgICAgeSA9IGJbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG5CdWZmZXIuaXNFbmNvZGluZyA9IGZ1bmN0aW9uIGlzRW5jb2RpbmcgKGVuY29kaW5nKSB7XG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpcbiAgICBjYXNlICd1dGY4JzpcbiAgICBjYXNlICd1dGYtOCc6XG4gICAgY2FzZSAnYXNjaWknOlxuICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgY2FzZSAnYmluYXJ5JzpcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgIGNhc2UgJ3VjczInOlxuICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2VcbiAgfVxufVxuXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcbiAgfVxuXG4gIHZhciBpXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGxlbmd0aCA9IDBcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgbGVuZ3RoICs9IGxpc3RbaV0ubGVuZ3RoXG4gICAgfVxuICB9XG5cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIHZhciBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBidWYgPSBCdWZmZXIuZnJvbShidWYpXG4gICAgfVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXG4gIGlmICghbXVzdE1hdGNoICYmIGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xuICAgICAgICAgIHJldHVybiBtdXN0TWF0Y2ggPyAtMSA6IHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIH1cbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIHN0ciA9IHRoaXMudG9TdHJpbmcoJ2hleCcsIDAsIG1heCkucmVwbGFjZSgvKC57Mn0pL2csICckMSAnKS50cmltKClcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcbiAgQnVmZmVyLnByb3RvdHlwZVtjdXN0b21JbnNwZWN0U3ltYm9sXSA9IEJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoaXNJbnN0YW5jZSh0YXJnZXQsIFVpbnQ4QXJyYXkpKSB7XG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcbiAgfVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHRhcmdldClcbiAgICApXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0IC8vIENvZXJjZSB0byBOdW1iZXIuXG4gIGlmIChudW1iZXJJc05hTihieXRlT2Zmc2V0KSkge1xuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxuICAgIGJ5dGVPZmZzZXQgPSBkaXIgPyAwIDogKGJ1ZmZlci5sZW5ndGggLSAxKVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXQ6IG5lZ2F0aXZlIG9mZnNldHMgc3RhcnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBidWZmZXJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgIGlmIChkaXIpIHJldHVybiAtMVxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICBpZiAoZGlyKSBieXRlT2Zmc2V0ID0gMFxuICAgIGVsc2UgcmV0dXJuIC0xXG4gIH1cblxuICAvLyBOb3JtYWxpemUgdmFsXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHZhbCA9IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gIH1cblxuICAvLyBGaW5hbGx5LCBzZWFyY2ggZWl0aGVyIGluZGV4T2YgKGlmIGRpciBpcyB0cnVlKSBvciBsYXN0SW5kZXhPZlxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAtMVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXG4gICAgaWYgKHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBpZiAoZGlyKSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFt2YWxdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGxhdGluMVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGFzY2lpV3JpdGUoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICB2YXIgcmVtYWluaW5nID0gdGhpcy5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkIHx8IGxlbmd0aCA+IHJlbWFpbmluZykgbGVuZ3RoID0gcmVtYWluaW5nXG5cbiAgaWYgKChzdHJpbmcubGVuZ3RoID4gMCAmJiAobGVuZ3RoIDwgMCB8fCBvZmZzZXQgPCAwKSkgfHwgb2Zmc2V0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byB3cml0ZSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICAvLyBXYXJuaW5nOiBtYXhMZW5ndGggbm90IHRha2VuIGludG8gYWNjb3VudCBpbiBiYXNlNjRXcml0ZVxuICAgICAgICByZXR1cm4gYmFzZTY0V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHVjczJXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xuICByZXR1cm4ge1xuICAgIHR5cGU6ICdCdWZmZXInLFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxuICB9XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKHN0YXJ0ID09PSAwICYmIGVuZCA9PT0gYnVmLmxlbmd0aCkge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1Zi5zbGljZShzdGFydCwgZW5kKSlcbiAgfVxufVxuXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG4gIHZhciByZXMgPSBbXVxuXG4gIHZhciBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgdmFyIGNvZGVQb2ludCA9IG51bGxcbiAgICB2YXIgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKSA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xuICAgICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIHZhciBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbnZhciBNQVhfQVJHVU1FTlRTX0xFTkdUSCA9IDB4MTAwMFxuXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcbiAgdmFyIGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgdmFyIHJlcyA9ICcnXG4gIHZhciBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICB2YXIgb3V0ID0gJydcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHR5cGVvZiBVaW50OEFycmF5LnByb3RvdHlwZS5jb3B5V2l0aGluID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gVXNlIGJ1aWx0LWluIHdoZW4gYXZhaWxhYmxlLCBtaXNzaW5nIGZyb20gSUUxMVxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcbiAgfSBlbHNlIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIHZhciBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcbiAgICAgID8gdmFsXG4gICAgICA6IEJ1ZmZlci5mcm9tKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXG5cbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcbiAgLy8gTm9kZSB0YWtlcyBlcXVhbCBzaWducyBhcyBlbmQgb2YgdGhlIEJhc2U2NCBlbmNvZGluZ1xuICBzdHIgPSBzdHIuc3BsaXQoJz0nKVswXVxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB1dGY4VG9CeXRlcyAoc3RyaW5nLCB1bml0cykge1xuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XG4gIHZhciBjb2RlUG9pbnRcbiAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIHZhciBieXRlcyA9IFtdXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIC8vIE5vZGUncyBjb2RlIHNlZW1zIHRvIGJlIGRvaW5nIHRoaXMgYW5kIG5vdCAmIDB4N0YuLlxuICAgIGJ5dGVBcnJheS5wdXNoKHN0ci5jaGFyQ29kZUF0KGkpICYgMHhGRilcbiAgfVxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVUb0J5dGVzIChzdHIsIHVuaXRzKSB7XG4gIHZhciBjLCBoaSwgbG9cbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG52YXIgaGV4U2xpY2VMb29rdXBUYWJsZSA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICB2YXIgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICB2YXIgaTE2ID0gaSAqIDE2XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgKytqKSB7XG4gICAgICB0YWJsZVtpMTYgKyBqXSA9IGFscGhhYmV0W2ldICsgYWxwaGFiZXRbal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRhYmxlXG59KSgpXG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1zdHlsZS1sb2FkZXIvcnVudGltZS9pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanNcIik7XG4gICAgICAgICAgICB2YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsyXSEuL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgLy8gdGhpcyBjb2RlIHNob3VsZCBmYWlsLlxuICAgICAgICAgICAgICAgIHZhciBhbmNob3JFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfXycpO1xuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XG4gICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgIC8vIEVhY2ggc3R5bGUgdGFnIHNob3VsZCBiZSBwbGFjZWQgcmlnaHQgYmVmb3JlIG91clxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcbiAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWxlbWVudCwgYW5jaG9yRWxlbWVudCk7XG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XG4gICAgaWYgKCFhICYmIGIgfHwgYSAmJiAhYikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGxldCBwO1xuICAgIGZvcihwIGluIGEpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yKHAgaW4gYil7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09ICdkZWZhdWx0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsyXSEuL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3NcIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzFdIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcG9zdGNzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsyXSEuL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3NcIik7XG5cbiAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQuX19lc01vZHVsZSA/IGNvbnRlbnQuZGVmYXVsdCA6IGNvbnRlbnQ7XG5cbiAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmICghaXNFcXVhbExvY2FscyhvbGRMb2NhbHMsIGNvbnRlbnQubG9jYWxzKSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZS5ob3QuaW52YWxpZGF0ZSgpO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgb2xkTG9jYWxzID0gY29udGVudC5sb2NhbHM7XG5cbiAgICAgICAgICAgICAgdXBkYXRlKGNvbnRlbnQpO1xuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHtcbiAgICB1cGRhdGUoKTtcbiAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHMgfHwge307IiwiLy8gSW1wb3J0c1xudmFyIF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyA9IHJlcXVpcmUoXCIuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvYXBpLmpzXCIpO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKHRydWUpO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiLmNoYXRDb21wb25lbnRzX2NoYXRIb2xkZXJfXzJFMUFYIHtcXHJcXG4gIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICBncmlkLXRlbXBsYXRlLXJvd3M6IDFmciAxMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX2NoYXRUZXh0X18zTVJFcyB7XFxyXFxuICBkaXNwbGF5OiAtbW96LWJveDtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICAtbW96LWJveC1vcmllbnQ6IHZlcnRpY2FsO1xcclxcbiAgLW1vei1ib3gtZGlyZWN0aW9uOiBub3JtYWw7XFxyXFxuICAgICAgIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxyXFxuICAtbW96LWJveC1hbGlnbjogc3RhcnQ7XFxyXFxuICAgICAgIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbiAgZ3JpZC1nYXA6IDFlbTtcXHJcXG4gIGdhcDogMWVtO1xcclxcbiAgcGFkZGluZzogMWVtO1xcclxcbiAgaGVpZ2h0OiAtd2Via2l0LWNhbGMoMTAwdmggLSA0MHB4IC0gMTAwcHggLSAxMDBweCAtIDEwMHB4KTtcXHJcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtIDQwcHggLSAxMDBweCAtIDEwMHB4IC0gMTAwcHgpO1xcclxcbiAgb3ZlcmZsb3cteTogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX2Zvcm1fXzNyRklLIHtcXHJcXG4gIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxMDBweDtcXHJcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWVlO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfdGV4dGFyZWFfXzJVdUx5IHtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGJvcmRlcjogMDtcXHJcXG4gIGZvbnQtZmFtaWx5OiAtYXBwbGUtc3lzdGVtLCBCbGlua01hY1N5c3RlbUZvbnQsIFNlZ29lIFVJLCBSb2JvdG8sIE94eWdlbixcXHJcXG4gICAgVWJ1bnR1LCBDYW50YXJlbGwsIEZpcmEgU2FucywgRHJvaWQgU2FucywgSGVsdmV0aWNhIE5ldWUsIHNhbnMtc2VyaWY7XFxyXFxuICBmb250LXNpemU6IDEuMmVtO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfYnV0dG9uX18zZVp5TSB7XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGZvbnQtc2l6ZTogMS40ZW07XFxyXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KGxpbmVhciwgbGVmdCB0b3AsIHJpZ2h0IHRvcCwgZnJvbSgjMzYzNzk1KSwgdG8oIzAwNWM5NykpO1xcclxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQobGVmdCwgIzM2Mzc5NSwgIzAwNWM5Nyk7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfYnV0dG9uX18zZVp5TTpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWdyYWRpZW50KFxcclxcbiAgICBsaW5lYXIsXFxyXFxuICAgIGxlZnQgdG9wLCByaWdodCB0b3AsXFxyXFxuICAgIGZyb20ocmdiYSg1NCwgNTUsIDE0OSwgMSkpLFxcclxcbiAgICBjb2xvci1zdG9wKDYyJSwgcmdiYSgwLCA5MiwgMTUxLCAxKSksXFxyXFxuICAgIHRvKHJnYmEoMCwgMTI1LCAyMDUsIDEpKVxcclxcbiAgKTtcXHJcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KFxcclxcbiAgICBsZWZ0LFxcclxcbiAgICByZ2JhKDU0LCA1NSwgMTQ5LCAxKSAwJSxcXHJcXG4gICAgcmdiYSgwLCA5MiwgMTUxLCAxKSA2MiUsXFxyXFxuICAgIHJnYmEoMCwgMTI1LCAyMDUsIDEpIDEwMCVcXHJcXG4gICk7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxyXFxuICAgIDkwZGVnLFxcclxcbiAgICByZ2JhKDU0LCA1NSwgMTQ5LCAxKSAwJSxcXHJcXG4gICAgcmdiYSgwLCA5MiwgMTUxLCAxKSA2MiUsXFxyXFxuICAgIHJnYmEoMCwgMTI1LCAyMDUsIDEpIDEwMCVcXHJcXG4gICk7XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c19idXR0b25fXzNlWnlNOmRpc2FibGVkLFxcclxcbi5jaGF0Q29tcG9uZW50c19idXR0b25fXzNlWnlNOmhvdmVyOmRpc2FibGVkIHtcXHJcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgcmlnaHQgdG9wLCBmcm9tKCMzNjM3OTUpLCB0bygjMDA1Yzk3KSk7XFxyXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCAjMzYzNzk1LCAjMDA1Yzk3KTtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgIzM2Mzc5NSwgIzAwNWM5Nyk7XFxyXFxuICBvcGFjaXR5OiAwLjU7XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c19tZXNzYWdlX18xZG5vQiB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVmNWY4O1xcclxcbiAgcGFkZGluZzogMWVtO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gIC1tb3otYm94LWZsZXg6IDA7XFxyXFxuICAgICAgIGZsZXgtZ3JvdzogMDtcXHJcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxyXFxufVxcclxcblwiLCBcIlwiLHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIndlYnBhY2s6Ly9jb21wb25lbnRzL2NoYXRyb29tL2NoYXRDb21wb25lbnRzLm1vZHVsZS5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7RUFDRSxhQUFhO0VBQ2IsNkJBQTZCO0FBQy9COztBQUVBO0VBQ0UsaUJBQWE7RUFBYixhQUFhO0VBQ2IseUJBQXNCO0VBQXRCLDBCQUFzQjtPQUF0QixzQkFBc0I7RUFDdEIscUJBQXVCO09BQXZCLHVCQUF1QjtFQUN2QixhQUFRO0VBQVIsUUFBUTtFQUNSLFlBQVk7RUFDWiwwREFBa0Q7RUFBbEQsa0RBQWtEO0VBQ2xELGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLGFBQWE7RUFDYixnQ0FBZ0M7RUFDaEMsMEJBQTBCO0FBQzVCOztBQUVBO0VBQ0UsWUFBWTtFQUNaLFNBQVM7RUFDVDt3RUFDc0U7RUFDdEUsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsU0FBUztFQUNULFlBQVk7RUFDWixpQkFBaUI7RUFDakIsZ0JBQWdCO0VBQ2hCLHFGQUF1RDtFQUF2RCwyREFBdUQ7RUFBdkQsdURBQXVEO0FBQ3pEOztBQUVBO0VBQ0U7Ozs7OztHQUtDO0VBTEQ7Ozs7O0dBS0M7RUFMRDs7Ozs7R0FLQztBQUNIOztBQUVBOztFQUVFLHFGQUF1RDtFQUF2RCwyREFBdUQ7RUFBdkQsdURBQXVEO0VBQ3ZELFlBQVk7QUFDZDs7QUFFQTtFQUNFLHlCQUF5QjtFQUN6QixZQUFZO0VBQ1osbUJBQW1CO0VBQ25CLGdCQUFZO09BQVosWUFBWTtFQUNaLDRCQUE0QjtBQUM5QlwiLFwic291cmNlc0NvbnRlbnRcIjpbXCIuY2hhdEhvbGRlciB7XFxyXFxuICBkaXNwbGF5OiBncmlkO1xcclxcbiAgZ3JpZC10ZW1wbGF0ZS1yb3dzOiAxZnIgMTAwcHg7XFxyXFxufVxcclxcblxcclxcbi5jaGF0VGV4dCB7XFxyXFxuICBkaXNwbGF5OiBmbGV4O1xcclxcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIGFsaWduLWl0ZW1zOiBmbGV4LXN0YXJ0O1xcclxcbiAgZ2FwOiAxZW07XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBoZWlnaHQ6IGNhbGMoMTAwdmggLSA0MHB4IC0gMTAwcHggLSAxMDBweCAtIDEwMHB4KTtcXHJcXG4gIG92ZXJmbG93LXk6IGF1dG87XFxyXFxufVxcclxcblxcclxcbi5mb3JtIHtcXHJcXG4gIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICBncmlkLXRlbXBsYXRlLWNvbHVtbnM6IDFmciAxMDBweDtcXHJcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjZWVlO1xcclxcbn1cXHJcXG5cXHJcXG4udGV4dGFyZWEge1xcclxcbiAgcGFkZGluZzogMWVtO1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgU2Vnb2UgVUksIFJvYm90bywgT3h5Z2VuLFxcclxcbiAgICBVYnVudHUsIENhbnRhcmVsbCwgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSwgc2Fucy1zZXJpZjtcXHJcXG4gIGZvbnQtc2l6ZTogMS4yZW07XFxyXFxufVxcclxcblxcclxcbi5idXR0b24ge1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgY29sb3I6IHdoaXRlO1xcclxcbiAgZm9udC13ZWlnaHQ6IGJvbGQ7XFxyXFxuICBmb250LXNpemU6IDEuNGVtO1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjMzYzNzk1LCAjMDA1Yzk3KTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbjpob3ZlciB7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQoXFxyXFxuICAgIDkwZGVnLFxcclxcbiAgICByZ2JhKDU0LCA1NSwgMTQ5LCAxKSAwJSxcXHJcXG4gICAgcmdiYSgwLCA5MiwgMTUxLCAxKSA2MiUsXFxyXFxuICAgIHJnYmEoMCwgMTI1LCAyMDUsIDEpIDEwMCVcXHJcXG4gICk7XFxyXFxufVxcclxcblxcclxcbi5idXR0b246ZGlzYWJsZWQsXFxyXFxuLmJ1dHRvbjpob3ZlcjpkaXNhYmxlZCB7XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbiAgb3BhY2l0eTogMC41O1xcclxcbn1cXHJcXG5cXHJcXG4ubWVzc2FnZSB7XFxyXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVmNWY4O1xcclxcbiAgcGFkZGluZzogMWVtO1xcclxcbiAgYm9yZGVyLXJhZGl1czogMTBweDtcXHJcXG4gIGZsZXgtZ3JvdzogMDtcXHJcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDA7XFxyXFxufVxcclxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ubG9jYWxzID0ge1xuXHRcImNoYXRIb2xkZXJcIjogXCJjaGF0Q29tcG9uZW50c19jaGF0SG9sZGVyX18yRTFBWFwiLFxuXHRcImNoYXRUZXh0XCI6IFwiY2hhdENvbXBvbmVudHNfY2hhdFRleHRfXzNNUkVzXCIsXG5cdFwiZm9ybVwiOiBcImNoYXRDb21wb25lbnRzX2Zvcm1fXzNyRklLXCIsXG5cdFwidGV4dGFyZWFcIjogXCJjaGF0Q29tcG9uZW50c190ZXh0YXJlYV9fMlV1THlcIixcblx0XCJidXR0b25cIjogXCJjaGF0Q29tcG9uZW50c19idXR0b25fXzNlWnlNXCIsXG5cdFwibWVzc2FnZVwiOiBcImNoYXRDb21wb25lbnRzX21lc3NhZ2VfXzFkbm9CXCJcbn07XG5tb2R1bGUuZXhwb3J0cyA9IF9fX0NTU19MT0FERVJfRVhQT1JUX19fO1xuIiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2FycmF5TGlrZVRvQXJyYXkoYXJyLCBsZW4pIHtcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgYXJyMltpXSA9IGFycltpXTtcbiAgfVxuXG4gIHJldHVybiBhcnIyO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycjtcbn0iLCJpbXBvcnQgYXJyYXlMaWtlVG9BcnJheSBmcm9tIFwiLi9hcnJheUxpa2VUb0FycmF5LmpzXCI7XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KGFycik7XG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHtcbiAgdmFyIF9pID0gYXJyID09IG51bGwgPyBudWxsIDogdHlwZW9mIFN5bWJvbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuXG4gIGlmIChfaSA9PSBudWxsKSByZXR1cm47XG4gIHZhciBfYXJyID0gW107XG4gIHZhciBfbiA9IHRydWU7XG4gIHZhciBfZCA9IGZhbHNlO1xuXG4gIHZhciBfcywgX2U7XG5cbiAgdHJ5IHtcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XG4gICAgICBfYXJyLnB1c2goX3MudmFsdWUpO1xuXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBfZCA9IHRydWU7XG4gICAgX2UgPSBlcnI7XG4gIH0gZmluYWxseSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghX24gJiYgX2lbXCJyZXR1cm5cIl0gIT0gbnVsbCkgX2lbXCJyZXR1cm5cIl0oKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gX2Fycjtcbn0iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfbm9uSXRlcmFibGVSZXN0KCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9ub25JdGVyYWJsZVNwcmVhZCgpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59IiwiaW1wb3J0IGFycmF5V2l0aEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5TGltaXQgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5TGltaXQuanNcIjtcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IG5vbkl0ZXJhYmxlUmVzdCBmcm9tIFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9zbGljZWRUb0FycmF5KGFyciwgaSkge1xuICByZXR1cm4gYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFyciwgaSkgfHwgbm9uSXRlcmFibGVSZXN0KCk7XG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCI7XG5pbXBvcnQgaXRlcmFibGVUb0FycmF5IGZyb20gXCIuL2l0ZXJhYmxlVG9BcnJheS5qc1wiO1xuaW1wb3J0IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5IGZyb20gXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCI7XG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHtcbiAgcmV0dXJuIGFycmF5V2l0aG91dEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5KGFycikgfHwgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCBub25JdGVyYWJsZVNwcmVhZCgpO1xufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59Il0sIm5hbWVzIjpbIkFibHkiLCJ1c2VFZmZlY3QiLCJhYmx5IiwiUmVhbHRpbWUiLCJQcm9taXNlIiwiYXV0aFVybCIsInVzZUNoYW5uZWwiLCJjaGFubmVsTmFtZSIsImNhbGxiYWNrT25NZXNzYWdlIiwiY2hhbm5lbCIsImNoYW5uZWxzIiwiZ2V0Iiwib25Nb3VudCIsInN1YnNjcmliZSIsIm1zZyIsIm9uVW5Nb3VudCIsInVuc3Vic2NyaWJlIiwidXNlRWZmZWN0SG9vayIsIlJlYWN0IiwidXNlU3RhdGUiLCJzdHlsZXMiLCJDaGF0Q29tcG9uZW50IiwiaW5wdXRCb3giLCJtZXNzYWdlRW5kIiwibWVzc2FnZVRleHQiLCJzZXRNZXNzYWdlVGV4dCIsInJlY2VpdmVkTWVzc2FnZXMiLCJzZXRNZXNzYWdlcyIsIm1lc3NhZ2VUZXh0SXNFbXB0eSIsInRyaW0iLCJsZW5ndGgiLCJtZXNzYWdlIiwiaGlzdG9yeSIsInNsaWNlIiwic2VuZENoYXRNZXNzYWdlIiwicHVibGlzaCIsIm5hbWUiLCJkYXRhIiwiZm9jdXMiLCJoYW5kbGVGb3JtU3VibWlzc2lvbiIsImV2ZW50IiwicHJldmVudERlZmF1bHQiLCJoYW5kbGVLZXlQcmVzcyIsImNoYXJDb2RlIiwibWVzc2FnZXMiLCJtYXAiLCJpbmRleCIsImF1dGhvciIsImNvbm5lY3Rpb25JZCIsImNvbm5lY3Rpb24iLCJpZCIsIm1pbGxpc2Vjb25kcyIsIkRhdGUiLCJ0aW1lU3RhbXAiLCJ0b0RhdGVTdHJpbmciLCJzY3JvbGxJbnRvVmlldyIsImJlaGF2aW91ciIsImNoYXRIb2xkZXIiLCJjaGF0VGV4dCIsImVsZW1lbnQiLCJmb3JtIiwiZSIsInRhcmdldCIsInZhbHVlIiwidGV4dGFyZWEiLCJidXR0b24iXSwic291cmNlUm9vdCI6IiJ9