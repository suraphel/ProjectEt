(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["components_chatroom_chatComponents_js"],{

/***/ "./components/chatroom/AblyReactEffect.js":
/*!************************************************!*\
  !*** ./components/chatroom/AblyReactEffect.js ***!
  \************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "useChannel": function() { return /* binding */ useChannel; }
/* harmony export */ });
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably/promises */ "./node_modules/ably/promises.js");
/* harmony import */ var ably_promises__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(ably_promises__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);
/* module decorator */ module = __webpack_require__.hmd(module);
var _s = $RefreshSig$();

//offer company name and logo
// textarea for his offer
// hidden and appear
// states for rendering the page
//WebSocket connections
//Ably
//add and Id
//add message storage and retrival
//


var ably = new (ably_promises__WEBPACK_IMPORTED_MODULE_0___default().Realtime.Promise)({
  authUrl: "/api/createTokenRequest"
}); // console.log(ably);

function useChannel(channelName, callbackOnMessage) {
  _s();

  var channel = ably.channels.get(channelName);

  var onMount = function onMount() {
    channel.subscribe(function (msg) {
      callbackOnMessage(msg);
    });
  };

  var onUnMount = function onUnMount() {
    channel.unsubscribe();
  };

  var useEffectHook = function useEffectHook() {
    onMount();
    return function () {
      onUnMount();
    };
  };

  (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(useEffectHook);
  return [channel, ably];
}

_s(useChannel, "OD7bBpZva5O2jO+Puf00hKivP7c=");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./components/chatroom/chatComponents.js":
/*!***********************************************!*\
  !*** ./components/chatroom/chatComponents.js ***!
  \***********************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var A_Projects_Gitkraken_ProjectEt_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/toConsumableArray */ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js");
/* harmony import */ var A_Projects_Gitkraken_ProjectEt_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./node_modules/@babel/runtime/helpers/esm/slicedToArray */ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ "./node_modules/react/index.js");
/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./AblyReactEffect */ "./components/chatroom/AblyReactEffect.js");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../chatroom/chatComponents.module.css */ "./components/chatroom/chatComponents.module.css");
/* harmony import */ var _chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react/jsx-dev-runtime */ "./node_modules/react/jsx-dev-runtime.js");
/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__);
/* module decorator */ module = __webpack_require__.hmd(module);



var _jsxFileName = "A:\\Projects\\Gitkraken\\ProjectEt\\components\\chatroom\\chatComponents.js",
    _this = undefined,
    _s = $RefreshSig$();






var ChatComponent = function ChatComponent() {
  _s();

  var inputBox = null;
  var messageEnd = null;

  var _useState = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)(""),
      messageText = _useState[0],
      setMessageText = _useState[1];

  var _useState2 = (0,react__WEBPACK_IMPORTED_MODULE_2__.useState)([]),
      receivedMessages = _useState2[0],
      setMessages = _useState2[1];

  var messageTextIsEmpty = messageText.trim().length === 0;

  var _useChannel = (0,_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel)("chat-demo", function (message) {
    var history = receivedMessages.slice(-199);
    setMessages([].concat((0,A_Projects_Gitkraken_ProjectEt_node_modules_babel_runtime_helpers_esm_toConsumableArray__WEBPACK_IMPORTED_MODULE_0__.default)(history), [message]));
  }),
      _useChannel2 = (0,A_Projects_Gitkraken_ProjectEt_node_modules_babel_runtime_helpers_esm_slicedToArray__WEBPACK_IMPORTED_MODULE_1__.default)(_useChannel, 2),
      channel = _useChannel2[0],
      ably = _useChannel2[1];

  var sendChatMessage = function sendChatMessage(messageText) {
    channel.publish({
      name: "chat-message",
      data: messageText
    });
    setMessageText("");
    inputBox.focus();
  };

  var handleFormSubmission = function handleFormSubmission(event) {
    event.preventDefault();
    sendChatMessage(messageText);
  };

  var handleKeyPress = function handleKeyPress(event) {
    if (event.charCode !== 13 || messageTextIsEmpty) {
      return;
    }

    sendChatMessage(messageText);
    event.preventDefault();
  };

  var messages = receivedMessages.map(function (message, index) {
    var author = message.connectionId === ably.connection.id ? "me" : "other";
    var milliseconds = new Date();
    var timeStamp = milliseconds.toDateString(); // function parseMillisecondsIntoReadableTime(milliseconds) {
    //   //Get hours from milliseconds
    //   var hours = milliseconds / (1000 * 60 * 60);
    //   var absoluteHours = Math.floor(hours);
    //   var h = absoluteHours > 9 ? absoluteHours : "0" + absoluteHours;
    //   //Get remainder from hours and convert to minutes
    //   var minutes = (hours - absoluteHours) * 60;
    //   var absoluteMinutes = Math.floor(minutes);
    //   var m = absoluteMinutes > 9 ? absoluteMinutes : "0" + absoluteMinutes;
    //   //Get remainder from minutes and convert to seconds
    //   var seconds = (minutes - absoluteMinutes) * 60;
    //   var absoluteSeconds = Math.floor(seconds);
    //   var s = absoluteSeconds > 9 ? absoluteSeconds : "0" + absoluteSeconds;
    //   return h + ":" + m + ":" + s;
    // }
    // var time = parseMillisecondsIntoReadableTime(milliseconds);
    // alert(time);
    // console.log(time);

    return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("span", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().message) // time={new Date().toString()}
      ,
      "data-author": author,
      children: message.data
    }, index, false, {
      fileName: _jsxFileName,
      lineNumber: 68,
      columnNumber: 7
    }, _this);
  });
  (0,react__WEBPACK_IMPORTED_MODULE_2__.useEffect)(function () {
    messageEnd.scrollIntoView({
      behaviour: "smooth"
    });
  });
  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
    className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatHolder),
    children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().chatText),
      children: [messages, new Date().toDateString(), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("div", {
        ref: function ref(element) {
          messageEnd = element;
        }
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 88,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 85,
      columnNumber: 7
    }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("form", {
      onSubmit: handleFormSubmission,
      className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().form),
      children: [/*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("textarea", {
        ref: function ref(element) {
          inputBox = element;
        },
        value: messageText,
        placeholder: "Type a message..." // time={new Date().toString()}
        ,
        onChange: function onChange(e) {
          return setMessageText(e.target.value);
        },
        onKeyPress: handleKeyPress,
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().textarea)
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 95,
        columnNumber: 9
      }, _this), /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_4__.jsxDEV)("button", {
        type: "submit",
        className: (_chatroom_chatComponents_module_css__WEBPACK_IMPORTED_MODULE_5___default().button),
        disabled: messageTextIsEmpty,
        children: "Send"
      }, void 0, false, {
        fileName: _jsxFileName,
        lineNumber: 106,
        columnNumber: 9
      }, _this)]
    }, void 0, true, {
      fileName: _jsxFileName,
      lineNumber: 94,
      columnNumber: 7
    }, _this)]
  }, void 0, true, {
    fileName: _jsxFileName,
    lineNumber: 84,
    columnNumber: 5
  }, _this);
};

_s(ChatComponent, "UHCFF9ns1jrEPUyCddaISRIBzu0=", false, function () {
  return [_AblyReactEffect__WEBPACK_IMPORTED_MODULE_3__.useChannel];
});

_c = ChatComponent;
/* harmony default export */ __webpack_exports__["default"] = (ChatComponent);

var _c;

$RefreshReg$(_c, "ChatComponent");

;
    var _a, _b;
    // Legacy CSS implementations will `eval` browser code in a Node.js context
    // to extract CSS. For backwards compatibility, we need to check we're in a
    // browser context before continuing.
    if (typeof self !== 'undefined' &&
        // AMP / No-JS mode does not inject these helpers:
        '$RefreshHelpers$' in self) {
        var currentExports = module.__proto__.exports;
        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;
        // This cannot happen in MainTemplate because the exports mismatch between
        // templating and execution.
        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);
        // A module can be accepted automatically based on its exports, e.g. when
        // it is a Refresh Boundary.
        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {
            // Save the previous exports on update so we can compare the boundary
            // signatures.
            module.hot.dispose(function (data) {
                data.prevExports = currentExports;
            });
            // Unconditionally accept an update to this module, we'll check if it's
            // still a Refresh Boundary later.
            module.hot.accept();
            // This field is set when the previous version of this module was a
            // Refresh Boundary, letting us know we need to check for invalidation or
            // enqueue an update.
            if (prevExports !== null) {
                // A boundary can become ineligible if its exports are incompatible
                // with the previous exports.
                //
                // For example, if you add/remove/change exports, we'll want to
                // re-execute the importing modules, and force those components to
                // re-render. Similarly, if you convert a class component to a
                // function, we want to invalidate the boundary.
                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {
                    module.hot.invalidate();
                }
                else {
                    self.$RefreshHelpers$.scheduleUpdate();
                }
            }
        }
        else {
            // Since we just executed the code for the module, it's possible that the
            // new exports made it ineligible for being a boundary.
            // We only care about the case when we were _previously_ a boundary,
            // because we already accepted this update (accidental side effect).
            var isNoLongerABoundary = prevExports !== null;
            if (isNoLongerABoundary) {
                module.hot.invalidate();
            }
        }
    }


/***/ }),

/***/ "./node_modules/ably/browser/static/ably-commonjs.js":
/*!***********************************************************!*\
  !*** ./node_modules/ably/browser/static/ably-commonjs.js ***!
  \***********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
/*!
 * @license Copyright 2021, Ably
 * 
 * Ably JavaScript Library v1.2.13
 * https://github.com/ably/ably-js
 * 
 * Ably Realtime Messaging
 * https://www.ably.com
 * 
 * Released under the Apache Licence v2.0
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(true)
		module.exports = factory();
	else {}
})(window, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __nested_webpack_require_775__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_775__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__nested_webpack_require_775__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__nested_webpack_require_775__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__nested_webpack_require_775__.d = function(exports, name, getter) {
/******/ 		if(!__nested_webpack_require_775__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__nested_webpack_require_775__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__nested_webpack_require_775__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __nested_webpack_require_775__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__nested_webpack_require_775__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_775__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__nested_webpack_require_775__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__nested_webpack_require_775__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__nested_webpack_require_775__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__nested_webpack_require_775__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __nested_webpack_require_775__(__nested_webpack_require_775__.s = 50);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_4335__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_4335__(3);


var Logger = (function() {
	var consoleLogger, errorLogger;

	/* Can't just check for console && console.log; fails in IE <=9 */
	if((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||
		 (global.console && global.console.log && (typeof global.console.log.apply === 'function')) /* sensible browsers */) {
		consoleLogger = function() { console.log.apply(console, arguments); };
		errorLogger = console.warn ? function() { console.warn.apply(console, arguments); } : consoleLogger;
	} else if(global.console && global.console.log) {
		/* IE <= 9 with the console open -- console.log does not
		 * inherit from Function, so has no apply method */
		consoleLogger = errorLogger = function() { Function.prototype.apply.call(console.log, console, arguments); };
	} else {
		/* IE <= 9 when dev tools are closed - window.console not even defined */
		consoleLogger = errorLogger = function() {};
	}

	function pad(str, three) {
		return ('000' + str).slice(-2-(three || 0));
	}

	var LOG_NONE  = 0,
	LOG_ERROR = 1,
	LOG_MAJOR = 2,
	LOG_MINOR = 3,
	LOG_MICRO = 4;

	var LOG_DEFAULT = LOG_ERROR,
	LOG_DEBUG   = LOG_MICRO;

	var logLevel = LOG_DEFAULT;

	function getHandler(logger) {
		return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logTimestamps ?
			function(msg) {
				var time = new Date();
				logger(pad(time.getHours()) + ':' + pad(time.getMinutes()) + ':' + pad(time.getSeconds()) + '.' + pad(time.getMilliseconds(), true) + ' ' + msg);
			} : logger;
	}

	var logHandler = getHandler(consoleLogger),
		logErrorHandler = getHandler(errorLogger);

	/* public constructor */
	function Logger(args) {}

	/* public constants */
	Logger.LOG_NONE    = LOG_NONE,
	Logger.LOG_ERROR   = LOG_ERROR,
	Logger.LOG_MAJOR   = LOG_MAJOR,
	Logger.LOG_MINOR   = LOG_MINOR,
	Logger.LOG_MICRO   = LOG_MICRO;

	Logger.LOG_DEFAULT = LOG_DEFAULT,
	Logger.LOG_DEBUG   = LOG_DEBUG;

	/* public static functions */
	Logger.logAction = function(level, action, message) {
		if (Logger.shouldLog(level)) {
			(level === LOG_ERROR ? logErrorHandler : logHandler)('Ably: ' + action + ': ' + message);
		}
	};

	Logger.deprecated = function(original, replacement) {
		Logger.deprecatedWithMsg(original, "Please use '" + replacement + "' instead.");
	}

	Logger.deprecatedWithMsg = function(funcName, msg) {
		if (Logger.shouldLog(LOG_ERROR)) {
			logErrorHandler("Ably: Deprecation warning - '" + funcName + "' is deprecated and will be removed from a future version. " + msg);
		}
	}

	/* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent
	   the object being serialised if the log level will not output the message */
	Logger.shouldLog = function(level) {
		return level <= logLevel;
	};

	Logger.setLog = function(level, handler) {
		if(level !== undefined) logLevel = level;
		if(handler !== undefined) logHandler = logErrorHandler = handler;
	};

	return Logger;
})();

/* harmony default export */ __webpack_exports__["a"] = (Logger);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_4335__(17)))

/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_7753__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_7753__(3);
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_7753__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_7753__(5);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var Utils = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function Utils() {}

	function randomPosn(arrOrStr) {
		return Math.floor(Math.random() * arrOrStr.length);
	}

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.mixin = function(target) {
		for(var i = 1; i < arguments.length; i++) {
			var source = arguments[i];
			if(!source) { break; }
			for(var key in source) {
				if(hasOwnProperty.call(source, key)) {
					target[key] = source[key];
				}
			}
		}
		return target;
	};

	/*
	 * Add a set of properties to a target object
	 * target: the target object
	 * props:  an object whose enumerable properties are
	 *         added, by reference only
	 */
	Utils.copy = function(src) {
		return Utils.mixin({}, src);
	};

	/*
	 * Determine whether or not a given object is
	 * an array.
	 */
	Utils.isArray = Array.isArray || function(ob) {
		return Object.prototype.toString.call(ob) == '[object Array]';
	};

	/*
	 * Ensures that an Array object is always returned
	 * returning the original Array of obj is an Array
	 * else wrapping the obj in a single element Array
	 */
	Utils.ensureArray = function(obj) {
		if(Utils.isEmptyArg(obj)) {
			return [];
		}
		if(Utils.isArray(obj)) {
			return obj;
		}
		return [obj];
	}

	/* ...Or an Object (in the narrow sense) */
	Utils.isObject = function(ob) {
		return Object.prototype.toString.call(ob) == '[object Object]';
	};

	/*
	 * Determine whether or not an object contains
	 * any enumerable properties.
	 * ob: the object
	 */
	Utils.isEmpty = function(ob) {
		for(var prop in ob)
			return false;
		return true;
	};

	Utils.isOnlyPropIn = function(ob, property) {
		for(var prop in ob) {
			if(prop !== property) {
				return false;
			}
		}
		return true;
	};

	/*
	 * Determine whether or not an argument to an overloaded function is
	 * undefined (missing) or null.
	 * This method is useful when constructing functions such as (WebIDL terminology):
	 *   off([TreatUndefinedAs=Null] DOMString? event)
	 * as you can then confirm the argument using:
	 *   Utils.isEmptyArg(event)
	 */

	Utils.isEmptyArg = function(arg) {
		return arg === null || arg === undefined;
	}

	/*
	 * Perform a simple shallow clone of an object.
	 * Result is an object irrespective of whether
	 * the input is an object or array. All
	 * enumerable properties are copied.
	 * ob: the object
	 */
	Utils.shallowClone = function(ob) {
		var result = new Object();
		for(var prop in ob)
			result[prop] = ob[prop];
		return result;
	};

	/*
	 * Clone an object by creating a new object with the
	 * given object as its prototype. Optionally
	 * a set of additional own properties can be
	 * supplied to be added to the newly created clone.
	 * ob:            the object to be cloned
	 * ownProperties: optional object with additional
	 *                properties to add
	 */
	Utils.prototypicalClone = function(ob, ownProperties) {
		function F() {}
		F.prototype = ob;
		var result = new F();
		if(ownProperties)
			Utils.mixin(result, ownProperties);
		return result;
	};

	/*
	 * Declare a constructor to represent a subclass
	 * of another constructor
	 * If platform has a built-in version we use that from Platform, else we
	 * define here (so can make use of other Utils fns)
	 * See node.js util.inherits
	 */
	Utils.inherits = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits || function(ctor, superCtor) {
		ctor.super_ = superCtor;
		ctor.prototype = Utils.prototypicalClone(superCtor.prototype, { constructor: ctor });
	};

	/*
	 * Determine whether or not an object has an enumerable
	 * property whose value equals a given value.
	 * ob:  the object
	 * val: the value to find
	 */
	Utils.containsValue = function(ob, val) {
		for(var i in ob) {
			if(ob[i] == val)
				return true;
		}
		return false;
	};

	Utils.intersect = function(arr, ob) { return Utils.isArray(ob) ? Utils.arrIntersect(arr, ob) : Utils.arrIntersectOb(arr, ob); };

	Utils.arrIntersect = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var member = arr1[i];
			if(Utils.arrIndexOf(arr2, member) != -1)
				result.push(member);
		}
		return result;
	};

	Utils.arrIntersectOb = function(arr, ob) {
		var result = [];
		for(var i = 0; i < arr.length; i++) {
			var member = arr[i];
			if(member in ob)
				result.push(member);
		}
		return result;
	};

	Utils.arrSubtract = function(arr1, arr2) {
		var result = [];
		for(var i = 0; i < arr1.length; i++) {
			var element = arr1[i];
			if(Utils.arrIndexOf(arr2, element) == -1)
				result.push(element);
		}
		return result;
	};

	Utils.arrIndexOf = Array.prototype.indexOf
		? function(arr, elem, fromIndex) {
			return arr.indexOf(elem,  fromIndex);
		}
		: function(arr, elem, fromIndex) {
			fromIndex = fromIndex || 0;
			var len = arr.length;
			for(;fromIndex < len; fromIndex++) {
				if(arr[fromIndex] === elem) {
					return fromIndex;
				}
			}
			return -1;
		};

	Utils.arrIn = function(arr, val) {
		return Utils.arrIndexOf(arr, val) !== -1;
	};

	Utils.arrDeleteValue = function(arr, val) {
		var idx = Utils.arrIndexOf(arr, val);
		var res = (idx != -1);
		if(res)
			arr.splice(idx, 1);
		return res;
	};

	Utils.arrWithoutValue = function(arr, val) {
		var newArr = arr.slice();
		Utils.arrDeleteValue(newArr, val);
		return newArr;
	};

	/*
	 * Construct an array of the keys of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.keysArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(prop);
		}
		return result;
	};

	/*
	 * Construct an array of the values of the enumerable
	 * properties of a given object, optionally limited
	 * to only the own properties.
	 * ob:      the object
	 * ownOnly: boolean, get own properties only
	 */
	Utils.valuesArray = function(ob, ownOnly) {
		var result = [];
		for(var prop in ob) {
			if(ownOnly && !hasOwnProperty.call(ob, prop)) continue;
			result.push(ob[prop]);
		}
		return result;
	};

	Utils.forInOwnNonNullProps = function(ob, fn) {
		for (var prop in ob) {
			if (hasOwnProperty.call(ob, prop) && ob[prop]) {
				fn(prop);
			}
		}
	};

	Utils.arrForEach = Array.prototype.forEach ?
		function(arr, fn) {
			arr.forEach(fn);
		} :
		function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				fn(arr[i], i, arr);
			}
		};

	/* Useful when the function may mutate the array */
	Utils.safeArrForEach = function(arr, fn) {
		return Utils.arrForEach(arr.slice(), fn);
	};

	Utils.arrMap = Array.prototype.map ?
		function(arr, fn) {
			return arr.map(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				result.push(fn(arr[i], i, arr));
			}
			return result;
		};

	Utils.arrFilter = Array.prototype.filter ?
		function(arr, fn) {
			return arr.filter(fn);
		} :
		function(arr, fn)	{
			var result = [],
				len = arr.length;
			for(var i = 0; i < len; i++) {
				if(fn(arr[i])) {
					result.push(arr[i]);
				}
			}
			return result;
		};

	Utils.arrEvery = Array.prototype.every ?
		function(arr, fn) {
			return arr.every(fn);
		} : function(arr, fn) {
			var len = arr.length;
			for(var i = 0; i < len; i++) {
				if(!fn(arr[i], i, arr)) {
					return false;
				};
			}
			return true;
		};

	Utils.allSame = function(arr, prop) {
		if(arr.length === 0) {
			return true;
		}
		var first = arr[0][prop];
		return Utils.arrEvery(arr, function(item) {
			return item[prop] === first;
		});
	};

	Utils.nextTick = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick;

	var contentTypes = {
		json:   'application/json',
		jsonp:  'application/javascript',
		xml:    'application/xml',
		html:   'text/html',
		msgpack: 'application/x-msgpack'
	};

	Utils.defaultGetHeaders = function(format) {
		var accept = contentTypes[format || 'json'];
		return {
			accept: accept,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.defaultPostHeaders = function(format) {
		var accept, contentType;
		accept = contentType = contentTypes[format || 'json'];

		return {
			accept: accept,
			'content-type': contentType,
			'X-Ably-Version': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].apiVersion,
			'Ably-Agent': _defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].agent
		};
	};

	Utils.arrPopRandomElement = function(arr) {
		return arr.splice(randomPosn(arr), 1)[0];
	};

	Utils.toQueryString = function(params) {
		var parts = [];
		if(params) {
			for(var key in params)
				parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));
		}
		return parts.length ? '?' + parts.join('&') : '';
	};

	Utils.parseQueryString = function(query) {
		var match,
			search = /([^?&=]+)=?([^&]*)/g,
			result = {};

		while (match = search.exec(query))
			result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);

 		return result;
	};

	Utils.now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	Utils.inspect = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect;

	Utils.isErrorInfo = function(err) {
		return err.constructor.name == 'ErrorInfo'
	};

	Utils.inspectError = function(x) {
		/* redundant, but node vmcontext issue makes instanceof unreliable, and
		 * can't use just constructor test as could be a TypeError constructor etc. */
		return (x && (Utils.isErrorInfo(x) ||
			x.constructor.name == 'Error' ||
			x instanceof Error)) ?
			x.toString() :
			Utils.inspect(x);
	};

	Utils.inspectBody = function(body) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(body)) {
			return body.toString();
		} else if(typeof body === 'string') {
			return body;
		} else {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(body);
		}
	};

	/* Data is assumed to be either a string or a buffer. */
	Utils.dataSizeBytes = function(data) {
		if(platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].byteLength(data);
		}
		if(typeof data === 'string') {
			return platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringByteSize(data);
		}
		throw new Error("Expected input of Utils.dataSizeBytes to be a buffer or string, but was: " + (typeof data));
	};

	Utils.cheapRandStr = function() {
		return String(Math.random()).substr(2);
	};

	/* Takes param the minimum number of bytes of entropy the string must
	 * include, not the length of the string. String length produced is not
	 * guaranteed. */
	Utils.randomString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(uIntArr);
		} : function(numBytes) {
			/* Old browser; fall back to Math.random. Could just use a
			 * CryptoJS version of the above, but want this to still work in nocrypto
			 * versions of the library */
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64CharSet;
			/* base64 has 33% overhead; round length up */
			var length = Math.round(numBytes * 4/3);
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	Utils.randomHexString = (platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues && typeof Uint8Array !== 'undefined') ?
		function(numBytes) {
			var uIntArr = new Uint8Array(numBytes);
			platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].getRandomValues(uIntArr);
			return platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexEncode(uIntArr);
		} : function(numBytes) {
			var charset = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].hexCharSet;
			var length = numBytes * 2;
			var result = '';
			for(var i=0; i<length; i++) {
				result += charset[randomPosn(charset)];
			}
			return result;
		};

	/* Pick n elements at random without replacement from an array */
	Utils.arrChooseN = function(arr, n) {
		var numItems = Math.min(n, arr.length),
			mutableArr = arr.slice(),
			result = [];
		for(var i = 0; i < numItems; i++) {
			result.push(Utils.arrPopRandomElement(mutableArr));
		}
		return result;
	};

	Utils.trim = String.prototype.trim ? function(str) {
		return str.trim();
	} : function(str) {
		return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '');
	};

	Utils.promisify = function(ob, fnName, args) {
		return new Promise(function(resolve, reject) {
			ob[fnName].apply(ob, Array.prototype.slice.call(args).concat(function(err, res) {
				err ? reject(err) : resolve(res);
			}));
		});
	};

	Utils.decodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.decode(body) : JSON.parse(String(body));
	};

	Utils.encodeBody = function(body, format) {
		return (format == 'msgpack') ? msgpack.encode(body, true) : JSON.stringify(body);
	};

	Utils.allToLowerCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toLowerCase();
		});
	};

	Utils.allToUpperCase = function(arr) {
		return Utils.arrMap(arr, function(element) {
			return element && element.toUpperCase();
		});
	};

	return Utils;
})();

/* harmony default export */ __webpack_exports__["a"] = (Utils);


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_22681__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_22681__(1);


var ErrorInfo = (function() {

	function ErrorInfo(message, code, statusCode, cause) {
		this.message = message;
		this.code = code;
		this.statusCode = statusCode;
		this.cause = cause;
		this.href = undefined;
	}

	ErrorInfo.prototype.toString = function() {
		var result = '[' + this.constructor.name;
		if(this.message) result += ': ' + this.message;
		if(this.statusCode) result += '; statusCode=' + this.statusCode;
		if(this.code) result += '; code=' + this.code;
		if(this.cause) result += '; cause=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(this.cause);
		if(this.href && !(this.message && this.message.indexOf('help.ably.io') > -1)) result += '; see ' + this.href + ' ';
		result += ']';
		return result;
	};

	ErrorInfo.fromValues = function(values) {
		var result = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ErrorInfo(), values);
		if (values instanceof Error) {
			/* Error.message is not enumerable, so mixin loses the message */
			result.message = values.message;
		}
		if(result.code && !result.href) {
			result.href = 'https://help.ably.io/error/' + result.code;
		}
		return result;
	};

	return ErrorInfo;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorInfo);


/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_24190__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/* harmony import */ var _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_24190__(24);


if(typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {
	console.log("Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm");
}

function allowComet() {
	/* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg
	 * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask
	 * So if websockets are supported, then just forget about comet transports and use that */
	var loc = global.location;
	return (!global.WebSocket || !loc || !loc.origin || loc.origin.indexOf("http") > -1);
}

var userAgent = global.navigator && global.navigator.userAgent.toString();
var currentUrl = global.location && global.location.href;

var Platform = {
        agent: 'browser',
	logTimestamps: true,
	userAgent: userAgent,
	currentUrl: currentUrl,
	noUpgrade: userAgent && userAgent.match(/MSIE\s8\.0/),
	binaryType: 'arraybuffer',
	WebSocket: global.WebSocket || global.MozWebSocket,
	xhrSupported: global.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),
	jsonpSupported: typeof(document) !== 'undefined',
	allowComet: allowComet(),
	streamingSupported: true,
	useProtocolHeartbeats: true,
	createHmac: null,
	msgpack: _lib_util_msgpack__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"],
	supportsBinary: !!global.TextDecoder,
	preferBinary: false,
	ArrayBuffer: global.ArrayBuffer,
	atob: global.atob,
	nextTick: typeof setImmediate !== 'undefined' ? global.setImmediate.bind(global) : function(f) { setTimeout(f, 0); },
	addEventListener: global.addEventListener,
	inspect: JSON.stringify,
	stringByteSize: function(str) {
		/* str.length will be an underestimate for non-ascii strings. But if we're
		 * in a browser too old to support TextDecoder, not much we can do. Better
		 * to underestimate, so if we do go over-size, the server will reject the
		 * message */
		return global.TextDecoder &&
			(new global.TextEncoder().encode(str)).length ||
			str.length;
	},
	TextEncoder: global.TextEncoder,
	TextDecoder: global.TextDecoder,
	Promise: global.Promise,
	getRandomValues: (function(crypto) {
		if (crypto === undefined) {
			return undefined;
		}
		return function(arr, callback) {
			crypto.getRandomValues(arr);
			if(callback) {
				callback(null);
			}
		};
	})(global.crypto || global.msCrypto) // mscrypto for IE11
};

/* harmony default export */ __webpack_exports__["a"] = (Platform);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_24190__(17), __nested_webpack_require_24190__(42).setImmediate))

/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_27111__) {

"use strict";

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_27111__(3);

// CONCATENATED MODULE: ./browser/lib/util/defaults.js


var Defaults = {
	internetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',
	jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',
	/* Order matters here: the base transport is the leftmost one in the
	 * intersection of baseTransportOrder and the transports clientOption that's
	 * supported.  This is not quite the same as the preference order -- e.g.
	 * xhr_polling is preferred to jsonp, but for browsers that support it we want
	 * the base transport to be xhr_polling, not jsonp */
	defaultTransports: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	baseTransportOrder: ['xhr_polling', 'xhr_streaming', 'jsonp', 'web_socket'],
	transportPreferenceOrder: ['jsonp', 'xhr_polling', 'xhr_streaming', 'web_socket'],
	upgradeTransports: ['xhr_streaming', 'web_socket']
};

/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -
* while it can do streaming, the low max http-connections-per-host limit means
* that the polling transport is crippled during the upgrade process. So just
* leave it at the base transport */
if(platform_browser["a" /* default */].noUpgrade) {
	Defaults.upgradeTransports = [];
}

/* harmony default export */ var defaults = (Defaults);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_27111__(1);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_27111__(5);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_27111__(0);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_27111__(2);

// CONCATENATED MODULE: ./common/lib/util/defaults.js







defaults.ENVIRONMENT              = '';
defaults.REST_HOST                = 'rest.ably.io';
defaults.REALTIME_HOST            = 'realtime.ably.io';
defaults.FALLBACK_HOSTS           = ['A.ably-realtime.com', 'B.ably-realtime.com', 'C.ably-realtime.com', 'D.ably-realtime.com', 'E.ably-realtime.com'];
defaults.PORT                     = 80;
defaults.TLS_PORT                 = 443;
defaults.TIMEOUTS = {
	/* Documented as options params: */
	disconnectedRetryTimeout   : 15000,
	suspendedRetryTimeout      : 30000,
	/* Undocumented, but part of the api and can be used by customers: */
	httpRequestTimeout         : 15000,
	channelRetryTimeout        : 15000,
	fallbackRetryTimeout       : 600000,
	/* For internal / test use only: */
	connectionStateTtl         : 120000,
	realtimeRequestTimeout     : 10000,
	recvTimeout                : 90000,
	preferenceConnectTimeout   : 6000,
	parallelUpgradeDelay       : 6000
};
defaults.httpMaxRetryCount = 3;
defaults.maxMessageSize    = 65536;

defaults.errorReportingUrl = 'https://errors.ably.io/api/15/store/';
defaults.errorReportingHeaders = {
	"X-Sentry-Auth": "Sentry sentry_version=7, sentry_key=a04e33c8674c451f8a310fbec029acf5, sentry_client=ably-js/0.1",
	"Content-Type": "application/json"
};

defaults.version          = '1.2.13';
defaults.apiVersion       = '1.2';

var agent = 'ably-js/' + defaults.version;
if (platform_browser["a" /* default */].agent) {
	agent += ' ' + platform_browser["a" /* default */].agent;
} 
defaults.agent = agent;

defaults.getHost = function(options, host, ws) {
	if(ws)
		host = ((host == options.restHost) && options.realtimeHost) || host || options.realtimeHost;
	else
		host = host || options.restHost;

	return host;
};

defaults.getPort = function(options, tls) {
	return (tls || options.tls) ? options.tlsPort : options.port;
};

defaults.getHttpScheme = function(options) {
	return options.tls ? 'https://' : 'http://';
};

// construct environment fallback hosts as per RSC15i
defaults.environmentFallbackHosts = function(environment) {
	return [
		environment + '-a-fallback.ably-realtime.com',
		environment + '-b-fallback.ably-realtime.com',
		environment + '-c-fallback.ably-realtime.com',
		environment + '-d-fallback.ably-realtime.com',
		environment + '-e-fallback.ably-realtime.com'
	];
};

defaults.getFallbackHosts = function(options) {
	var fallbackHosts = options.fallbackHosts,
		httpMaxRetryCount = typeof(options.httpMaxRetryCount) !== 'undefined' ? options.httpMaxRetryCount : defaults.httpMaxRetryCount;

	return fallbackHosts ? utils["a" /* default */].arrChooseN(fallbackHosts, httpMaxRetryCount) : [];
};

defaults.getHosts = function(options) {
	return [options.restHost].concat(defaults.getFallbackHosts(options));
};

function checkHost(host) {
	if(typeof host !== 'string') {
		throw new errorinfo["a" /* default */]('host must be a string; was a ' + typeof host, 40000, 400);
	};
	if(!host.length) {
		throw new errorinfo["a" /* default */]('host must not be zero-length', 40000, 400);
	};
}

defaults.objectifyOptions = function(options) {
	if(typeof options == 'string') {
		return (options.indexOf(':') == -1) ? {token: options} : {key: options};
	}
	return options;
};

defaults.normaliseOptions = function(options) {
	/* Deprecated options */
	if(options.host) {
		logger["a" /* default */].deprecated('host', 'restHost');
		options.restHost = options.host;
	}
	if(options.wsHost) {
		logger["a" /* default */].deprecated('wsHost', 'realtimeHost');
		options.realtimeHost = options.wsHost;
	}
	if(options.queueEvents) {
		logger["a" /* default */].deprecated('queueEvents', 'queueMessages');
		options.queueMessages = options.queueEvents;
	}

	if(options.fallbackHostsUseDefault) {
		/* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */
		if(options.fallbackHosts) {
			var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* default fallbacks can't be used with custom ports */
		if(options.port || options.tlsPort) {
			var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', msg);
			throw new errorinfo["a" /* default */](msg, 40000, 400);
		}

		/* emit an appropriate deprecation warning */
		if(options.environment) {
			logger["a" /* default */].deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');
		} else {
			logger["a" /* default */].deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');
		}

		/* use the default fallback hosts as requested */
		options.fallbackHosts = defaults.FALLBACK_HOSTS;
	}

	if(options.recover === true) {
		logger["a" /* default */].deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');
		options.recover = function(lastConnectionDetails, cb) { cb(true); };
	}

	if(typeof options.recover === 'function' && options.closeOnUnload === true) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');
		options.recover = null;
	}

	if(!('closeOnUnload' in options)) {
		/* Have closeOnUnload default to true unless we have any indication that
		 * the user may want to recover the connection */
		options.closeOnUnload = !options.recover;
	}

	if(options.transports && utils["a" /* default */].arrIn(options.transports, 'xhr')) {
		logger["a" /* default */].deprecated('transports: ["xhr"]', 'transports: ["xhr_streaming"]');
		utils["a" /* default */].arrDeleteValue(options.transports, 'xhr');
		options.transports.push('xhr_streaming');
	}

	if(!('queueMessages' in options))
		options.queueMessages = true;

	/* infer hosts and fallbacks based on the configured environment */
	var environment = (options.environment && String(options.environment).toLowerCase()) || defaults.ENVIRONMENT;
	var production = !environment || (environment === 'production');

	if(!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {
		options.fallbackHosts = production ? defaults.FALLBACK_HOSTS : defaults.environmentFallbackHosts(environment);
	}

	if(!options.realtimeHost) {
		/* prefer setting realtimeHost to restHost as a custom restHost typically indicates
		 * a development environment is being used that can't be inferred by the library */
		if(options.restHost) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_WARN, 'Defaults.normaliseOptions', 'restHost is set to "' + options.restHost + '" but realtimeHost is not set, so setting realtimeHost to "' + options.restHost + '" too. If this is not what you want, please set realtimeHost explicitly.');
			options.realtimeHost = options.restHost
		} else {
			options.realtimeHost = production ? defaults.REALTIME_HOST : environment + '-' + defaults.REALTIME_HOST;
		}
	}

	if(!options.restHost) {
		options.restHost = production ? defaults.REST_HOST : environment + '-' + defaults.REST_HOST;
	}

	utils["a" /* default */].arrForEach((options.fallbackHosts || []).concat(options.restHost, options.realtimeHost), checkHost);

	options.port = options.port || defaults.PORT;
	options.tlsPort = options.tlsPort || defaults.TLS_PORT;
	options.maxMessageSize = options.maxMessageSize || defaults.maxMessageSize;
	if(!('tls' in options)) options.tls = true;

	/* Allow values passed in options to override default timeouts */
	options.timeouts = {};
	for(var prop in defaults.TIMEOUTS) {
		options.timeouts[prop] = options[prop] || defaults.TIMEOUTS[prop];
	};

	if('useBinaryProtocol' in options) {
		options.useBinaryProtocol = platform_browser["a" /* default */].supportsBinary && options.useBinaryProtocol;
	} else {
		options.useBinaryProtocol = platform_browser["a" /* default */].preferBinary;
	}

	if(options.clientId) {
		var headers = options.headers = options.headers || {};
		headers['X-Ably-ClientId'] = bufferutils["a" /* default */].base64Encode(bufferutils["a" /* default */].utf8Encode(options.clientId));
	}

	if(!('idempotentRestPublishing' in options)) {
		options.idempotentRestPublishing = true;
	}

	if(options.promises && !platform_browser["a" /* default */].Promise) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');
		options.promises = false;
	}

        if(options.agents) {
          for(var key in options.agents) {
            defaults.agent += ' ' + key + '/' + options.agents[key];
          }
        }

	return options;
};

/* harmony default export */ var util_defaults = __webpack_exports__["a"] = (defaults);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_38479__) {

"use strict";
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_38479__(32);
/* harmony import */ var crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_38479__.n(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_38479__(33);
/* harmony import */ var crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_38479__.n(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_38479__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_38479__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_38479__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_38479__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_38479__(3);






var BufferUtils = (function() {
	var ArrayBuffer = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].ArrayBuffer;
	var atob = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].atob;
	var TextEncoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextEncoder;
	var TextDecoder = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].TextDecoder;
	var base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
	var hexCharSet = '0123456789abcdef';

	function isWordArray(ob) { return ob !== null && ob !== undefined && ob.sigBytes !== undefined; }
	function isArrayBuffer(ob) { return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer; }
	function isTypedArray(ob) { return ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob); }

	// https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js
	function uint8ViewToBase64(bytes) {
		var base64    = ''
		var encodings = base64CharSet;

		var byteLength    = bytes.byteLength
		var byteRemainder = byteLength % 3
		var mainLength    = byteLength - byteRemainder

		var a, b, c, d
		var chunk

		// Main loop deals with bytes in chunks of 3
		for (var i = 0; i < mainLength; i = i + 3) {
			// Combine the three bytes into a single integer
			chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]

			// Use bitmasks to extract 6-bit segments from the triplet
			a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
			b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
			c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
			d = chunk & 63               // 63       = 2^6 - 1

			// Convert the raw binary segments to the appropriate ASCII encoding
			base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
		}

		// Deal with the remaining bytes and padding
		if (byteRemainder == 1) {
			chunk = bytes[mainLength]

			a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2

			// Set the 4 least significant bits to zero
			b = (chunk & 3)   << 4 // 3   = 2^2 - 1

			base64 += encodings[a] + encodings[b] + '=='
		} else if (byteRemainder == 2) {
			chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]

			a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
			b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4

			// Set the 2 least significant bits to zero
			c = (chunk & 15)    <<  2 // 15    = 2^4 - 1

			base64 += encodings[a] + encodings[b] + encodings[c] + '='
		}

		return base64
	}

	function base64ToArrayBuffer(base64) {
		var binary_string =  atob(base64);
		var len = binary_string.length;
		var bytes = new Uint8Array( len );
		for (var i = 0; i < len; i++)        {
			var ascii = binary_string.charCodeAt(i);
			bytes[i] = ascii;
		}
		return bytes.buffer;
	}

	/* Most BufferUtils methods that return a binary object return an ArrayBuffer
	 * if supported, else a CryptoJS WordArray. The exception is toBuffer, which
	 * returns a Uint8Array (and won't work on browsers too old to support it) */
	function BufferUtils() {}

	BufferUtils.base64CharSet = base64CharSet;
	BufferUtils.hexCharSet = hexCharSet;

	var isBuffer = BufferUtils.isBuffer = function(buf) { return isArrayBuffer(buf) || isWordArray(buf) || isTypedArray(buf); };

	/* In browsers, returns a Uint8Array */
	var toBuffer = BufferUtils.toBuffer = function(buf) {
		if(!ArrayBuffer) {
			throw new Error("Can't convert to Buffer: browser does not support the necessary types");
		}

		if(isArrayBuffer(buf)) {
			return new Uint8Array(buf);
		}

		if(isTypedArray(buf)) {
			return new Uint8Array(buf.buffer);
		}

		if(isWordArray(buf)) {
			/* Backported from unreleased CryptoJS
			* https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */
			var arrayBuffer = new ArrayBuffer(buf.sigBytes);
			var uint8View = new Uint8Array(arrayBuffer);

			for (var i = 0; i < buf.sigBytes; i++) {
				uint8View[i] = (buf.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
			}

			return uint8View;
		};

		throw new Error("BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray");
	};

	BufferUtils.toArrayBuffer = function(buf) {
		if(isArrayBuffer(buf)) {
			return buf;
		}
		return toBuffer(buf).buffer;
	};

	BufferUtils.toWordArray = function(buf) {
		if(isTypedArray(buf)) {
			buf = buf.buffer;
		}
		return isWordArray(buf) ? buf : crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_3___default.a.create(buf);
	};

	BufferUtils.base64Encode = function(buf) {
		if(isWordArray(buf)) {
			return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["stringify"])(buf);
		}
		return uint8ViewToBase64(toBuffer(buf));
	};

	BufferUtils.base64Decode = function(str) {
		if(ArrayBuffer && atob) {
			return base64ToArrayBuffer(str);
		}
		return Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_2__["parse"])(str);
	};

	BufferUtils.hexEncode = function(buf) {
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["stringify"])(buf);
	};

	BufferUtils.hexDecode = function(string) {
		var wordArray = Object(crypto_js_build_enc_hex__WEBPACK_IMPORTED_MODULE_0__["parse"])(string);
		return ArrayBuffer ? BufferUtils.toArrayBuffer(wordArray) : wordArray;
	};

	BufferUtils.utf8Encode = function(string) {
		if(TextEncoder) {
			return (new TextEncoder()).encode(string).buffer;
		}
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["parse"])(string);
	};

	/* For utf8 decoding we apply slightly stricter input validation than to
	 * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from
	 * can take (in particular allowing strings, which are just interpreted as
	 * binary); here we ensure that the input is actually a buffer since trying
	 * to utf8-decode a string to another string is almost certainly a mistake */
	BufferUtils.utf8Decode = function(buf) {
		if(!isBuffer(buf)) {
			throw new Error("Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray");
		}
		if(TextDecoder && !isWordArray(buf)) {
			return (new TextDecoder()).decode(buf);
		}
		buf = BufferUtils.toWordArray(buf);
		return Object(crypto_js_build_enc_utf8__WEBPACK_IMPORTED_MODULE_1__["stringify"])(buf);
	};

	BufferUtils.bufferCompare = function(buf1, buf2) {
		if(!buf1) return -1;
		if(!buf2) return 1;
		buf1 = BufferUtils.toWordArray(buf1);
		buf2 = BufferUtils.toWordArray(buf2);
		buf1.clamp(); buf2.clamp();

		var cmp = buf1.sigBytes - buf2.sigBytes;
		if(cmp != 0) return cmp;
		buf1 = buf1.words; buf2 = buf2.words;
		for(var i = 0; i < buf1.length; i++) {
			cmp = buf1[i] - buf2[i];
			if(cmp != 0) return cmp;
		}
		return 0;
	};

	BufferUtils.byteLength = function(buf) {
		if(isArrayBuffer(buf) || isTypedArray(buf)) {
			return buf.byteLength
		} else if(isWordArray(buf)) {
			return buf.sigBytes;
		}
	};

	/* Returns ArrayBuffer on browser and Buffer on Node.js */
	BufferUtils.typedArrayToBuffer = function(typedArray) {
		return typedArray.buffer;
	};

	return BufferUtils;
})();

/* harmony default export */ __webpack_exports__["a"] = (BufferUtils);


/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_47244__) {

"use strict";
/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_47244__(1);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_47244__(4);



var Http = (function() {
	var noop = function() {};

	function Http() {}

	var now = Date.now || function() {
		/* IE 8 */
		return new Date().getTime();
	};

	function shouldFallback(err) {
		var statusCode = err.statusCode;
		/* 400 + no code = a generic xhr onerror. Browser doesn't give us enough
		 * detail to know whether it's fallback-fixable, but it may be (eg if a
		 * network issue), so try just in case */
		return (statusCode === 408 && !err.code) ||
			(statusCode === 400 && !err.code)      ||
			(statusCode >= 500 && statusCode <= 504);
	}

	function getHosts(client) {
		/* If we're a connected realtime client, try the endpoint we're connected
		 * to first -- but still have fallbacks, being connected is not an absolute
		 * guarantee that a datacenter has free capacity to service REST requests. */
		var connection = client.connection,
			connectionHost = connection && connection.connectionManager.host;

		if(connectionHost) {
			return [connectionHost].concat(_common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getFallbackHosts(client.options));
		}

		return _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].getHosts(client.options);
	}
	Http._getHosts = getHosts;

	Http.methods = ['get', 'delete', 'post', 'put', 'patch'];
	Http.methodsWithoutBody = ['get', 'delete'];
	Http.methodsWithBody = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrSubtract(Http.methods, Http.methodsWithoutBody);

	/* - Http.get, Http.post, Http.put, ...
	 * Perform an HTTP request for a given path against prime and fallback Ably hosts
	 * @param rest
	 * @param path the full path
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 *
	 * - Http.getUri, Http.postUri, Http.putUri, ...
	 * Perform an HTTP request for a given full URI
	 * @param rest
	 * @param uri the full URI
	 * @param headers optional hash of headers
	 * [only for methods with body: @param body object or buffer containing request body]
	 * @param params optional hash of params
	 * @param callback (err, response)
	 */
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithoutBody, function(method) {
		Http[method] = function(rest, path, headers, params, callback) {
			Http['do'](method, rest, path, headers, null, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, params, callback) {
			Http.doUri(method, rest, uri, headers, null, params, callback);
		};
	});

	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(Http.methodsWithBody, function(method) {
		Http[method] = function(rest, path, headers, body, params, callback) {
			Http['do'](method, rest, path, headers, body, params, callback);
		};
		Http[method + 'Uri'] = function(rest, uri, headers, body, params, callback) {
			Http.doUri(method, rest, uri, headers, body, params, callback);
		};
	});

	/* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */
	Http['do'] = function(method, rest, path, headers, body, params, callback) {
		callback = callback || noop;
		var uriFromHost = (typeof(path) == 'function') ? path : function(host) { return rest.baseUri(host) + path; };
		var binary = (headers && headers.accept != 'application/json');
		var doArgs = arguments;

		var currentFallback = rest._currentFallback;
		if(currentFallback) {
			if(currentFallback.validUntil > now()) {
				/* Use stored fallback */
				Http.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function(err) {
					if(err && shouldFallback(err)) {
						/* unstore the fallback and start from the top with the default sequence */
						rest._currentFallback = null;
						Http['do'].apply(Http, doArgs);
						return;
					}
					callback.apply(null, arguments);
				});
				return;
			} else {
				/* Fallback expired; remove it and fallthrough to normal sequence */
				rest._currentFallback = null;
			}
		}

		var hosts = getHosts(rest);

		/* if there is only one host do it */
		if(hosts.length == 1) {
			Http.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);
			return;
		}

		/* hosts is an array with preferred host plus at least one fallback */
		var tryAHost = function(candidateHosts, persistOnSuccess) {
			var host = candidateHosts.shift();
			Http.doUri(method, rest, uriFromHost(host), headers, body, params, function(err) {
				if(err && shouldFallback(err) && candidateHosts.length) {
					tryAHost(candidateHosts, true);
					return;
				}
				if(persistOnSuccess) {
					/* RSC15f */
					rest._currentFallback = {
						host: host,
						validUntil: now() + rest.options.timeouts.fallbackRetryTimeout
					};
				}
				callback.apply(null, arguments);
			});
		};
		tryAHost(hosts);
	};

	Http.doUri = function(method, rest, uri, headers, body, params, callback) {
		Http.Request(method, rest, uri, headers, params, body, callback);
	};

	Http.supportsAuthHeaders = false;
	Http.supportsLinkHeaders = false;
	return Http;
})();

/* harmony default export */ __webpack_exports__["a"] = (Http);


/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_52986__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_52986__(1);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_52986__(0);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_52986__(3);




var hasOwnProperty = Object.prototype.hasOwnProperty;

var EventEmitter = (function() {

	/* public constructor */
	function EventEmitter() {
		this.any = [];
		this.events = Object.create(null);
		this.anyOnce = [];
		this.eventsOnce = Object.create(null);
	}

	/* Call the listener, catch any exceptions and log, but continue operation*/
	function callListener(eventThis, listener, args) {
		try {
			listener.apply(eventThis, args);
		} catch(e) {
			_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));
		}
	}

	/**
	 * Remove listeners that match listener
	 * @param targetListeners is an array of listener arrays or event objects with arrays of listeners
	 * @param listener the listener callback to remove
	 * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event
	 */
	function removeListener(targetListeners, listener, eventFilter) {
		var listeners, idx, eventName, targetListenersIndex;

		for (targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {
			listeners = targetListeners[targetListenersIndex];
			if (eventFilter) { listeners = listeners[eventFilter]; }

			if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners)) {
				while ((idx = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIndexOf(listeners, listener)) !== -1) {
					listeners.splice(idx, 1);
				}
				/* If events object has an event name key with no listeners then
				   remove the key to stop the list growing indefinitely */
				if (eventFilter && (listeners.length === 0)) {
					delete targetListeners[targetListenersIndex][eventFilter];
				}
			} else if (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isObject(listeners)) {
				/* events */
				for (eventName in listeners) {
					if (hasOwnProperty.call(listeners, eventName) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(listeners[eventName])) {
						removeListener([listeners], listener, eventName);
					}
				}
			}
		}
	}

	/**
	 * Add an event listener
	 * @param event (optional) the name of the event to listen to
	 *        if not supplied, all events trigger a call to the listener
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.on = function(event, listener) {
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.any.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.any.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listener);
			});
		} else {
			var listeners = (this.events[event] || (this.events[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Remove one or more event listeners
	 * @param event (optional) the name of the event whose listener
	 *        is to be removed. If not supplied, the listener is
	 *        treated as an 'any' listener
	 * @param listener (optional) the listener to remove. If not
	 *        supplied, all listeners are removed.
	 */
	EventEmitter.prototype.off = function(event, listener) {
		if(arguments.length == 0 || (_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event) && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(listener))) {
			this.any = [];
			this.events = Object.create(null);
			this.anyOnce = [];
			this.eventsOnce = Object.create(null);
			return;
		}
		if(arguments.length == 1) {
			if(typeof(event) == 'function') {
				/* we take this to be the listener and treat the event as "any" .. */
				listener = event;
				event = null;
			}
			/* ... or we take event to be the actual event name and listener to be all */
		}

		if(listener && _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);
			return;
		}

		if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)) {
			var self = this;
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.off(ev, listener);
			});
		}

		/* "normal" case where event is an actual event */
		if(listener) {
			removeListener([this.events, this.eventsOnce], listener, event);
		} else {
			delete this.events[event];
			delete this.eventsOnce[event];
		}
	};

	/**
	 * Get the array of listeners for a given event; excludes once events
	 * @param event (optional) the name of the event, or none for 'any'
	 * @return array of events, or null if none
	 */
	EventEmitter.prototype.listeners = function(event) {
		if(event) {
			var listeners = (this.events[event] || []);
			if(this.eventsOnce[event])
				Array.prototype.push.apply(listeners, this.eventsOnce[event]);
			return listeners.length ? listeners : null;
		}
		return this.any.length ? this.any : null;
	};

	/**
	 * Emit an event
	 * @param event the event name
	 * @param args the arguments to pass to the listener
	 */
	EventEmitter.prototype.emit = function(event  /* , args... */) {
		var args = Array.prototype.slice.call(arguments, 1);
		var eventThis = {event:event};
		var listeners = [];

		if(this.anyOnce.length) {
			Array.prototype.push.apply(listeners, this.anyOnce);
			this.anyOnce = [];
		}
		if(this.any.length) {
			Array.prototype.push.apply(listeners, this.any);
		}
		var eventsOnceListeners = this.eventsOnce[event];
		if(eventsOnceListeners) {
			Array.prototype.push.apply(listeners, eventsOnceListeners);
			delete this.eventsOnce[event];
		}
		var eventsListeners = this.events[event];
		if(eventsListeners) {
			Array.prototype.push.apply(listeners, eventsListeners);
		}

		_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(listeners, function(listener) {
			callListener(eventThis, listener, args);
		});
	};

	/**
	 * Listen for a single occurrence of an event
	 * @param event the name of the event to listen to
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.once = function(event, listener) {
		var argCount = arguments.length, self = this;
		if((argCount === 0 || (argCount === 1 && typeof event !== 'function')) && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				self.once(event, resolve);
			});
		}
		if(arguments.length == 1 && typeof(event) == 'function') {
			this.anyOnce.push(event);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(event)) {
			this.anyOnce.push(listener);
		} else if(_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(event)){
			var listenerWrapper = function() {
				var args = Array.prototype.slice.call(arguments);
				_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
					self.off(ev, listenerWrapper);
				});
				listener.apply(this, args);
			};
			_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(event, function(ev) {
				self.on(ev, listenerWrapper);
			});
		} else {
			var listeners = (this.eventsOnce[event] || (this.eventsOnce[event] = []));
			listeners.push(listener);
		}
	};

	/**
	 * Private API
	 *
	 * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState
	 * @param targetState the name of the state event to listen to
	 * @param currentState the name of the current state of this object
	 * @param listener the listener to be called
	 */
	EventEmitter.prototype.whenState = function(targetState, currentState, listener /* ...listenerArgs */) {
		var eventThis = {event:targetState},
			self = this,
			listenerArgs = Array.prototype.slice.call(arguments, 3);

		if((typeof(targetState) !== 'string') || (typeof(currentState) !== 'string')) {
			throw("whenState requires a valid event String argument");
		}
		if(typeof listener !== 'function' && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise) {
			return new platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].Promise(function(resolve) {
				EventEmitter.prototype.whenState.apply(self, [targetState, currentState, resolve].concat(listenerArgs));
			});
		}
		if(targetState === currentState) {
			callListener(eventThis, listener, listenerArgs);
		} else {
			this.once(targetState, listener);
		}
	}

	return EventEmitter;
})();

/* harmony default export */ __webpack_exports__["a"] = (EventEmitter);


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_62347__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_62347__(1);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_62347__(2);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_62347__(9);
/* harmony import */ var _presencemessage__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_62347__(11);





var ProtocolMessage = (function() {

	function ProtocolMessage() {
		this.action = undefined;
		this.flags = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.count = undefined;
		this.error = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.connectionSerial = undefined;
		this.channel = undefined;
		this.channelSerial = undefined;
		this.msgSerial = undefined;
		this.messages = undefined;
		this.presence = undefined;
		this.auth = undefined;
		this.params = undefined;
	}

	var actions = ProtocolMessage.Action = {
		'HEARTBEAT' : 0,
		'ACK' : 1,
		'NACK' : 2,
		'CONNECT' : 3,
		'CONNECTED' : 4,
		'DISCONNECT' : 5,
		'DISCONNECTED' : 6,
		'CLOSE' : 7,
		'CLOSED' : 8,
		'ERROR' : 9,
		'ATTACH' : 10,
		'ATTACHED' : 11,
		'DETACH' : 12,
		'DETACHED' : 13,
		'PRESENCE' : 14,
		'MESSAGE' : 15,
		'SYNC' : 16,
		'AUTH' : 17
	};

	ProtocolMessage.channelModes = [ 'PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE' ];

	ProtocolMessage.ActionName = [];
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(ProtocolMessage.Action, true), function(name) {
		ProtocolMessage.ActionName[actions[name]] = name;
	});

	var flags = {
		/* Channel attach state flags */
		'HAS_PRESENCE':       1 << 0,
		'HAS_BACKLOG':        1 << 1,
		'RESUMED':            1 << 2,
		'TRANSIENT':          1 << 4,
		'ATTACH_RESUME':      1 << 5,
		/* Channel mode flags */
		'PRESENCE':           1 << 16,
		'PUBLISH':            1 << 17,
		'SUBSCRIBE':          1 << 18,
		'PRESENCE_SUBSCRIBE': 1 << 19
	};
	var flagNames = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].keysArray(flags);
	flags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;

	ProtocolMessage.prototype.hasFlag = function(flag) {
		return ((this.flags & flags[flag]) > 0);
	};

	ProtocolMessage.prototype.setFlag = function(flag) {
		return this.flags = this.flags | flags[flag];
	};

	ProtocolMessage.prototype.getMode = function() {
		return this.flags && (this.flags & flags.MODE_ALL);
	};

	ProtocolMessage.prototype.encodeModesToFlags = function(modes) {
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(modes, function(mode) {
			self.setFlag(mode);
		});
	};

	ProtocolMessage.prototype.decodeModesFromFlags = function() {
		var modes = [],
			self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrForEach(ProtocolMessage.channelModes, function(mode) {
			if(self.hasFlag(mode)) {
				modes.push(mode);
			}
		});
		return modes.length > 0 ? modes : undefined;
	};

	ProtocolMessage.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].encodeBody;

	ProtocolMessage.deserialize = function(serialized, format) {
		var deserialized = _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].decodeBody(serialized, format);
		return ProtocolMessage.fromDeserialized(deserialized);
	};

	ProtocolMessage.fromDeserialized = function(deserialized) {
		var error = deserialized.error;
		if(error) deserialized.error = _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(error);
		var messages = deserialized.messages;
		if(messages) for(var i = 0; i < messages.length; i++) messages[i] = _message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValues(messages[i]);
		var presence = deserialized.presence;
		if(presence) for(var i = 0; i < presence.length; i++) presence[i] = _presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(presence[i], true);
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), deserialized);
	};

	ProtocolMessage.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin(new ProtocolMessage(), values);
	};

	function toStringArray(array) {
		var result = [];
		if (array) {
			for (var i = 0; i < array.length; i++) {
				result.push(array[i].toString());
			}
		}
		return '[ ' + result.join(', ') + ' ]';
	}

	var simpleAttributes = 'id channel channelSerial connectionId connectionKey connectionSerial count msgSerial timestamp'.split(' ');

	ProtocolMessage.stringify = function(msg) {
		var result = '[ProtocolMessage';
		if(msg.action !== undefined)
			result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;

		var attribute;
		for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {
			attribute = simpleAttributes[attribIndex];
			if(msg[attribute] !== undefined)
				result += '; ' + attribute + '=' + msg[attribute];
		}

		if(msg.messages)
			result += '; messages=' + toStringArray(_message__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].fromValuesArray(msg.messages));
		if(msg.presence)
			result += '; presence=' + toStringArray(_presencemessage__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValuesArray(msg.presence));
		if(msg.error)
			result += '; error=' + _errorinfo__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues(msg.error).toString();
		if(msg.auth && msg.auth.accessToken)
			result += '; token=' + msg.auth.accessToken;
		if(msg.flags)
			result += '; flags=' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrFilter(flagNames, function(flag) {
				return msg.hasFlag(flag);
			}).join(',');
		if(msg.params) {
			var stringifiedParams = '';
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].forInOwnNonNullProps(msg.params, function(prop) {
				if (stringifiedParams.length > 0) {
					stringifiedParams += '; ';
				}
				stringifiedParams += prop + '=' + msg.params[prop];
			});
			if (stringifiedParams.length > 0) {
				result += '; params=[' + stringifiedParams + ']';
			}
		}
		result += ']';
		return result;
	};

	/* Only valid for channel messages */
	ProtocolMessage.isDuplicate = function(a, b) {
		if (a && b) {
			if ((a.action === actions.MESSAGE || a.action === actions.PRESENCE) &&
				(a.action === b.action) &&
				(a.channel === b.channel) &&
				(a.id === b.id)) {
				if (a.action === actions.PRESENCE) {
					return true;
				} else if (a.messages.length === b.messages.length) {
					for (var i = 0; i < a.messages.length; i++) {
						var aMessage = a.messages[i];
						var bMessage = b.messages[i];
						if ((aMessage.extras && aMessage.extras.delta && aMessage.extras.delta.format) !==
							(bMessage.extras && bMessage.extras.delta && bMessage.extras.delta.format)) {
							return false;
						}
					}

					return true;
				}
			}
		}

		return false;
	};

	return ProtocolMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (ProtocolMessage);


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_69766__) {

"use strict";
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_69766__(5);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_69766__(1);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_69766__(0);
/* harmony import */ var platform_crypto__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_69766__(19);
/* harmony import */ var _errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_69766__(2);






var Message = (function() {

	function Message() {
		this.name = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.extras = undefined;
		this.size = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	Message.prototype.toJSON = function() {
		var result = {
			name: this.name,
			id: this.id,
			clientId: this.clientId,
			connectionId: this.connectionId,
			connectionKey: this.connectionKey,
			encoding: this.encoding,
			extras: this.extras
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	Message.prototype.toString = function() {
		var result = '[Message';
		if(this.name)
			result += '; name=' + this.name;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.extras)
			result += '; extras =' + JSON.stringify(this.extras);
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		if(this.extras)
			result += '; extras=' + JSON.stringify(this.extras);
		result += ']';
		return result;
	};

	Message.encrypt = function(msg, options, callback) {
		var data = msg.data,
			encoding = msg.encoding,
			cipher = options.channelCipher;

		encoding = encoding ? (encoding + '/') : '';
		if(!platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data)) {
			data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(String(data));
			encoding = encoding + 'utf-8/';
		}
		cipher.encrypt(data, function(err, data) {
			if (err) {
				callback(err);
				return;
			}
			msg.data = data;
			msg.encoding = encoding + 'cipher+' + cipher.algorithm;
			callback(null, msg);
		});
	};

	Message.encode = function(msg, options, callback) {
		var data = msg.data, encoding,
			nativeDataType = typeof(data) == 'string' || platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isBuffer(data) || data === null || data === undefined;

		if (!nativeDataType) {
			if (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isObject(data) || _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isArray(data)) {
				msg.data = JSON.stringify(data);
				msg.encoding = (encoding = msg.encoding) ? (encoding + '/json') : 'json';
			} else {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Data type is unsupported', 40013, 400);
			}
		}

		if(options != null && options.cipher) {
			Message.encrypt(msg, options, callback);
		} else {
			callback(null, msg);
		}
	};

	Message.encodeArray = function(messages, options, callback) {
		var processed = 0;
		for (var i = 0; i < messages.length; i++) {
			Message.encode(messages[i], options, function(err, msg) {
				if (err) {
					callback(err);
					return;
				}
				processed++;
				if (processed == messages.length) {
					callback(null, messages);
				}
			});
		}
	};

	Message.serialize = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].encodeBody;

	Message.decode = function(message, context) {
		/* The second argument could be either EncodingDecodingContext that contains ChannelOptions or ChannelOptions */
		if(!context || !context.channelOptions) {
			var channelOptions = context;
			context = {
				channelOptions: channelOptions,
				plugins: { },
				baseEncodedPreviousPayload: undefined
			};
		}

		var lastPayload = message.data;
		var encoding = message.encoding;
		if(encoding) {
			var xforms = encoding.split('/'),
				lastProcessedEncodingIndex, encodingsToProcess = xforms.length,
				data = message.data;

			try {
				while((lastProcessedEncodingIndex = encodingsToProcess) > 0) {
					var match = xforms[--encodingsToProcess].match(/([\-\w]+)(\+([\w\-]+))?/);
					if(!match) break;
					var xform = match[1];
					switch(xform) {
						case 'base64':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].base64Decode(String(data));
							if(lastProcessedEncodingIndex == xforms.length) {
								lastPayload = data;
							}
							continue;
						case 'utf-8':
							data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Decode(data);
							continue;
						case 'json':
							data = JSON.parse(data);
							continue;
						case 'cipher':
							if(context.channelOptions != null && context.channelOptions.cipher) {
								var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;
								/* don't attempt to decrypt unless the cipher params are compatible */
								if(xformAlgorithm != cipher.algorithm) {
									throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');
								}
								data = cipher.decrypt(data);
								continue;
							} else {
								throw new Error('Unable to decrypt message; not an encrypted channel');
							}
						case 'vcdiff':
							if(!context.plugins || !context.plugins.vcdiff) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);
							}
							if(typeof Uint8Array === 'undefined') {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);
							}
							try {
								var deltaBase = context.baseEncodedPreviousPayload;
								if(typeof deltaBase === 'string') {
									deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].utf8Encode(deltaBase);
								}

								/* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we
								 * don't have a TextDecoder, deltaBase might be a WordArray here, so need
								 * to process it into a buffer anyway) */
								deltaBase = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(deltaBase);
								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toBuffer(data);

								data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));
								lastPayload = data;
							} catch(e) {
								throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Vcdiff delta decode failed with ' + e, 40018, 400);
							}
							continue;
						default:
							throw new Error("Unknown encoding");
					}
					break;
				}
			} catch(e) {
				throw new _errorinfo__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]('Error processing the ' + xform + ' encoding, decoder returned ' + e.message + '', e.code || 40013, 400);
			} finally {
				message.encoding = (lastProcessedEncodingIndex <= 0) ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');
				message.data = data;
			}
		}
		context.baseEncodedPreviousPayload = lastPayload;
	};

	Message.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = Message.fromValues(body[i]);
			try {
				Message.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	Message.fromValues = function(values) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(new Message(), values);
	};

	Message.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = Message.fromValues(values[i]);
		return result;
	};

	function normalizeCipherOptions(options) {
		if(options && options.cipher && !options.cipher.channelCipher) {
			if(!platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = platform_crypto__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		}
	}

	Message.fromEncoded = function(encoded, options) {
		var msg = Message.fromValues(encoded);
		normalizeCipherOptions(options);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			Message.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_ERROR, 'Message.fromEncoded()', e.toString());
		}
		return msg;
	};

	Message.fromEncodedArray = function(encodedArray, options) {
		normalizeCipherOptions(options);
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return Message.fromEncoded(encoded, options);
		});
	};

	function getMessageSize(msg) {
		var size = 0;
		if(msg.name) {
			size += msg.name.length;
		}
		if(msg.clientId) {
			size += msg.clientId.length;
		}
		if(msg.extras) {
			size += JSON.stringify(msg.extras).length;
		}
		if(msg.data) {
			size += _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].dataSizeBytes(msg.data);
		}
		return size;
	};

	/* This should be called on encode()d (and encrypt()d) Messages (as it
	 * assumes the data is a string or buffer) */
	Message.getMessagesSize = function(messages) {
		var msg, total = 0;
		for(var i=0; i<messages.length; i++) {
			msg = messages[i];
			total += (msg.size || (msg.size = getMessageSize(msg)))
		}
		return total;
	};

	return Message;
})();

/* harmony default export */ __webpack_exports__["a"] = (Message);


/***/ }),
/* 10 */
/***/ (function(module, exports, __nested_webpack_require_81922__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_81922__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Check if typed arrays are supported
	    if (typeof ArrayBuffer != 'function') {
	        return;
	    }

	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;

	    // Reference original init
	    var superInit = WordArray.init;

	    // Augment WordArray.init to handle typed arrays
	    var subInit = WordArray.init = function (typedArray) {
	        // Convert buffers to uint8
	        if (typedArray instanceof ArrayBuffer) {
	            typedArray = new Uint8Array(typedArray);
	        }

	        // Convert other array views to uint8
	        if (
	            typedArray instanceof Int8Array ||
	            (typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray) ||
	            typedArray instanceof Int16Array ||
	            typedArray instanceof Uint16Array ||
	            typedArray instanceof Int32Array ||
	            typedArray instanceof Uint32Array ||
	            typedArray instanceof Float32Array ||
	            typedArray instanceof Float64Array
	        ) {
	            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
	        }

	        // Handle Uint8Array
	        if (typedArray instanceof Uint8Array) {
	            // Shortcut
	            var typedArrayByteLength = typedArray.byteLength;

	            // Extract bytes
	            var words = [];
	            for (var i = 0; i < typedArrayByteLength; i++) {
	                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);
	            }

	            // Initialize this word array
	            superInit.call(this, words, typedArrayByteLength);
	        } else {
	            // Else call normal init
	            superInit.apply(this, arguments);
	        }
	    };

	    subInit.prototype = WordArray;
	}());


	return CryptoJS.lib.WordArray;

}));

/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_84148__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_84148__(3);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_84148__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_84148__(5);
/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_84148__(9);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_84148__(1);






var PresenceMessage = (function() {
	var msgpack = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].msgpack;

	function toActionValue(actionString) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrIndexOf(PresenceMessage.Actions, actionString)
	}

	function PresenceMessage() {
		this.action = undefined;
		this.id = undefined;
		this.timestamp = undefined;
		this.clientId = undefined;
		this.connectionId = undefined;
		this.data = undefined;
		this.encoding = undefined;
		this.size = undefined;
	}

	PresenceMessage.Actions = [
		'absent',
		'present',
		'enter',
		'leave',
		'update'
	];

	/* Returns whether this presenceMessage is synthesized, i.e. was not actually
	 * sent by the connection (usually means a leave event sent 15s after a
	 * disconnection). This is useful because synthesized messages cannot be
	 * compared for newness by id lexicographically - RTP2b1
	 */
	PresenceMessage.prototype.isSynthesized = function() {
		return this.id.substring(this.connectionId.length, 0) !== this.connectionId;
	};

	/* RTP2b2 */
	PresenceMessage.prototype.parseId = function() {
		var parts = this.id.split(':');
		return {
			connectionId: parts[0],
			msgSerial: parseInt(parts[1], 10),
			index: parseInt(parts[2], 10)
		};
	};

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PresenceMessage.prototype.toJSON = function() {
		var result = {
			clientId: this.clientId,
			/* Convert presence action back to an int for sending to Ably */
			action: toActionValue(this.action),
			encoding: this.encoding
		};

		/* encode data to base64 if present and we're returning real JSON;
		 * although msgpack calls toJSON(), we know it is a stringify()
		 * call if it has a non-empty arguments list */
		var data = this.data;
		if(data && platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(data)) {
			if(arguments.length > 0) {
				/* stringify call */
				var encoding = this.encoding;
				result.encoding = encoding ? (encoding + '/base64') : 'base64';
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(data);
			} else {
				/* Called by msgpack. toBuffer returns a datatype understandable by
				 * that platform's msgpack implementation (Buffer in node, Uint8Array
				 * in browsers) */
				data = platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].toBuffer(data);
			}
		}
		result.data = data;
		return result;
	};

	PresenceMessage.prototype.toString = function() {
		var result = '[PresenceMessage';
		result += '; action=' + this.action;
		if(this.id)
			result += '; id=' + this.id;
		if(this.timestamp)
			result += '; timestamp=' + this.timestamp;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.connectionId)
			result += '; connectionId=' + this.connectionId;
		if(this.encoding)
			result += '; encoding=' + this.encoding;
		if(this.data) {
			if (typeof(this.data) == 'string')
				result += '; data=' + this.data;
			else if (platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].isBuffer(this.data))
				result += '; data (buffer)=' + platform_bufferutils__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].base64Encode(this.data);
			else
				result += '; data (json)=' + JSON.stringify(this.data);
		}
		result += ']';
		return result;
	};
	PresenceMessage.encode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].encode;
	PresenceMessage.decode = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].decode;

	PresenceMessage.fromResponseBody = function(body, options, format) {
		if(format) {
			body = _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].decodeBody(body, format);
		}

		for(var i = 0; i < body.length; i++) {
			var msg = body[i] = PresenceMessage.fromValues(body[i], true);
			try {
				PresenceMessage.decode(msg, options);
			} catch (e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());
			}
		}
		return body;
	};

	/* Creates a PresenceMessage from specified values, with a string presence action */
	PresenceMessage.fromValues = function(values, stringifyAction) {
		if(stringifyAction) {
			values.action = PresenceMessage.Actions[values.action]
		}
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].mixin(new PresenceMessage(), values);
	};

	PresenceMessage.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PresenceMessage.fromValues(values[i]);
		return result;
	};

	PresenceMessage.fromEncoded = function(encoded, options) {
		var msg = PresenceMessage.fromValues(encoded, true);
		/* if decoding fails at any point, catch and return the message decoded to
		 * the fullest extent possible */
		try {
			PresenceMessage.decode(msg, options);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());
		}
		return msg;
	};

	PresenceMessage.fromEncodedArray = function(encodedArray, options) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].arrMap(encodedArray, function(encoded) {
			return PresenceMessage.fromEncoded(encoded, options);
		});
	};

	PresenceMessage.getMessagesSize = _message__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getMessagesSize;

	return PresenceMessage;
})();

/* harmony default export */ __webpack_exports__["a"] = (PresenceMessage);


/***/ }),
/* 12 */
/***/ (function(module, exports, __nested_webpack_require_90558__) {

/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory();
	}
	else {}
}(this, function () {

	/*globals window, global, require*/

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {

	    var crypto;

	    // Native crypto from window (Browser)
	    if (typeof window !== 'undefined' && window.crypto) {
	        crypto = window.crypto;
	    }

	    // Native (experimental IE 11) crypto from window (Browser)
	    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {
	        crypto = window.msCrypto;
	    }

	    // Native crypto from global (NodeJS)
	    if (!crypto && typeof global !== 'undefined' && global.crypto) {
	        crypto = global.crypto;
	    }

	    // Native crypto import via require (NodeJS)
	    if (!crypto && "function" === 'function') {
	        try {
	            crypto = __nested_webpack_require_90558__(45);
	        } catch (err) {}
	    }

	    /*
	     * Cryptographically secure pseudorandom number generator
	     *
	     * As Math.random() is cryptographically not safe to use
	     */
	    var cryptoSecureRandomInt = function () {
	        if (crypto) {
	            // Use getRandomValues method (Browser)
	            if (typeof crypto.getRandomValues === 'function') {
	                try {
	                    return crypto.getRandomValues(new Uint32Array(1))[0];
	                } catch (err) {}
	            }

	            // Use randomBytes method (NodeJS)
	            if (typeof crypto.randomBytes === 'function') {
	                try {
	                    return crypto.randomBytes(4).readInt32LE();
	                } catch (err) {}
	            }
	        }

	        throw new Error('Native crypto module could not be used to get secure random number.');
	    };

	    /*
	     * Local polyfill of Object.create

	     */
	    var create = Object.create || (function () {
	        function F() {}

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            for (var i = 0; i < nBytes; i += 4) {
	                words.push(cryptoSecureRandomInt());
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            var processedWords;

	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_90558__(17)))

/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_114733__) {

"use strict";
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_114733__(2);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_114733__(1);



var ConnectionError = {
	disconnected: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80003,
		message: 'Connection to server temporarily unavailable'
	}),
	suspended: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80002,
		message: 'Connection to server unavailable'
	}),
	failed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80000,
		message: 'Connection failed or disconnected by server'
	}),
	closing: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closing'
	}),
	closed: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 400,
		code: 80017,
		message: 'Connection closed'
	}),
	unknownConnectionErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50002,
		message: 'Internal connection error'
	}),
	unknownChannelErr: _types_errorinfo__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
		statusCode: 500,
		code: 50001,
		message: 'Internal channel error'
	})
};

ConnectionError.isRetriable = function(err) {
	if (!err.statusCode || !err.code || err.statusCode >= 500) {
		return true;
	}
	var retriable = false;
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].valuesArray(ConnectionError).forEach(function(connErr) {
		if (connErr.code && connErr.code == err.code) {
			retriable = true;
		}
	});
	return retriable;
};

/* harmony default export */ __webpack_exports__["a"] = (ConnectionError);


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_116782__) {

"use strict";

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_116782__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_116782__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_116782__(1);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_116782__(6);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var multicaster = __nested_webpack_require_116782__(22);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_116782__(5);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_116782__(2);

// CONCATENATED MODULE: ./browser/lib/util/base64.js
/*
 Copyright (c) 2008 Fred Palmer fred.palmer_at_gmail.com

 Permission is hereby granted, free of charge, to any person
 obtaining a copy of this software and associated documentation
 files (the "Software"), to deal in the Software without
 restriction, including without limitation the rights to use,
 copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the
 Software is furnished to do so, subject to the following
 conditions:

 The above copyright notice and this permission notice shall be
 included in all copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 OTHER DEALINGS IN THE SOFTWARE.
 */
var Base64 = (function() {
	function StringBuffer()
	{
		this.buffer = [];
	}

	StringBuffer.prototype.append = function append(string)
	{
		this.buffer.push(string);
		return this;
	};

	StringBuffer.prototype.toString = function toString()
	{
		return this.buffer.join("");
	};

	var Base64 =
	{
		codex : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",

		encode : function (input)
		{
			var output = new StringBuffer();
			var codex = Base64.codex;

			var enumerator = new Utf8EncodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var chr1 = enumerator.current;

				enumerator.moveNext();
				var chr2 = enumerator.current;

				enumerator.moveNext();
				var chr3 = enumerator.current;

				var enc1 = chr1 >> 2;
				var enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
				var enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
				var enc4 = chr3 & 63;

				if (isNaN(chr2))
				{
					enc3 = enc4 = 64;
				}
				else if (isNaN(chr3))
				{
					enc4 = 64;
				}

				output.append(codex.charAt(enc1) + codex.charAt(enc2) + codex.charAt(enc3) + codex.charAt(enc4));
			}

			return output.toString();
		},

		decode : function (input)
		{
			var output = new StringBuffer();

			var enumerator = new Base64DecodeEnumerator(input);
			while (enumerator.moveNext())
			{
				var charCode = enumerator.current;

				if (charCode < 128)
					output.append(String.fromCharCode(charCode));
				else if ((charCode > 191) && (charCode < 224))
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 31) << 6) | (charCode2 & 63)));
				}
				else
				{
					enumerator.moveNext();
					var charCode2 = enumerator.current;

					enumerator.moveNext();
					var charCode3 = enumerator.current;

					output.append(String.fromCharCode(((charCode & 15) << 12) | ((charCode2 & 63) << 6) | (charCode3 & 63)));
				}
			}

			return output.toString();
		}
	};

	function Utf8EncodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Utf8EncodeEnumerator.prototype =
	{
		current: Number.NaN,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = Number.NaN;
				return false;
			}
			else
			{
				var charCode = this._input.charCodeAt(++this._index);

				// "\r\n" -> "\n"
				//
				if ((charCode == 13) && (this._input.charCodeAt(this._index + 1) == 10))
				{
					charCode = 10;
					this._index += 2;
				}

				if (charCode < 128)
				{
					this.current = charCode;
				}
				else if ((charCode > 127) && (charCode < 2048))
				{
					this.current = (charCode >> 6) | 192;
					this._buffer.push((charCode & 63) | 128);
				}
				else
				{
					this.current = (charCode >> 12) | 224;
					this._buffer.push(((charCode >> 6) & 63) | 128);
					this._buffer.push((charCode & 63) | 128);
				}

				return true;
			}
		}
	};

	function Base64DecodeEnumerator(input)
	{
		this._input = input;
		this._index = -1;
		this._buffer = [];
	}

	Base64DecodeEnumerator.prototype =
	{
		current: 64,

		moveNext: function()
		{
			if (this._buffer.length > 0)
			{
				this.current = this._buffer.shift();
				return true;
			}
			else if (this._index >= (this._input.length - 1))
			{
				this.current = 64;
				return false;
			}
			else
			{
				var enc1 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc2 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc3 = Base64.codex.indexOf(this._input.charAt(++this._index));
				var enc4 = Base64.codex.indexOf(this._input.charAt(++this._index));

				var chr1 = (enc1 << 2) | (enc2 >> 4);
				var chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
				var chr3 = ((enc3 & 3) << 6) | enc4;

				this.current = chr1;

				if (enc3 != 64)
					this._buffer.push(chr2);

				if (enc4 != 64)
					this._buffer.push(chr3);

				return true;
			}
		}
	};

	return Base64;
})();

/* harmony default export */ var base64 = (Base64);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/hmac-sha256.js
var hmac_sha256 = __nested_webpack_require_116782__(38);
var hmac_sha256_default = /*#__PURE__*/__nested_webpack_require_116782__.n(hmac_sha256);

// EXTERNAL MODULE: ./node_modules/crypto-js/build/enc-base64.js
var enc_base64 = __nested_webpack_require_116782__(18);

// CONCATENATED MODULE: ./common/lib/client/auth.js











var auth_Auth = (function() {
	var MAX_TOKEN_LENGTH = Math.pow(2, 17);
	function noop() {}
	function random() { return ('000000' + Math.floor(Math.random() * 1E16)).slice(-16); }
	function normaliseAuthcallbackError(err) {
		/* A client auth callback may give errors in any number of formats; normalise to an errorinfo */
		if(!utils["a" /* default */].isErrorInfo(err)) {
			return new errorinfo["a" /* default */](utils["a" /* default */].inspectError(err), err.code || 40170, err.statusCode || 401);
		}
		/* network errors will not have an inherent error code */
		if(!err.code) {
			if(err.statusCode === 403) {
				err.code = 40300;
			} else {
				err.code = 40170;
				/* normalise statusCode to 401 per RSA4e */
				err.statusCode = 401;
			}
		}
		return err;
	}

	var hmac, toBase64;
	if(platform_browser["a" /* default */].createHmac) {
		toBase64 = function(str) { return (Buffer.from(str, 'ascii')).toString('base64'); };
		hmac = function(text, key) {
			var inst = platform_browser["a" /* default */].createHmac('SHA256', key);
			inst.update(text);
			return inst.digest('base64');
		};
	} else {
		toBase64 = base64.encode;
		hmac = function(text, key) {
			return Object(enc_base64["stringify"])(hmac_sha256_default()(text, key));
		};
	}

	function c14n(capability) {
		if(!capability)
			return '';

		if(typeof(capability) == 'string')
			capability = JSON.parse(capability);

		var c14nCapability = Object.create(null);
		var keys = utils["a" /* default */].keysArray(capability, true);
		if(!keys)
			return '';
		keys.sort();
		for(var i = 0; i < keys.length; i++) {
			c14nCapability[keys[i]] = capability[keys[i]].sort();
		}
		return JSON.stringify(c14nCapability);
	}

	function logAndValidateTokenAuthMethod(authOptions) {
		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authCallback');
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with authUrl');
		} else if(authOptions.key) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with client-side signing');
		} else if(authOptions.tokenDetails) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'using token auth with supplied token only');
		} else {
			var msg = 'authOptions must include valid authentication parameters';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
			throw new Error(msg);
		}
	}

	function basicAuthForced(options) {
		return 'useTokenAuth' in options && !options.useTokenAuth;
	}

	/* RSA4 */
	function useTokenAuth(options) {
		return options.useTokenAuth ||
			(!basicAuthForced(options) &&
			 (options.authCallback ||
			  options.authUrl      ||
			  options.token        ||
			  options.tokenDetails))
	}

	/* RSA4a */
	function noWayToRenew(options) {
		return !options.key &&
			!options.authCallback &&
			!options.authUrl;
	}

	var trId = 0;
	function getTokenRequestId() {
		return trId++;
	}

	function Auth(client, options) {
		this.client = client;
		this.tokenParams = options.defaultTokenParams || {};
		/* The id of the current token request if one is in progress, else null */
		this.currentTokenRequestId = null;
		this.waitingForTokenRequest = null;

		if(useTokenAuth(options)) {
			/* Token auth */
			if(options.key && !hmac) {
				var msg = 'client-side token request signing not supported';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new Error(msg);
			}
			if(noWayToRenew(options)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			}
			this._saveTokenOptions(options.defaultTokenParams, options);
			logAndValidateTokenAuthMethod(this.authOptions);
		} else {
			/* Basic auth */
			if(!options.key) {
				var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', msg);
				throw new errorinfo["a" /* default */](msg, 40160, 401);
			}
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth()', 'anonymous, using basic auth');
			this._saveBasicOptions(options);
		}
	}

	/**
	 * Instructs the library to get a token immediately and ensures Token Auth
	 * is used for all future requests, storing the tokenParams and authOptions
	 * given as the new defaults for subsequent use.
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 *
	 * - ttl:        (optional) the requested life of any new token in ms. If none
	 *               is specified a default of 1 hour is provided. The maximum lifetime
	 *               is 24hours; any request exceeeding that lifetime will be rejected
	 *               with an error.
	 *
	 * - capability: (optional) the capability to associate with the access token.
	 *               If none is specified, a token will be requested with all of the
	 *               capabilities of the specified key.
	 *
	 * - clientId:   (optional) a client Id to associate with the token
	 *
	 * - timestamp:  (optional) the time in ms since the epoch. If none is specified,
	 *               the system will be queried for a time value to use.
	 *
	 * @param authOptions
	 * an object containing auth options relevant to token auth:
	 *
	 * - queryTime   (optional) boolean indicating that the Ably system should be
	 *               queried for the current time when none is specified explicitly.
	 *
	 * - tokenDetails: (optional) object: An authenticated TokenDetails object.
	 *
	 * - token:        (optional) string: the `token` property of a tokenDetails object
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.authorize = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback) {
			if(this.client.options.promises) {
				return utils["a" /* default */].promisify(this, 'authorize', arguments);
			}
			callback = noop;
		}
		var self = this;

		/* RSA10a: authorize() call implies token auth. If a key is passed it, we
		 * just check if it doesn't clash and assume we're generating a token from it */
		if(authOptions && authOptions.key && (this.authOptions.key !== authOptions.key)) {
			throw new errorinfo["a" /* default */]('Unable to update auth options with incompatible key', 40102, 401);
		}

		if(authOptions && ('force' in authOptions)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');
			/* Emulate the old behaviour: if 'force' was the only member of authOptions,
			 * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */
			if(utils["a" /* default */].isOnlyPropIn(authOptions, 'force')) {
				authOptions = null;
			}
		}

		this._forceNewToken(tokenParams, authOptions, function(err, tokenDetails) {
			if(err) {
				if(self.client.connection) {
					/* We interpret RSA4d as including requests made by a client lib to
					 * authenticate triggered by an explicit authorize() or an AUTH received from
					 * ably, not just connect-sequence-triggered token fetches */
					self.client.connection.connectionManager.actOnErrorFromAuthorize(err);
				}
				callback(err);
				return;
			}

			/* RTC8
			 * - When authorize called by an end user and have a realtime connection,
			 * don't call back till new token has taken effect.
			 * - Use self.client.connection as a proxy for (self.client instanceof Realtime),
			 * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */
			if(self.client.connection) {
				self.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback);
			} else {
				callback(null, tokenDetails);
			}
		})
	};

	Auth.prototype.authorise = function() {
		logger["a" /* default */].deprecated('Auth.authorise', 'Auth.authorize');
		this.authorize.apply(this, arguments);
	};

	/* For internal use, eg by connectionManager - useful when want to call back
	 * as soon as we have the new token, rather than waiting for it to take
	 * effect on the connection as #authorize does */
	Auth.prototype._forceNewToken = function(tokenParams, authOptions, callback) {
		var self = this;

		/* get rid of current token even if still valid */
		this.tokenDetails = null;

		/* _save normalises the tokenParams and authOptions and updates the auth
		 * object. All subsequent operations should use the values on `this`,
		 * not the passed in ones. */
		this._saveTokenOptions(tokenParams, authOptions);

		logAndValidateTokenAuthMethod(this.authOptions);

		this._ensureValidAuthCredentials(true, function(err, tokenDetails) {
			/* RSA10g */
			delete self.tokenParams.timestamp;
			delete self.authOptions.queryTime;
			callback(err, tokenDetails);
		});
	}

	/**
	 * Request an access token
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use.
	 *
	 * - authCallback:  (optional) a JavaScript callback to be called to get auth information.
	 *                  authCallback should be a function of (tokenParams, callback) that calls
	 *                  the callback with (err, result), where result is any of:
	 *                  - a tokenRequest object (ie the result of a rest.auth.createTokenRequest call),
	 *                  - a tokenDetails object (ie the result of a rest.auth.requestToken call),
	 *                  - a token string
	 *
	 * - authUrl:       (optional) a URL to be used to GET or POST a set of token request
	 *                  params, to obtain a signed token request.
	 *
	 * - authHeaders:   (optional) a set of application-specific headers to be added to any request
	 *                  made to the authUrl.
	 *
	 * - authParams:    (optional) a set of application-specific query params to be added to any
	 *                  request made to the authUrl.
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:          (optional) the requested life of the token in milliseconds. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 * @param callback (err, tokenDetails)
	 */
	Auth.prototype.requestToken = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		}
		else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'requestToken', arguments);
		}

		/* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);
		callback = callback || noop;

		/* first set up whatever callback will be used to get signed
		 * token requests */
		var tokenRequestCallback, client = this.client;

		if(authOptions.authCallback) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');
			tokenRequestCallback = authOptions.authCallback;
		} else if(authOptions.authUrl) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');
			tokenRequestCallback = function(params, cb) {
				var authHeaders = utils["a" /* default */].mixin({accept: 'application/json, text/plain'}, authOptions.authHeaders),
					usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';
				if(!usePost) {
					/* Combine authParams with any qs params given in the authUrl */
					var queryIdx = authOptions.authUrl.indexOf('?');
					if(queryIdx > -1) {
						var providedQsParams = utils["a" /* default */].parseQueryString(authOptions.authUrl.slice(queryIdx));
						authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);
						/* In case of conflict, authParams take precedence over qs params in the authUrl */
						authOptions.authParams = utils["a" /* default */].mixin(providedQsParams, authOptions.authParams);
					}
				}
				/* RSA8c2 */
				var authParams = utils["a" /* default */].mixin({}, authOptions.authParams || {}, params);
				var authUrlRequestCallback = function(err, body, headers, unpacked) {
					var contentType;
					if (err) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + utils["a" /* default */].inspectError(err));
					} else {
						contentType = headers['content-type'];
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + utils["a" /* default */].inspectBody(body));
					}
					if(err || unpacked) return cb(err, body);
					if(bufferutils["a" /* default */].isBuffer(body)) body = body.toString();
					if(!contentType) {
						cb(new errorinfo["a" /* default */]('authUrl response is missing a content-type header', 40170, 401));
						return;
					}
					var json = contentType.indexOf('application/json') > -1,
						text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;
					if(!json && !text) {
						cb(new errorinfo["a" /* default */]('authUrl responded with unacceptable content-type ' + contentType + ', should be either text/plain, application/jwt or application/json', 40170, 401));
						return;
					}
					if(json) {
						if(body.length > MAX_TOKEN_LENGTH) {
							cb(new errorinfo["a" /* default */]('authUrl response exceeded max permitted length', 40170, 401));
							return;
						}
						try {
							body = JSON.parse(body);
						} catch(e) {
							cb(new errorinfo["a" /* default */]('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));
							return;
						}
					}
					cb(null, body, contentType);
				};
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' + authOptions.authUrl + '; Params: ' + JSON.stringify(authParams) + '; method: ' + (usePost ? 'POST' : 'GET'));
				if(usePost) {
					/* send body form-encoded */
					var headers = authHeaders || {};
					headers['content-type'] = 'application/x-www-form-urlencoded';
					var body = utils["a" /* default */].toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */
					http["a" /* default */].postUri(client, authOptions.authUrl, headers, body, {}, authUrlRequestCallback);
				} else {
					http["a" /* default */].getUri(client, authOptions.authUrl, authHeaders || {}, authParams, authUrlRequestCallback);
				}
			};
		} else if(authOptions.key) {
			var self = this;
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');
			tokenRequestCallback = function(params, cb) { self.createTokenRequest(params, authOptions, cb); };
		} else {
			var msg = "Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)";
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');
			callback(new errorinfo["a" /* default */](msg, 40171, 403));
			return;
		}

		/* normalise token params */
		if('capability' in tokenParams)
			tokenParams.capability = c14n(tokenParams.capability);

		var tokenRequest = function(signedTokenParams, tokenCb) {
			var keyName = signedTokenParams.keyName,
				path = '/keys/' + keyName + '/requestToken',
				tokenUri = function(host) { return client.baseUri(host) + path; };

			var requestHeaders = utils["a" /* default */].defaultPostHeaders();
			if(authOptions.requestHeaders) utils["a" /* default */].mixin(requestHeaders, authOptions.requestHeaders);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));
			signedTokenParams = JSON.stringify(signedTokenParams);
			http["a" /* default */].post(client, tokenUri, requestHeaders, signedTokenParams, null, tokenCb);
		};

		var tokenRequestCallbackTimeoutExpired = false,
			timeoutLength = this.client.options.timeouts.realtimeRequestTimeout,
			tokenRequestCallbackTimeout = setTimeout(function() {
				tokenRequestCallbackTimeoutExpired = true;
				var msg = 'Token request callback timed out after ' + (timeoutLength / 1000) + ' seconds';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
			}, timeoutLength);

		tokenRequestCallback(tokenParams, function(err, tokenRequestOrDetails, contentType) {
			if(tokenRequestCallbackTimeoutExpired) return;
			clearTimeout(tokenRequestCallbackTimeout);

			if(err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + utils["a" /* default */].inspectError(err));
				callback(normaliseAuthcallbackError(err));
				return;
			}
			/* the response from the callback might be a token string, a signed request or a token details */
			if(typeof(tokenRequestOrDetails) === 'string') {
				if(tokenRequestOrDetails.length === 0) {
					callback(new errorinfo["a" /* default */]('Token string is empty', 40170, 401));
				} else if(tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {
					callback(new errorinfo["a" /* default */]('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));
				} else if(tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {
					/* common failure mode with poorly-implemented authCallbacks */
					callback(new errorinfo["a" /* default */]('Token string was literal null/undefined', 40170, 401));
				} else if((tokenRequestOrDetails[0] === '{') && !(contentType && contentType.indexOf('application/jwt') > -1)) {
					callback(new errorinfo["a" /* default */]('Token was double-encoded; make sure you\'re not JSON-encoding an already encoded token request or details', 40170, 401));
				} else {
					callback(null, {token: tokenRequestOrDetails});
				}
				return;
			}
			if(typeof(tokenRequestOrDetails) !== 'object') {
				var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' + typeof(tokenRequestOrDetails);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			var objectSize = JSON.stringify(tokenRequestOrDetails).length;
			if(objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {
				callback(new errorinfo["a" /* default */]('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));
				return;
			}
			if('issued' in tokenRequestOrDetails) {
				/* a tokenDetails object */
				callback(null, tokenRequestOrDetails);
				return;
			}
			if(!('keyName' in tokenRequestOrDetails)) {
				var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', msg);
				callback(new errorinfo["a" /* default */](msg, 40170, 401));
				return;
			}
			/* it's a token request, so make the request */
			tokenRequest(tokenRequestOrDetails, function(err, tokenResponse, headers, unpacked) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + utils["a" /* default */].inspectError(err));
					callback(normaliseAuthcallbackError(err));
					return;
				}
				if(!unpacked) tokenResponse = JSON.parse(tokenResponse);
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'token received');
				callback(null, tokenResponse);
			});
		});
	};

	/**
	 * Create and sign a token request based on the given options.
	 * NOTE this can only be used when the key value is available locally.
	 * Otherwise, signed token requests must be obtained from the key
	 * owner (either using the token request callback or url).
	 *
	 * @param authOptions
	 * an object containing the request options:
	 * - key:           the key to use. If not specified, a key passed in constructing
	 *                  the Rest interface will be used
	 *
	 * - queryTime      (optional) boolean indicating that the ably system should be
	 *                  queried for the current time when none is specified explicitly
	 *
	 * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the
	 *                  requestToken request
	 *
	 * @param tokenParams
	 * an object containing the parameters for the requested token:
	 * - ttl:       (optional) the requested life of the token in ms. If none is specified
	 *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request
	 *                  exceeeding that lifetime will be rejected with an error.
	 *
	 * - capability:    (optional) the capability to associate with the access token.
	 *                  If none is specified, a token will be requested with all of the
	 *                  capabilities of the specified key.
	 *
	 * - clientId:      (optional) a client Id to associate with the token; if not
	 *                  specified, a clientId passed in constructing the Rest interface will be used
	 *
	 * - timestamp:     (optional) the time in ms since the epoch. If none is specified,
	 *                  the system will be queried for a time value to use.
	 *
	 */
	Auth.prototype.createTokenRequest = function(tokenParams, authOptions, callback) {
		/* shuffle and normalise arguments as necessary */
		if(typeof(tokenParams) == 'function' && !callback) {
			callback = tokenParams;
			authOptions = tokenParams = null;
		} else if(typeof(authOptions) == 'function' && !callback) {
			callback = authOptions;
			authOptions = null;
		}
		if(!callback && this.client.options.promises) {
			return utils["a" /* default */].promisify(this, 'createTokenRequest', arguments);
		}

		/* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */
		authOptions = authOptions || this.authOptions;
		tokenParams = tokenParams || utils["a" /* default */].copy(this.tokenParams);

		var key = authOptions.key;
		if(!key) {
			callback(new errorinfo["a" /* default */]('No key specified', 40101, 403));
			return;
		}
		var keyParts = key.split(':'),
			keyName = keyParts[0],
			keySecret = keyParts[1];

		if(!keySecret) {
			callback(new errorinfo["a" /* default */]('Invalid key specified', 40101, 403));
			return;
		}

		if(tokenParams.clientId === '') {
			callback(new errorinfo["a" /* default */]('clientId cant be an empty string', 40012, 400));
			return;
		}

		if('capability' in tokenParams) {
			tokenParams.capability = c14n(tokenParams.capability);
		}

		var request = utils["a" /* default */].mixin({ keyName: keyName }, tokenParams),
			clientId = tokenParams.clientId || '',
			ttl = tokenParams.ttl || '',
			capability = tokenParams.capability || '',
			self = this;

		(function(authoriseCb) {
			if(request.timestamp) {
				authoriseCb();
				return;
			};
			self.getTimestamp(authOptions && authOptions.queryTime, function(err, time) {
				if(err) {callback(err); return;}
				request.timestamp = time;
				authoriseCb();
			});
		})(function() {
			/* nonce */
			/* NOTE: there is no expectation that the client
			 * specifies the nonce; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			var nonce = request.nonce || (request.nonce = random()),
				timestamp = request.timestamp;

			var signText
			=	request.keyName + '\n'
			+	ttl + '\n'
			+	capability + '\n'
			+	clientId + '\n'
			+	timestamp + '\n'
			+	nonce + '\n';

			/* mac */
			/* NOTE: there is no expectation that the client
			 * specifies the mac; this is done by the library
			 * However, this can be overridden by the client
			 * simply for testing purposes. */
			request.mac = request.mac || hmac(signText, keySecret);

			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');
			callback(null, request);
		});
	};

	/**
	 * Get the auth query params to use for a websocket connection,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthParams = function(callback) {
		if(this.method == 'basic')
			callback(null, {key: this.key});
		else
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {access_token: tokenDetails.token});
			});
	};

	/**
	 * Get the authorization header to use for a REST or comet request,
	 * based on the current auth parameters
	 */
	Auth.prototype.getAuthHeaders = function(callback) {
		if(this.method == 'basic') {
			callback(null, {authorization: 'Basic ' + this.basicKey});
		} else {
			this._ensureValidAuthCredentials(false, function(err, tokenDetails) {
				if(err) {
					callback(err);
					return;
				}
				callback(null, {authorization: 'Bearer ' + toBase64(tokenDetails.token)});
			});
		}
	};

	/**
	 * Get the current time based on the local clock,
	 * or if the option queryTime is true, return the server time.
	 * The server time offset from the local time is stored so that
	 * only one request to the server to get the time is ever needed
	 */
	Auth.prototype.getTimestamp = function(queryTime, callback) {
		if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {
			this.client.time(callback);
		} else {
			callback(null, this.getTimestampUsingOffset());
		}
	};

	Auth.prototype.getTimestampUsingOffset = function() {
		return utils["a" /* default */].now() + (this.client.serverTimeOffset || 0);
	};

	Auth.prototype.isTimeOffsetSet = function() {
		return this.client.serverTimeOffset !== null;
	};

	Auth.prototype._saveBasicOptions = function(authOptions) {
		this.method = 'basic';
		this.key = authOptions.key;
		this.basicKey = toBase64(authOptions.key);
		this.authOptions = authOptions || {};
		if('clientId' in authOptions) {
			this._userSetClientId(authOptions.clientId);
		}
	}

	Auth.prototype._saveTokenOptions = function(tokenParams, authOptions) {
		this.method = 'token';

		if(tokenParams) {
			/* We temporarily persist tokenParams.timestamp in case a new token needs
			 * to be requested, then null it out in the callback of
			 * _ensureValidAuthCredentials for RSA10g compliance */
			this.tokenParams = tokenParams;
		}

		if(authOptions) {
			/* normalise */
			if(authOptions.token) {
				/* options.token may contain a token string or, for convenience, a TokenDetails */
				authOptions.tokenDetails = (typeof(authOptions.token) === 'string') ? {token: authOptions.token} : authOptions.token;
			}

			if(authOptions.tokenDetails) {
				this.tokenDetails = authOptions.tokenDetails;
			}

			if('clientId' in authOptions) {
				this._userSetClientId(authOptions.clientId);
			}

			this.authOptions = authOptions;
		}
	};

	/* @param forceSupersede: force a new token request even if there's one in
	 * progress, making all pending callbacks wait for the new one */
	Auth.prototype._ensureValidAuthCredentials = function(forceSupersede, callback) {
		var self = this,
			token = this.tokenDetails;

		if(token) {
			if(this._tokenClientIdMismatch(token.clientId)) {
				/* 403 to trigger a permanently failed client - RSA15c */
				callback(new errorinfo["a" /* default */]('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));
				return;
			}
			/* RSA4b1 -- if we have a server time offset set already, we can
			 * autoremove expired tokens. Else just use the cached token. If it is
			 * expired Ably will tell us and we'll discard it then. */
			if(!this.isTimeOffsetSet() || !token.expires || (token.expires >= this.getTimestampUsingOffset())) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);
				callback(null, token);
				return;
			}
			/* expired, so remove and fallthrough to getting a new one */
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth.getToken()', 'deleting expired token');
			this.tokenDetails = null;
		}

		(this.waitingForTokenRequest || (this.waitingForTokenRequest = Object(multicaster["a" /* default */])())).push(callback);
		if(this.currentTokenRequestId !== null && !forceSupersede) {
			return;
		}

		/* Request a new token */
		var tokenRequestId = this.currentTokenRequestId = getTokenRequestId();
		this.requestToken(this.tokenParams, this.authOptions, function(err, tokenResponse) {
			if(self.currentTokenRequestId > tokenRequestId) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');
				return;
			}
			self.currentTokenRequestId = null;
			var callbacks = self.waitingForTokenRequest || noop;
			self.waitingForTokenRequest = null;
			if(err) {
				callbacks(err);
				return;
			}
			callbacks(null, (self.tokenDetails = tokenResponse));
		});
	};


	/* User-set: check types, '*' is disallowed, throw any errors */
	Auth.prototype._userSetClientId = function(clientId) {
		if(!(typeof(clientId) === 'string' || clientId === null)) {
			throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
		} else if(clientId === '*') {
			throw new errorinfo["a" /* default */]('Cant use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: "*"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: "*"}, authOptions)', 40012, 400);
		} else {
			var err = this._uncheckedSetClientId(clientId);
			if(err) throw err;
		}
	};

	/* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */
	Auth.prototype._uncheckedSetClientId = function(clientId) {
		if(this._tokenClientIdMismatch(clientId)) {
			/* Should never happen in normal circumstances as realtime should
			 * recognise mismatch and return an error */
			var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;
			var err = new errorinfo["a" /* default */](msg, 40102, 401);
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);
			return err;
		} else {
			/* RSA7a4: if options.clientId is provided and is not
			 * null, it overrides defaultTokenParams.clientId */
			this.clientId = this.tokenParams.clientId = clientId;
			return null;
		}
	};

	Auth.prototype._tokenClientIdMismatch = function(tokenClientId) {
		return this.clientId &&
			(this.clientId !== '*') &&
			tokenClientId &&
			(tokenClientId !== '*') &&
			(this.clientId !== tokenClientId);
	};

	Auth.isTokenErr = function(error) {
		return error.code && (error.code >= 40140) && (error.code < 40150);
	};

	return Auth;
})();

/* harmony default export */ var auth = __webpack_exports__["a"] = (auth_Auth);


/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_159250__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_159250__(1);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_159250__(8);
/* harmony import */ var _transport_transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_159250__(20);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_159250__(0);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_159250__(4);
/* harmony import */ var _connectionerror__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_159250__(13);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_159250__(14);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_159250__(2);









var CometTransport = (function() {

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	/* TODO: can remove once realtime sends protocol message responses for comet errors */
	function shouldBeErrorAction(err) {
		var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];
		if(err.code) {
			if(_client_auth__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].isTokenErr(err)) return false;
			if(_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrIn(UNRESOLVABLE_ERROR_CODES, err.code)) return true;
			return (err.code >= 40000 && err.code < 50000);
		} else {
			/* Likely a network or transport error of some kind. Certainly not fatal to the connection */
			return false;
		}
	}

	function protocolMessageFromRawError(err) {
		/* err will be either a legacy (non-protocolmessage) comet error response
		 * (which will have an err.code), or a xhr/network error (which won't). */
		if(shouldBeErrorAction(err)) {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.ERROR, error: err})];
		} else {
			return [_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromValues({action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].Action.DISCONNECTED, error: err})];
		}
	}

	/*
	 * A base comet transport class
	 */
	function CometTransport(connectionManager, auth, params) {
		/* binary not supported for comet, so just fall back to default */
		params.format = undefined;
		params.heartbeats = true;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		/* streaming defaults to true */
		this.stream = ('stream' in params) ? params.stream : true;
		this.sendRequest = null;
		this.recvRequest = null;
		this.pendingCallback = null;
		this.pendingItems = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(CometTransport, _transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	CometTransport.REQ_SEND = REQ_SEND;
	CometTransport.REQ_RECV = REQ_RECV;
	CometTransport.REQ_RECV_POLL = REQ_RECV_POLL;
	CometTransport.REQ_RECV_STREAM = REQ_RECV_STREAM;

	/* public instance methods */
	CometTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'starting');
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var host = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getHost(options, params.host);
		var port = _util_defaults__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getPort(options);
		var cometScheme = options.tls ? 'https://' : 'http://';

		this.baseUri = cometScheme + host + ':' + port + '/comet/';
		var connectUri = this.baseUri + 'connect';
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(err) {
				self.disconnect(err);
				return;
			}
			if(self.isDisposed) {
				return;
			}
			self.authParams = authParams;
			var connectParams = self.params.getConnectParams(authParams);
			if('stream' in connectParams) self.stream = connectParams.stream;
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(connectParams));

			/* this will be the 'recvRequest' so this connection can stream messages */
			var preconnected = false,
				connectRequest = self.recvRequest = self.createRequest(connectUri, null, connectParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV));

			connectRequest.on('data', function(data) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					return;
				}
				if(!preconnected) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onData(data);
			});
			connectRequest.on('complete', function(err, _body, headers) {
				if(!self.recvRequest) {
					/* the transport was disposed before we connected */
					err = err || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"]('Request cancelled', 80003, 400);
				}
				self.recvRequest = null;
				/* Connect request may complete without a emitting 'data' event since that is not
				 * emitted for e.g. a non-streamed error response. Still implies preconnect. */
				if(!preconnected && !err) {
					preconnected = true;
					self.emit('preconnect');
				}
				self.onActivity();
				if(err) {
					if(err.code) {
						/* A protocol error received from realtime. TODO: once realtime
						 * consistendly sends errors wrapped in protocol messages, should be
						 * able to remove this */
						self.onData(protocolMessageFromRawError(err));
					} else {
						/* A network/xhr error. Don't bother wrapping in a protocol message,
						 * just disconnect the transport */
						self.disconnect(err);
					}
					return;
				}
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					self.recv();
				});
			});
			connectRequest.exec();
		});
	};

	CometTransport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestClose()');
		this._requestCloseOrDisconnect(true);
	};

	CometTransport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.requestDisconnect()');
		this._requestCloseOrDisconnect(false);
	};

	CometTransport.prototype._requestCloseOrDisconnect = function(closing) {
		var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;
		if(closeOrDisconnectUri) {
			var self = this,
				request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, REQ_SEND);

			request.on('complete', function (err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
					self.finish('disconnected', err);
				}
			});
			request.exec();
		}
	};

	CometTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', '');
		if(!this.isDisposed) {
			this.isDisposed = true;
			if(this.recvRequest) {
				_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');
				this.recvRequest.abort();
				this.recvRequest = null;
			}
			/* In almost all cases the transport will be finished before it's
			 * disposed. Finish here just to make sure. */
			this.finish('disconnected', _connectionerror__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].disconnected);
			var self = this;
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.emit('disposed');
			});
		}
	};

	CometTransport.prototype.onConnect = function(message) {
		/* if this transport has been disposed whilst awaiting connection, do nothing */
		if(this.isDisposed) {
			return;
		}

		/* the connectionKey in a comet connected response is really
		 * <instId>-<connectionKey> */
		var connectionStr = message.connectionKey;
		_transport_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.onConnect.call(this, message);

		var baseConnectionUri =  this.baseUri + connectionStr;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri + '; connectionKey = ' + message.connectionKey);
		this.sendUri = baseConnectionUri + '/send';
		this.recvUri = baseConnectionUri + '/recv';
		this.closeUri = baseConnectionUri + '/close';
		this.disconnectUri = baseConnectionUri + '/disconnect';
	};

	CometTransport.prototype.send = function(message) {
		if(this.sendRequest) {
			/* there is a pending send, so queue this message */
			this.pendingItems = this.pendingItems || [];
			this.pendingItems.push(message);
			return;
		}
		/* send this, plus any pending, now */
		var pendingItems = this.pendingItems || [];
		pendingItems.push(message);
		this.pendingItems = null;

		this.sendItems(pendingItems);
	};

	CometTransport.prototype.sendAnyPending = function() {
		var pendingItems = this.pendingItems;

		if(!pendingItems) {
			return;
		}

		this.pendingItems = null;
		this.sendItems(pendingItems);
	}

	CometTransport.prototype.sendItems = function(items) {
		var self = this,
			sendRequest = this.sendRequest = self.createRequest(self.sendUri, null, self.authParams, this.encodeRequest(items), REQ_SEND);

		sendRequest.on('complete', function(err, data) {
			if(err) _util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err));
			self.sendRequest = null;

			/* the result of the request, even if a nack, is usually a protocol response
			 * contained in the data. An err is anomolous, and indicates some issue with the
			 * network,transport, or connection */
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}

			if(data) {
				self.onData(data);
			}

			if(self.pendingItems) {
				_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
					/* If there's a new send request by now, any pending items will have
					 * been picked up by that; any new ones added since then will be
					 * picked up after that one completes */
					if(!self.sendRequest) {
						self.sendAnyPending();
					}
				});
			}
		});
		sendRequest.exec();
	};

	CometTransport.prototype.recv = function() {
		/* do nothing if there is an active request, which might be streaming */
		if(this.recvRequest)
			return;

		/* If we're no longer connected, do nothing */
		if(!this.isConnected)
			return;

		var self = this,
			recvRequest = this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, (self.stream ? REQ_RECV_STREAM : REQ_RECV_POLL));

		recvRequest.on('data', function(data) {
			self.onData(data);
		});
		recvRequest.on('complete', function(err) {
			self.recvRequest = null;
			/* A request completing must be considered activity, as realtime sends
			 * heartbeats every 15s since a request began, not every 15s absolutely */
			self.onActivity();
			if(err) {
				if(err.code) {
					/* A protocol error received from realtime. TODO: once realtime
					 * consistendly sends errors wrapped in protocol messages, should be
					 * able to remove this */
					self.onData(protocolMessageFromRawError(err));
				} else {
					/* A network/xhr error. Don't bother wrapping in a protocol message,
					 * just disconnect the transport */
					self.disconnect(err);
				}
				return;
			}
			_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.recv();
			});
		});
		recvRequest.exec();
	};

	CometTransport.prototype.onData = function(responseData) {
		try {
			var items = this.decodeResponse(responseData);
			if(items && items.length)
				for(var i = 0; i < items.length; i++)
					this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].fromDeserialized(items[i]));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);
		}
	};

	CometTransport.prototype.encodeRequest = function(requestItems) {
		return JSON.stringify(requestItems);
	};

	CometTransport.prototype.decodeResponse = function(responseData) {
		if(typeof(responseData) == 'string')
			responseData = JSON.parse(responseData);
		return responseData;
	};

	/* For comet, we could do the auth update by aborting the current recv and
	 * starting a new one with the new token, that'd be sufficient for realtime.
	 * Problem is JSONP - you can't cancel truly abort a recv once started. So
	 * we need to send an AUTH for jsonp. In which case it's simpler to keep all
	 * comet transports the same and do it for all of them. So we send the AUTH
	 * instead, and don't need to abort the recv */
	CometTransport.prototype.onAuthUpdated = function(tokenDetails) {
		this.authParams = {access_token: tokenDetails.token};
	};

	return CometTransport;
})();

/* harmony default export */ __webpack_exports__["a"] = (CometTransport);


/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_174425__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_174425__(1);


var WebStorage = (function() {
	var sessionSupported,
		localSupported,
		test = 'ablyjs-storage-test';

	/* Even just accessing the session/localStorage object can throw a
	 * security exception in some circumstances with some browsers. In
	 * others, calling setItem will throw. So have to check in this
	 * somewhat roundabout way. (If unsupported or no global object,
	 * will throw on accessing a property of undefined) */
	try {
		global.sessionStorage.setItem(test, test);
		global.sessionStorage.removeItem(test);
		sessionSupported = true;
	} catch(e) {
		sessionSupported = false;
	}

	try {
		global.localStorage.setItem(test, test);
		global.localStorage.removeItem(test);
		localSupported = true;
	} catch(e) {
		localSupported = false;
	}

	function WebStorage() {}

	function storageInterface(session) {
		return session ? global.sessionStorage : global.localStorage;
	}

	function set(name, value, ttl, session) {
		var wrappedValue = {value: value};
		if(ttl) {
			wrappedValue.expires = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now() + ttl;
		}
		return storageInterface(session).setItem(name, JSON.stringify(wrappedValue));
	}

	function get(name, session) {
		var rawItem = storageInterface(session).getItem(name);
		if(!rawItem) return null;
		var wrappedValue = JSON.parse(rawItem);
		if(wrappedValue.expires && (wrappedValue.expires < _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].now())) {
			storageInterface(session).removeItem(name);
			return null;
		}
		return wrappedValue.value;
	}

	function remove(name, session) {
		return storageInterface(session).removeItem(name);
	}

	if(localSupported) {
		WebStorage.set    = function(name, value, ttl) { return set(name, value, ttl, false); };
		WebStorage.get    = function(name) { return get(name, false); };
		WebStorage.remove = function(name) { return remove(name, false); };
	}

	if(sessionSupported) {
		WebStorage.setSession    = function(name, value, ttl) { return set(name, value, ttl, true); };
		WebStorage.getSession    = function(name) { return get(name, true); };
		WebStorage.removeSession = function(name) { return remove(name, true); };
	}

	return WebStorage;
})();

/* harmony default export */ __webpack_exports__["a"] = (WebStorage);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_174425__(17)))

/***/ }),
/* 17 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 18 */
/***/ (function(module, exports, __nested_webpack_require_177656__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_177656__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * Base64 encoding strategy.
	     */
	    var Base64 = C_enc.Base64 = {
	        /**
	         * Converts a word array to a Base64 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Base64 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

	            // Clamp excess bits
	            wordArray.clamp();

	            // Convert
	            var base64Chars = [];
	            for (var i = 0; i < sigBytes; i += 3) {
	                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;
	                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;
	                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;

	                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;

	                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {
	                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));
	                }
	            }

	            // Add padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                while (base64Chars.length % 4) {
	                    base64Chars.push(paddingChar);
	                }
	            }

	            return base64Chars.join('');
	        },

	        /**
	         * Converts a Base64 string to a word array.
	         *
	         * @param {string} base64Str The Base64 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
	         */
	        parse: function (base64Str) {
	            // Shortcuts
	            var base64StrLength = base64Str.length;
	            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
	            var reverseMap = this._reverseMap;

	            if (!reverseMap) {
	                    reverseMap = this._reverseMap = [];
	                    for (var j = 0; j < map.length; j++) {
	                        reverseMap[map.charCodeAt(j)] = j;
	                    }
	            }

	            // Ignore padding
	            var paddingChar = map.charAt(64);
	            if (paddingChar) {
	                var paddingIndex = base64Str.indexOf(paddingChar);
	                if (paddingIndex !== -1) {
	                    base64StrLength = paddingIndex;
	                }
	            }

	            // Convert
	            return parseLoop(base64Str, base64StrLength, reverseMap);

	        }
	    };

	    function parseLoop(base64Str, base64StrLength, reverseMap) {
	      var words = [];
	      var nBytes = 0;
	      for (var i = 0; i < base64StrLength; i++) {
	          if (i % 4) {
	              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);
	              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);
	              var bitsCombined = bits1 | bits2;
	              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);
	              nBytes++;
	          }
	      }
	      return WordArray.create(words, nBytes);
	    }
	}());


	return CryptoJS.enc.Base64;

}));

/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_181824__) {

"use strict";
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_181824__(10);
/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_181824__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_181824__(18);
/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_181824__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_181824__(28);
/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_181824__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_181824__(3);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_181824__(0);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_181824__(5);







var Crypto = (function() {
	var DEFAULT_ALGORITHM = 'aes';
	var DEFAULT_KEYLENGTH = 256; // bits
	var DEFAULT_MODE = 'cbc';
	var DEFAULT_BLOCKLENGTH = 16; // bytes
	var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words
	var UINT32_SUP = 0x100000000;
	var INT32_SUP = 0x80000000;

	/**
	 * Internal: generate an array of secure random words corresponding to the given length of bytes
	 * @param bytes
	 * @param callback
	 */
	var generateRandom;
	if(platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray) {
		generateRandom = platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomWordArray;
	} else if(typeof Uint32Array !== 'undefined' && platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues) {
		var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);
		generateRandom = function(bytes, callback) {
			var words = bytes / 4, nativeArray = (words == DEFAULT_BLOCKLENGTH_WORDS) ? blockRandomArray : new Uint32Array(words);
			platform__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getRandomValues(nativeArray, function(err) {
				callback(err, platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(nativeArray))
			});
		};
	} else {
		generateRandom = function(bytes, callback) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MAJOR, 'Ably.Crypto.generateRandom()', 'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()');
			var words = bytes / 4, array = new Array(words);
			for(var i = 0; i < words; i++) {
				/* cryptojs wordarrays use signed ints. When WordArray.create is fed a
				* Uint32Array unsigned are converted to signed automatically, but when
				* fed a normal array they aren't, so need to do so ourselves by
				* subtracting INT32_SUP */
				array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;
			}

			callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));
		};
	}

	/**
	 * Internal: calculate the padded length of a given plaintext
	 * using PKCS5.
	 * @param plaintextLength
	 * @return
	 */
	function getPaddedLength(plaintextLength) {
		return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;
	}

	/**
	 * Internal: checks that the cipherParams are a valid combination. Currently
	 * just checks that the calculated keyLength is a valid one for aes-cbc
	 */
	function validateCipherParams(params) {
		if(params.algorithm === 'aes' && params.mode === 'cbc') {
			if(params.keyLength === 128 || params.keyLength === 256) {
				return;
			}
			throw new Error('Unsupported key length ' + params.keyLength + ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)');
		}
	}

	function normaliseBase64(string) {
		/* url-safe base64 strings use _ and - instread of / and + */
		return string.replace('_', '/').replace('-', '+');
	}

	/**
	 * Internal: a block containing zeros
	 */
	var emptyBlock = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0,0,0,0]);

	/**
	 * Internal: obtain the pkcs5 padding string for a given padded length;
	 */
	var pkcs5Padding = [
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505,0x05000000], 5),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606,0x06060000], 6),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707,0x07070700], 7),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808,0x08080808], 8),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909,0x09090909,0x09000000], 9),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a,0x0a0a0a0a,0x0a0a0000], 10),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b,0x0b0b0b0b,0x0b0b0b00], 11),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c,0x0c0c0c0c,0x0c0c0c0c], 12),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d,0x0d0d0d0d,0x0d0d0d0d,0x0d000000], 13),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e,0x0e0e0e0e,0x0e0e0e0e,0x0e0e0000], 14),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f,0x0f0f0f0f], 15),
		crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010,0x10101010,0x10101010,0x10101010], 16)
	];

	/**
	 * Utility classes and interfaces for message payload encryption.
	 *
	 * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits
	 * but supporting other keylengths. Other algorithms and chaining modes are
	 * not supported directly, but supportable by extending/implementing the base
	 * classes and interfaces here.
	 *
	 * Secure random data for creation of Initialization Vectors (IVs) and keys
	 * is obtained from window.crypto.getRandomValues if available, or from
	 * Math.random() if not. Clients who do not want to depend on Math.random()
	 * should polyfill window.crypto.getRandomValues with a library that seeds
	 * a PRNG with real entropy.
	 *
	 * Each message payload is encrypted with an IV in CBC mode, and the IV is
	 * concatenated with the resulting raw ciphertext to construct the "ciphertext"
	 * data passed to the recipient.
	 */
	function Crypto() {}

	/**
	 * A class encapsulating the client-specifiable parameters for
	 * the cipher.
	 *
	 * algorithm is the name of the algorithm in the default system provider,
	 * or the lower-cased version of it; eg "aes" or "AES".
	 *
	 * Clients are recommended to not call this directly, but instead to use the
	 * Crypto.getDefaultParams helper, which will fill in any fields not supplied
	 * with default values and validation the result.
	 */
	function CipherParams() {
		this.algorithm = null;
		this.keyLength = null;
		this.mode = null;
		this.key = null;
	}
	Crypto.CipherParams = CipherParams;

	/**
	 * Obtain a complete CipherParams instance from the provided params, filling
	 * in any not provided with default values, calculating a keyLength from
	 * the supplied key, and validating the result.
	 * @param params an object containing at a minimum a `key` key with value the
	 * key, as either a binary (ArrayBuffer, Array, WordArray) or a
	 * base64-encoded string. May optionally also contain: algorithm (defaults to
	 * AES), mode (defaults to 'cbc')
	 */
	Crypto.getDefaultParams = function(params) {
		var key;
		/* Backward compatibility */
		if((typeof(params) === 'function') || (typeof(params) === 'string')) {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');
			if(typeof(params) === 'function') {
				Crypto.generateRandomKey(function(key) {
					params(null, Crypto.getDefaultParams({key: key}));
				})
			} else if(typeof arguments[1] === 'function') {
				arguments[1](null, Crypto.getDefaultParams({key: params}));
			} else {
				throw new Error('Invalid arguments for Crypto.getDefaultParams');
			}
			return;
		}

		if(!params.key) {
			throw new Error('Crypto.getDefaultParams: a key is required');
		}

		if (typeof(params.key) === 'string') {
			key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__["parse"])(normaliseBase64(params.key));
		} else {
			key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point
		}

		var cipherParams = new CipherParams();
		cipherParams.key = key;
		cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;
		cipherParams.keyLength = key.words.length * (4 * 8);
		cipherParams.mode = params.mode || DEFAULT_MODE;

		if(params.keyLength && params.keyLength !== cipherParams.keyLength) {
			throw new Error('Crypto.getDefaultParams: a keyLength of ' + params.keyLength + ' was specified, but the key actually has length ' + cipherParams.keyLength);
		}

		validateCipherParams(cipherParams);
		return cipherParams;
	};

	/**
	 * Generate a random encryption key from the supplied keylength (or the
	 * default keyLength if none supplied) as a CryptoJS WordArray
	 * @param keyLength (optional) the required keyLength in bits
	 * @param callback (err, key)
	 */
	Crypto.generateRandomKey = function(keyLength, callback) {
		if(arguments.length == 1 && typeof(keyLength) == 'function') {
			callback = keyLength;
			keyLength = undefined;
		}
		generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, callback);
	};

	/**
	 * Internal; get a ChannelCipher instance based on the given cipherParams
	 * @param params either a CipherParams instance or some subset of its
	 * fields that includes a key
	 */
	Crypto.getCipher = function(params) {
		var cipherParams = (params instanceof CipherParams) ?
		                   params :
		                   Crypto.getDefaultParams(params);

		return {cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv)};
	};

	function CBCCipher(params, blockLengthWords, iv) {
		this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;
		this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\d+$/, '');
		this.key = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(params.key);
		if(iv) {
			this.iv = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(iv).clone();
		}
		this.blockLengthWords = blockLengthWords;
	}

	CBCCipher.prototype.encrypt = function(plaintext, callback) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.encrypt()', '');
		plaintext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(plaintext);
		var plaintextLength = plaintext.sigBytes,
			paddedLength = getPaddedLength(plaintextLength),
			self = this;

		var then = function() {
			self.getIv(function(err, iv) {
				if (err) {
					callback(err);
					return;
				}
				var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));
				var ciphertext = iv.concat(cipherOut);
				callback(null, ciphertext);
			});
		};

		if (!this.encryptCipher) {
			if(this.iv) {
				this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });
				then();
			} else {
				generateRandom(DEFAULT_BLOCKLENGTH, function(err, iv) {
					if (err) {
						callback(err);
						return;
					}
					self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });
					self.iv = iv;
					then();
				});
			}
		} else {
			then();
		}
	};

	CBCCipher.prototype.decrypt = function(ciphertext) {
		_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'CBCCipher.decrypt()', '');
		ciphertext = platform_bufferutils__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].toWordArray(ciphertext);
		var blockLengthWords = this.blockLengthWords,
			ciphertextWords = ciphertext.words,
			iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),
			ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));

		var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });
		var plaintext = decryptCipher.process(ciphertextBody);
		var epilogue = decryptCipher.finalize();
		decryptCipher.reset();
		if(epilogue && epilogue.sigBytes) plaintext.concat(epilogue);
		return plaintext;
	};

	CBCCipher.prototype.getIv = function(callback) {
		if(this.iv) {
			var iv = this.iv;
			this.iv = null;
			callback(null, iv);
			return;
		}

		/* Since the iv for a new block is the ciphertext of the last, this
		* sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as
		* returning it */
		var self = this;
		generateRandom(DEFAULT_BLOCKLENGTH, function(err, randomBlock) {
			if (err) {
				callback(err);
				return;
			} 
			callback(null, self.encryptCipher.process(randomBlock));
		});
	};

	return Crypto;
})();

/* harmony default export */ __webpack_exports__["a"] = (Crypto);


/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_196843__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_196843__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_196843__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_196843__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_196843__(0);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_196843__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_196843__(2);







var Transport = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var closeMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.CLOSE});
	var disconnectMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({action: actions.DISCONNECT});
	var noop = function() {};

	/*
	 * EventEmitter, generates the following events:
	 *
	 * event name       data
	 * closed           error
	 * failed           error
	 * disposed
	 * connected        null error, connectionSerial, connectionId, connectionDetails
	 * sync             connectionSerial, connectionId
	 * event            channel message object
	 */

	/* public constructor */
	function Transport(connectionManager, auth, params) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.connectionManager = connectionManager;
		connectionManager.registerProposedTransport(this);
		this.auth = auth;
		this.params = params;
		this.timeouts = params.options.timeouts;
		this.format = params.format;
		this.isConnected = false;
		this.isFinished = false;
		this.isDisposed = false;
		this.maxIdleInterval = null;
		this.idleTimer = null;
		this.lastActivity = null;
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Transport, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Transport.prototype.connect = function() {};

	Transport.prototype.close = function() {
		if(this.isConnected) {
			this.requestClose();
		}
		this.finish('closed', _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].closed);
	};

	Transport.prototype.disconnect = function(err) {
		/* Used for network/transport issues that need to result in the transport
		 * being disconnected, but should not affect the connection */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('disconnected', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].disconnected);
	};

	Transport.prototype.fail = function(err) {
		/* Used for client-side-detected fatal connection issues */
		if(this.isConnected) {
			this.requestDisconnect();
		}
		this.finish('failed', err || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].failed);
	};

	Transport.prototype.finish = function(event, err) {
		if(this.isFinished) {
			return;
		}

		this.isFinished = true;
		this.isConnected = false;
		this.maxIdleInterval = null;
		clearTimeout(this.idleTimer);
		this.idleTimer = null;
		this.emit(event, err);
		this.dispose();
	};

	Transport.prototype.onProtocolMessage = function(message) {
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' + this.shortName + ': ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(message) + '; connectionId = ' + this.connectionManager.connectionId);
		}
		this.onActivity();

		switch(message.action) {
		case actions.HEARTBEAT:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);
			this.emit('heartbeat', message.id);
			break;
		case actions.CONNECTED:
			this.onConnect(message);
			this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);
			break;
		case actions.CLOSED:
			this.onClose(message);
			break;
		case actions.DISCONNECTED:
			this.onDisconnect(message);
			break;
		case actions.ACK:
			this.emit('ack', message.msgSerial, message.count);
			break;
		case actions.NACK:
			this.emit('nack', message.msgSerial, message.count, message.error);
			break;
		case actions.SYNC:
			if(message.connectionId !== undefined) {
				/* a transport SYNC */
				this.emit('sync', message.connectionId, message);
				break;
			}
			/* otherwise it's a channel SYNC, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		case actions.AUTH:
			this.auth.authorize(function(err) {
				if(err) {
					_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
				}
			});
			break;
		case actions.ERROR:
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' + this.connectionManager.connectionId + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(message.error) + (message.channel ? (', channel: ' +  message.channel) : ''));
			if(message.channel === undefined) {
				this.onFatalError(message);
				break;
			}
			/* otherwise it's a channel-specific error, so handle it in the channel */
			this.connectionManager.onChannelMessage(message, this);
			break;
		default:
			/* all other actions are channel-specific */
			this.connectionManager.onChannelMessage(message, this);
		}
	};

	Transport.prototype.onConnect = function(message) {
		this.isConnected = true;
		var maxPromisedIdle = message.connectionDetails.maxIdleInterval;
		if(maxPromisedIdle) {
			this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;
			this.onActivity();
		}
		/* else Realtime declines to guarantee any maximum idle interval - CD2h */
	};

	Transport.prototype.onDisconnect = function(message) {
		/* Used for when the server has disconnected the client (usually with a
		 * DISCONNECTED action) */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('disconnected', err);
	};

	Transport.prototype.onFatalError = function(message) {
		/* On receipt of a fatal connection error, we can assume that the server
		 * will close the connection and the transport, and do not need to request
		 * a disconnection - RTN15i */
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onFatalError()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('failed', err);
	};

	Transport.prototype.onClose = function(message) {
		var err = message && message.error;
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.onClose()', 'err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		this.finish('closed', err);
	};

	Transport.prototype.requestClose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestClose()', '');
		this.send(closeMessage);
	};

	Transport.prototype.requestDisconnect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.requestDisconnect()', '');
		this.send(disconnectMessage);
	};

	Transport.prototype.ping = function(id) {
		var msg = {action: _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action.HEARTBEAT};
		if(id) msg.id = id;
		this.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues(msg));
	};

	Transport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MINOR, 'Transport.dispose()', '');
		this.isDisposed = true;
		this.off();
	};

	Transport.prototype.onActivity = function() {
		if(!this.maxIdleInterval) { return; }
		this.lastActivity = this.connectionManager.lastActivity = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
		this.setIdleTimer(this.maxIdleInterval + 100);
	};

	Transport.prototype.setIdleTimer = function(timeout) {
		var self = this;
		if(!this.idleTimer) {
			this.idleTimer = setTimeout(function() {
				self.onIdleTimerExpire();
			}, timeout);
		}
	};

	Transport.prototype.onIdleTimerExpire = function() {
		this.idleTimer = null;
		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity,
			timeRemaining = this.maxIdleInterval - sinceLast;
		if(timeRemaining <= 0) {
			var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);
			this.disconnect(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"](msg, 80003, 408));
		} else {
			this.setIdleTimer(timeRemaining + 100);
		}
	};

	Transport.prototype.onAuthUpdated = function() {};

	return Transport;
})();

/* harmony default export */ __webpack_exports__["a"] = (Transport);


/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var ConnectionStateChange = (function() {

	/* public constructor */
	function ConnectionStateChange(previous, current, retryIn, reason) {
		this.previous = previous;
		this.current = current;
		if(retryIn) this.retryIn = retryIn;
		if(reason) this.reason = reason;
	}

	return ConnectionStateChange;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionStateChange);


/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_208188__) {

"use strict";
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_208188__(0);


var Multicaster = (function() {

	function Multicaster(members) {
		members = members || [];

		var handler = function() {
			for(var i = 0; i < members.length; i++) {
				var member = members[i];
				if(member) {
					try {
						member.apply(null, arguments);
					} catch(e){
						_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);
					}
				}
			}
		};

		handler.push = function() {
			Array.prototype.push.apply(members, arguments);
		};
		return handler;
	}

	return Multicaster;
})();

/* harmony default export */ __webpack_exports__["a"] = (Multicaster);


/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_209166__) {

"use strict";
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_209166__(1);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_209166__(3);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_209166__(4);
/* harmony import */ var _logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_209166__(0);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_209166__(6);






var ErrorReporter = (function() {
	function ErrorReporter() {}

	var levels = ErrorReporter.levels = [
		'fatal',
		'error',
		'warning',
		'info',
		'debug'
	];

	/* (level: typeof ErrorReporter.levels[number], message: string, fingerprint?: string, tags?: {[key: string]: string}): void */
	ErrorReporter.report = function(level, message, fingerprint, tags) {
		var eventId = _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].randomHexString(16);

		var event = {
			event_id: eventId,
			tags: _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].mixin({
				ablyAgent: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].agent
			}, tags),
			platform: 'javascript',
			level: level,
			release: _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].version,
			fingerprint: fingerprint && [ fingerprint ],
			message: message,
			request: {
				headers: {
					'User-Agent': platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].userAgent
				},
				url: platform__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].currentUrl
			}
		};

		_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter: ' + message);
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].postUri(null, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingUrl, _util_defaults__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].errorReportingHeaders, JSON.stringify(event), {}, function(err, res) {
			_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'ErrorReporter', 'POSTing to error reporter resulted in: ' +
				(err ? _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectError(err) : _utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspectBody(res))
			);
		});
	};

	return ErrorReporter;
})();

/* harmony default export */ __webpack_exports__["a"] = (ErrorReporter);


/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
var msgpack = (function() {
	"use strict";

	var exports = {};

	exports.inspect = inspect;
	function inspect(buffer) {
		if (buffer === undefined)
			return "undefined";
		var view;
		var type;
		if ( buffer instanceof ArrayBuffer) {
			type = "ArrayBuffer";
			view = new DataView(buffer);
		} else if ( buffer instanceof DataView) {
			type = "DataView";
			view = buffer;
		}
		if (!view)
			return JSON.stringify(buffer);
		var bytes = [];
		for (var i = 0; i < buffer.byteLength; i++) {
			if (i > 20) {
				bytes.push("...");
				break;
			}
			var byte_ = view.getUint8(i).toString(16);
			if (byte_.length === 1)
				byte_ = "0" + byte_;
			bytes.push(byte_);
		}
		return "<" + type + " " + bytes.join(" ") + ">";
	}

	// Encode string as utf8 into dataview at offset
	exports.utf8Write = utf8Write;
	function utf8Write(view, offset, string) {
		var byteLength = view.byteLength;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);

			// One byte of UTF-8
			if (codePoint < 0x80) {
				view.setUint8(offset++, codePoint >>> 0 & 0x7f | 0x00);
				continue;
			}

			// Two bytes of UTF-8
			if (codePoint < 0x800) {
				view.setUint8(offset++, codePoint >>> 6 & 0x1f | 0xc0);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Three bytes of UTF-8.
			if (codePoint < 0x10000) {
				view.setUint8(offset++, codePoint >>> 12 & 0x0f | 0xe0);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}

			// Four bytes of UTF-8
			if (codePoint < 0x110000) {
				view.setUint8(offset++, codePoint >>> 18 & 0x07 | 0xf0);
				view.setUint8(offset++, codePoint >>> 12 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 6 & 0x3f | 0x80);
				view.setUint8(offset++, codePoint >>> 0 & 0x3f | 0x80);
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
	}


	exports.utf8Read = utf8Read;
	function utf8Read(view, offset, length) {
		var string = "";
		for (var i = offset, end = offset + length; i < end; i++) {
			var byte_ = view.getUint8(i);
			// One byte character
			if ((byte_ & 0x80) === 0x00) {
				string += String.fromCharCode(byte_);
				continue;
			}
			// Two byte character
			if ((byte_ & 0xe0) === 0xc0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));
				continue;
			}
			// Three byte character
			if ((byte_ & 0xf0) === 0xe0) {
				string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			// Four byte character
			if ((byte_ & 0xf8) === 0xf0) {
				string += String.fromCharCode(((byte_ & 0x07) << 18) | ((view.getUint8(++i) & 0x3f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));
				continue;
			}
			throw new Error("Invalid byte " + byte_.toString(16));
		}
		return string;
	}


	exports.utf8ByteCount = utf8ByteCount;
	function utf8ByteCount(string) {
		var count = 0;
		for (var i = 0, l = string.length; i < l; i++) {
			var codePoint = string.charCodeAt(i);
			if (codePoint < 0x80) {
				count += 1;
				continue;
			}
			if (codePoint < 0x800) {
				count += 2;
				continue;
			}
			if (codePoint < 0x10000) {
				count += 3;
				continue;
			}
			if (codePoint < 0x110000) {
				count += 4;
				continue;
			}
			throw new Error("bad codepoint " + codePoint);
		}
		return count;
	}


	exports.encode = function(value, sparse) {
		var size = sizeof(value, sparse);
		if(size == 0)
			return undefined;
		var buffer = new ArrayBuffer(size);
		var view = new DataView(buffer);
		encode(value, view, 0, sparse);
		return buffer;
	};

	exports.decode = decode;

	var SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;
	function getInt64(view, offset) {
		offset = offset || 0;
		return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function getUint64(view, offset) {
		offset = offset || 0;
		return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);
	}

	function setInt64(view, offset, val) {
		if (val < 0x8000000000000000) {
			view.setInt32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0x7fffffff);
			view.setUint32(offset + 4, 0x7fffffff);
		}
	}

	function setUint64(view, offset, val) {
		if (val < 0x10000000000000000) {
			view.setUint32(offset, Math.floor(val * SH_R_32));
			view.setInt32(offset + 4, val & -1);
		} else {
			view.setUint32(offset, 0xffffffff);
			view.setUint32(offset + 4, 0xffffffff);
		}
	}

// https://gist.github.com/frsyuki/5432559 - v5 spec
//
// I've used one extension point from `fixext 1` to store `undefined`. On the wire this
// should translate to exactly 0xd40000
//
// +--------+--------+--------+
// |  0xd4  |  0x00  |  0x00  |
// +--------+--------+--------+
//    ^ fixext |        ^ value part unused (fixed to be 0)
//             ^ indicates undefined value
//

	function Decoder(view, offset) {
		this.offset = offset || 0;
		this.view = view;
	}


	Decoder.prototype.map = function(length) {
		var value = {};
		for (var i = 0; i < length; i++) {
			var key = this.parse();
			value[key] = this.parse();
		}
		return value;
	};

	Decoder.prototype.bin = Decoder.prototype.buf = function(length) {
		var value = new ArrayBuffer(length);
		(new Uint8Array(value)).set(new Uint8Array(this.view.buffer, this.offset, length), 0);
		this.offset += length;
		return value;
	};

	Decoder.prototype.str = function(length) {
		var value = utf8Read(this.view, this.offset, length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.array = function(length) {
		var value = new Array(length);
		for (var i = 0; i < length; i++) {
			value[i] = this.parse();
		}
		return value;
	};

	Decoder.prototype.ext = function(length) {
		var value = {};
		// Get the type byte
		value['type'] = this.view.getInt8(this.offset);
		this.offset++;
		// Get the data array (length)
		value['data'] = this.buf(length);
		this.offset += length;
		return value;
	};

	Decoder.prototype.parse = function() {
		var type = this.view.getUint8(this.offset);
		var value, length;

		// Positive FixInt - 0xxxxxxx
		if ((type & 0x80) === 0x00) {
			this.offset++;
			return type;
		}

		// FixMap - 1000xxxx
		if ((type & 0xf0) === 0x80) {
			length = type & 0x0f;
			this.offset++;
			return this.map(length);
		}

		// FixArray - 1001xxxx
		if ((type & 0xf0) === 0x90) {
			length = type & 0x0f;
			this.offset++;
			return this.array(length);
		}

		// FixStr - 101xxxxx
		if ((type & 0xe0) === 0xa0) {
			length = type & 0x1f;
			this.offset++;
			return this.str(length);
		}

		// Negative FixInt - 111xxxxx
		if ((type & 0xe0) === 0xe0) {
			value = this.view.getInt8(this.offset);
			this.offset++;
			return value;
		}

		switch (type) {

			// nil
			case 0xc0:
				this.offset++;
				return null;

			// 0xc1 never used - use for undefined (NON-STANDARD)
			case 0xc1:
				this.offset++;
				return undefined;

			// false
			case 0xc2:
				this.offset++;
				return false;

			// true
			case 0xc3:
				this.offset++;
				return true;

			// bin 8
			case 0xc4:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.bin(length);

			// bin 16
			case 0xc5:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.bin(length);

			// bin 32
			case 0xc6:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.bin(length);

			// ext 8
			case 0xc7:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.ext(length);

			// ext 16
			case 0xc8:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.ext(length);

			// ext 32
			case 0xc9:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.ext(length);

			// float 32
			case 0xca:
				value = this.view.getFloat32(this.offset + 1);
				this.offset += 5;
				return value;

			// float 64
			case 0xcb:
				value = this.view.getFloat64(this.offset + 1);
				this.offset += 9;
				return value;

			// uint8
			case 0xcc:
				value = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return value;

			// uint 16
			case 0xcd:
				value = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return value;

			// uint 32
			case 0xce:
				value = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return value;

			// uint 64
			case 0xcf:
				value = getUint64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// int 8
			case 0xd0:
				value = this.view.getInt8(this.offset + 1);
				this.offset += 2;
				return value;

			// int 16
			case 0xd1:
				value = this.view.getInt16(this.offset + 1);
				this.offset += 3;
				return value;

			// int 32
			case 0xd2:
				value = this.view.getInt32(this.offset + 1);
				this.offset += 5;
				return value;

			// int 64
			case 0xd3:
				value = getInt64(this.view, this.offset + 1);
				this.offset += 9;
				return value;

			// fixext 1
			case 0xd4:
				length = 1;
				this.offset++;
				return this.ext(length);

			// fixext 2
			case 0xd5:
				length = 2;
				this.offset++;
				return this.ext(length);

			// fixext 4
			case 0xd6:
				length = 4;
				this.offset++;
				return this.ext(length);

			// fixext 8
			case 0xd7:
				length = 8;
				this.offset++;
				return this.ext(length);

			// fixext 16
			case 0xd8:
				length = 16;
				this.offset++;
				return this.ext(length);

			// str8
			case 0xd9:
				length = this.view.getUint8(this.offset + 1);
				this.offset += 2;
				return this.str(length);

			// str 16
			case 0xda:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.str(length);

			// str 32
			case 0xdb:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.str(length);

			// array 16
			case 0xdc:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.array(length);

			// array 32
			case 0xdd:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.array(length);

			// map 16
			case 0xde:
				length = this.view.getUint16(this.offset + 1);
				this.offset += 3;
				return this.map(length);

			// map 32
			case 0xdf:
				length = this.view.getUint32(this.offset + 1);
				this.offset += 5;
				return this.map(length);
		}
		throw new Error("Unknown type 0x" + type.toString(16));
	};

	function decode(buffer) {
		var view = new DataView(buffer);
		var decoder = new Decoder(view);
		var value = decoder.parse();
		if (decoder.offset !== buffer.byteLength)
			throw new Error((buffer.byteLength - decoder.offset) + " trailing bytes");
		return value;
	}

	function encodeableKeys(value, sparse) {
		var keys = []; // TODO: use Object.keys when we are able to transpile to ES3
		for (var key in value) {
			if (!value.hasOwnProperty(key)) continue;
			keys.push(key);
		}
		return keys.filter(function (e) {
			var val = value[e], type = typeof(val);
			return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);
		})
	}

	function encode(value, view, offset, sparse) {
		var type = typeof value;

		// Strings Bytes
		// There are four string types: fixstr/str8/str16/str32
		if (type === "string") {
			var length = utf8ByteCount(value);

			// fixstr
			if (length < 0x20) {
				view.setUint8(offset, length | 0xa0);
				utf8Write(view, offset + 1, value);
				return 1 + length;
			}

			// str8
			if (length < 0x100) {
				view.setUint8(offset, 0xd9);
				view.setUint8(offset + 1, length);
				utf8Write(view, offset + 2, value);
				return 2 + length;
			}

			// str16
			if (length < 0x10000) {
				view.setUint8(offset, 0xda);
				view.setUint16(offset + 1, length);
				utf8Write(view, offset + 3, value);
				return 3 + length;
			}
			// str32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xdb);
				view.setUint32(offset + 1, length);
				utf8Write(view, offset + 5, value);
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// There are three bin types: bin8/bin16/bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;

			// bin8
			if (length < 0x100) {
				view.setUint8(offset, 0xc4);
				view.setUint8(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 2);
				return 2 + length;
			}

			// bin16
			if (length < 0x10000) {
				view.setUint8(offset, 0xc5);
				view.setUint16(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 3);
				return 3 + length;
			}

			// bin 32
			if (length < 0x100000000) {
				view.setUint8(offset, 0xc6);
				view.setUint32(offset + 1, length);
				(new Uint8Array(view.buffer)).set(new Uint8Array(value), offset + 5);
				return 5 + length;
			}
		}

		if (type === "number") {

			// Floating Point
			// NOTE: We're always using float64
			if (Math.floor(value) !== value) {
				view.setUint8(offset, 0xcb);
				view.setFloat64(offset + 1, value);
				return 9;
			}

			// Integers
			if (value >= 0) {
				// positive fixnum
				if (value < 0x80) {
					view.setUint8(offset, value);
					return 1;
				}
				// uint 8
				if (value < 0x100) {
					view.setUint8(offset, 0xcc);
					view.setUint8(offset + 1, value);
					return 2;
				}
				// uint 16
				if (value < 0x10000) {
					view.setUint8(offset, 0xcd);
					view.setUint16(offset + 1, value);
					return 3;
				}
				// uint 32
				if (value < 0x100000000) {
					view.setUint8(offset, 0xce);
					view.setUint32(offset + 1, value);
					return 5;
				}
				// uint 64
				if (value < 0x10000000000000000) {
					view.setUint8(offset, 0xcf);
					setUint64(view, offset + 1, value);
					return 9;
				}
				throw new Error("Number too big 0x" + value.toString(16));
			}

			// negative fixnum
			if (value >= -0x20) {
				view.setInt8(offset, value);
				return 1;
			}
			// int 8
			if (value >= -0x80) {
				view.setUint8(offset, 0xd0);
				view.setInt8(offset + 1, value);
				return 2;
			}
			// int 16
			if (value >= -0x8000) {
				view.setUint8(offset, 0xd1);
				view.setInt16(offset + 1, value);
				return 3;
			}
			// int 32
			if (value >= -0x80000000) {
				view.setUint8(offset, 0xd2);
				view.setInt32(offset + 1, value);
				return 5;
			}
			// int 64
			if (value >= -0x8000000000000000) {
				view.setUint8(offset, 0xd3);
				setInt64(view, offset + 1, value);
				return 9;
			}
			throw new Error("Number too small -0x" + (-value).toString(16).substr(1));
		}

		// undefined - use d4 (NON-STANDARD)
		if (type === "undefined") {
			if(sparse) return 0;
			view.setUint8(offset, 0xd4);
			view.setUint8(offset + 1, 0x00);
			view.setUint8(offset + 2, 0x00);
			return 3;
		}

		// null
		if (value === null) {
			if(sparse) return 0;
			view.setUint8(offset, 0xc0);
			return 1;
		}

		// Boolean
		if (type === "boolean") {
			view.setUint8(offset, value ? 0xc3 : 0xc2);
			return 1;
		}

		if('function' === typeof value.toJSON)
			return encode(value.toJSON(), view, offset, sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			var isArray = Array.isArray(value);

			if (isArray) {
				length = value.length;
			} else {
				var keys = encodeableKeys(value, sparse);
				length = keys.length;
			}

			var size;
			if (length < 0x10) {
				view.setUint8(offset, length | ( isArray ? 0x90 : 0x80));
				size = 1;
			} else if (length < 0x10000) {
				view.setUint8(offset, isArray ? 0xdc : 0xde);
				view.setUint16(offset + 1, length);
				size = 3;
			} else if (length < 0x100000000) {
				view.setUint8(offset, isArray ? 0xdd : 0xdf);
				view.setUint32(offset + 1, length);
				size = 5;
			}

			if (isArray) {
				for (var i = 0; i < length; i++) {
					size += encode(value[i], view, offset + size, sparse);
				}
			} else {
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += encode(key, view, offset + size);
					size += encode(value[key], view, offset + size, sparse);
				}
			}

			return size;
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	function sizeof(value, sparse) {
		var type = typeof value;

		// fixstr or str8 or str16 or str32
		if (type === "string") {
			var length = utf8ByteCount(value);
			if (length < 0x20) {
				return 1 + length;
			}
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if(ArrayBuffer.isView && ArrayBuffer.isView(value)) {
			// extract the arraybuffer and fallthrough
			value = value.buffer;
		}

		// bin8 or bin16 or bin32
		if (value instanceof ArrayBuffer) {
			var length = value.byteLength;
			if (length < 0x100) {
				return 2 + length;
			}
			if (length < 0x10000) {
				return 3 + length;
			}
			if (length < 0x100000000) {
				return 5 + length;
			}
		}

		if (type === "number") {
			// Floating Point (32 bits)
			// double
			if (Math.floor(value) !== value)
				return 9;

			// Integers
			if (value >= 0) {
				// positive fixint
				if (value < 0x80)
					return 1;
				// uint 8
				if (value < 0x100)
					return 2;
				// uint 16
				if (value < 0x10000)
					return 3;
				// uint 32
				if (value < 0x100000000)
					return 5;
				// uint 64
				if (value < 0x10000000000000000)
					return 9;
				// Too big
				throw new Error("Number too big 0x" + value.toString(16));
			}
			// negative fixint
			if (value >= -0x20)
				return 1;
			// int 8
			if (value >= -0x80)
				return 2;
			// int 16
			if (value >= -0x8000)
				return 3;
			// int 32
			if (value >= -0x80000000)
				return 5;
			// int 64
			if (value >= -0x8000000000000000)
				return 9;
			// Too small
			throw new Error("Number too small -0x" + value.toString(16).substr(1));
		}

		// Boolean
		if (type === "boolean") return 1;

		// undefined, null
		if (value === null) return sparse ? 0 : 1;
		if (value === undefined) return sparse ? 0 : 3;

		if('function' === typeof value.toJSON)
			return sizeof(value.toJSON(), sparse);

		// Container Types
		if (type === "object") {
			var length, size = 0;
			if (Array.isArray(value)) {
				length = value.length;
				for (var i = 0; i < length; i++) {
					size += sizeof(value[i], sparse);
				}
			} else {
				var keys = encodeableKeys(value, sparse)
				length = keys.length;
				for (var i = 0; i < length; i++) {
					var key = keys[i];
					size += sizeof(key) + sizeof(value[key], sparse);
				}
			}
			if (length < 0x10) {
				return 1 + size;
			}
			if (length < 0x10000) {
				return 3 + size;
			}
			if (length < 0x100000000) {
				return 5 + size;
			}
			throw new Error("Array or object too long 0x" + length.toString(16));
		}
		if(type === "function")
			return 0;

		throw new Error("Unknown type " + type);
	}

	return exports;
})();

/* harmony default export */ __webpack_exports__["a"] = (msgpack);


/***/ }),
/* 25 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_231954__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_231954__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_231954__(1);
/* harmony import */ var _protocol__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_231954__(34);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_231954__(4);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_231954__(3);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_231954__(7);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_231954__(26);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_231954__(0);
/* harmony import */ var _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_231954__(21);
/* harmony import */ var _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__ = __nested_webpack_require_231954__(13);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__ = __nested_webpack_require_231954__(2);
/* harmony import */ var _client_auth__WEBPACK_IMPORTED_MODULE_11__ = __nested_webpack_require_231954__(14);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_12__ = __nested_webpack_require_231954__(6);
/* harmony import */ var _types_message__WEBPACK_IMPORTED_MODULE_13__ = __nested_webpack_require_231954__(9);
/* harmony import */ var _util_multicaster__WEBPACK_IMPORTED_MODULE_14__ = __nested_webpack_require_231954__(22);
/* harmony import */ var _util_errorreporter__WEBPACK_IMPORTED_MODULE_15__ = __nested_webpack_require_231954__(23);
/* harmony import */ var platform_webstorage__WEBPACK_IMPORTED_MODULE_16__ = __nested_webpack_require_231954__(16);
/* harmony import */ var platform_transports__WEBPACK_IMPORTED_MODULE_17__ = __nested_webpack_require_231954__(41);
/* harmony import */ var _websockettransport__WEBPACK_IMPORTED_MODULE_18__ = __nested_webpack_require_231954__(40);




















var ConnectionManager = (function() {
	var haveWebStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get);
	var haveSessionStorage = !!(typeof(platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"]) !== 'undefined' && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession);
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;
	var PendingMessage = _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].PendingMessage;
	var noop = function() {};
	var transportPreferenceOrder = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].transportPreferenceOrder;
	var optimalTransport = transportPreferenceOrder[transportPreferenceOrder.length - 1];
	var transportPreferenceName = 'ably-transport-preference';

	var sessionRecoveryName = 'ably-connection-recovery';
	function getSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].getSession(sessionRecoveryName);
	}
	function setSessionRecoverData(value) {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].setSession(sessionRecoveryName, value);
	}
	function clearSessionRecoverData() {
		return haveSessionStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].removeSession(sessionRecoveryName);
	}

	function betterTransportThan(a, b) {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, a.shortName) >
		   _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(transportPreferenceOrder, b.shortName);
	}

	function TransportParams(options, host, mode, connectionKey) {
		this.options = options;
		this.host = host;
		this.mode = mode;
		this.connectionKey = connectionKey;
		this.format = options.useBinaryProtocol ? 'msgpack' : 'json';

		this.connectionSerial = undefined;
		this.timeSerial = undefined;
	}

	TransportParams.prototype.getConnectParams = function(authParams) {
		var params = authParams ? _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].copy(authParams) : {};
		var options = this.options;
		switch(this.mode) {
			case 'upgrade':
				params.upgrade = this.connectionKey;
				break;
			case 'resume':
				params.resume = this.connectionKey;
				if(this.timeSerial !== undefined) {
					params.timeSerial = this.timeSerial;
				} else if(this.connectionSerial !== undefined) {
					params.connectionSerial = this.connectionSerial;
				}
				break;
			case 'recover':
				var match = options.recover.split(':');
				if(match) {
					params.recover = match[0];
					var recoverSerial = match[1];
					if(isNaN(recoverSerial)) {
						params.timeSerial = recoverSerial;
					} else {
						params.connectionSerial = recoverSerial;
					}
				}
				break;
			default:
		}
		if(options.clientId !== undefined) {
			params.clientId = options.clientId;
		}
		if(options.echoMessages === false) {
			params.echo = 'false';
		}
		if(this.format !== undefined) {
			params.format = this.format;
		}
		if(this.stream !== undefined) {
			params.stream = this.stream;
		}
		if(this.heartbeats !== undefined) {
			params.heartbeats = this.heartbeats;
		}
		params.v = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].apiVersion;
		params.agent = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].agent;
		if(options.transportParams !== undefined) {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].mixin(params, options.transportParams);
		}
		return params;
	};

	TransportParams.prototype.toString = function() {
		var result = '[mode=' + this.mode;
		if(this.host) { result += (',host=' + this.host); }
		if(this.connectionKey) { result += (',connectionKey=' + this.connectionKey); }
		if(this.connectionSerial !== undefined) { result += (',connectionSerial=' + this.connectionSerial); }
		if(this.timeSerial) { result += (',timeSerial=' + this.timeSerial); }
		if(this.format) { result += (',format=' + this.format); }
		result += ']';

		return result;
	};

	/* public constructor */
	function ConnectionManager(realtime, options) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].call(this);
		this.realtime = realtime;
		this.options = options;
		var timeouts = options.timeouts;
		var self = this;
		/* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the
		 * preference transport, then realtimeRequestTimeout (~10s) to establish
		 * the base transport in case that fails */
		var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;
		this.states = {
			initialized:   {state: 'initialized',   terminal: false, queueEvents: true,  sendEvents: false, failState: 'disconnected'},
			connecting:    {state: 'connecting',    terminal: false, queueEvents: true,  sendEvents: false, retryDelay: connectingTimeout, failState: 'disconnected'},
			connected:     {state: 'connected',     terminal: false, queueEvents: false, sendEvents: true,  failState: 'disconnected'},
			synchronizing: {state: 'connected',     terminal: false, queueEvents: true,  sendEvents: false, forceQueueEvents: true, failState: 'disconnected'},
			disconnected:  {state: 'disconnected',  terminal: false, queueEvents: true,  sendEvents: false, retryDelay: timeouts.disconnectedRetryTimeout, failState: 'disconnected'},
			suspended:     {state: 'suspended',     terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.suspendedRetryTimeout, failState: 'suspended'},
			closing:       {state: 'closing',       terminal: false, queueEvents: false, sendEvents: false, retryDelay: timeouts.realtimeRequestTimeout, failState: 'closed'},
			closed:        {state: 'closed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'closed'},
			failed:        {state: 'failed',        terminal: true,  queueEvents: false, sendEvents: false, failState: 'failed'}
		};
		this.state = this.states.initialized;
		this.errorReason = null;

		this.queuedMessages = new _messagequeue__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]();
		this.msgSerial = 0;
		this.connectionDetails = undefined;
		this.connectionId = undefined;
		this.connectionKey = undefined;
		this.timeSerial = undefined;
		this.connectionSerial = undefined;
		this.connectionStateTtl = timeouts.connectionStateTtl;
		this.maxIdleInterval = null;

		this.transports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect((options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports), ConnectionManager.supportedTransports);
		/* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list
		* that's both requested and supported. Normally this will be xhr_polling;
		* if xhr isn't supported it will be jsonp. If the user has forced a
		* transport, it'll just be that one. */
		this.baseTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].baseTransportOrder, this.transports)[0];
		this.upgradeTransports = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].intersect(this.transports, _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports);
		this.transportPreference = null;

		this.httpHosts = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHosts(options);
		this.activeProtocol = null;
		this.proposedTransports = [];
		this.pendingTransports = [];
		this.host = null;
		this.lastAutoReconnectAttempt = null;
		this.lastActivity = null;
		this.mostRecentMsg = null;
		this.forceFallbackHost = false;
		this.connectCounter = 0;

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'Realtime.ConnectionManager()', 'started');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].defaultTransports) + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + this.transports + ']');
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + this.httpHosts + ']');

		if(!this.transports.length) {
			var msg = 'no requested transports available';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'realtime.ConnectionManager()', msg);
			throw new Error(msg);
		}

		var addEventListener = platform__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].addEventListener;
		if(addEventListener) {
			/* intercept close event in browser to persist connection id if requested */
			if(haveSessionStorage && typeof options.recover === 'function') {
				/* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */
				addEventListener('beforeunload', this.persistConnection.bind(this));
			}

			if(options.closeOnUnload === true) {
				addEventListener('beforeunload', function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');
					self.requestState({state: 'closing'});
				});
			}

			/* Listen for online and offline events */
			addEventListener('online', function() {
				if(self.state == self.states.disconnected || self.state == self.states.suspended) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser online event', 'reattempting connection');
					self.requestState({state: 'connecting'});
				}
			});
			addEventListener('offline', function() {
				if(self.state == self.states.connected) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager caught browser offline event', 'disconnecting active transport');
					// Not sufficient to just go to the 'disconnected' state, want to
					// force all transports to reattempt the connection. Will immediately
					// retry.
					self.disconnectAllTransports();
				}
			});
		}
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(ConnectionManager, _util_eventemitter__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]);

	/*********************
	 * transport management
	 *********************/

	ConnectionManager.supportedTransports = {};

	Object(_websockettransport__WEBPACK_IMPORTED_MODULE_18__[/* default */ "a"])(ConnectionManager);
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(platform_transports__WEBPACK_IMPORTED_MODULE_17__[/* default */ "a"], function (initFn) {
		initFn(ConnectionManager);
	});

	ConnectionManager.prototype.createTransportParams = function(host, mode) {
		var params = new TransportParams(this.options, host, mode, this.connectionKey);
		if(this.timeSerial) {
			params.timeSerial = this.timeSerial;
		} else if(this.connectionSerial !== undefined) {
			params.connectionSerial = this.connectionSerial;
		}
		return params;
	};

	ConnectionManager.prototype.getTransportParams = function(callback) {
		var self = this;

		function decideMode(modeCb) {
			if(self.connectionKey) {
				modeCb('resume');
				return;
			}

			if(typeof self.options.recover === 'string') {
				modeCb('recover');
				return;
			}

			var recoverFn = self.options.recover,
				lastSessionData = getSessionRecoverData();
			if(lastSessionData && typeof(recoverFn) === 'function') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');
				recoverFn(lastSessionData, function(shouldRecover) {
					if(shouldRecover) {
						self.options.recover = lastSessionData.recoveryKey;
						modeCb('recover');
					} else {
						modeCb('clean');
					}
				});
				return;
			}
			modeCb('clean');
		}

		decideMode(function(mode) {
			var transportParams = self.createTransportParams(null, mode);
			if(mode === 'recover') {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + self.options.recover);
				var match = self.options.recover.split(':');
				if(match && match[2]) {
					self.msgSerial = match[2];
				}
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());
			}
			callback(transportParams);
		});
	};

	/**
	 * Attempt to connect using a given transport
	 * @param transportParams
	 * @param candidate, the transport to try
	 * @param callback
	 */
	ConnectionManager.prototype.tryATransport = function(transportParams, candidate, callback) {
		var self = this, host = transportParams.host;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);
		(ConnectionManager.supportedTransports[candidate]).tryConnect(this, this.realtime.auth, transportParams, function(wrappedErr, transport) {
			var state = self.state;
			if(state == self.states.closing || state == self.states.closed || state == self.states.failed) {
				if(transport) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);
					transport.close();
				}
				callback(true);
				return;
			}

			if(wrappedErr) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());

				/* Comet transport onconnect token errors can be dealt with here.
				* Websocket ones only happen after the transport claims to be viable,
				* so are dealt with as non-onconnect token errors */
				if(_client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(wrappedErr.error) && !(self.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(self.errorReason))) {
					self.errorReason = wrappedErr.error;
					/* re-get a token and try again */
					self.realtime.auth._forceNewToken(null, null, function(err) {
						if(err) {
							self.actOnErrorFromAuthorize(err);
							return;
						}
						self.tryATransport(transportParams, candidate, callback);
					});
				} else if(wrappedErr.event === 'failed') {
					/* Error that's fatal to the connection */
					self.notifyState({state: 'failed', error: wrappedErr.error});
					callback(true);
				} else if(wrappedErr.event === 'disconnected') {
					if(!_transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"].isRetriable(wrappedErr.error)) {
						/* Error received from the server that does not call for trying a fallback host, eg a rate limit */
						self.notifyState({state: self.states.connecting.failState, error: wrappedErr.error});
						callback(true);
					} else {
						/* Error with that transport only; continue trying other fallback hosts */
						callback(false);
					}
				}
				return;
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');
			self.setTransportPending(transport, transportParams);
			callback(null, transport);
		});
	};


	/**
	 * Called when a transport is indicated to be viable, and the connectionmanager
	 * expects to activate this transport as soon as it is connected.
	 * @param host
	 * @param transportParams
	 */
	ConnectionManager.prototype.setTransportPending = function(transport, transportParams) {
		var mode = transportParams.mode;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport);
		this.pendingTransports.push(transport);

		var self = this;
		transport.once('connected', function(error, connectionId, connectionDetails, connectionPosition) {
			if(mode == 'upgrade' && self.activeProtocol) {
				/*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */
				if(transport.shortName !== optimalTransport && _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(self.getUpgradePossibilities(), optimalTransport)) {
					setTimeout(function() {
						self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
					}, self.options.timeouts.parallelUpgradeDelay);
				} else {
					self.scheduleTransportActivation(error, transport, connectionId, connectionDetails, connectionPosition);
				}
			} else {
				self.activateTransport(error, transport, connectionId, connectionDetails, connectionPosition);

				/* allow connectImpl to start the upgrade process if needed, but allow
				 * other event handlers, including activating the transport, to run first */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.connectImpl(transportParams);
				});
			}

			if(mode === 'recover' && self.options.recover) {
				/* After a successful recovery, we unpersist, as a recovery key cannot
				* be used more than once */
				self.options.recover = null;
				self.unpersistConnection();
			}
		});

		transport.on(['disconnected', 'closed', 'failed'], function(error) {
			self.deactivateTransport(transport, this.event, error);
		});

		this.emit('transport.pending', transport);
	};

	/**
	 * Called when an upgrade transport is connected,
	 * to schedule the activation of that transport.
	 * @param error
	 * @param transport
	 * @param connectionId
	 * @param connectionDetails
	 * @param connectedMessage
	 */
	ConnectionManager.prototype.scheduleTransportActivation = function(error, transport, connectionId, connectionDetails, upgradeConnectionPosition) {
		var self = this,
			currentTransport = this.activeProtocol && this.activeProtocol.getTransport(),
			abandon = function() {
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			};

		if(this.state !== this.states.connected && this.state !== this.states.connecting) {
			/* This is most likely to happen for the delayed xhrs, when xhrs and ws are scheduled in parallel*/
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + this.state.state + (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
			abandon();
			return;
		}

		if(currentTransport && !betterTransportThan(transport, currentTransport)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + ' is no better than current active transport ' + currentTransport.shortName + ' - abandoning upgrade');
			abandon();
			return;
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);

		this.realtime.channels.onceNopending(function(err) {
			var oldProtocol;
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unable to activate transport; transport = ' + transport + '; err = ' + err);
				return;
			}

			if(!transport.isConnected) {
				/* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');
				abandon();
				return;
			}

			if(self.state === self.states.connected) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');
				self.state = self.states.synchronizing;
				oldProtocol = self.activeProtocol;
			} else if(self.state !== self.states.connecting) {
				/* Note: upgrading from the connecting state is valid if the old active
				* transport was deactivated after the upgrade transport first connected;
				* see logic in deactivateTransport */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' + self.state.state + (self.state === self.states.synchronizing ? ', but with an upgrade already in progress' : '') + ') is not valid to upgrade in; abandoning upgrade to ' + transport.shortName);
				abandon();
				return;
			}

			/* If the connectionId has changed, the upgrade hasn't worked. But as
			* it's still an upgrade, realtime still expects a sync - it just needs to
			* be a sync with the new connection position. (And it
			* needs to be set in the library, which is done by activateTransport). */
			var connectionReset = connectionId !== self.connectionId,
				syncPosition = connectionReset ? upgradeConnectionPosition : self;

			if(connectionReset) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Upgrade resulted in new connectionId; resetting library connection position from ' + (self.timeSerial || self.connectionSerial) + ' to ' + (syncPosition.timeSerial || syncPosition.connectionSerial) + '; upgrade error was ' + error);
			}

			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);
			self.sync(transport, syncPosition, function(syncErr, connectionId, postSyncPosition) {
				/* If there's been some problem with syncing (and the connection hasn't
				 * closed or something in the meantime), we have a problem -- we can't
				 * just fall back on the old transport, as we don't know whether
				 * realtime got the sync -- if it did, the old transport is no longer
				 * valid. To be safe, we disconnect both and start again from scratch. */
				if(syncErr) {
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.scheduleTransportActivation()', 'Unexpected error attempting to sync transport; transport = ' + transport + '; err = ' + syncErr);
						self.disconnectAllTransports();
					}
					return;
				}
				var finishUpgrade = function() {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);
					self.activateTransport(error, transport, connectionId, connectionDetails, postSyncPosition);
					/* Restore pre-sync state. If state has changed in the meantime,
					 * don't touch it -- since the websocket transport waits a tick before
					 * disposing itself, it's possible for it to have happily synced
					 * without err while, unknown to it, the connection has closed in the
					 * meantime and the ws transport is scheduled for death */
					if(self.state === self.states.synchronizing) {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);
						self.state = self.states.connected;
					} else {
						_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + self.state.state + ', so leaving unchanged');
					}
					if(self.state.sendEvents) {
						self.sendQueuedMessages();
					}
				};

				/* Wait until sync is done and old transport is idle before activating new transport. This
				 * guarantees that messages arrive at realtime in the same order they are sent.
				 *
				 * If a message times out on the old transport, since it's still the active transport the
				 * message will be requeued. deactivateTransport will see the pending transport and notify
				 * the `connecting` state without starting a new connection, so the new transport can take
				 * over once deactivateTransport clears the old protocol's queue.
				 *
				 * If there is no old protocol, that meant that we weren't in the connected state at the
				 * beginning of the sync - likely the base transport died just before the sync. So can just
				 * finish the upgrade. If we're actually in closing/failed rather than connecting, that's
				 * fine, activatetransport will deal with that. */
				if(oldProtocol) {
				 /* Most of the time this will be already true: the new-transport sync will have given
				 * enough time for in-flight messages on the old transport to complete. */
					oldProtocol.onceIdle(finishUpgrade);
				} else {
					finishUpgrade();
				}
			});
		});
	};

	/**
	 * Called when a transport is connected, and the connectionmanager decides that
	 * it will now be the active transport. Returns whether or not it activated
	 * the transport (if the connection is closing/closed it will choose not to).
	 * @param transport the transport instance
	 * @param connectionId the id of the new active connection
	 * @param connectionDetails the details of the new active connection
	 * @param connectionPosition the position at the point activation; either {connectionSerial: <serial>} or {timeSerial: <serial>}
	 */
	ConnectionManager.prototype.activateTransport = function(error, transport, connectionId, connectionDetails, connectionPosition) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);
		if(error) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);
		}
		if(connectionId) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);
		}
		if(connectionDetails) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));
		}
		if(connectionPosition) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.activateTransport()', 'serial =  ' + (connectionPosition.timeSerial || connectionPosition.connectionSerial));
		}

		this.persistTransportPreference(transport);

		/* if the connectionmanager moved to the closing/closed state before this
		 * connection event, then we won't activate this transport */
		var existingState = this.state,
			connectedState = this.states.connected.state;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);
		if(existingState.state == this.states.closing.state || existingState.state == this.states.closed.state || existingState.state == this.states.failed.state) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');
			transport.disconnect();
			return false;
		}

		/* remove this transport from pending transports */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);

		/* if the transport is not connected (eg because it failed during a
		 * scheduleTransportActivation#onceNoPending wait) then don't activate it */
		if(!transport.isConnected) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');
			return false;
		}

		/* the given transport is connected; this will immediately
		 * take over as the active transport */
		var existingActiveProtocol = this.activeProtocol;
		this.activeProtocol = new _protocol__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"](transport);
		this.host = transport.params.host;

		var connectionKey = connectionDetails.connectionKey;
		if(connectionKey && this.connectionKey != connectionKey)  {
			this.setConnection(connectionId, connectionDetails, connectionPosition, !!error);
		}

		/* Rebroadcast any new connectionDetails from the active transport, which
		 * can come at any time (eg following a reauth), and emit an RTN24 UPDATE
		 * event. (Listener added on nextTick because we're in a transport.on('connected')
		 * callback at the moment; if we add it now we'll be adding it to the end
		 * of the listeners array and it'll be called immediately) */
		this.onConnectionDetailsUpdate(connectionDetails, transport);
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			transport.on('connected', function(connectedErr, _connectionId, connectionDetails) {
				self.onConnectionDetailsUpdate(connectionDetails, transport);
				self.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, connectedErr));
			});
		})

		/* If previously not connected, notify the state change (including any
		 * error). */
		if(existingState.state === this.states.connected.state) {
			if(error) {
				/* if upgrading without error, leave any existing errorReason alone */
				this.errorReason = this.realtime.connection.errorReason = error;
				/* Only bother emitting an upgrade if there's an error; otherwise it's
				 * just a transport upgrade, so auth details won't have changed */
				this.emit('update', new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](connectedState, connectedState, null, error));
			}
		} else {
			this.notifyState({state: 'connected', error: error});
			this.errorReason = this.realtime.connection.errorReason = error || null;
		}

		/* Send after the connection state update, as Channels hooks into this to
		 * resend attaches on a new transport if necessary */
		this.emit('transport.active', transport);

		/* Gracefully terminate existing protocol */
		if(existingActiveProtocol) {
			if(existingActiveProtocol.messageQueue.count() > 0) {
				/* We could just requeue pending messages on the new transport, but
				 * actually this should never happen: transports should only take over
				 * from other active transports when upgrading, and upgrading waits for
				 * the old transport to be idle. So log an error. */
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' + existingActiveProtocol.transport.shortName + ', new one is ' + transport.shortName + ') finishing with ' + existingActiveProtocol.messageQueue.count() + ' messages still pending');
			}
			if(existingActiveProtocol.transport === transport) {
				var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-previously-active');
			} else {
				existingActiveProtocol.finish();
			}
		}

		/* Terminate any other pending transport(s), and
		 * abort any not-yet-pending transport attempts */
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(pendingTransport) {
			if(pendingTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-pending');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.pendingTransports, transport);
			} else {
				pendingTransport.disconnect();
			}
		});
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(proposedTransport) {
			if(proposedTransport === transport) {
				var msg = 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' + transport.shortName + '; stack = ' + new Error().stack;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.activateTransport()', msg);
				_util_errorreporter__WEBPACK_IMPORTED_MODULE_15__[/* default */ "a"].report('error', msg, 'transport-activating-proposed');
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(self.proposedTransports, transport);
			} else {
				proposedTransport.dispose();
			}
		});

		return true;
	};

	/**
	 * Called when a transport is no longer the active transport. This can occur
	 * in any transport connection state.
	 * @param transport
	 */
	ConnectionManager.prototype.deactivateTransport = function(transport, state, error) {
		var currentProtocol = this.activeProtocol,
			wasActive = currentProtocol && currentProtocol.getTransport() === transport,
			wasPending = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport),
			wasProposed = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.proposedTransports, transport),
			noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' + state + (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') + (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));
		if(error && error.message)
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);

		if(wasActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' + this.activeProtocol.messageQueue.count() + ' pending messages');
			this.queuePendingMessages(currentProtocol.getPendingMessages());
			/* Clear any messages we requeue to allow the protocol to become idle.
			 * In case of an upgrade, this will trigger an immediate activation of
			 * the upgrade transport, so delay a tick so this transport can finish
			 * deactivating */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				currentProtocol.clearPendingMessages();
			});
			this.activeProtocol = this.host = null;
			clearTimeout(this.channelResumeCheckTimer);
		}

		this.emit('transport.inactive', transport);

		/* this transport state change is a state change for the connectionmanager if
		 * - the transport was the active transport and there are no transports
		 *   which are connected and scheduled for activation, just waiting for the
		 *   active transport to finish what its doing; or
		 * - the transport was the active transport and the error was fatal (so
		 *   unhealable by another transport); or
		 * - there is no active transport, and this is the last remaining
		 *   pending transport (so we were in the connecting state)
		 */
		if((wasActive && noTransportsScheduledForActivation) ||
			(wasActive && (state === 'failed') || (state === 'closed')) ||
			(currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {

			/* If we're disconnected with a 5xx we need to try fallback hosts
			 * (RTN14d), but (a) due to how the upgrade sequence works, the
			 * host/transport selection sequence only cares about getting to
			 * `preconnect` (eg establishing a websocket) getting a `disconnected`
			 * protocol message afterwards is too late; and (b) host retry only
			 * applies to connectBase unless the stored preference transport doesn't
			 * work. We solve this by unpersisting the transport preference and
			 * setting an instance variable to force fallback hosts to be used (if
			 * any) here. Bit of a kludge, but no real better alternatives without
			 * rewriting the entire thing */
			if(state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {
				this.unpersistTransportPreference();
				this.forceFallbackHost = true;
				/* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */
				this.notifyState({state: state, error: error, retryImmediately: true});
				return;
			}

			/* TODO remove below line once realtime sends token errors as DISCONNECTEDs */
			var newConnectionState = (state === 'failed' && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(error)) ? 'disconnected' : state;
			this.notifyState({state: newConnectionState, error: error});
			return;
		}

		if(wasActive && (state === 'disconnected') && (this.state !== this.states.synchronizing)) {
			/* If we were active but there is another transport scheduled for
			* activation, go into to the connecting state until that transport
			* activates and sets us back to connected. (manually starting the
			* transition timers in case that never happens). (If we were in the
			* synchronizing state, then that's fine, the old transport just got its
			* disconnected before the new one got the sync -- ignore it and keep
			* waiting for the sync. If it fails we have a separate sync timer that
			* will expire). */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');
			this.startSuspendTimer();
			this.startTransitionTimer(this.states.connecting);
			this.notifyState({state: 'connecting', error: error});
		}
	};

	/* Helper that returns true if there are no transports which are pending,
	* have been connected, and are just waiting for onceNoPending to fire before
	* being activated */
	ConnectionManager.prototype.noTransportsScheduledForActivation = function() {
		return _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].isEmpty(this.pendingTransports) ||
			this.pendingTransports.every(function(transport) {
				return !transport.isConnected;
			});
	};

	/**
	 * Called when activating a new transport, to ensure message delivery
	 * on the new transport synchronises with the messages already received
	 */
	ConnectionManager.prototype.sync = function(transport, requestedSyncPosition, callback) {
		var timeout = setTimeout(function () {
			transport.off('sync');
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for sync response', 50000, 500));
		}, this.options.timeouts.realtimeRequestTimeout);

		/* send sync request */
		var syncMessage = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
			action: actions.SYNC,
			connectionKey: this.connectionKey
		});

		if(requestedSyncPosition.timeSerial) {
			syncMessage.timeSerial = requestedSyncPosition.timeSerial;
		} else if(requestedSyncPosition.connectionSerial !== undefined) {
			syncMessage.connectionSerial = requestedSyncPosition.connectionSerial;
		}
		transport.send(syncMessage);

		transport.once('sync', function(connectionId, syncPosition) {
			clearTimeout(timeout);
			callback(null, connectionId, syncPosition);
		});
	};

	ConnectionManager.prototype.setConnection = function(connectionId, connectionDetails, connectionPosition, hasConnectionError) {
		/* if connectionKey changes but connectionId stays the same, then just a
		 * transport change on the same connection. If connectionId changes, we're
		 * on a new connection, with implications for msgSerial and channel state,
		 * and resetting the connectionSerial position */
		var self = this;
		/* If no previous connectionId, don't reset the msgSerial as it may have
		 * been set by recover data (unless the recover failed) */
		var prevConnId = this.connectionid,
			connIdChanged = prevConnId && (prevConnId !== connectionId),
			recoverFailure = !prevConnId && hasConnectionError;
		if(connIdChanged || recoverFailure)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');
			this.msgSerial = 0;
		}
		/* but do need to reattach channels, for channels that were previously in
		 * the attached state even though the connection mode was 'clean' due to a
		 * freshness check - see https://github.com/ably/ably-js/issues/394 */
		if(this.connectionId !== connectionId)  {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');
			/* Wait till next tick before reattaching channels, so that connection
			 * state will be updated and so that it will be applied after
			 * Channels#onTransportUpdate, else channels will not have an ATTACHED
			 * sent twice (once from this and once from that). */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				self.realtime.channels.reattach();
			});
		} else if(this.options.checkChannelsOnResume) {
			/* For attached channels, set the attached msg indicator variable to false,
			 * wait 30s, and check we got an attached for each one.
			 * 30s was chosen to be 5s longer than the transport idle timeout expire
			 * time, in an attempt to avoid false positives due to a transport
			 * silently failing immediately after a resume */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.setConnection()', 'Same connectionId; checkChannelsOnResume is enabled');
			clearTimeout(this.channelResumeCheckTimer);
			this.realtime.channels.resetAttachedMsgIndicators();
			this.channelResumeCheckTimer = setTimeout(function() {
				self.realtime.channels.checkAttachedMsgIndicators(connectionId);
			}, 30000);
		}
		this.realtime.connection.id = this.connectionId = connectionId;
		this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;
		var forceResetMessageSerial = connIdChanged || !prevConnId;
		this.setConnectionSerial(connectionPosition, forceResetMessageSerial);
	};

	ConnectionManager.prototype.clearConnection = function() {
		this.realtime.connection.id = this.connectionId = undefined;
		this.realtime.connection.key = this.connectionKey = undefined;
		this.clearConnectionSerial();
		this.msgSerial = 0;
		this.unpersistConnection();
	};

	/* force: set the connectionSerial even if it's less than the current
	 * connectionSerial. Used for new connections.
	 * Returns true iff the message was rejected as a duplicate. */
	ConnectionManager.prototype.setConnectionSerial = function(connectionPosition, force) {
		var timeSerial = connectionPosition.timeSerial,
			connectionSerial = connectionPosition.connectionSerial;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.setConnectionSerial()', 'Updating connection serial; serial = ' + connectionSerial + '; timeSerial = ' + timeSerial + '; force = ' + force + '; previous = ' + this.connectionSerial);
		if(timeSerial !== undefined) {
			if(timeSerial <= this.timeSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with timeSerial ' + timeSerial + ', but current timeSerial is ' + this.timeSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.timeSerial = this.timeSerial = timeSerial;
			this.setRecoveryKey();
			return;
		}
		if(connectionSerial !== undefined) {
			if(connectionSerial <= this.connectionSerial && !force) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.setConnectionSerial()', 'received message with connectionSerial ' + connectionSerial + ', but current connectionSerial is ' + this.connectionSerial + '; assuming message is a duplicate and discarding it');
				return true;
			}
			this.realtime.connection.serial = this.connectionSerial = connectionSerial;
			this.setRecoveryKey();
		}
	};

	ConnectionManager.prototype.clearConnectionSerial = function() {
		this.realtime.connection.serial = this.connectionSerial = undefined;
		this.realtime.connection.timeSerial = this.timeSerial = undefined;
		this.clearRecoveryKey();
	};

	ConnectionManager.prototype.setRecoveryKey = function() {
		this.realtime.connection.recoveryKey = this.connectionKey + ':' + (this.timeSerial || this.connectionSerial) + ':' + this.msgSerial;
	};

	ConnectionManager.prototype.clearRecoveryKey = function() {
		this.realtime.connection.recoveryKey = null;
	};

	ConnectionManager.prototype.checkConnectionStateFreshness = function() {
		if(!this.lastActivity || !this.connectionId) { return; }

		var sinceLast = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastActivity;
		if(sinceLast > this.connectionStateTtl + this.maxIdleInterval) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');
			this.clearConnection();
			this.states.connecting.failState = 'suspended';
			this.states.connecting.queueEvents = false;
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.persistConnection = function() {
		if(haveSessionStorage) {
			var recoveryKey = this.realtime.connection.recoveryKey;
			if(recoveryKey) {
				setSessionRecoverData({
					recoveryKey: recoveryKey,
					disconnectedAt: _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
					location: global.location,
					clientId: this.realtime.auth.clientId
				}, this.connectionStateTtl);
			}
		}
	};

	/**
	 * Called when the connectionmanager wants to persist transport
	 * state for later recovery. Only applicable in the browser context.
	 */
	ConnectionManager.prototype.unpersistConnection = function() {
		clearSessionRecoverData();
	};

	/*********************
	 * state management
	 *********************/

	ConnectionManager.prototype.getError = function() {
		return this.errorReason || this.getStateError();
	};

	ConnectionManager.prototype.getStateError = function() {
		return _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][this.state.state];
	};

	ConnectionManager.prototype.activeState = function() {
		return this.state.queueEvents || this.state.sendEvents;
	};

	ConnectionManager.prototype.enactStateChange = function(stateChange) {
		var logLevel = stateChange.current === 'failed' ? _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR : _util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MAJOR;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? ('; reason: ' + stateChange.reason) : ''));
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' + stateChange.current + '; reason = ' + (stateChange.reason && stateChange.reason.message));
		var newState = this.state = this.states[stateChange.current];
		if(stateChange.reason) {
			this.errorReason = stateChange.reason;
			this.realtime.connection.errorReason = stateChange.reason;
		}
		if(newState.terminal || newState.state === 'suspended') {
			/* suspended is nonterminal, but once in the suspended state, realtime
			 * will have discarded our connection state, so futher connection
			 * attempts should start from scratch */
			this.clearConnection();
		}
		this.emit('connectionstate', stateChange);
	};

	/****************************************
	 * ConnectionManager connection lifecycle
	 ****************************************/

	ConnectionManager.prototype.startTransitionTimer = function(transitionState) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);

		if(this.transitionTimer) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');
			clearTimeout(this.transitionTimer);
		}

		var self = this;
		this.transitionTimer = setTimeout(function() {
			if(self.transitionTimer) {
				self.transitionTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);
				self.notifyState({state: transitionState.failState});
			}
		}, transitionState.retryDelay);
	};

	ConnectionManager.prototype.cancelTransitionTimer = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');
		if(this.transitionTimer) {
			clearTimeout(this.transitionTimer);
			this.transitionTimer = null;
		}
	};

	ConnectionManager.prototype.startSuspendTimer = function() {
		var self = this;
		if(this.suspendTimer)
			return;
		this.suspendTimer = setTimeout(function() {
			if(self.suspendTimer) {
				self.suspendTimer = null;
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');
				self.states.connecting.failState = 'suspended';
				self.states.connecting.queueEvents = false;
				self.notifyState({state: 'suspended'});
			}
		}, this.connectionStateTtl);
	};

	ConnectionManager.prototype.checkSuspendTimer = function(state) {
		if(state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')
			this.cancelSuspendTimer();
	};

	ConnectionManager.prototype.cancelSuspendTimer = function() {
		this.states.connecting.failState = 'disconnected';
		this.states.connecting.queueEvents = true;
		if(this.suspendTimer) {
			clearTimeout(this.suspendTimer);
			this.suspendTimer = null;
		}
	};

	ConnectionManager.prototype.startRetryTimer = function(interval) {
		var self = this;
		this.retryTimer = setTimeout(function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');
			self.retryTimer = null;
			self.requestState({state: 'connecting'});
		}, interval);
	};

	ConnectionManager.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.retryTimer = null;
		}
	};

	ConnectionManager.prototype.notifyState = function(indicated) {
		var state = indicated.state,
			self = this;

		/* We retry immediately if:
		 * - something disconnects us while we're connected, or
		 * - a viable (but not yet active) transport fails due to a token error (so
		 *   this.errorReason will be set, and startConnect will do a forced
		 *   authorize). If this.errorReason is already set (to a token error),
		 *   then there has been at least one previous attempt to connect that also
		 *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait
		 *   before trying again */
		var retryImmediately = (state === 'disconnected' &&
			(this.state === this.states.connected     ||
			 this.state === this.states.synchronizing ||
			 indicated.retryImmediately               ||
				(this.state === this.states.connecting &&
					indicated.error && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(indicated.error) &&
					!(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)))));

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));
		/* do nothing if we're already in the indicated state */
		if(state == this.state.state)
			return;

		/* kill timers (possibly excepting suspend timer depending on the notified
		* state), as these are superseded by this notification */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		this.checkSuspendTimer(indicated.state);

		/* do nothing if we're unable to move from the current state */
		if(this.state.terminal)
			return;

		/* process new state */
		var newState = this.states[indicated.state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, newState.retryDelay, (indicated.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		if(retryImmediately) {
			var autoReconnect = function() {
				if(self.state === self.states.disconnected) {
					self.lastAutoReconnectAttempt = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now();
					self.requestState({state: 'connecting'});
				}
			};
			var sinceLast = this.lastAutoReconnectAttempt && (_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - this.lastAutoReconnectAttempt + 1);
			if(sinceLast && (sinceLast < 1000)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' + sinceLast + 'ms ago, waiting another ' + (1000 - sinceLast) + 'ms before trying again');
				setTimeout(autoReconnect, 1000 - sinceLast);
			} else {
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(autoReconnect);
			}
		} else if(state === 'disconnected' || state === 'suspended') {
			this.startRetryTimer(newState.retryDelay);
		}

		 /* If going into disconnect/suspended (and not retrying immediately), or a
			* terminal state, ensure there are no orphaned transports hanging around. */
		if((state === 'disconnected' && !retryImmediately) ||
			 (state === 'suspended') ||
			 newState.terminal) {
				 /* Wait till the next tick so the connection state change is enacted,
				 * so aborting transports doesn't trigger redundant state changes */
				 _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					 self.disconnectAllTransports();
				 });
		 }

		if(state == 'connected' && !this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');
		}

		/* implement the change and notify */
		this.enactStateChange(change);
		if(this.state.sendEvents) {
			this.sendQueuedMessages();
		} else if(!this.state.queueEvents) {
			this.realtime.channels.propogateConnectionInterruption(state, change.reason);
			this.failQueuedMessages(change.reason); // RTN7c
		}
	};

	ConnectionManager.prototype.requestState = function(request) {
		var state = request.state, self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);
		if(state == this.state.state)
			return; /* silently do nothing */

		/* kill running timers, as this request supersedes them */
		this.cancelTransitionTimer();
		this.cancelRetryTimer();
		/* for suspend timer check rather than cancel -- eg requesting a connecting
		* state should not reset the suspend timer */
		this.checkSuspendTimer(state);

		if(state == 'connecting' && this.state.state == 'connected') return;
		if(state == 'closing' && this.state.state == 'closed') return;

		var newState = this.states[state],
			change = new _client_connectionstatechange__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"](this.state.state, newState.state, null, (request.error || _transport_connectionerror__WEBPACK_IMPORTED_MODULE_9__[/* default */ "a"][newState.state]));

		this.enactStateChange(change);

		if(state == 'connecting') {
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() { self.startConnect(); });
		}
		if(state == 'closing') {
			this.closeImpl();
		}
	};


	ConnectionManager.prototype.startConnect = function() {
		if(this.state !== this.states.connecting) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);
			return;
		}

		var auth = this.realtime.auth,
			self = this;

		/* The point of the connectCounter mechanism is to ensure that the
		 * connection procedure can be cancelled. We want disconnectAllTransports
		 * to be able to stop any in-progress connection, even before it gets to
		 * the stage of having a pending (or even a proposed) transport that it can
		 * dispose() of. So we check that it's still current after any async stage,
		 * up until the stage that is synchronous with instantiating a transport */
		var connectCount = ++this.connectCounter;

		var connect = function() {
			self.checkConnectionStateFreshness();
			self.getTransportParams(function(transportParams) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				self.connectImpl(transportParams, connectCount);
			});
		};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');
		this.startSuspendTimer();
		this.startTransitionTimer(this.states.connecting);

		if(auth.method === 'basic') {
			connect();
		} else {
			var authCb = function(err) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(err) {
					self.actOnErrorFromAuthorize(err);
				} else {
					connect();
				}
			};
			if(this.errorReason && _client_auth__WEBPACK_IMPORTED_MODULE_11__[/* default */ "a"].isTokenErr(this.errorReason)) {
				/* Force a refetch of a new token */
				auth._forceNewToken(null, null, authCb);
			} else {
				auth._ensureValidAuthCredentials(false, authCb);
			}
		}
	};

	/**
	 * There are three stages in connecting:
	 * - preference: if there is a cached transport preference, we try to connect
	 *   on that. If that fails or times out we abort the attempt, remove the
	 *   preference and fall back to base. If it succeeds, we try upgrading it if
	 *   needed (will only be in the case where the preference is xhrs and the
	 *   browser supports ws).
	 * - base: we try to connect with the best transport that we think will
	 *   never fail for this browser (usually this is xhr_polling; for very old
	 *   browsers will be jsonp, for node will be comet). If it doesn't work, we
	 *   try fallback hosts.
	 * - upgrade: given a connected transport, we see if there are any better
	 *   ones, and if so, try to upgrade to them.
	 *
	 * connectImpl works out what stage you're at (which is purely a function of
	 * the current connection state and whether there are any stored preferences),
	 * and dispatches accordingly. After a transport has been set pending,
	 * tryATransport calls connectImpl to see if there's another stage to be done.
	 * */
	ConnectionManager.prototype.connectImpl = function(transportParams, connectCount) {
		var state = this.state.state;

		if(state !== this.states.connecting.state && state !== this.states.connected.state) {
			/* Only keep trying as long as in the 'connecting' state (or 'connected'
			 * for upgrading). Any operation can put us into 'disconnected' to cancel
			 * connection attempts and wait before retrying, or 'failed' to fail. */
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);
		} else if(this.pendingTransports.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');
		} else if(state == this.states.connected.state) {
			this.upgradeIfNeeded(transportParams);
		} else if(this.transports.length > 1 && this.getTransportPreference()) {
			this.connectPreference(transportParams);
		} else {
			this.connectBase(transportParams, connectCount);
		}
	};


	ConnectionManager.prototype.connectPreference = function(transportParams) {
		var preference = this.getTransportPreference(),
			self = this,
			preferenceTimeoutExpired = false;

		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.transports, preference)) {
			this.unpersistTransportPreference();
			this.connectImpl(transportParams);
		}

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);

		var preferenceTimeout = setTimeout(function() {
			preferenceTimeoutExpired = true;
			if(!(self.state.state === self.states.connected.state)) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');
				/* Abort all connection attempts. (This also disconnects the active
				 * protocol, but none exists if we're not in the connected state) */
				self.disconnectAllTransports();
				/* Be quite agressive about clearing the stored preference if ever it doesn't work */
				self.unpersistTransportPreference();
			}
			self.connectImpl(transportParams);
		}, this.options.timeouts.preferenceConnectTimeout);

		/* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.
		 * The wstransport it will substitute the httphost for an appropriate wshost */
		transportParams.host = self.httpHosts[0];
		self.tryATransport(transportParams, preference, function(fatal, transport) {
			clearTimeout(preferenceTimeout);
			if(preferenceTimeoutExpired && transport) {
				/* Viable, but too late - connectImpl() will already be trying
				* connectBase, and we weren't in upgrade mode. Just remove the
				* onconnected listener and get rid of it */
				transport.off();
				transport.disconnect();
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrDeleteValue(this.pendingTransports, transport);
			} else if(!transport && !fatal) {
				/* Preference failed in a transport-specific way. Try more */
				self.unpersistTransportPreference();
				self.connectImpl(transportParams);
			}
			/* If suceeded, or failed fatally, nothing to do */
		});
	};


	/**
	 * Try to establish a transport on the base transport (the best transport
	 * such that if it doesn't work, nothing will work) as determined through
	 * static feature detection, checking for network connectivity and trying
	 * fallback hosts if applicable.
	 * @param transportParams
	 */
	ConnectionManager.prototype.connectBase = function(transportParams, connectCount) {
		var self = this,
			giveUp = function(err) {
				self.notifyState({state: self.states.connecting.failState, error: err});
			},
			candidateHosts = this.httpHosts.slice(),
			hostAttemptCb = function(fatal, transport) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				if(!transport && !fatal) {
					tryFallbackHosts();
				}
			};

		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);

		/* first try to establish a connection with the priority host with http transport */
		var host = candidateHosts.shift();
		if(!host) {
			giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (no available host)', 80003, 404));
			return;
		}
		transportParams.host = host;

		/* this is what we'll be doing if the attempt for the main host fails */
		function tryFallbackHosts() {
			/* if there aren't any fallback hosts, fail */
			if(!candidateHosts.length) {
				giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (and no more fallback hosts to try)', 80003, 404));
				return;
			}
			/* before trying any fallback (or any remaining fallback) we decide if
			 * there is a problem with the ably host, or there is a general connectivity
			 * problem */
			platform_http__WEBPACK_IMPORTED_MODULE_12__[/* default */ "a"].checkConnectivity(function(err, connectivity) {
				if(connectCount !== self.connectCounter) {
					return;
				}
				/* we know err won't happen but handle it here anyway */
				if(err) {
					giveUp(err);
					return;
				}
				if(!connectivity) {
					/* the internet isn't reachable, so don't try the fallback hosts */
					giveUp(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to connect (network unreachable)', 80003, 404));
					return;
				}
				/* the network is there, so there's a problem with the main host, or
				 * its dns. Try the fallback hosts. We could try them simultaneously but
				 * that would potentially cause a huge spike in load on the load balancer */
				transportParams.host = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrPopRandomElement(candidateHosts);
				self.tryATransport(transportParams, self.baseTransport, hostAttemptCb);
			});
		}

		if(this.forceFallbackHost && candidateHosts.length) {
			this.forceFallbackHost = false;
			tryFallbackHosts();
			return;
		}

		this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);
	};


	ConnectionManager.prototype.getUpgradePossibilities = function() {
		/* returns the subset of upgradeTransports to the right of the current
		 * transport in upgradeTransports (if it's in there - if not, currentPosition
		 * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */
		var current = this.activeProtocol.getTransport().shortName;
		var currentPosition = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf(this.upgradeTransports, current);
		return this.upgradeTransports.slice(currentPosition + 1);
	};


	ConnectionManager.prototype.upgradeIfNeeded = function(transportParams) {
		var upgradePossibilities = this.getUpgradePossibilities(),
			self = this;
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspect(upgradePossibilities));

		if(!upgradePossibilities.length) {
			return;
		}

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrForEach(upgradePossibilities, function(upgradeTransport) {
			/* Note: the transport may mutate the params, so give each transport a fresh one */
			var upgradeTransportParams = self.createTransportParams(transportParams.host, 'upgrade');
			self.tryATransport(upgradeTransportParams, upgradeTransport, noop);
		});
	};


	ConnectionManager.prototype.closeImpl = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');
		this.cancelSuspendTimer();
		this.startTransitionTimer(this.states.closing);

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);
			if(transport) transport.close();
		});

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});

		if(this.activeProtocol) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().close();
		}

		/* If there was an active transport, this will probably be
		 * preempted by the notifyState call in deactivateTransport */
		this.notifyState({state: 'closed'});
	};

	ConnectionManager.prototype.onAuthUpdated = function(tokenDetails, callback) {
		var self = this;
		switch(this.state.state) {
			case 'connected':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');
				/* If there are any proposed/pending transports (eg an upgrade that
				 * isn't yet scheduled for activation) that hasn't yet started syncing,
				 * just to get rid of them & restart the upgrade with the new token, to
				 * avoid a race condition. (If it has started syncing, the AUTH will be
				 * queued until the upgrade is complete, so everything's fine) */
				if((this.pendingTransports.length || this.proposedTransports.length) &&
					self.state !== self.states.synchronizing) {
					this.disconnectAllTransports(/* exceptActive: */true);
					var transportParams = this.activeProtocol.getTransport().params;
					_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
						if(self.state.state === 'connected') {
							self.upgradeIfNeeded(transportParams);
						}
					});
				}

				/* Do any transport-specific new-token action */
				this.activeProtocol.getTransport().onAuthUpdated(tokenDetails);

				var authMsg = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].fromValues({
					action: actions.AUTH,
					auth: {
						accessToken: tokenDetails.token
					}
				});
				this.send(authMsg);

				/* The answer will come back as either a connectiondetails event
				 * (realtime sends a CONNECTED to asknowledge the reauth) or a
				 * statechange to failed */
				var successListener = function() {
					self.off(failureListener);
					callback(null, tokenDetails);
				};
				var failureListener = function(stateChange) {
					if(stateChange.current === 'failed') {
						self.off(successListener);
						self.off(failureListener);
						callback(stateChange.reason || self.getStateError());
					}
				};
				this.once('connectiondetails', successListener);
				this.on('connectionstate', failureListener);
				break;

			case 'connecting':
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Aborting current connection attempts in order to start again with the new auth details');
				this.disconnectAllTransports();
				/* fallthrough to add statechange listener */

			default:
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onAuthUpdated()',
					'Connection state is ' + this.state.state + '; waiting until either connected or failed');
				var listener = function(stateChange) {
					switch(stateChange.current) {
						case 'connected':
							self.off(listener);
							callback(null, tokenDetails);
							break;
						case 'failed':
						case 'closed':
						case 'suspended':
							self.off(listener);
							callback(stateChange.reason || self.getStateError());
							break;
						default:
							/* ignore till we get either connected or failed */
							break;
					}
				};
				self.on('connectionstate', listener);
				if(this.state.state === 'connecting') {
					/* can happen if in the connecting state but no transport was pending
					 * yet, so disconnectAllTransports did not trigger a disconnected state */
					self.startConnect();
				} else {
					self.requestState({state: 'connecting'});
				}
		}
	};

	ConnectionManager.prototype.disconnectAllTransports = function(exceptActive) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));

		/* This will prevent any connection procedure in an async part of one of its early stages from continuing */
		this.connectCounter++;

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.pendingTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);
			if(transport) transport.disconnect();
		});
		this.pendingTransports = [];

		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].safeArrForEach(this.proposedTransports, function(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);
			if(transport) transport.dispose();
		});
		this.proposedTransports = [];

		if(this.activeProtocol && !exceptActive) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());
			this.activeProtocol.getTransport().disconnect();
		}
		/* No need to notify state disconnected; disconnecting the active transport
		 * will have that effect */
	};

	/******************
	 * event queueing
	 ******************/

	ConnectionManager.prototype.send = function(msg, queueEvent, callback) {
		callback = callback || noop;
		var state = this.state;

		if(state.sendEvents) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'sending event');
			this.sendImpl(new PendingMessage(msg, callback));
			return;
		}
		var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;
		if(!shouldQueue) {
			var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', err);
			callback(this.errorReason || new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](err, 90000, 400));
			return;
		}
		if(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(msg));
		}
		this.queue(msg, callback);
	};

	ConnectionManager.prototype.sendImpl = function(pendingMessage) {
		var msg = pendingMessage.message;
		/* If have already attempted to send this, resend with the same msgSerial,
		 * so Ably can dedup if the previous send succeeded */
		if(pendingMessage.ackRequired && !pendingMessage.sendAttempted) {
			msg.msgSerial = this.msgSerial++;
			this.setRecoveryKey();
		}
		try {
			this.activeProtocol.send(pendingMessage);
		} catch(e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);
		}
	};

	function bundleWith(dest, src, maxSize) {
		var action;
		if(dest.channel !== src.channel) {
			/* RTL6d3 */
			return false;
		}
		if((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {
			/* RTL6d - can only bundle messages or presence */
			return false;
		}
		if(action !== src.action) {
			/* RTL6d4 */
			return false;
		}
		var kind = (action === actions.PRESENCE) ? 'presence' : 'messages',
			proposed = dest[kind].concat(src[kind]),
			size = _types_message__WEBPACK_IMPORTED_MODULE_13__[/* default */ "a"].getMessagesSize(proposed);
		if(size > maxSize) {
			/* RTL6d1 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].allSame(proposed, 'clientId')) {
			/* RTL6d2 */
			return false;
		}
		if(!_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrEvery(proposed, function(msg) {
			return !msg.id;
		})) {
			/* RTL6d7 */
			return false;
		}
		/* we're good to go! */
		dest[kind] = proposed;
		return true;
	};

	ConnectionManager.prototype.queue = function(msg, callback) {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');
		var lastQueued = this.queuedMessages.last();
		var maxSize = this.options.maxMessageSize;
		/* If have already attempted to send a message, don't merge more messages
		 * into it, as if the previous send actually succeeded and realtime ignores
		 * the dup, they'll be lost */
		if(lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {
			if(!lastQueued.merged) {
				lastQueued.callback = Object(_util_multicaster__WEBPACK_IMPORTED_MODULE_14__[/* default */ "a"])([lastQueued.callback]);
				lastQueued.merged = true;
			}
			lastQueued.callback.push(callback);
		} else {
			this.queuedMessages.push(new PendingMessage(msg, callback));
		}
	};

	ConnectionManager.prototype.sendQueuedMessages = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');
		var pendingMessage;
		while(pendingMessage = this.queuedMessages.shift())
			this.sendImpl(pendingMessage);
	};

	ConnectionManager.prototype.queuePendingMessages = function(pendingMessages) {
		if(pendingMessages && pendingMessages.length) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');
			this.queuedMessages.prepend(pendingMessages);
		}
	};

	ConnectionManager.prototype.failQueuedMessages = function(err) {
		var numQueued = this.queuedMessages.count();
		if(numQueued > 0) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
			this.queuedMessages.completeAllMessages(err);
		}
	};

	ConnectionManager.prototype.onChannelMessage = function(message, transport) {
		var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(),
			onUpgradeTransport = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing,
			notControlMsg = message.action === actions.MESSAGE || message.action === actions.PRESENCE;

		/* As the lib now has a period where the upgrade transport is synced but
		 * before it's become active (while waiting for the old one to become
		 * idle), message can validly arrive on it even though it isn't active */
		if(onActiveTransport || onUpgradeTransport) {
			if(notControlMsg) {
				var suppressed = this.setConnectionSerial(message);
				if(suppressed) {
					return;
				}
				if(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isDuplicate(message, this.mostRecentMsg)) {
					_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onChannelMessage()', 'received message with different connectionSerial, but same message id as a previous; discarding; id = ' + message.id);
					return;
				}
				this.mostRecentMsg = message;
			}
			this.realtime.channels.onChannelMessage(message);
		} else {
			// Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding
			// messages,  no new messages (as sync has been sent on new transport so new messages will
			// be resent there, or connection has been closed so don't want new messages)
			if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {
				this.realtime.channels.onChannelMessage(message);
			} else {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');
			}
		}
	};

	ConnectionManager.prototype.ping = function(transport, callback) {
		/* if transport is specified, try that */
		if(transport) {
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);

			var onTimeout = function () {
				transport.off('heartbeat', onHeartbeat);
				callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Timeout waiting for heartbeat response', 50000, 500));
			};

			var pingStart = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now(),
				id = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].cheapRandStr();

			var onHeartbeat = function (responseId) {
				if(responseId === id) {
					transport.off('heartbeat', onHeartbeat);
					clearTimeout(timer);
					var responseTime = _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].now() - pingStart;
					callback(null, responseTime);
				}
			};

			var timer = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);

			transport.on('heartbeat', onHeartbeat);
			transport.ping(id);
			return;
		}

		/* if we're not connected, don't attempt */
		if(this.state.state !== 'connected') {
			callback(new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"]('Unable to ping service; not connected', 40000, 400));
			return;
		}

		/* no transport was specified, so use the current (connected) one
		 * but ensure that we retry if the transport is superseded before we complete */
		var completed = false, self = this;

		var onPingComplete = function(err, responseTime) {
			self.off('transport.active', onTransportActive);
			if(!completed) {
				completed = true;
				callback(err, responseTime);
			}
		};

		var onTransportActive = function() {
			if(!completed) {
				/* ensure that no callback happens for the currently outstanding operation */
				completed = true;
				/* repeat but picking up the new transport */
				_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
					self.ping(null, callback);
				});
			}
		};

		this.on('transport.active', onTransportActive);
		this.ping(this.activeProtocol.getTransport(), onPingComplete);
	};

	ConnectionManager.prototype.abort = function(error) {
		this.activeProtocol.getTransport().fail(error);
	};

	ConnectionManager.prototype.registerProposedTransport = function(transport) {
		this.proposedTransports.push(transport);
	};

	ConnectionManager.prototype.getTransportPreference = function() {
		return this.transportPreference || (haveWebStorage && platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].get(transportPreferenceName));
	};

	ConnectionManager.prototype.persistTransportPreference = function(transport) {
		if(_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].arrIn(_util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].upgradeTransports, transport.shortName)) {
			this.transportPreference = transport.shortName;
			if(haveWebStorage) {
				platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].set(transportPreferenceName, transport.shortName);
			}
		}
	};

	ConnectionManager.prototype.unpersistTransportPreference = function() {
		this.transportPreference = null;
		if(haveWebStorage) {
			platform_webstorage__WEBPACK_IMPORTED_MODULE_16__[/* default */ "a"].remove(transportPreferenceName);
		}
	};

	/* This method is only used during connection attempts, so implements RSA4c1,
	 * RSA4c2, and RSA4d. In particular it is not invoked for
	 * serverside-triggered reauths or manual reauths, so RSA4c3 does not apply */
	ConnectionManager.prototype.actOnErrorFromAuthorize = function(err) {
		if(err.code === 40171) {
			/* No way to reauth */
			this.notifyState({state: 'failed', error: err});
		} else if(err.statusCode === 403) {
			var msg = 'Client configured authentication provider returned 403; failing the connection';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);
			this.notifyState({state: 'failed', error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 403, err)});
		} else {
			var msg = 'Client configured authentication provider request failed';
			_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);
			this.notifyState({state: this.state.failState, error: new _types_errorinfo__WEBPACK_IMPORTED_MODULE_10__[/* default */ "a"](msg, 80019, 401, err)});
		}
	};

	ConnectionManager.prototype.onConnectionDetailsUpdate = function(connectionDetails, transport) {
		if(!connectionDetails) {
			return;
		}
		this.connectionDetails = connectionDetails;
		if(connectionDetails.maxMessageSize) {
			this.options.maxMessageSize = connectionDetails.maxMessageSize;
		}
		var clientId = connectionDetails.clientId;
		if(clientId) {
			var err = this.realtime.auth._uncheckedSetClientId(clientId);
			if(err) {
				_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);
				/* Errors setting the clientId are fatal to the connection */
				transport.fail(err);
				return;
			}
		}
		var connectionStateTtl = connectionDetails.connectionStateTtl;
		if(connectionStateTtl) {
			this.connectionStateTtl = connectionStateTtl;
		}
		this.maxIdleInterval = connectionDetails.maxIdleInterval;
		this.emit('connectiondetails', connectionDetails);
	};

	return ConnectionManager;
})();

/* harmony default export */ __webpack_exports__["a"] = (ConnectionManager);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_231954__(17)))

/***/ }),
/* 26 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_330360__) {

"use strict";
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_330360__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_330360__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_330360__(0);




var MessageQueue = (function() {
	function MessageQueue() {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		this.messages = [];
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(MessageQueue, _util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	MessageQueue.prototype.count = function() {
		return this.messages.length;
	};

	MessageQueue.prototype.push = function(message) {
		this.messages.push(message);
	};

	MessageQueue.prototype.shift = function() {
		return this.messages.shift();
	};

	MessageQueue.prototype.last = function() {
		return this.messages[this.messages.length - 1];
	};

	MessageQueue.prototype.copyAll = function() {
		return this.messages.slice();
	};

	MessageQueue.prototype.append = function(messages) {
		this.messages.push.apply(this.messages, messages);
	};

	MessageQueue.prototype.prepend = function(messages) {
		this.messages.unshift.apply(this.messages, messages);
	};

	MessageQueue.prototype.completeMessages = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);
		err = err || null;
		var messages = this.messages;
		var first = messages[0];
		if(first) {
			var startSerial = first.message.msgSerial;
			var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */
			if(endSerial > startSerial) {
				var completeMessages = messages.splice(0, (endSerial - startSerial));
				for(var i = 0; i < completeMessages.length; i++) {
					completeMessages[i].callback(err);
				}
			}
			if(messages.length == 0)
				this.emit('idle');
		}
	};

	MessageQueue.prototype.completeAllMessages = function(err) {
		this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);
	};

	MessageQueue.prototype.clear = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');
		this.messages = [];
		this.emit('idle');
	};

	return MessageQueue;
})();

/* harmony default export */ __webpack_exports__["a"] = (MessageQueue);


/***/ }),
/* 27 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_333199__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_333199__(1);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_333199__(7);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_333199__(3);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_333199__(2);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_333199__(6);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_333199__(0);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_333199__(4);
/* harmony import */ var platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_333199__(5);
/* harmony import */ var _util_domevent__WEBPACK_IMPORTED_MODULE_8__ = __nested_webpack_require_333199__(35);










var XHRRequest = (function() {
	var noop = function() {};
	var idCounter = 0;
	var pendingRequests = {};

	var REQ_SEND = 0,
		REQ_RECV = 1,
		REQ_RECV_POLL = 2,
		REQ_RECV_STREAM = 3;

	function clearPendingRequests() {
		for(var id in pendingRequests)
			pendingRequests[id].dispose();
	}

	var isIE = typeof global !== 'undefined' && global.XDomainRequest;

	function ieVersion() {
		var match = navigator.userAgent.toString().match(/MSIE\s([\d.]+)/);
		return match && Number(match[1]);
	}

	function needJsonEnvelope() {
		/* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */
		var version;
		return isIE && (version = ieVersion()) && version === 10;
	}

	function getHeader(xhr, header) {
		return xhr.getResponseHeader && xhr.getResponseHeader(header);
	}

	/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact
	 * it is 'chunked'. So instead, decide that it is chunked when
	 * transfer-encoding is present or content-length is absent.  ('or' because
	 * when using http2 streaming, there's no transfer-encoding header, but can
	 * still deduce streaming from lack of content-length) */
	function isEncodingChunked(xhr) {
		return xhr.getResponseHeader
			&& (xhr.getResponseHeader('transfer-encoding')
			|| !xhr.getResponseHeader('content-length'));
	}

	function getHeadersAsObject(xhr) {
		var headerPairs = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim(xhr.getAllResponseHeaders()).split('\r\n'),
			headers = {};
		for (var i = 0; i < headerPairs.length; i++) {
			var parts = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].arrMap(headerPairs[i].split(':'), _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].trim);
			headers[parts[0].toLowerCase()] = parts[1];
		}
		return headers;
	}

	function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this);
		params = params || {};
		params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(needJsonEnvelope() && !params.envelope)
			params.envelope = 'json';
		this.uri = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		this.headers = headers || {};
		this.body = body;
		this.method = method ? method.toUpperCase() : (_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isEmptyArg(body) ? 'GET' : 'POST');
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.timedOut = false;
		this.requestComplete = false;
		pendingRequests[this.id = String(++idCounter)] = this;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(XHRRequest, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	var createRequest = XHRRequest.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* XHR requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new XHRRequest(uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	XHRRequest.prototype.complete = function(err, body, headers, unpacked, statusCode) {
		if(!this.requestComplete) {
			this.requestComplete = true;
			if(!err && body) {
				this.emit('data', body);
			}
			this.emit('complete', err, body, headers, unpacked, statusCode);
			this.dispose();
		}
	};

	XHRRequest.prototype.abort = function() {
		this.dispose();
	};

	XHRRequest.prototype.exec = function() {
		var timeout = (this.requestMode == REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout,
			self = this,
			timer = this.timer = setTimeout(function() {
				self.timedOut = true;
				xhr.abort();
			}, timeout),
			body = this.body,
			method = this.method,
			headers = this.headers,
			xhr = this.xhr = new XMLHttpRequest(),
			accept = headers['accept'],
			responseType = 'text';

		if(!accept) {
			headers['accept'] = 'application/json';
		} else if(accept.indexOf('application/x-msgpack') === 0) {
			responseType = 'arraybuffer';
		}

		if(body) {
			var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');
			if(contentType.indexOf('application/json') > -1 && typeof(body) != 'string')
				body = JSON.stringify(body);
		}

		xhr.open(method, this.uri, true);
		xhr.responseType = responseType;

		if ('authorization' in headers) {
			xhr.withCredentials = true;
		}

		for(var h in headers)
			xhr.setRequestHeader(h, headers[h]);

		var errorHandler = function(errorEvent, message, code, statusCode) {
			var errorMessage = message + ' (event type: ' + errorEvent.type + ')' + (self.xhr.statusText ? ', current statusText is ' + self.xhr.statusText : '');
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"](errorMessage, code, statusCode));
		};
		xhr.onerror = function(errorEvent) {
			errorHandler(errorEvent, 'XHR error occurred', null, 400);
		}
		xhr.onabort = function(errorEvent) {
			if(self.timedOut) {
				errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);
			} else {
				errorHandler(errorEvent, 'Request cancelled', null, 400);
			}
		};
		xhr.ontimeout = function(errorEvent) {
			errorHandler(errorEvent, 'Request timed out', null, 408);
		};

		var streaming,
			statusCode,
			responseBody,
			contentType,
			successResponse,
			streamPos = 0,
			unpacked = false;

		function onResponse() {
			clearTimeout(timer);
			successResponse = (statusCode < 400);
			if(statusCode == 204) {
				self.complete(null, null, null, null, statusCode);
				return;
			}
			streaming = (self.requestMode == REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr));
		}

		function onEnd() {
			try {
				var contentType = getHeader(xhr, 'content-type'),
					headers,
					responseBody,
					/* Be liberal in what we accept; buggy auth servers may respond
					 * without the correct contenttype, but assume they're still
					 * responding with json */
					json = contentType ? (contentType.indexOf('application/json') >= 0) : (xhr.responseType == 'text');

				if(json) {
					/* If we requested msgpack but server responded with json, then since
					 * we set the responseType expecting msgpack, the response will be
					 * an ArrayBuffer containing json */
					responseBody = (xhr.responseType === 'arraybuffer') ? platform_bufferutils__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].utf8Decode(xhr.response) : String(xhr.responseText);
					if(responseBody.length) {
						responseBody = JSON.parse(responseBody);
					}
					unpacked = true;
				} else {
					responseBody = xhr.response;
				}

				if(responseBody.response !== undefined) {
					/* unwrap JSON envelope */
					statusCode = responseBody.statusCode;
					successResponse = (statusCode < 400);
					headers = responseBody.headers;
					responseBody = responseBody.response;
				} else {
					headers = getHeadersAsObject(xhr);
				}
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}

			/* If response is an array, it's an array of protocol messages -- even if
			 * is contains an error action (hence the nonsuccess statuscode), we can
			 * consider the request to have succeeded, just pass it on to
			 * onProtocolMessage to decide what to do */
			if(successResponse || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(responseBody)) {
				self.complete(null, responseBody, headers, unpacked, statusCode);
				return;
			}

			var err = responseBody.error && _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].fromValues(responseBody.error);
			if(!err) {
				err = new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Error response received from server: ' + statusCode + ' body was: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(responseBody), null, statusCode);
			}
			self.complete(err, responseBody, headers, unpacked, statusCode);
		}

		function onProgress() {
			responseBody = xhr.responseText;
			var bodyEnd = responseBody.length - 1, idx, chunk;
			while((streamPos < bodyEnd) && (idx = responseBody.indexOf('\n', streamPos)) > -1) {
				chunk = responseBody.slice(streamPos, idx);
				streamPos = idx + 1;
				onChunk(chunk);
			}
		}

		function onChunk(chunk) {
			try {
				chunk = JSON.parse(chunk);
			} catch(e) {
				self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]('Malformed response body from server: ' + e.message, null, 400));
				return;
			}
			self.emit('data', chunk);
		}

		function onStreamEnd() {
			onProgress();
			self.streamComplete = true;
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				self.complete();
			});
		}

		xhr.onreadystatechange = function() {
			var readyState = xhr.readyState;
			if(readyState < 3) return;
			if(xhr.status !== 0) {
				if(statusCode === undefined) {
					statusCode = xhr.status;
					/* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */
					if(statusCode === 1223) statusCode = 204;
					onResponse();
				}
				if(readyState == 3 && streaming) {
					onProgress();
				} else if(readyState == 4) {
					if(streaming)
						onStreamEnd();
					else
						onEnd();
				}
			}
		};
		xhr.send(body);
	};

	XHRRequest.prototype.dispose = function() {
		var xhr = this.xhr;
		if(xhr) {
			xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;
			this.xhr = null;
			var timer = this.timer;
			if(timer) {
				clearTimeout(timer);
				this.timer = null;
			}
			if(!this.requestComplete)
				xhr.abort();
		}
		delete pendingRequests[this.id];
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].xhrSupported) {
		if(typeof _util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"] === 'object') {
			_util_domevent__WEBPACK_IMPORTED_MODULE_8__[/* default */ "a"].addUnloadListener(clearPendingRequests);
		}
		if(typeof(platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]) !== 'undefined') {
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].supportsAuthHeaders = true;
			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
				var req = createRequest(uri, headers, params, body, REQ_SEND, rest && rest.options.timeouts, method);
				req.once('complete', callback);
				req.exec();
				return req;
			};

			platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
				var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].internetUpUrl;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + upUrl);
				platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].getUri(null, upUrl, null, null, function(err, responseText) {
					var result = (!err && responseText.replace(/\n/, '') == 'yes');
					_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);
					callback(null, result);
				});
			};
		}
	}

	return XHRRequest;
})();

/* harmony default export */ __webpack_exports__["a"] = (XHRRequest);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_333199__(17)))

/***/ }),
/* 28 */
/***/ (function(module, exports, __nested_webpack_require_346930__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_346930__(12), __nested_webpack_require_346930__(10), __nested_webpack_require_346930__(46), __nested_webpack_require_346930__(18), __nested_webpack_require_346930__(37), __nested_webpack_require_346930__(36), __nested_webpack_require_346930__(29), __nested_webpack_require_346930__(30), __nested_webpack_require_346930__(31), __nested_webpack_require_346930__(47), __nested_webpack_require_346930__(48));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS;

}));

/***/ }),
/* 29 */
/***/ (function(module, exports, __nested_webpack_require_347459__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_347459__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var C_algo = C.algo;

	    /**
	     * HMAC algorithm.
	     */
	    var HMAC = C_algo.HMAC = Base.extend({
	        /**
	         * Initializes a newly created HMAC.
	         *
	         * @param {Hasher} hasher The hash algorithm to use.
	         * @param {WordArray|string} key The secret key.
	         *
	         * @example
	         *
	         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
	         */
	        init: function (hasher, key) {
	            // Init hasher
	            hasher = this._hasher = new hasher.init();

	            // Convert string to WordArray, else assume WordArray already
	            if (typeof key == 'string') {
	                key = Utf8.parse(key);
	            }

	            // Shortcuts
	            var hasherBlockSize = hasher.blockSize;
	            var hasherBlockSizeBytes = hasherBlockSize * 4;

	            // Allow arbitrary length keys
	            if (key.sigBytes > hasherBlockSizeBytes) {
	                key = hasher.finalize(key);
	            }

	            // Clamp excess bits
	            key.clamp();

	            // Clone key for inner and outer pads
	            var oKey = this._oKey = key.clone();
	            var iKey = this._iKey = key.clone();

	            // Shortcuts
	            var oKeyWords = oKey.words;
	            var iKeyWords = iKey.words;

	            // XOR keys with pad constants
	            for (var i = 0; i < hasherBlockSize; i++) {
	                oKeyWords[i] ^= 0x5c5c5c5c;
	                iKeyWords[i] ^= 0x36363636;
	            }
	            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this HMAC to its initial state.
	         *
	         * @example
	         *
	         *     hmacHasher.reset();
	         */
	        reset: function () {
	            // Shortcut
	            var hasher = this._hasher;

	            // Reset
	            hasher.reset();
	            hasher.update(this._iKey);
	        },

	        /**
	         * Updates this HMAC with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {HMAC} This HMAC instance.
	         *
	         * @example
	         *
	         *     hmacHasher.update('message');
	         *     hmacHasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            this._hasher.update(messageUpdate);

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the HMAC computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The HMAC.
	         *
	         * @example
	         *
	         *     var hmac = hmacHasher.finalize();
	         *     var hmac = hmacHasher.finalize('message');
	         *     var hmac = hmacHasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Shortcut
	            var hasher = this._hasher;

	            // Compute HMAC
	            var innerHash = hasher.finalize(messageUpdate);
	            hasher.reset();
	            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));

	            return hmac;
	        }
	    });
	}());


}));

/***/ }),
/* 30 */
/***/ (function(module, exports, __nested_webpack_require_351496__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_351496__(12), __nested_webpack_require_351496__(37), __nested_webpack_require_351496__(29));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var C_algo = C.algo;
	    var MD5 = C_algo.MD5;

	    /**
	     * This key derivation function is meant to conform with EVP_BytesToKey.
	     * www.openssl.org/docs/crypto/EVP_BytesToKey.html
	     */
	    var EvpKDF = C_algo.EvpKDF = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
	         * @property {Hasher} hasher The hash algorithm to use. Default: MD5
	         * @property {number} iterations The number of iterations to perform. Default: 1
	         */
	        cfg: Base.extend({
	            keySize: 128/32,
	            hasher: MD5,
	            iterations: 1
	        }),

	        /**
	         * Initializes a newly created key derivation function.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for the derivation.
	         *
	         * @example
	         *
	         *     var kdf = CryptoJS.algo.EvpKDF.create();
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
	         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
	         */
	        init: function (cfg) {
	            this.cfg = this.cfg.extend(cfg);
	        },

	        /**
	         * Derives a key from a password.
	         *
	         * @param {WordArray|string} password The password.
	         * @param {WordArray|string} salt A salt.
	         *
	         * @return {WordArray} The derived key.
	         *
	         * @example
	         *
	         *     var key = kdf.compute(password, salt);
	         */
	        compute: function (password, salt) {
	            var block;

	            // Shortcut
	            var cfg = this.cfg;

	            // Init hasher
	            var hasher = cfg.hasher.create();

	            // Initial values
	            var derivedKey = WordArray.create();

	            // Shortcuts
	            var derivedKeyWords = derivedKey.words;
	            var keySize = cfg.keySize;
	            var iterations = cfg.iterations;

	            // Generate key
	            while (derivedKeyWords.length < keySize) {
	                if (block) {
	                    hasher.update(block);
	                }
	                block = hasher.update(password).finalize(salt);
	                hasher.reset();

	                // Iterations
	                for (var i = 1; i < iterations; i++) {
	                    block = hasher.finalize(block);
	                    hasher.reset();
	                }

	                derivedKey.concat(block);
	            }
	            derivedKey.sigBytes = keySize * 4;

	            return derivedKey;
	        }
	    });

	    /**
	     * Derives a key from a password.
	     *
	     * @param {WordArray|string} password The password.
	     * @param {WordArray|string} salt A salt.
	     * @param {Object} cfg (Optional) The configuration options to use for this computation.
	     *
	     * @return {WordArray} The derived key.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var key = CryptoJS.EvpKDF(password, salt);
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
	     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
	     */
	    C.EvpKDF = function (password, salt, cfg) {
	        return EvpKDF.create(cfg).compute(password, salt);
	    };
	}());


	return CryptoJS.EvpKDF;

}));

/***/ }),
/* 31 */
/***/ (function(module, exports, __nested_webpack_require_355518__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_355518__(12), __nested_webpack_require_355518__(30));
	}
	else {}
}(this, function (CryptoJS) {

	/**
	 * Cipher core components.
	 */
	CryptoJS.lib.Cipher || (function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var Base = C_lib.Base;
	    var WordArray = C_lib.WordArray;
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
	    var C_enc = C.enc;
	    var Utf8 = C_enc.Utf8;
	    var Base64 = C_enc.Base64;
	    var C_algo = C.algo;
	    var EvpKDF = C_algo.EvpKDF;

	    /**
	     * Abstract base cipher template.
	     *
	     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
	     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
	     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
	     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
	     */
	    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {WordArray} iv The IV to use for this operation.
	         */
	        cfg: Base.extend(),

	        /**
	         * Creates this cipher in encryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createEncryptor: function (key, cfg) {
	            return this.create(this._ENC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Creates this cipher in decryption mode.
	         *
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {Cipher} A cipher instance.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
	         */
	        createDecryptor: function (key, cfg) {
	            return this.create(this._DEC_XFORM_MODE, key, cfg);
	        },

	        /**
	         * Initializes a newly created cipher.
	         *
	         * @param {number} xformMode Either the encryption or decryption transormation mode constant.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @example
	         *
	         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
	         */
	        init: function (xformMode, key, cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Store transform mode and key
	            this._xformMode = xformMode;
	            this._key = key;

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this cipher to its initial state.
	         *
	         * @example
	         *
	         *     cipher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-cipher logic
	            this._doReset();
	        },

	        /**
	         * Adds data to be encrypted or decrypted.
	         *
	         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.process('data');
	         *     var encrypted = cipher.process(wordArray);
	         */
	        process: function (dataUpdate) {
	            // Append
	            this._append(dataUpdate);

	            // Process available blocks
	            return this._process();
	        },

	        /**
	         * Finalizes the encryption or decryption process.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
	         *
	         * @return {WordArray} The data after final processing.
	         *
	         * @example
	         *
	         *     var encrypted = cipher.finalize();
	         *     var encrypted = cipher.finalize('data');
	         *     var encrypted = cipher.finalize(wordArray);
	         */
	        finalize: function (dataUpdate) {
	            // Final data update
	            if (dataUpdate) {
	                this._append(dataUpdate);
	            }

	            // Perform concrete-cipher logic
	            var finalProcessedData = this._doFinalize();

	            return finalProcessedData;
	        },

	        keySize: 128/32,

	        ivSize: 128/32,

	        _ENC_XFORM_MODE: 1,

	        _DEC_XFORM_MODE: 2,

	        /**
	         * Creates shortcut functions to a cipher's object interface.
	         *
	         * @param {Cipher} cipher The cipher to create a helper for.
	         *
	         * @return {Object} An object with encrypt and decrypt shortcut functions.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
	         */
	        _createHelper: (function () {
	            function selectCipherStrategy(key) {
	                if (typeof key == 'string') {
	                    return PasswordBasedCipher;
	                } else {
	                    return SerializableCipher;
	                }
	            }

	            return function (cipher) {
	                return {
	                    encrypt: function (message, key, cfg) {
	                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
	                    },

	                    decrypt: function (ciphertext, key, cfg) {
	                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
	                    }
	                };
	            };
	        }())
	    });

	    /**
	     * Abstract base stream cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
	     */
	    var StreamCipher = C_lib.StreamCipher = Cipher.extend({
	        _doFinalize: function () {
	            // Process partial blocks
	            var finalProcessedBlocks = this._process(!!'flush');

	            return finalProcessedBlocks;
	        },

	        blockSize: 1
	    });

	    /**
	     * Mode namespace.
	     */
	    var C_mode = C.mode = {};

	    /**
	     * Abstract base block cipher mode template.
	     */
	    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
	        /**
	         * Creates this mode for encryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
	         */
	        createEncryptor: function (cipher, iv) {
	            return this.Encryptor.create(cipher, iv);
	        },

	        /**
	         * Creates this mode for decryption.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
	         */
	        createDecryptor: function (cipher, iv) {
	            return this.Decryptor.create(cipher, iv);
	        },

	        /**
	         * Initializes a newly created mode.
	         *
	         * @param {Cipher} cipher A block cipher instance.
	         * @param {Array} iv The IV words.
	         *
	         * @example
	         *
	         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
	         */
	        init: function (cipher, iv) {
	            this._cipher = cipher;
	            this._iv = iv;
	        }
	    });

	    /**
	     * Cipher Block Chaining mode.
	     */
	    var CBC = C_mode.CBC = (function () {
	        /**
	         * Abstract base CBC mode.
	         */
	        var CBC = BlockCipherMode.extend();

	        /**
	         * CBC encryptor.
	         */
	        CBC.Encryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // XOR and encrypt
	                xorBlock.call(this, words, offset, blockSize);
	                cipher.encryptBlock(words, offset);

	                // Remember this block to use with next block
	                this._prevBlock = words.slice(offset, offset + blockSize);
	            }
	        });

	        /**
	         * CBC decryptor.
	         */
	        CBC.Decryptor = CBC.extend({
	            /**
	             * Processes the data block at offset.
	             *
	             * @param {Array} words The data words to operate on.
	             * @param {number} offset The offset where the block starts.
	             *
	             * @example
	             *
	             *     mode.processBlock(data.words, offset);
	             */
	            processBlock: function (words, offset) {
	                // Shortcuts
	                var cipher = this._cipher;
	                var blockSize = cipher.blockSize;

	                // Remember this block to use with next block
	                var thisBlock = words.slice(offset, offset + blockSize);

	                // Decrypt and XOR
	                cipher.decryptBlock(words, offset);
	                xorBlock.call(this, words, offset, blockSize);

	                // This block becomes the previous block
	                this._prevBlock = thisBlock;
	            }
	        });

	        function xorBlock(words, offset, blockSize) {
	            var block;

	            // Shortcut
	            var iv = this._iv;

	            // Choose mixing block
	            if (iv) {
	                block = iv;

	                // Remove IV for subsequent blocks
	                this._iv = undefined;
	            } else {
	                block = this._prevBlock;
	            }

	            // XOR blocks
	            for (var i = 0; i < blockSize; i++) {
	                words[offset + i] ^= block[i];
	            }
	        }

	        return CBC;
	    }());

	    /**
	     * Padding namespace.
	     */
	    var C_pad = C.pad = {};

	    /**
	     * PKCS #5/7 padding strategy.
	     */
	    var Pkcs7 = C_pad.Pkcs7 = {
	        /**
	         * Pads data using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to pad.
	         * @param {number} blockSize The multiple that the data should be padded to.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
	         */
	        pad: function (data, blockSize) {
	            // Shortcut
	            var blockSizeBytes = blockSize * 4;

	            // Count padding bytes
	            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

	            // Create padding word
	            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;

	            // Create padding
	            var paddingWords = [];
	            for (var i = 0; i < nPaddingBytes; i += 4) {
	                paddingWords.push(paddingWord);
	            }
	            var padding = WordArray.create(paddingWords, nPaddingBytes);

	            // Add padding
	            data.concat(padding);
	        },

	        /**
	         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
	         *
	         * @param {WordArray} data The data to unpad.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     CryptoJS.pad.Pkcs7.unpad(wordArray);
	         */
	        unpad: function (data) {
	            // Get number of padding bytes from last byte
	            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;

	            // Remove padding
	            data.sigBytes -= nPaddingBytes;
	        }
	    };

	    /**
	     * Abstract base block cipher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
	     */
	    var BlockCipher = C_lib.BlockCipher = Cipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Mode} mode The block mode to use. Default: CBC
	         * @property {Padding} padding The padding strategy to use. Default: Pkcs7
	         */
	        cfg: Cipher.cfg.extend({
	            mode: CBC,
	            padding: Pkcs7
	        }),

	        reset: function () {
	            var modeCreator;

	            // Reset cipher
	            Cipher.reset.call(this);

	            // Shortcuts
	            var cfg = this.cfg;
	            var iv = cfg.iv;
	            var mode = cfg.mode;

	            // Reset block mode
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                modeCreator = mode.createEncryptor;
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                modeCreator = mode.createDecryptor;
	                // Keep at least one block in the buffer for unpadding
	                this._minBufferSize = 1;
	            }

	            if (this._mode && this._mode.__creator == modeCreator) {
	                this._mode.init(this, iv && iv.words);
	            } else {
	                this._mode = modeCreator.call(mode, this, iv && iv.words);
	                this._mode.__creator = modeCreator;
	            }
	        },

	        _doProcessBlock: function (words, offset) {
	            this._mode.processBlock(words, offset);
	        },

	        _doFinalize: function () {
	            var finalProcessedBlocks;

	            // Shortcut
	            var padding = this.cfg.padding;

	            // Finalize
	            if (this._xformMode == this._ENC_XFORM_MODE) {
	                // Pad data
	                padding.pad(this._data, this.blockSize);

	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');
	            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {
	                // Process final blocks
	                finalProcessedBlocks = this._process(!!'flush');

	                // Unpad data
	                padding.unpad(finalProcessedBlocks);
	            }

	            return finalProcessedBlocks;
	        },

	        blockSize: 128/32
	    });

	    /**
	     * A collection of cipher parameters.
	     *
	     * @property {WordArray} ciphertext The raw ciphertext.
	     * @property {WordArray} key The key to this ciphertext.
	     * @property {WordArray} iv The IV used in the ciphering operation.
	     * @property {WordArray} salt The salt used with a key derivation function.
	     * @property {Cipher} algorithm The cipher algorithm.
	     * @property {Mode} mode The block mode used in the ciphering operation.
	     * @property {Padding} padding The padding scheme used in the ciphering operation.
	     * @property {number} blockSize The block size of the cipher.
	     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
	     */
	    var CipherParams = C_lib.CipherParams = Base.extend({
	        /**
	         * Initializes a newly created cipher params object.
	         *
	         * @param {Object} cipherParams An object with any of the possible cipher parameters.
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.lib.CipherParams.create({
	         *         ciphertext: ciphertextWordArray,
	         *         key: keyWordArray,
	         *         iv: ivWordArray,
	         *         salt: saltWordArray,
	         *         algorithm: CryptoJS.algo.AES,
	         *         mode: CryptoJS.mode.CBC,
	         *         padding: CryptoJS.pad.PKCS7,
	         *         blockSize: 4,
	         *         formatter: CryptoJS.format.OpenSSL
	         *     });
	         */
	        init: function (cipherParams) {
	            this.mixIn(cipherParams);
	        },

	        /**
	         * Converts this cipher params object to a string.
	         *
	         * @param {Format} formatter (Optional) The formatting strategy to use.
	         *
	         * @return {string} The stringified cipher params.
	         *
	         * @throws Error If neither the formatter nor the default formatter is set.
	         *
	         * @example
	         *
	         *     var string = cipherParams + '';
	         *     var string = cipherParams.toString();
	         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
	         */
	        toString: function (formatter) {
	            return (formatter || this.formatter).stringify(this);
	        }
	    });

	    /**
	     * Format namespace.
	     */
	    var C_format = C.format = {};

	    /**
	     * OpenSSL formatting strategy.
	     */
	    var OpenSSLFormatter = C_format.OpenSSL = {
	        /**
	         * Converts a cipher params object to an OpenSSL-compatible string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The OpenSSL-compatible string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            var wordArray;

	            // Shortcuts
	            var ciphertext = cipherParams.ciphertext;
	            var salt = cipherParams.salt;

	            // Format
	            if (salt) {
	                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
	            } else {
	                wordArray = ciphertext;
	            }

	            return wordArray.toString(Base64);
	        },

	        /**
	         * Converts an OpenSSL-compatible string to a cipher params object.
	         *
	         * @param {string} openSSLStr The OpenSSL-compatible string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
	         */
	        parse: function (openSSLStr) {
	            var salt;

	            // Parse base64
	            var ciphertext = Base64.parse(openSSLStr);

	            // Shortcut
	            var ciphertextWords = ciphertext.words;

	            // Test for salt
	            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
	                // Extract salt
	                salt = WordArray.create(ciphertextWords.slice(2, 4));

	                // Remove salt from ciphertext
	                ciphertextWords.splice(0, 4);
	                ciphertext.sigBytes -= 16;
	            }

	            return CipherParams.create({ ciphertext: ciphertext, salt: salt });
	        }
	    };

	    /**
	     * A cipher wrapper that returns ciphertext as a serializable cipher params object.
	     */
	    var SerializableCipher = C_lib.SerializableCipher = Base.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
	         */
	        cfg: Base.extend({
	            format: OpenSSLFormatter
	        }),

	        /**
	         * Encrypts a message.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Encrypt
	            var encryptor = cipher.createEncryptor(key, cfg);
	            var ciphertext = encryptor.finalize(message);

	            // Shortcut
	            var cipherCfg = encryptor.cfg;

	            // Create and return serializable cipher params
	            return CipherParams.create({
	                ciphertext: ciphertext,
	                key: key,
	                iv: cipherCfg.iv,
	                algorithm: cipher,
	                mode: cipherCfg.mode,
	                padding: cipherCfg.padding,
	                blockSize: cipher.blockSize,
	                formatter: cfg.format
	            });
	        },

	        /**
	         * Decrypts serialized ciphertext.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {WordArray} key The key.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, key, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Decrypt
	            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);

	            return plaintext;
	        },

	        /**
	         * Converts serialized ciphertext to CipherParams,
	         * else assumed CipherParams already and returns ciphertext unchanged.
	         *
	         * @param {CipherParams|string} ciphertext The ciphertext.
	         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
	         *
	         * @return {CipherParams} The unserialized ciphertext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
	         */
	        _parse: function (ciphertext, format) {
	            if (typeof ciphertext == 'string') {
	                return format.parse(ciphertext, this);
	            } else {
	                return ciphertext;
	            }
	        }
	    });

	    /**
	     * Key derivation function namespace.
	     */
	    var C_kdf = C.kdf = {};

	    /**
	     * OpenSSL key derivation function.
	     */
	    var OpenSSLKdf = C_kdf.OpenSSL = {
	        /**
	         * Derives a key and IV from a password.
	         *
	         * @param {string} password The password to derive from.
	         * @param {number} keySize The size in words of the key to generate.
	         * @param {number} ivSize The size in words of the IV to generate.
	         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
	         *
	         * @return {CipherParams} A cipher params object with the key, IV, and salt.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
	         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
	         */
	        execute: function (password, keySize, ivSize, salt) {
	            // Generate random salt
	            if (!salt) {
	                salt = WordArray.random(64/8);
	            }

	            // Derive key and IV
	            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);

	            // Separate key and IV
	            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
	            key.sigBytes = keySize * 4;

	            // Return params
	            return CipherParams.create({ key: key, iv: iv, salt: salt });
	        }
	    };

	    /**
	     * A serializable cipher wrapper that derives the key from a password,
	     * and returns ciphertext as a serializable cipher params object.
	     */
	    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
	        /**
	         * Configuration options.
	         *
	         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
	         */
	        cfg: SerializableCipher.cfg.extend({
	            kdf: OpenSSLKdf
	        }),

	        /**
	         * Encrypts a message using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {WordArray|string} message The message to encrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {CipherParams} A cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
	         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        encrypt: function (cipher, message, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Encrypt
	            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

	            // Mix in derived params
	            ciphertext.mixIn(derivedParams);

	            return ciphertext;
	        },

	        /**
	         * Decrypts serialized ciphertext using a password.
	         *
	         * @param {Cipher} cipher The cipher algorithm to use.
	         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
	         * @param {string} password The password.
	         * @param {Object} cfg (Optional) The configuration options to use for this operation.
	         *
	         * @return {WordArray} The plaintext.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
	         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
	         */
	        decrypt: function (cipher, ciphertext, password, cfg) {
	            // Apply config defaults
	            cfg = this.cfg.extend(cfg);

	            // Convert string to CipherParams
	            ciphertext = this._parse(ciphertext, cfg.format);

	            // Derive key and other params
	            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

	            // Add IV to config
	            cfg.iv = derivedParams.iv;

	            // Decrypt
	            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);

	            return plaintext;
	        }
	    });
	}());


}));

/***/ }),
/* 32 */
/***/ (function(module, exports, __nested_webpack_require_385953__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_385953__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Hex;

}));

/***/ }),
/* 33 */
/***/ (function(module, exports, __nested_webpack_require_386240__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_386240__(12));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.enc.Utf8;

}));

/***/ }),
/* 34 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_386540__) {

"use strict";
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_386540__(8);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_386540__(1);
/* harmony import */ var _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_386540__(7);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_386540__(0);
/* harmony import */ var _messagequeue__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_386540__(26);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_386540__(2);







var Protocol = (function() {
	var actions = _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Action;

	function Protocol(transport) {
		_util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this);
		this.transport = transport;
		this.messageQueue = new _messagequeue__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"]();
		var self = this;
		transport.on('ack', function(serial, count) { self.onAck(serial, count); });
		transport.on('nack', function(serial, count, err) { self.onNack(serial, count, err); });
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(Protocol, _util_eventemitter__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	Protocol.prototype.onAck = function(serial, count) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);
		this.messageQueue.completeMessages(serial, count);
	};

	Protocol.prototype.onNack = function(serial, count, err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(err));
		if(!err) {
			err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Unable to send message; channel not responding', 50001, 500);
		}
		this.messageQueue.completeMessages(serial, count, err);
	};

	Protocol.prototype.onceIdle = function(listener) {
		var messageQueue = this.messageQueue;
		if(messageQueue.count() === 0) {
			listener();
			return;
		}
		messageQueue.once('idle', listener);
	};

	Protocol.prototype.send = function(pendingMessage) {
		if(pendingMessage.ackRequired) {
			this.messageQueue.push(pendingMessage);
		}
		if (_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].shouldLog(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO)) {
			_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].LOG_MICRO, 'Protocol.send()', 'sending msg; ' + _types_protocolmessage__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].stringify(pendingMessage.message));
		}
		pendingMessage.sendAttempted = true;
		this.transport.send(pendingMessage.message);
	};

	Protocol.prototype.getTransport = function() {
		return this.transport;
	};

	Protocol.prototype.getPendingMessages = function() {
		return this.messageQueue.copyAll();
	};

	Protocol.prototype.clearPendingMessages = function() {
		return this.messageQueue.clear();
	};

	Protocol.prototype.finish = function() {
		var transport = this.transport;
		this.onceIdle(function() {
			transport.disconnect();
		});
	};

	function PendingMessage(message, callback) {
		this.message = message;
		this.callback = callback;
		this.merged = false;
		var action = message.action;
		this.sendAttempted = false;
		this.ackRequired = (action == actions.MESSAGE || action == actions.PRESENCE);
	}
	Protocol.PendingMessage = PendingMessage;

	return Protocol;
})();

/* harmony default export */ __webpack_exports__["a"] = (Protocol);


/***/ }),
/* 35 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_390631__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var DomEvent = (function() {
	function DomEvent() {}

	DomEvent.addListener = function(target, event, listener) {
		if(target.addEventListener) {
			target.addEventListener(event, listener, false);
		} else {
			target.attachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.removeListener = function(target, event, listener) {
		if(target.removeEventListener) {
			target.removeEventListener(event, listener, false);
		} else {
			target.detachEvent('on'+event, function() { listener.apply(target, arguments); });
		}
	};

	DomEvent.addMessageListener = function(target, listener) {
		DomEvent.addListener(target, 'message', listener);
	};

	DomEvent.removeMessageListener = function(target, listener) {
		DomEvent.removeListener(target, 'message', listener);
	};

	DomEvent.addUnloadListener = function(listener) {
		DomEvent.addListener(global, 'unload', listener);
	};

	return DomEvent;
})();

/* harmony default export */ __webpack_exports__["a"] = (DomEvent);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_390631__(17)))

/***/ }),
/* 36 */
/***/ (function(module, exports, __nested_webpack_require_391884__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_391884__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Initialization and round constants tables
	    var H = [];
	    var K = [];

	    // Compute constants
	    (function () {
	        function isPrime(n) {
	            var sqrtN = Math.sqrt(n);
	            for (var factor = 2; factor <= sqrtN; factor++) {
	                if (!(n % factor)) {
	                    return false;
	                }
	            }

	            return true;
	        }

	        function getFractionalBits(n) {
	            return ((n - (n | 0)) * 0x100000000) | 0;
	        }

	        var n = 2;
	        var nPrime = 0;
	        while (nPrime < 64) {
	            if (isPrime(n)) {
	                if (nPrime < 8) {
	                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
	                }
	                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));

	                nPrime++;
	            }

	            n++;
	        }
	    }());

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-256 hash algorithm.
	     */
	    var SHA256 = C_algo.SHA256 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init(H.slice(0));
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];
	            var f = H[5];
	            var g = H[6];
	            var h = H[7];

	            // Computation
	            for (var i = 0; i < 64; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var gamma0x = W[i - 15];
	                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^
	                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^
	                                   (gamma0x >>> 3);

	                    var gamma1x = W[i - 2];
	                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^
	                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^
	                                   (gamma1x >>> 10);

	                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
	                }

	                var ch  = (e & f) ^ (~e & g);
	                var maj = (a & b) ^ (a & c) ^ (b & c);

	                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));
	                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));

	                var t1 = h + sigma1 + ch + K[i] + W[i];
	                var t2 = sigma0 + maj;

	                h = g;
	                g = f;
	                f = e;
	                e = (d + t1) | 0;
	                d = c;
	                c = b;
	                b = a;
	                a = (t1 + t2) | 0;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	            H[5] = (H[5] + f) | 0;
	            H[6] = (H[6] + g) | 0;
	            H[7] = (H[7] + h) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA256('message');
	     *     var hash = CryptoJS.SHA256(wordArray);
	     */
	    C.SHA256 = Hasher._createHelper(SHA256);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA256(message, key);
	     */
	    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
	}(Math));


	return CryptoJS.SHA256;

}));

/***/ }),
/* 37 */
/***/ (function(module, exports, __nested_webpack_require_397531__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_397531__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Reusable object
	    var W = [];

	    /**
	     * SHA-1 hash algorithm.
	     */
	    var SHA1 = C_algo.SHA1 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476,
	                0xc3d2e1f0
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Shortcut
	            var H = this._hash.words;

	            // Working variables
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];
	            var e = H[4];

	            // Computation
	            for (var i = 0; i < 80; i++) {
	                if (i < 16) {
	                    W[i] = M[offset + i] | 0;
	                } else {
	                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
	                    W[i] = (n << 1) | (n >>> 31);
	                }

	                var t = ((a << 5) | (a >>> 27)) + e + W[i];
	                if (i < 20) {
	                    t += ((b & c) | (~b & d)) + 0x5a827999;
	                } else if (i < 40) {
	                    t += (b ^ c ^ d) + 0x6ed9eba1;
	                } else if (i < 60) {
	                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;
	                } else /* if (i < 80) */ {
	                    t += (b ^ c ^ d) - 0x359d3e2a;
	                }

	                e = d;
	                d = c;
	                c = (b << 30) | (b >>> 2);
	                b = a;
	                a = t;
	            }

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	            H[4] = (H[4] + e) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;
	            data.sigBytes = dataWords.length * 4;

	            // Hash final blocks
	            this._process();

	            // Return final computed hash
	            return this._hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.SHA1('message');
	     *     var hash = CryptoJS.SHA1(wordArray);
	     */
	    C.SHA1 = Hasher._createHelper(SHA1);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacSHA1(message, key);
	     */
	    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
	}());


	return CryptoJS.SHA1;

}));

/***/ }),
/* 38 */
/***/ (function(module, exports, __nested_webpack_require_401654__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_401654__(12), __nested_webpack_require_401654__(36), __nested_webpack_require_401654__(29));
	}
	else {}
}(this, function (CryptoJS) {

	return CryptoJS.HmacSHA256;

}));

/***/ }),
/* 39 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_402006__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_402006__(1);
/* harmony import */ var _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_402006__(15);
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_402006__(3);
/* harmony import */ var _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_402006__(7);
/* harmony import */ var platform_http__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_402006__(6);
/* harmony import */ var _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_402006__(2);
/* harmony import */ var _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_402006__(4);
/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__ = __nested_webpack_require_402006__(0);









var JSONPTransport = function(connectionManager) {
	var noop = function() {};
	/* Can't just use window.Ably, as that won't exist if using the commonjs version. */
	var _ = global._ablyjs_jsonp = {};

	/* express strips out parantheses from the callback!
	 * Kludge to still alow its responses to work, while not keeping the
	 * function form for normal use and not cluttering window.Ably
	 * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305
	 */
	_._ = function(id) { return _['_' + id] || noop; };
	var idCounter = 1;
	var head = null;
	var shortName = 'jsonp';

	/* public constructor */
	function JSONPTransport(connectionManager, auth, params) {
		params.stream = false;
		_common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(JSONPTransport, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"]);

	JSONPTransport.isAvailable = function() {
		return platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].allowComet;
	};
	if(JSONPTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = JSONPTransport;
	}
	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported) {
		head = document.getElementsByTagName('head')[0];
	}

	/* connectivity check; since this has a hard-coded callback id,
	 * we just make sure that we handle concurrent requests (but the
	 * connectionmanager should ensure this doesn't happen anyway */
	var checksInProgress = null;
	global.JSONPTransport = JSONPTransport

	JSONPTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new JSONPTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MINOR, 'JSONPTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	JSONPTransport.prototype.toString = function() {
		return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	var createRequest = JSONPTransport.prototype.createRequest = function(uri, headers, params, body, requestMode, timeouts, method) {
		/* JSONP requests are used either with the context being a realtime
		 * transport, or with timeouts passed in (for when used by a rest client),
		 * or completely standalone.  Use the appropriate timeouts in each case */
		timeouts = (this && this.timeouts) || timeouts || _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS;
		return new Request(undefined, uri, headers, _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].copy(params), body, requestMode, timeouts, method);
	};

	function Request(id, uri, headers, params, body, requestMode, timeouts, method) {
		_common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].call(this);
		if(id === undefined) id = idCounter++;
		this.id = id;
		this.uri = uri;
		this.params = params || {};
		this.params.rnd = _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].cheapRandStr();
		if(headers) {
			/* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */
			if(headers['X-Ably-Version']) this.params.v = headers['X-Ably-Version'];
			if(headers['Ably-Agent']) this.params.agent = headers['Ably-Agent'];
		}
		this.body = body;
		this.method = method;
		this.requestMode = requestMode;
		this.timeouts = timeouts;
		this.requestComplete = false;
	}
	_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inherits(Request, _common_lib_util_eventemitter__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"]);

	Request.prototype.exec = function() {
		var id = this.id,
			body = this.body,
			method = this.method,
			uri = this.uri,
			params = this.params,
			self = this;

		params.callback = '_ablyjs_jsonp._(' + id + ')';

		params.envelope = 'jsonp';
		if(body) {
			params.body = body;
		}
		if(method && method !== 'get') {
			params.method = method;
		}

		var script = this.script = document.createElement('script');
		var src = uri + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].toQueryString(params);
		script.src = src;
		if(script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {
			/* The src has been truncated. Can't abort, but can at least emit an
			 * error so the user knows what's gone wrong. (Can't compare strings
			 * directly as src may have a port, script.src won't) */
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');
		}
		script.async = true;
		script.type = 'text/javascript';
		script.charset = 'UTF-8';
		script.onerror = function(err) {
			self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('JSONP script error (event: ' + _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].inspect(err) + ')', null, 400));
		};

		_['_' + id] = function(message) {
			if(message.statusCode) {
				/* Handle as enveloped jsonp, as all jsonp transport uses should be */
				var response = message.response;
				if(message.statusCode == 204) {
					self.complete(null, null, null, message.statusCode);
				} else if(!response) {
					self.complete(new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Invalid server response: no envelope detected', null, 500));
				} else if(message.statusCode < 400 || _common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].isArray(response)) {
					/* If response is an array, it's an array of protocol messages -- even if
					 * it contains an error action (hence the nonsuccess statuscode), we can
					 * consider the request to have succeeded, just pass it on to
					 * onProtocolMessage to decide what to do */
					self.complete(null, response, message.headers, message.statusCode);
				} else {
					var err = response.error || new _common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"]('Error response received from server', null, message.statusCode);
					self.complete(err);
				}
			} else {
				/* Handle as non-enveloped -- as will be eg from a customer's authUrl server */
				self.complete(null, message);
			}
		};

		var timeout = (this.requestMode == _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND) ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;
		this.timer = setTimeout(function() { self.abort(); }, timeout);
		head.insertBefore(script, head.firstChild);
	};

	Request.prototype.complete = function(err, body, headers, statusCode) {
		headers = headers || {};
		if(!this.requestComplete) {
			this.requestComplete = true;
			var contentType;
			if(body) {
				contentType = (typeof(body) == 'string') ? 'text/plain' : 'application/json';
				headers['content-type'] = contentType;
				this.emit('data', body);
			}

			this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);
			this.dispose();
		}
	};

	Request.prototype.abort = function() {
		this.dispose();
	};

	Request.prototype.dispose = function() {
		var timer = this.timer;
		if(timer) {
			clearTimeout(timer);
			this.timer = null;
		}
		var script = this.script;
		if(script.parentNode) script.parentNode.removeChild(script);
		delete _[this.id];
		this.emit('disposed');
	};

	if(platform__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].jsonpSupported && !platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request) {
		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].Request = function(method, rest, uri, headers, params, body, callback) {
			var req = createRequest(uri, headers, params, body, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, rest && rest.options.timeouts, method);
			req.once('complete', callback);
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
			return req;
		};

		platform_http__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].checkConnectivity = function(callback) {
			var upUrl = _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].jsonpInternetUpUrl;

			if(checksInProgress) {
				checksInProgress.push(callback);
				return;
			}
			checksInProgress = [callback];
			_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);

			var req = new Request('isTheInternetUp', upUrl, null, null, null, _common_lib_transport_comettransport__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].REQ_SEND, _common_lib_util_defaults__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"].TIMEOUTS);
			req.once('complete', function(err, response) {
				var result = !err && response;
				_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_7__[/* default */ "a"].LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);
				for(var i = 0; i < checksInProgress.length; i++) checksInProgress[i](null, result);
				checksInProgress = null;
			});
			_common_lib_util_utils__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].nextTick(function() {
				req.exec();
			});
		};
	}

	return JSONPTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (JSONPTransport);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_402006__(17)))

/***/ }),
/* 40 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_413601__) {

"use strict";
/* harmony import */ var platform__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_413601__(3);
/* harmony import */ var _util_utils__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_413601__(1);
/* harmony import */ var _transport__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_413601__(20);
/* harmony import */ var _util_defaults__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_413601__(4);
/* harmony import */ var _util_logger__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_413601__(0);
/* harmony import */ var _types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__ = __nested_webpack_require_413601__(8);
/* harmony import */ var _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__ = __nested_webpack_require_413601__(2);








var WebSocketTransport = function(connectionManager) {
	var WebSocket = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].WebSocket;
	var shortName = 'web_socket';

	/* public constructor */
	function WebSocketTransport(connectionManager, auth, params) {
		this.shortName = shortName;
		/* If is a browser, can't detect pings, so request protocol heartbeats */
		params.heartbeats = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].useProtocolHeartbeats;
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].call(this, connectionManager, auth, params);
		this.wsHost = _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getHost(params.options, params.host, true);
	}
	_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inherits(WebSocketTransport, _transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"]);

	WebSocketTransport.isAvailable = function() {
		return !!WebSocket;
	};

	if(WebSocketTransport.isAvailable())
		connectionManager.supportedTransports[shortName] = WebSocketTransport;

	WebSocketTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new WebSocketTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('wsopen', function() {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	WebSocketTransport.prototype.createWebSocket = function(uri, connectParams) {
		this.uri = uri + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].toQueryString(connectParams)
		return new WebSocket(this.uri);
	};

	WebSocketTransport.prototype.toString = function() {
		return 'WebSocketTransport; uri=' + this.uri;
	};

	WebSocketTransport.prototype.connect = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'starting');
		_transport__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"].prototype.connect.call(this);
		var self = this, params = this.params, options = params.options;
		var wsScheme = options.tls ? 'wss://' : 'ws://';
		var wsUri = wsScheme + this.wsHost + ':' + _util_defaults__WEBPACK_IMPORTED_MODULE_3__[/* default */ "a"].getPort(options) + '/';
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);
		this.auth.getAuthParams(function(err, authParams) {
			if(self.isDisposed) {
				return;
			}
			var paramStr = ''; for(var param in authParams) paramStr += ' ' + param + ': ' + authParams[param] + ';';
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);
			if(err) {
				self.disconnect(err);
				return;
			}
			var connectParams = params.getConnectParams(authParams);
			try {
				var wsConnection = self.wsConnection = self.createWebSocket(wsUri, connectParams);
				wsConnection.binaryType = platform__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].binaryType;
				wsConnection.onopen = function() { self.onWsOpen(); };
				wsConnection.onclose = function(ev) { self.onWsClose(ev); };
				wsConnection.onmessage = function(ev) { self.onWsData(ev.data); };
				wsConnection.onerror = function(ev) { self.onWsError(ev); };
				if(wsConnection.on) {
					/* node; browsers currently don't have a general eventemitter and can't detect
					 * pings. Also, no need to reply with a pong explicitly, ws lib handles that */
					wsConnection.on('ping', function() { self.onActivity(); });
				}
			} catch(e) {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));
				self.disconnect(e);
			}
		});
	};

	WebSocketTransport.prototype.send = function(message) {
		var wsConnection = this.wsConnection;
		if(!wsConnection) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');
			return;
		}
		try {
			wsConnection.send(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].serialize(message, this.params.format));
		} catch (e) {
			var msg = 'Exception from ws connection when trying to send: ' + _util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].inspectError(e);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.send()', msg);
			/* Don't try to request a disconnect, that'll just involve sending data
			 * down the websocket again. Just finish the transport. */
			this.finish('disconnected', new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 50000, 500));
		}
	};

	WebSocketTransport.prototype.onWsData = function(data) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof(data));
		try {
			this.onProtocolMessage(_types_protocolmessage__WEBPACK_IMPORTED_MODULE_5__[/* default */ "a"].deserialize(data, this.format));
		} catch (e) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);
		}
	};

	WebSocketTransport.prototype.onWsOpen = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');
		this.emit('wsopen');
	};

	WebSocketTransport.prototype.onWsClose = function(ev) {
		var wasClean, code, reason;
		if(typeof(ev) == 'object') {
			/* W3C spec-compatible */
			wasClean = ev.wasClean;
			code = ev.code;
		} else /*if(typeof(ev) == 'number')*/ {
			/* ws in node */
			code = ev;
			wasClean = (code == 1000);
		}
		delete this.wsConnection;
		if(wasClean) {
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');
			var err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"]('Websocket closed', 80003, 400);
			this.finish('disconnected', err);
		} else {
			var msg = 'Unclean disconnection of WebSocket ; code = ' + code,
				err = new _types_errorinfo__WEBPACK_IMPORTED_MODULE_6__[/* default */ "a"](msg, 80003, 400);
			_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);
			this.finish('disconnected', err);
		}
		this.emit('disposed');
	};

	WebSocketTransport.prototype.onWsError = function(err) {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);
		/* Wait a tick before aborting: if the websocket was connected, this event
		 * will be immediately followed by an onclose event with a close code. Allow
		 * that to close it (so we see the close code) rather than anticipating it */
		var self = this;
		_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
			self.disconnect(err);
		});
	};

	WebSocketTransport.prototype.dispose = function() {
		_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MINOR, 'WebSocketTransport.dispose()', '');
		this.isDisposed = true;
		var wsConnection = this.wsConnection;
		if(wsConnection) {
			/* Ignore any messages that come through after dispose() is called but before
			 * websocket is actually closed. (mostly would be harmless, but if it's a
			 * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */
			wsConnection.onmessage = function() {};
			delete this.wsConnection;
			/* defer until the next event loop cycle before closing the socket,
			 * giving some implementations the opportunity to send any outstanding close message */
			_util_utils__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"].nextTick(function() {
				_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].logAction(_util_logger__WEBPACK_IMPORTED_MODULE_4__[/* default */ "a"].LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');
				wsConnection.close();
			});
		}
	};

	return WebSocketTransport;
};

/* harmony default export */ __webpack_exports__["a"] = (WebSocketTransport);


/***/ }),
/* 41 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_424053__) {

"use strict";

// EXTERNAL MODULE: ./browser/lib/transport/jsonptransport.js
var jsonptransport = __nested_webpack_require_424053__(39);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_424053__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_424053__(0);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_424053__(3);

// EXTERNAL MODULE: ./common/lib/transport/comettransport.js
var comettransport = __nested_webpack_require_424053__(15);

// EXTERNAL MODULE: ./browser/lib/transport/xhrrequest.js
var xhrrequest = __nested_webpack_require_424053__(27);

// CONCATENATED MODULE: ./browser/lib/transport/xhrpollingtransport.js






var xhrpollingtransport_XHRPollingTransport = function(connectionManager) {
	var shortName = 'xhr_polling';

	function XHRPollingTransport(connectionManager, auth, params) {
		params.stream = false;
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRPollingTransport, comettransport["a" /* default */]);

	XHRPollingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRPollingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRPollingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRPollingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRPollingTransport.prototype.toString = function() {
		return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRPollingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRPollingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRPollingTransport;
	}

	return XHRPollingTransport;
};

/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/xhrstreamingtransport.js






var xhrstreamingtransport_XHRStreamingTransport = function(connectionManager) {
	var shortName = 'xhr_streaming';

	/* public constructor */
	function XHRStreamingTransport(connectionManager, auth, params) {
		comettransport["a" /* default */].call(this, connectionManager, auth, params);
		this.shortName = shortName;
	}
	utils["a" /* default */].inherits(XHRStreamingTransport, comettransport["a" /* default */]);

	XHRStreamingTransport.isAvailable = function() {
		return platform_browser["a" /* default */].xhrSupported && platform_browser["a" /* default */].streamingSupported && platform_browser["a" /* default */].allowComet;
	};

	XHRStreamingTransport.tryConnect = function(connectionManager, auth, params, callback) {
		var transport = new XHRStreamingTransport(connectionManager, auth, params);
		var errorCb = function(err) { callback({event: this.event, error: err}); };
		transport.on(['failed', 'disconnected'], errorCb);
		transport.on('preconnect', function() {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'XHRStreamingTransport.tryConnect()', 'viable transport ' + transport);
			transport.off(['failed', 'disconnected'], errorCb);
			callback(null, transport);
		});
		transport.connect();
	};

	XHRStreamingTransport.prototype.toString = function() {
		return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;
	};

	XHRStreamingTransport.prototype.createRequest = function(uri, headers, params, body, requestMode) {
		return xhrrequest["a" /* default */].createRequest(uri, headers, params, body, requestMode, this.timeouts);
	};

	if(typeof(connectionManager) !== 'undefined' && XHRStreamingTransport.isAvailable()) {
		connectionManager.supportedTransports[shortName] = XHRStreamingTransport;
	}

	return XHRStreamingTransport;
};

/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);

// CONCATENATED MODULE: ./browser/lib/transport/index.js




/* harmony default export */ var lib_transport = __webpack_exports__["a"] = ([
  jsonptransport["a" /* default */],
  xhrpollingtransport,
  xhrstreamingtransport
]);


/***/ }),
/* 42 */
/***/ (function(module, exports, __nested_webpack_require_429019__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__nested_webpack_require_429019__(43);
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_429019__(17)))

/***/ }),
/* 43 */
/***/ (function(module, exports, __nested_webpack_require_431301__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_431301__(17), __nested_webpack_require_431301__(44)))

/***/ }),
/* 44 */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),
/* 45 */
/***/ (function(module, exports) {



/***/ }),
/* 46 */
/***/ (function(module, exports, __nested_webpack_require_443919__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_443919__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var C_enc = C.enc;

	    /**
	     * UTF-16 BE encoding strategy.
	     */
	    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
	        /**
	         * Converts a word array to a UTF-16 BE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 BE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 BE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 BE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    /**
	     * UTF-16 LE encoding strategy.
	     */
	    C_enc.Utf16LE = {
	        /**
	         * Converts a word array to a UTF-16 LE string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-16 LE string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var utf16Chars = [];
	            for (var i = 0; i < sigBytes; i += 2) {
	                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);
	                utf16Chars.push(String.fromCharCode(codePoint));
	            }

	            return utf16Chars.join('');
	        },

	        /**
	         * Converts a UTF-16 LE string to a word array.
	         *
	         * @param {string} utf16Str The UTF-16 LE string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
	         */
	        parse: function (utf16Str) {
	            // Shortcut
	            var utf16StrLength = utf16Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < utf16StrLength; i++) {
	                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));
	            }

	            return WordArray.create(words, utf16StrLength * 2);
	        }
	    };

	    function swapEndian(word) {
	        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);
	    }
	}());


	return CryptoJS.enc.Utf16;

}));

/***/ }),
/* 47 */
/***/ (function(module, exports, __nested_webpack_require_448064__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_448064__(12), __nested_webpack_require_448064__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function (undefined) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var CipherParams = C_lib.CipherParams;
	    var C_enc = C.enc;
	    var Hex = C_enc.Hex;
	    var C_format = C.format;

	    var HexFormatter = C_format.Hex = {
	        /**
	         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
	         *
	         * @param {CipherParams} cipherParams The cipher params object.
	         *
	         * @return {string} The hexadecimally encoded string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
	         */
	        stringify: function (cipherParams) {
	            return cipherParams.ciphertext.toString(Hex);
	        },

	        /**
	         * Converts a hexadecimally encoded ciphertext string to a cipher params object.
	         *
	         * @param {string} input The hexadecimally encoded string.
	         *
	         * @return {CipherParams} The cipher params object.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
	         */
	        parse: function (input) {
	            var ciphertext = Hex.parse(input);
	            return CipherParams.create({ ciphertext: ciphertext });
	        }
	    };
	}());


	return CryptoJS.format.Hex;

}));

/***/ }),
/* 48 */
/***/ (function(module, exports, __nested_webpack_require_449837__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_449837__(12), __nested_webpack_require_449837__(18), __nested_webpack_require_449837__(49), __nested_webpack_require_449837__(30), __nested_webpack_require_449837__(31));
	}
	else {}
}(this, function (CryptoJS) {

	(function () {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var BlockCipher = C_lib.BlockCipher;
	    var C_algo = C.algo;

	    // Lookup tables
	    var SBOX = [];
	    var INV_SBOX = [];
	    var SUB_MIX_0 = [];
	    var SUB_MIX_1 = [];
	    var SUB_MIX_2 = [];
	    var SUB_MIX_3 = [];
	    var INV_SUB_MIX_0 = [];
	    var INV_SUB_MIX_1 = [];
	    var INV_SUB_MIX_2 = [];
	    var INV_SUB_MIX_3 = [];

	    // Compute lookup tables
	    (function () {
	        // Compute double table
	        var d = [];
	        for (var i = 0; i < 256; i++) {
	            if (i < 128) {
	                d[i] = i << 1;
	            } else {
	                d[i] = (i << 1) ^ 0x11b;
	            }
	        }

	        // Walk GF(2^8)
	        var x = 0;
	        var xi = 0;
	        for (var i = 0; i < 256; i++) {
	            // Compute sbox
	            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);
	            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;
	            SBOX[x] = sx;
	            INV_SBOX[sx] = x;

	            // Compute multiplication
	            var x2 = d[x];
	            var x4 = d[x2];
	            var x8 = d[x4];

	            // Compute sub bytes, mix columns tables
	            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);
	            SUB_MIX_0[x] = (t << 24) | (t >>> 8);
	            SUB_MIX_1[x] = (t << 16) | (t >>> 16);
	            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);
	            SUB_MIX_3[x] = t;

	            // Compute inv sub bytes, inv mix columns tables
	            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);
	            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);
	            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);
	            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);
	            INV_SUB_MIX_3[sx] = t;

	            // Compute next counter
	            if (!x) {
	                x = xi = 1;
	            } else {
	                x = x2 ^ d[d[d[x8 ^ x2]]];
	                xi ^= d[d[xi]];
	            }
	        }
	    }());

	    // Precomputed Rcon lookup
	    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

	    /**
	     * AES block cipher algorithm.
	     */
	    var AES = C_algo.AES = BlockCipher.extend({
	        _doReset: function () {
	            var t;

	            // Skip reset of nRounds has been set before and key did not change
	            if (this._nRounds && this._keyPriorReset === this._key) {
	                return;
	            }

	            // Shortcuts
	            var key = this._keyPriorReset = this._key;
	            var keyWords = key.words;
	            var keySize = key.sigBytes / 4;

	            // Compute number of rounds
	            var nRounds = this._nRounds = keySize + 6;

	            // Compute number of key schedule rows
	            var ksRows = (nRounds + 1) * 4;

	            // Compute key schedule
	            var keySchedule = this._keySchedule = [];
	            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
	                if (ksRow < keySize) {
	                    keySchedule[ksRow] = keyWords[ksRow];
	                } else {
	                    t = keySchedule[ksRow - 1];

	                    if (!(ksRow % keySize)) {
	                        // Rot word
	                        t = (t << 8) | (t >>> 24);

	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];

	                        // Mix Rcon
	                        t ^= RCON[(ksRow / keySize) | 0] << 24;
	                    } else if (keySize > 6 && ksRow % keySize == 4) {
	                        // Sub word
	                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];
	                    }

	                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
	                }
	            }

	            // Compute inv key schedule
	            var invKeySchedule = this._invKeySchedule = [];
	            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
	                var ksRow = ksRows - invKsRow;

	                if (invKsRow % 4) {
	                    var t = keySchedule[ksRow];
	                } else {
	                    var t = keySchedule[ksRow - 4];
	                }

	                if (invKsRow < 4 || ksRow <= 4) {
	                    invKeySchedule[invKsRow] = t;
	                } else {
	                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^
	                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
	                }
	            }
	        },

	        encryptBlock: function (M, offset) {
	            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
	        },

	        decryptBlock: function (M, offset) {
	            // Swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;

	            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

	            // Inv swap 2nd and 4th rows
	            var t = M[offset + 1];
	            M[offset + 1] = M[offset + 3];
	            M[offset + 3] = t;
	        },

	        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
	            // Shortcut
	            var nRounds = this._nRounds;

	            // Get input, add round key
	            var s0 = M[offset]     ^ keySchedule[0];
	            var s1 = M[offset + 1] ^ keySchedule[1];
	            var s2 = M[offset + 2] ^ keySchedule[2];
	            var s3 = M[offset + 3] ^ keySchedule[3];

	            // Key schedule row counter
	            var ksRow = 4;

	            // Rounds
	            for (var round = 1; round < nRounds; round++) {
	                // Shift rows, sub bytes, mix columns, add round key
	                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
	                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
	                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
	                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

	                // Update state
	                s0 = t0;
	                s1 = t1;
	                s2 = t2;
	                s3 = t3;
	            }

	            // Shift rows, sub bytes, add round key
	            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
	            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
	            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
	            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

	            // Set output
	            M[offset]     = t0;
	            M[offset + 1] = t1;
	            M[offset + 2] = t2;
	            M[offset + 3] = t3;
	        },

	        keySize: 256/32
	    });

	    /**
	     * Shortcut functions to the cipher's object interface.
	     *
	     * @example
	     *
	     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
	     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
	     */
	    C.AES = BlockCipher._createHelper(AES);
	}());


	return CryptoJS.AES;

}));

/***/ }),
/* 49 */
/***/ (function(module, exports, __nested_webpack_require_458579__) {

;(function (root, factory) {
	if (true) {
		// CommonJS
		module.exports = exports = factory(__nested_webpack_require_458579__(12));
	}
	else {}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/***/ }),
/* 50 */
/***/ (function(module, __webpack_exports__, __nested_webpack_require_468187__) {

"use strict";
// ESM COMPAT FLAG
__nested_webpack_require_468187__.r(__webpack_exports__);

// EXTERNAL MODULE: ./browser/fragments/platform-browser.js
var platform_browser = __nested_webpack_require_468187__(3);

// EXTERNAL MODULE: ./common/lib/util/utils.js
var utils = __nested_webpack_require_468187__(1);

// EXTERNAL MODULE: ./common/lib/util/logger.js
var logger = __nested_webpack_require_468187__(0);

// EXTERNAL MODULE: ./common/lib/util/defaults.js + 1 modules
var defaults = __nested_webpack_require_468187__(4);

// EXTERNAL MODULE: ./common/lib/client/auth.js + 1 modules
var auth = __nested_webpack_require_468187__(14);

// CONCATENATED MODULE: ./common/lib/types/devicedetails.js


var devicedetails_DeviceDetails = (function() {

	function DeviceDetails() {
		this.id = undefined;
		this.deviceSecret = undefined;
		this.platform = undefined;
		this.formFactor = undefined;
		this.clientId = undefined;
		this.metadata = undefined;
		this.deviceIdentityToken = undefined;
		this.push = {
			recipient: undefined,
			state: undefined,
			error: undefined
		};
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	DeviceDetails.prototype.toJSON = function() {
		return {
			id: this.id,
			deviceSecret: this.deviceSecret,
			platform: this.platform,
			formFactor: this.formFactor,
			clientId: this.clientId,
			metadata: this.metadata,
			deviceIdentityToken: this.deviceIdentityToken,
			push: {
				recipient: this.push.recipient,
				state: this.push.state,
				error: this.push.error
			}
		};
	};

	DeviceDetails.prototype.toString = function() {
		var result = '[DeviceDetails';
		if(this.id)
			result += '; id=' + this.id;
		if(this.platform)
			result += '; platform=' + this.platform;
		if(this.formFactor)
			result += '; formFactor=' + this.formFactor;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		if(this.metadata)
			result += '; metadata=' + this.metadata;
		if(this.deviceIdentityToken)
			result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);
		if(this.push.recipient)
			result += '; push.recipient=' + JSON.stringify(this.push.recipient);
		if(this.push.state)
			result += '; push.state=' + this.push.state;
		if(this.push.error)
			result += '; push.error=' + JSON.stringify(this.push.error);
		if(this.push.metadata)
			result += '; push.metadata=' + this.push.metadata;
		result += ']';
		return result;
	};

	DeviceDetails.toRequestBody = utils["a" /* default */].encodeBody;

	DeviceDetails.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return DeviceDetails.fromValuesArray(body);
		} else {
			return DeviceDetails.fromValues(body);
		}
	};

	DeviceDetails.fromValues = function(values) {
		values.error = values.error && ErrorInfo.fromValues(values.error); 
		return utils["a" /* default */].mixin(new DeviceDetails(), values);
	};

	DeviceDetails.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = DeviceDetails.fromValues(values[i]);
		return result;
	};

	return DeviceDetails;
})();

/* harmony default export */ var devicedetails = (devicedetails_DeviceDetails);

// EXTERNAL MODULE: ./browser/lib/util/http.js
var http = __nested_webpack_require_468187__(6);

// EXTERNAL MODULE: ./browser/lib/util/bufferutils.js
var bufferutils = __nested_webpack_require_468187__(5);

// CONCATENATED MODULE: ./common/lib/client/resource.js







var resource_Resource = (function() {
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Resource() {}

	function withAuthDetails(rest, headers, params, errCallback, opCallback) {
		if (http["a" /* default */].supportsAuthHeaders) {
			rest.auth.getAuthHeaders(function(err, authHeaders) {
				if(err)
					errCallback(err);
				else
					opCallback(utils["a" /* default */].mixin(authHeaders, headers), params);
			});
		} else {
			rest.auth.getAuthParams(function(err, authParams) {
				if(err)
					errCallback(err);
				else
					opCallback(headers, utils["a" /* default */].mixin(authParams, params));
			});
		}
	}

	function unenvelope(callback, format) {
		return function(err, body, outerHeaders, unpacked, outerStatusCode) {
			if(err && !body) {
				callback(err);
				return;
			}

			if(!unpacked) {
				try {
					body = utils["a" /* default */].decodeBody(body, format);
				} catch(e) {
					callback(e);
					return;
				}
			}

			if(body.statusCode === undefined) {
				/* Envelope already unwrapped by the transport */
				callback(err, body, outerHeaders, true, outerStatusCode);
				return;
			}

			var wrappedStatusCode = body.statusCode,
				response = body.response,
				wrappedHeaders = body.headers;

			if(wrappedStatusCode < 200 || wrappedStatusCode >= 300) {
				/* handle wrapped errors */
				var wrappedErr = (response && response.error) || err;
				if(!wrappedErr) {
					wrappedErr = new Error("Error in unenveloping " + body);
					wrappedErr.statusCode = wrappedStatusCode;
				}
				callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);
				return;
			}

			callback(err, response, wrappedHeaders, true, wrappedStatusCode);
		};
	}

	function paramString(params) {
		var paramPairs = [];
		if (params) {
			for (var needle in params) {
				paramPairs.push(needle + '=' + params[needle]);
			}
		}
		return paramPairs.join('&');
	}

	function urlFromPathAndParams(path, params) {
		return path + (params ? '?' : '') + paramString(params);
	}

	function logResponseHandler(callback, method, path, params) {
		return function(err, body, headers, unpacked, statusCode) {
			if (err) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + utils["a" /* default */].inspectError(err));
			} else {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()',
					'Received; ' + urlFromPathAndParams(path, params) + '; Headers: ' + paramString(headers) + '; StatusCode: ' + statusCode + '; Body: ' + (bufferutils["a" /* default */].isBuffer(body) ? body.toString() : body));
			}
			if (callback) { callback(err, body, headers, unpacked, statusCode); }
		}
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		Resource[method] = function(rest, path, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, null, origheaders, origparams, envelope, callback);
		};
	});

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		Resource[method] = function(rest, path, body, origheaders, origparams, envelope, callback) {
			Resource['do'](method, rest, path, body, origheaders, origparams, envelope, callback);
		};
	});

	Resource['do'] = function(method, rest, path, body, origheaders, origparams, envelope, callback) {
		if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
			callback = logResponseHandler(callback, method, path, origparams);
		}

		if(envelope) {
			callback = (callback && unenvelope(callback, envelope));
			(origparams = (origparams || {}))['envelope'] = envelope;
		}

		function doRequest(headers, params) {
			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));
			}

			var args = [rest, path, headers, body, params, function(err, res, headers, unpacked, statusCode) {
				if(err && auth["a" /* default */].isTokenErr(err)) {
					/* token has expired, so get a new one */
					rest.auth.authorize(null, null, function(err) {
						if(err) {
							callback(err);
							return;
						}
						/* retry ... */
						withAuthDetails(rest, origheaders, origparams, callback, doRequest);
					});
					return;
				}
				callback(err, res, headers, unpacked, statusCode);
			}];
			if (!body) {
				args.splice(3, 1);
			}

			if (logger["a" /* default */].shouldLog(logger["a" /* default */].LOG_MICRO)) {
				var decodedBody = body;
				if ((headers['content-type'] || '').indexOf('msgpack') > 0) {
					try {
						decodedBody = msgpack.decode(body);
					} catch (decodeErr) {
						logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + utils["a" /* default */].inspectError(decodeErr));
					}
				}
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);
			}
			http["a" /* default */][method].apply(this, args);
		}

		withAuthDetails(rest, origheaders, origparams, callback, doRequest);
	};

	return Resource;
})();

/* harmony default export */ var client_resource = (resource_Resource);

// CONCATENATED MODULE: ./common/lib/client/paginatedresource.js





var paginatedresource_PaginatedResource = (function() {

	function getRelParams(linkUrl) {
		var urlMatch = linkUrl.match(/^\.\/(\w+)\?(.*)$/);
		return urlMatch && utils["a" /* default */].parseQueryString(urlMatch[2]);
	}

	function parseRelLinks(linkHeader) {
		if(typeof(linkHeader) == 'string')
			linkHeader = linkHeader.split(',');

		var relParams = {};
		for(var i = 0; i < linkHeader.length; i++) {
			var linkMatch = linkHeader[i].match(/^\s*<(.+)>;\s*rel="(\w+)"$/);
			if(linkMatch) {
				var params = getRelParams(linkMatch[1]);
				if(params)
					relParams[linkMatch[2]] = params;
			}
		}
		return relParams;
	}

	function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {
		this.rest = rest;
		this.path = path;
		this.headers = headers;
		this.envelope = envelope;
		this.bodyHandler = bodyHandler;
		this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;
	}

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithoutBody, function(method) {
		PaginatedResource.prototype[method] = function(params, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, self.headers, params, self.envelope, function(err, body, headers, unpacked, statusCode) {
				self.handlePage(err, body, headers, unpacked, statusCode, callback);
			});
		};
	})

	utils["a" /* default */].arrForEach(http["a" /* default */].methodsWithBody, function(method) {
		PaginatedResource.prototype[method] = function(params, body, callback) {
			var self = this;
			client_resource[method](self.rest, self.path, body, self.headers, params, self.envelope, function(err, resbody, headers, unpacked, statusCode) {
				if(callback) {
					self.handlePage(err, resbody, headers, unpacked, statusCode, callback);
				}
			});
		};
	});

	function returnErrOnly(err, body, useHPR) {
		/* If using httpPaginatedResponse, errors from Ably are returned as part of
		 * the HPR, only do callback(err) for network errors etc. which don't
		 * return a body and/or have no ably-originated error code (non-numeric
		 * error codes originate from node) */
		return !(useHPR && (body || typeof err.code === 'number'));
	}

	PaginatedResource.prototype.handlePage = function(err, body, headers, unpacked, statusCode, callback) {
		if(err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + utils["a" /* default */].inspectError(err));
			callback(err);
			return;
		}
		var items, linkHeader, relParams;
		try {
			items = this.bodyHandler(body, headers, unpacked);
		} catch(e) {
			/* If we got an error, the failure to parse the body is almost certainly
			 * due to that, so cb with that in preference to the parse error */
			callback(err || e);
			return;
		}

		if(headers && (linkHeader = (headers['Link'] || headers['link']))) {
			relParams = parseRelLinks(linkHeader);
		}

		if(this.useHttpPaginatedResponse) {
			callback(null, new HttpPaginatedResponse(this, items, headers, statusCode, relParams, err));
		} else {
			callback(null, new PaginatedResult(this, items, relParams));
		}
	};

	function PaginatedResult(resource, items, relParams) {
		this.resource = resource;
		this.items = items;

		if(relParams) {
			var self = this;
			if('first' in relParams) {
				this.first = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'first', []);
					}
					self.get(relParams.first, cb);
				};
			}
			if('current' in relParams) {
				this.current = function(cb) {
					if(!cb && self.resource.rest.options.promises) {
						return utils["a" /* default */].promisify(self, 'current', []);
					}
					self.get(relParams.current, cb);
				};
			}
			this.next = function(cb) {
				if(!cb && self.resource.rest.options.promises) {
					return utils["a" /* default */].promisify(self, 'next', []);
				}
				if('next' in relParams) {
					self.get(relParams.next, cb);
				} else {
					cb(null, null);
				}
			};

			this.hasNext = function() { return ('next' in relParams) };
			this.isLast = function() { return !this.hasNext(); }
		}
	}

	/* We assume that only the initial request can be a POST, and that accessing
	 * the rest of a multipage set of results can always be done with GET */
	PaginatedResult.prototype.get = function(params, callback) {
		var res = this.resource;
		client_resource.get(res.rest, res.path, res.headers, params, res.envelope, function(err, body, headers, unpacked, statusCode) {
			res.handlePage(err, body, headers, unpacked, statusCode, callback);
		});
	};

	function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {
		PaginatedResult.call(this, resource, items, relParams);
		this.statusCode = statusCode;
		this.success = statusCode < 300 && statusCode >= 200;
		this.headers = headers;
		this.errorCode = err && err.code;
		this.errorMessage = err && err.message;
	}
	utils["a" /* default */].inherits(HttpPaginatedResponse, PaginatedResult);

	return PaginatedResource;
})();

/* harmony default export */ var paginatedresource = (paginatedresource_PaginatedResource);

// EXTERNAL MODULE: ./common/lib/types/errorinfo.js
var errorinfo = __nested_webpack_require_468187__(2);

// CONCATENATED MODULE: ./common/lib/types/pushchannelsubscription.js


var pushchannelsubscription_PushChannelSubscription = (function() {

	function PushChannelSubscription() {
		this.channel = undefined;
		this.deviceId = undefined;
		this.clientId = undefined;
	}

	/**
	 * Overload toJSON() to intercept JSON.stringify()
	 * @return {*}
	 */
	PushChannelSubscription.prototype.toJSON = function() {
		return {
			channel: this.channel,
			deviceId: this.deviceId,
			clientId: this.clientId
		};
	};

	PushChannelSubscription.prototype.toString = function() {
		var result = '[PushChannelSubscription';
		if(this.channel)
			result += '; channel=' + this.channel;
		if(this.deviceId)
			result += '; deviceId=' + this.deviceId;
		if(this.clientId)
			result += '; clientId=' + this.clientId;
		result += ']';
		return result;
	};

	PushChannelSubscription.toRequestBody = utils["a" /* default */].encodeBody;

	PushChannelSubscription.fromResponseBody = function(body, format) {
		if(format) {
			body = utils["a" /* default */].decodeBody(body, format);
		}

		if(utils["a" /* default */].isArray(body)) {
			return PushChannelSubscription.fromValuesArray(body);
		} else {
			return PushChannelSubscription.fromValues(body);
		}
	};

	PushChannelSubscription.fromValues = function(values) {
		return utils["a" /* default */].mixin(new PushChannelSubscription(), values);
	};

	PushChannelSubscription.fromValuesArray = function(values) {
		var count = values.length, result = new Array(count);
		for(var i = 0; i < count; i++) result[i] = PushChannelSubscription.fromValues(values[i]);
		return result;
	};

	return PushChannelSubscription;
})();

/* harmony default export */ var pushchannelsubscription = (pushchannelsubscription_PushChannelSubscription);

// CONCATENATED MODULE: ./common/lib/client/push.js








var push_Push = (function() {
	var noop = function() {};

	function Push(rest) {
		this.rest = rest;
		this.admin = new Admin(rest);
	}

	function Admin(rest) {
		this.rest = rest;
		this.deviceRegistrations = new DeviceRegistrations(rest);
		this.channelSubscriptions = new ChannelSubscriptions(rest);
	}

	Admin.prototype.publish = function(recipient, payload, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = utils["a" /* default */].mixin({recipient: recipient}, payload),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/publish', requestBody, headers, params, false, function(err) { callback(err); });
	};

	function DeviceRegistrations(rest) {
		this.rest = rest;
	}

	DeviceRegistrations.prototype.save = function(device, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = devicedetails.fromValues(device),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.get = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		client_resource.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, false, function(err, body, headers, unpacked) {
			callback(err, !err && devicedetails.fromResponseBody(body, !unpacked && format));
		});
	};

	DeviceRegistrations.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/deviceRegistrations', headers, envelope, function(body, headers, unpacked) {
			return devicedetails.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	DeviceRegistrations.prototype.remove = function(deviceIdOrDetails, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format),
			params = {},
			deviceId = deviceIdOrDetails.id || deviceIdOrDetails;

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'remove', arguments);
			}
			callback = noop;
		}

		if(typeof deviceId !== 'string' || !deviceId.length) {
			callback(new errorinfo["a" /* default */]('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));
			return;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, false, function(err) { callback(err); });
	};

	DeviceRegistrations.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/deviceRegistrations', headers, params, false, function(err) { callback(err); });
	};

	function ChannelSubscriptions(rest) {
		this.rest = rest;
	}

	ChannelSubscriptions.prototype.save = function(subscription, callback) {
		var rest = this.rest;
		var format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			requestBody = pushchannelsubscription.fromValues(subscription),
			headers = utils["a" /* default */].defaultPostHeaders(format),
			params = {};

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'save', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		requestBody = utils["a" /* default */].encodeBody(requestBody, format);
		client_resource.post(rest, '/push/channelSubscriptions', requestBody, headers, params, false, function(err, body, headers, unpacked) {
			callback(err, !err && pushchannelsubscription.fromResponseBody(body, !unpacked && format));
		});
	};

	ChannelSubscriptions.prototype.list = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'list', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		(new paginatedresource(rest, '/push/channelSubscriptions', headers, envelope, function(body, headers, unpacked) {
			return pushchannelsubscription.fromResponseBody(body, !unpacked && format);
		})).get(params, callback);
	};

	ChannelSubscriptions.prototype.removeWhere = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'removeWhere', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		client_resource['delete'](rest, '/push/channelSubscriptions', headers, params, false, function(err) { callback(err); });
	};

	/* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */
	ChannelSubscriptions.prototype.remove = ChannelSubscriptions.prototype.removeWhere;

	ChannelSubscriptions.prototype.listChannels = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(typeof callback !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'listChannels', arguments);
			}
			callback = noop;
		}

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		if(rest.options.pushFullWait)
			utils["a" /* default */].mixin(params, {fullWait: 'true'});

		(new paginatedresource(rest, '/push/channels', headers, envelope, function(body, headers, unpacked) {
			var f = !unpacked && format;

			if(f) {
				body = utils["a" /* default */].decodeBody(body, format);
			}

			for(var i = 0; i < body.length; i++) {
				body[i] = String(body[i]);
			}
			return body;
		})).get(params, callback);
	};

	return Push;
})();

/* harmony default export */ var push = (push_Push);

// EXTERNAL MODULE: ./common/lib/util/eventemitter.js
var eventemitter = __nested_webpack_require_468187__(7);

// EXTERNAL MODULE: ./common/lib/types/presencemessage.js
var presencemessage = __nested_webpack_require_468187__(11);

// CONCATENATED MODULE: ./common/lib/client/presence.js







var presence_Presence = (function() {
	function noop() {}
	function Presence(channel) {
		this.channel = channel;
		this.basePath = channel.basePath + '/presence';
	}
	utils["a" /* default */].inherits(Presence, eventemitter["a" /* default */]);

	Presence.prototype.get = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'get', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format);

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath, headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	Presence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);
		this._history(params, callback);
	};

	Presence.prototype._history = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.rest.options.promises) {
					return utils["a" /* default */].promisify(this, '_history', arguments);
				}
				callback = noop;
			}
		}
		var rest = this.channel.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this.channel;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channel.channelOptions;
		(new paginatedresource(rest, this.basePath + '/history', headers, envelope, function(body, headers, unpacked) {
			return presencemessage["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	return Presence;
})();

/* harmony default export */ var client_presence = (presence_Presence);

// EXTERNAL MODULE: ./browser/lib/util/crypto.js
var util_crypto = __nested_webpack_require_468187__(19);

// EXTERNAL MODULE: ./common/lib/types/message.js
var types_message = __nested_webpack_require_468187__(9);

// CONCATENATED MODULE: ./common/lib/client/channel.js











var channel_Channel = (function() {
	function noop() {}
	var MSG_ID_ENTROPY_BYTES = 9;

	/* public constructor */
	function Channel(rest, name, channelOptions) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Channel()', 'started; name = ' + name);
		eventemitter["a" /* default */].call(this);
		this.rest = rest;
		this.name = name;
		this.basePath = '/channels/' + encodeURIComponent(name);
		this.presence = new client_presence(this);
		this.setOptions(channelOptions);
	}
	utils["a" /* default */].inherits(Channel, eventemitter["a" /* default */]);

	Channel.prototype.setOptions = function(options) {
		this.channelOptions = options = options || {};
		if(options.cipher) {
			if(!util_crypto["a" /* default */]) throw new Error('Encryption not enabled; use ably.encryption.js instead');
			var cipher = util_crypto["a" /* default */].getCipher(options.cipher);
			options.cipher = cipher.cipherParams;
			options.channelCipher = cipher.cipher;
		} else if('cipher' in options) {
			/* Don't deactivate an existing cipher unless options
			 * has a 'cipher' key that's falsey */
			options.cipher = null;
			options.channelCipher = null;
		}
	};

	Channel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		this._history(params, callback);
	};

	Channel.prototype._history = function(params, callback) {
		var rest = this.rest,
			format = rest.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format,
			headers = utils["a" /* default */].defaultGetHeaders(format),
			channel = this;

		if(rest.options.headers)
			utils["a" /* default */].mixin(headers, rest.options.headers);

		var options = this.channelOptions;
		(new paginatedresource(rest, this.basePath + '/messages', headers, envelope, function(body, headers, unpacked) {
			return types_message["a" /* default */].fromResponseBody(body, options, !unpacked && format);
		})).get(params, callback);
	};

	function allEmptyIds(messages) {
		return utils["a" /* default */].arrEvery(messages, function(message) {
			return !message.id;
		});
	}

	Channel.prototype.publish = function() {
		var argCount = arguments.length,
			first = arguments[0],
			second = arguments[1],
			callback = arguments[argCount - 1],
			messages,
			params,
			self = this;

		if(typeof(callback) !== 'function') {
			if(this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
		}

		if(typeof first === 'string' || first === null) {
			/* (name, data, ...) */
			messages = [types_message["a" /* default */].fromValues({name: first, data: second})];
			params = arguments[2];
		} else if(utils["a" /* default */].isObject(first)) {
			messages = [types_message["a" /* default */].fromValues(first)];
			params = arguments[1];
		} else if(utils["a" /* default */].isArray(first)) {
			messages = types_message["a" /* default */].fromValuesArray(first);
			params = arguments[1];
		} else {
			throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		}

		if(typeof params !== 'object' || !params) {
			/* No params supplied (so after-message argument is just the callback or undefined) */
			params = {};
		}

		var rest = this.rest,
			options = rest.options,
			format = options.useBinaryProtocol ? 'msgpack' : 'json',
			idempotentRestPublishing = rest.options.idempotentRestPublishing,
			headers = utils["a" /* default */].defaultPostHeaders(format);

		if(options.headers)
			utils["a" /* default */].mixin(headers, options.headers);

		if(idempotentRestPublishing && allEmptyIds(messages)) {
			var msgIdBase = utils["a" /* default */].randomString(MSG_ID_ENTROPY_BYTES);
			utils["a" /* default */].arrForEach(messages, function(message, index) {
				message.id = msgIdBase + ':' + index.toString();
			});
		}

		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if(err) {
				callback(err);
				return;
			}

			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages),
				maxMessageSize = options.maxMessageSize;
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}

			self._publish(types_message["a" /* default */].serialize(messages, format), headers, params, callback);
		});
	};

	Channel.prototype._publish = function(requestBody, headers, params, callback) {
		client_resource.post(this.rest, this.basePath + '/messages', requestBody, headers, params, false, callback);
	};

	return Channel;
})();

/* harmony default export */ var client_channel = (channel_Channel);

// CONCATENATED MODULE: ./common/lib/types/stats.js


var stats_Stats = (function() {

	function MessageCount(values) {
		this.count = (values && values.count) || 0;
		this.data = (values && values.data) || 0;
		this.uncompressedData = (values && values.uncompressedData) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function MessageCategory(values) {
		var self = this;
		MessageCount.call(this, values);
		this.category = undefined;
		if (values && values.category) {
			this.category = { };
			utils["a" /* default */].forInOwnNonNullProps(values.category, function(prop) {
				self.category[prop] = new MessageCount(values.category[prop]);
			});
		}
	}

	function ResourceCount(values) {
		this.peak = (values && values.peak) || 0;
		this.min = (values && values.min) || 0;
		this.mean = (values && values.mean) || 0;
		this.opened = (values && values.opened) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function RequestCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.failed = (values && values.failed) || 0;
		this.refused = (values && values.refused) || 0;
	}

	function ConnectionTypes(values) {
		this.plain = new ResourceCount(values && values.plain);
		this.tls = new ResourceCount(values && values.tls);
		this.all = new ResourceCount(values && values.all);
	}

	function MessageTypes(values) {
		this.messages = new MessageCategory(values && values.messages);
		this.presence = new MessageCategory(values && values.presence);
		this.all = new MessageCategory(values && values.all);
	}

	function MessageTraffic(values) {
		this.realtime = new MessageTypes(values && values.realtime);
		this.rest = new MessageTypes(values && values.rest);
		this.webhook = new MessageTypes(values && values.webhook);
		this.sharedQueue = new MessageTypes(values && values.sharedQueue);
		this.externalQueue = new MessageTypes(values && values.externalQueue);
		this.httpEvent = new MessageTypes(values && values.httpEvent);
		this.push = new MessageTypes(values && values.push);
		this.all = new MessageTypes(values && values.all);
	}

	function MessageDirections(values) {
		this.all           = new MessageTypes(values && values.all);
		this.inbound       = new MessageTraffic(values && values.inbound);
		this.outbound      = new MessageTraffic(values && values.outbound);
	}

	function XchgMessages(values) {
		this.all           = new MessageTypes(values && values.all);
		this.producerPaid  = new MessageDirections(values && values.producerPaid);
		this.consumerPaid  = new MessageDirections(values && values.consumerPaid);
	}

	function PushStats(values) {
		this.messages = (values && values.messages) || 0;
		var notifications = values && values.notifications;
		this.notifications = {
			invalid: notifications && notifications.invalid || 0,
			attempted: notifications && notifications.attempted || 0,
			successful: notifications && notifications.successful || 0,
			failed: notifications && notifications.failed || 0
		};
		this.directPublishes = (values && values.directPublishes) || 0;
	}

	function ProcessedCount(values) {
		this.succeeded = (values && values.succeeded) || 0;
		this.skipped = (values && values.skipped) || 0;
		this.failed = (values && values.failed) || 0;
	}

	function ProcessedMessages(values) {
		var self = this;
		this.delta = undefined;
		if (values && values.delta) {
			this.delta = { };
			utils["a" /* default */].forInOwnNonNullProps(values.delta, function(prop) {
				self.delta[prop] = new ProcessedCount(values.delta[prop]);
			});
		}
	}

	function Stats(values) {
		MessageDirections.call(this, values);
		this.persisted     = new MessageTypes(values && values.persisted);
		this.connections   = new ConnectionTypes(values && values.connections);
		this.channels      = new ResourceCount(values && values.channels);
		this.apiRequests   = new RequestCount(values && values.apiRequests);
		this.tokenRequests = new RequestCount(values && values.tokenRequests);
		this.xchgProducer  = new XchgMessages(values && values.xchgProducer);
		this.xchgConsumer  = new XchgMessages(values && values.xchgConsumer);
		this.push          = new PushStats(values && values.pushStats);
		this.processed     = new ProcessedMessages(values && values.processed);
		this.inProgress    = (values && values.inProgress) || undefined;
		this.unit          = (values && values.unit) || undefined;
		this.intervalId    = (values && values.intervalId) || undefined;
	}

	Stats.fromValues = function(values) {
		return new Stats(values);
	};

	return Stats;
})();

/* harmony default export */ var stats = (stats_Stats);

// CONCATENATED MODULE: ./common/lib/client/rest.js












var rest_Rest = (function() {
	var noop = function() {};
	var msgpack = platform_browser["a" /* default */].msgpack;

	function Rest(options) {
		if(!(this instanceof Rest)){
			return new Rest(options);
		}

		/* normalise options */
		if(!options) {
			var msg = 'no options provided';
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
			throw new Error(msg);
		}
		options = defaults["a" /* default */].objectifyOptions(options);

		if(options.log) {
			logger["a" /* default */].setLog(options.log.level, options.log.handler);
		}
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + utils["a" /* default */].inspect(options));

		this.options = defaults["a" /* default */].normaliseOptions(options);

		/* process options */
		if(options.key) {
			var keyMatch = options.key.match(/^([^:\s]+):([^:.\s]+)$/);
			if(!keyMatch) {
				var msg = 'invalid key parameter';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Rest()', msg);
				throw new Error(msg);
			}
			options.keyName = keyMatch[1];
			options.keySecret = keyMatch[2];
		}

		if('clientId' in options) {
			if(!(typeof(options.clientId) === 'string' || options.clientId === null))
				throw new errorinfo["a" /* default */]('clientId must be either a string or null', 40012, 400);
			else if(options.clientId === '*')
				throw new errorinfo["a" /* default */]('Cant use "*" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: "*"}})', 40012, 400);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Rest()', 'started; version = ' + defaults["a" /* default */].libstring);

		this.baseUri = this.authority = function(host) { return defaults["a" /* default */].getHttpScheme(options) + host + ':' + defaults["a" /* default */].getPort(options, false); };
		this._currentFallback = null;

		this.serverTimeOffset = null;
		this.auth = new auth["a" /* default */](this, options);
		this.channels = new Channels(this);
		this.push = new push(this);
	}

	Rest.prototype.stats = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'stats', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders(),
			format = this.options.useBinaryProtocol ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;

		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);

		(new paginatedresource(this, '/stats', headers, envelope, function(body, headers, unpacked) {
			var statsValues = (unpacked ? body : JSON.parse(body));
			for(var i = 0; i < statsValues.length; i++) statsValues[i] = stats.fromValues(statsValues[i]);
			return statsValues;
		})).get(params, callback);
	};

	Rest.prototype.time = function(params, callback) {
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.options.promises) {
					return utils["a" /* default */].promisify(this, 'time', arguments);
				}
				callback = noop;
			}
		}
		var headers = utils["a" /* default */].defaultGetHeaders();
		if(this.options.headers)
			utils["a" /* default */].mixin(headers, this.options.headers);
		var self = this;
		var timeUri = function(host) { return self.authority(host) + '/time' };
		http["a" /* default */].get(this, timeUri, headers, params, function(err, res, headers, unpacked) {
			if(err) {
				callback(err);
				return;
			}
			if(!unpacked) res = JSON.parse(res);
			var time = res[0];
			if(!time) {
				err = new Error('Internal error (unexpected result type from GET /time)');
				err.statusCode = 500;
				callback(err);
				return;
			}
			/* calculate time offset only once for this device by adding to the prototype */
			self.serverTimeOffset = (time - utils["a" /* default */].now());
			callback(null, time);
		});
	};

	Rest.prototype.request = function(method, path, params, body, customHeaders, callback) {
		var useBinary = this.options.useBinaryProtocol,
			encoder = useBinary ? msgpack.encode: JSON.stringify,
			decoder = useBinary ? msgpack.decode : JSON.parse,
			format = useBinary ? 'msgpack' : 'json',
			envelope = http["a" /* default */].supportsLinkHeaders ? undefined : format;
		params = params || {};
		method = method.toLowerCase();
		var headers = method == 'get' ? utils["a" /* default */].defaultGetHeaders(format) : utils["a" /* default */].defaultPostHeaders(format);

		if(callback === undefined) {
			if(this.options.promises) {
				return utils["a" /* default */].promisify(this, 'request', [method, path, params, body, customHeaders]);
			}
			callback = noop;
		}

		if(typeof body !== 'string') {
			body = encoder(body);
		}
		if(this.options.headers) {
			utils["a" /* default */].mixin(headers, this.options.headers);
		}
		if(customHeaders) {
			utils["a" /* default */].mixin(headers, customHeaders);
		}
		var paginatedResource = new paginatedresource(this, path, headers, envelope, function(resbody, headers, unpacked) {
			return utils["a" /* default */].ensureArray(unpacked ? resbody : decoder(resbody));
		}, /* useHttpPaginatedResponse: */ true);

		if(!utils["a" /* default */].arrIn(http["a" /* default */].methods, method)) {
			throw new errorinfo["a" /* default */]('Unsupported method ' + method, 40500, 405);
		}

		if(utils["a" /* default */].arrIn(http["a" /* default */].methodsWithBody, method)) {
			paginatedResource[method](params, body, callback);
		} else {
			paginatedResource[method](params, callback);
		}
	};

	Rest.prototype.setLog = function(logOptions) {
		logger["a" /* default */].setLog(logOptions.level, logOptions.handler);
	};

	function Channels(rest) {
		this.rest = rest;
		this.all = Object.create(null);
	}

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			this.all[name] = channel = new client_channel(this.rest, name, channelOptions);
		} else if(channelOptions) {
			channel.setOptions(channelOptions);
		}

		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		delete this.all[String(name)];
	};

	return Rest;
})();

rest_Rest.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new rest_Rest(options);
};

rest_Rest.Callbacks = rest_Rest;

/* harmony default export */ var client_rest = (rest_Rest);

// EXTERNAL MODULE: ./common/lib/transport/connectionmanager.js
var connectionmanager = __nested_webpack_require_468187__(25);

// EXTERNAL MODULE: ./common/lib/client/connectionstatechange.js
var connectionstatechange = __nested_webpack_require_468187__(21);

// CONCATENATED MODULE: ./common/lib/client/connection.js






var connection_Connection = (function() {
	function noop() {}

	/* public constructor */
	function Connection(ably, options) {
		eventemitter["a" /* default */].call(this);
		this.ably = ably;
		this.connectionManager = new connectionmanager["a" /* default */](ably, options);
		this.state = this.connectionManager.state.state;
		this.key = undefined;
		this.id = undefined;
		this.serial = undefined;
		this.timeSerial = undefined;
		this.recoveryKey = undefined;
		this.errorReason = null;

		var self = this;
		this.connectionManager.on('connectionstate', function(stateChange) {
			var state = self.state = stateChange.current;
			utils["a" /* default */].nextTick(function() {
				self.emit(state, stateChange);
			});
		});
		this.connectionManager.on('update', function(stateChange) {
			utils["a" /* default */].nextTick(function() {
				self.emit('update', stateChange);
			});
		});
	}
	utils["a" /* default */].inherits(Connection, eventemitter["a" /* default */]);

	Connection.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener, new connectionstatechange["a" /* default */](undefined, state));
	}

	Connection.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.connect()', '');
		this.connectionManager.requestState({state: 'connecting'});
	};

	Connection.prototype.ping = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.ping()', '');
		if(!callback) {
			if(this.ably.options.promises) {
				return utils["a" /* default */].promisify(this, 'ping', arguments);
			}
			callback = noop;
		}
		this.connectionManager.ping(null, callback);
	};

	Connection.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);
		this.connectionManager.requestState({state: 'closing'});
	};

	return Connection;
})();

/* harmony default export */ var connection = (connection_Connection);

// EXTERNAL MODULE: ./common/lib/types/protocolmessage.js
var protocolmessage = __nested_webpack_require_468187__(8);

// EXTERNAL MODULE: ./common/lib/transport/connectionerror.js
var connectionerror = __nested_webpack_require_468187__(13);

// EXTERNAL MODULE: ./common/lib/util/multicaster.js
var util_multicaster = __nested_webpack_require_468187__(22);

// CONCATENATED MODULE: ./common/lib/client/channelstatechange.js
var ChannelStateChange = (function() {

	/* public constructor */
	function ChannelStateChange(previous, current, resumed, reason) {
		this.previous = previous;
		this.current = current;
		if(current === 'attached') this.resumed = resumed;
		if(reason) this.reason = reason;
	}

	return ChannelStateChange;
})();

/* harmony default export */ var channelstatechange = (ChannelStateChange);

// CONCATENATED MODULE: ./common/lib/client/realtimepresence.js











var realtimepresence_RealtimePresence = (function() {
	var noop = function() {};

	function memberKey(item) {
		return item.clientId + ':' + item.connectionId;
	}

	function getClientId(realtimePresence) {
		return realtimePresence.channel.realtime.auth.clientId;
	}

	function isAnonymousOrWildcard(realtimePresence) {
		var realtime = realtimePresence.channel.realtime;
		/* If not currently connected, we can't assume that we're an anonymous
		 * client, as realtime may inform us of our clientId in the CONNECTED
		 * message. So assume we're not anonymous and leave it to realtime to
		 * return an error if we are */
		var clientId = realtime.auth.clientId;
		return (!clientId || (clientId === '*')) && realtime.connection.state === 'connected';
	}

	/* Callback is called only in the event of an error */
	function waitAttached(channel, callback, action) {
		switch(channel.state) {
			case 'attached':
			case 'suspended':
				action();
				break;
			case 'initialized':
			case 'detached':
			case 'detaching':
			case 'attaching':
				channel.attach(function(err) {
					if(err) callback(err);
					else action();
				});
				break;
			default:
				callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError(channel.state)));
		}
	}

	function RealtimePresence(channel, options) {
		client_presence.call(this, channel);
		this.syncComplete = false;
		this.members = new PresenceMap(this);
		this._myMembers = new PresenceMap(this);
		this.subscriptions = new eventemitter["a" /* default */]();
		this.pendingPresence = [];
	}
	utils["a" /* default */].inherits(RealtimePresence, client_presence);

	RealtimePresence.prototype.enter = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to enter a presence channel', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'enter', callback);
	};

	RealtimePresence.prototype.update = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must be specified to update presence data', 40012, 400);
		}
		return this._enterOrUpdateClient(undefined, data, 'update', callback);
	};

	RealtimePresence.prototype.enterClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'enter', callback);
	};

	RealtimePresence.prototype.updateClient = function(clientId, data, callback) {
		return this._enterOrUpdateClient(clientId, data, 'update', callback);
	};

	RealtimePresence.prototype._enterOrUpdateClient = function(clientId, data, action, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, '_enterOrUpdateClient', [clientId, data, action]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.' + action + 'Client()',
		  'channel = ' + channel.name + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));

		var presence = presencemessage["a" /* default */].fromValues({
			action : action,
			data   : data
		});
		if (clientId) {
			presence.clientId = clientId;
		}

		var self = this;
		presencemessage["a" /* default */].encode(presence, channel.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			switch(channel.state) {
				case 'attached':
					channel.sendPresence(presence, callback);
					break;
				case 'initialized':
				case 'detached':
					channel.attach();
				case 'attaching':
					self.pendingPresence.push({
						presence : presence,
						callback : callback
					});
					break;
				default:
					err = new errorinfo["a" /* default */]('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);
					err.code = 90001;
					callback(err);
			}
		});
	};

	RealtimePresence.prototype.leave = function(data, callback) {
		if(isAnonymousOrWildcard(this)) {
			throw new errorinfo["a" /* default */]('clientId must have been specified to enter or leave a presence channel', 40012, 400);
		}
		return this.leaveClient(undefined, data, callback);
	};

	RealtimePresence.prototype.leaveClient = function(clientId, data, callback) {
		if (!callback) {
			if (typeof(data)==='function') {
				callback = data;
				data = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'leaveClient', [clientId, data]);
				}
				callback = noop;
			}
		}

		var channel = this.channel;
		if(!channel.connectionManager.activeState()) {
			callback(channel.connectionManager.getError());
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);
		var presence = presencemessage["a" /* default */].fromValues({
			action : 'leave',
			data   : data
		});
		if (clientId) { presence.clientId = clientId; }

		switch(channel.state) {
			case 'attached':
				channel.sendPresence(presence, callback);
				break;
			case 'attaching':
				this.pendingPresence.push({
					presence : presence,
					callback : callback
				});
				break;
			case 'initialized':
			case 'failed':
				/* we're not attached; therefore we let any entered status
				 * timeout by itself instead of attaching just in order to leave */
				var err = new errorinfo["a" /* default */]('Unable to leave presence channel (incompatible state)', 90001);
				callback(err);
				break;
			default:
				/* there is no connection; therefore we let
				 * any entered status timeout by itself */
				callback(connectionerror["a" /* default */].failed);
		}
	};

	RealtimePresence.prototype.get = function(/* params, callback */) {
		var args = Array.prototype.slice.call(arguments);
		if(args.length == 1 && typeof(args[0]) == 'function')
			args.unshift(null);

		var params = args[0],
			callback = args[1],
			waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'get', args);
			}
			callback = noop;
		}

		function returnMembers(members) {
			callback(null, params ? members.list(params) : members.values());
		}

		/* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */
		if(this.channel.state === 'suspended') {
			if(waitForSync) {
				callback(errorinfo["a" /* default */].fromValues({
					statusCode: 400,
					code: 91005,
					message: 'Presence state is out of sync due to channel being in the SUSPENDED state'
				}));
			} else {
				returnMembers(this.members);
			}
			return;
		}

		var self = this;
		waitAttached(this.channel, callback, function() {
			var members = self.members;
			if(waitForSync) {
				members.waitSync(function() {
					returnMembers(members);
				});
			} else {
				returnMembers(members);
			}
		});
	};

	RealtimePresence.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.channel.realtime.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.channel.state === 'attached') {
				delete params.untilAttach;
				params.from_serial = this.channel.properties.attachSerial;
			} else {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached, was: " + this.channel.state, 40000, 400));
			}
		}

		client_presence.prototype._history.call(this, params, callback);
	};

	RealtimePresence.prototype.setPresence = function(presenceSet, isSync, syncChannelSerial) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);
		var syncCursor, match, members = this.members, myMembers = this._myMembers,
			broadcastMessages = [], connId = this.channel.connectionManager.connectionId;

		if(isSync) {
			this.members.startSync();
			if(syncChannelSerial && (match = syncChannelSerial.match(/^[\w\-]+:(.*)$/))) {
				syncCursor = match[1];
			}
		}

		for(var i = 0; i < presenceSet.length; i++) {
			var presence = presencemessage["a" /* default */].fromValues(presenceSet[i]);
			switch(presence.action) {
				case 'leave':
					if(members.remove(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId && !presence.isSynthesized()) {
						myMembers.remove(presence);
					}
					break;
				case 'enter':
				case 'present':
				case 'update':
					if(members.put(presence)) {
						broadcastMessages.push(presence);
					}
					if(presence.connectionId === connId) {
						myMembers.put(presence);
					}
					break;
			}
		}
		/* if this is the last (or only) message in a sequence of sync updates, end the sync */
		if(isSync && !syncCursor) {
			members.endSync();
			/* RTP5c2: re-enter our own members if they haven't shown up in the sync */
			this._ensureMyMembersPresent();
			this.channel.setInProgress(realtimechannel.progressOps.sync, false);
			this.channel.syncChannelSerial = null;
		}

		/* broadcast to listeners */
		for(var i = 0; i < broadcastMessages.length; i++) {
			var presence = broadcastMessages[i];
			this.subscriptions.emit(presence.action, presence);
		}
	};

	RealtimePresence.prototype.onAttached = function(hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);

		if(hasPresence) {
			this.members.startSync();
		} else {
			this._synthesizeLeaves(this.members.values());
			this.members.clear();
			this._ensureMyMembersPresent();
		}

		/* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */
		var pendingPresence = this.pendingPresence,
			pendingPresCount = pendingPresence.length;

		if(pendingPresCount) {
			this.pendingPresence = [];
			var presenceArray = [];
			var multicaster = Object(util_multicaster["a" /* default */])();
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');
			for(var i = 0; i < pendingPresCount; i++) {
				var event = pendingPresence[i];
				presenceArray.push(event.presence);
				multicaster.push(event.callback);
			}
			this.channel.sendPresence(presenceArray, multicaster);
		}
	};

	RealtimePresence.prototype.actOnChannelState = function(state, hasPresence, err) {
		switch(state) {
			case 'attached':
				this.onAttached(hasPresence);
				break;
			case 'detached':
			case 'failed':
				this._clearMyMembers();
				this.members.clear();
				/* falls through */
			case 'suspended':
				this.failPendingPresence(err);
				break;
		}
	};

	RealtimePresence.prototype.failPendingPresence = function(err) {
		if(this.pendingPresence.length) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + utils["a" /* default */].inspectError(err));
			for(var i = 0; i < this.pendingPresence.length; i++)
				try {
					this.pendingPresence[i].callback(err);
				} catch(e) {}
			this.pendingPresence = [];
		}
	};

	RealtimePresence.prototype._clearMyMembers = function() {
		this._myMembers.clear();
	};

	RealtimePresence.prototype._ensureMyMembersPresent = function() {
		var self = this, members = this.members, myMembers = this._myMembers,
			reenterCb = function(err) {
				if(err) {
					var msg = 'Presence auto-re-enter failed: ' + err.toString();
					var wrappedErr = new errorinfo["a" /* default */](msg, 91004, 400);
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);
					var change = new channelstatechange(self.channel.state, self.channel.state, true, wrappedErr);
					self.channel.emit('update', change);
				}
			};

		for(var memberKey in myMembers.map) {
			if(!(memberKey in members.map)) {
				var entry = myMembers.map[memberKey];
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId "' + entry.clientId + '" into the presence set');
				this._enterOrUpdateClient(entry.clientId, entry.data, 'enter', reenterCb);
				delete myMembers.map[memberKey];
			}
		}
	};

	RealtimePresence.prototype._synthesizeLeaves = function(items) {
		var subscriptions = this.subscriptions;
		utils["a" /* default */].arrForEach(items, function(item) {
			var presence = presencemessage["a" /* default */].fromValues({
				action: 'leave',
				connectionId: item.connectionId,
				clientId: item.clientId,
				data: item.data,
				encoding: item.encoding,
				timestamp: utils["a" /* default */].now()
			});
			subscriptions.emit('leave', presence);
		});
	};

	/* Deprecated */
	RealtimePresence.prototype.on = function() {
		logger["a" /* default */].deprecated('presence.on', 'presence.subscribe');
		this.subscribe.apply(this, arguments);
	};

	/* Deprecated */
	RealtimePresence.prototype.off = function() {
		logger["a" /* default */].deprecated('presence.off', 'presence.unsubscribe');
		this.unsubscribe.apply(this, arguments);
	};

	RealtimePresence.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];
		var channel = this.channel;
		var self = this;

		if(!callback) {
			if(this.channel.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(channel.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(realtimechannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);
		channel.attach(callback);
	};

	RealtimePresence.prototype.unsubscribe = function(/* [event], listener */) {
		var args = realtimechannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	function PresenceMap(presence) {
		eventemitter["a" /* default */].call(this);
		this.presence = presence;
		this.map = Object.create(null);
		this.syncInProgress = false;
		this.residualMembers = null;
	}
	utils["a" /* default */].inherits(PresenceMap, eventemitter["a" /* default */]);

	PresenceMap.prototype.get = function(key) {
		return this.map[key];
	};

	PresenceMap.prototype.getClient = function(clientId) {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.clientId == clientId && item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.list = function(params) {
		var map = this.map,
			clientId = params && params.clientId,
			connectionId = params && params.connectionId,
			result = [];

		for(var key in map) {
			var item = map[key];
			if(item.action === 'absent') continue;
			if(clientId && clientId != item.clientId) continue;
			if(connectionId && connectionId != item.connectionId) continue;
			result.push(item);
		}
		return result;
	};

	function newerThan(item, existing) {
		/* RTP2b1: if either is synthesised, compare by timestamp */
		if(item.isSynthesized() || existing.isSynthesized()) {
			return item.timestamp > existing.timestamp;
		}

		/* RTP2b2 */
		var itemOrderings = item.parseId(),
			existingOrderings = existing.parseId();
		if(itemOrderings.msgSerial === existingOrderings.msgSerial) {
			return itemOrderings.index > existingOrderings.index;
		} else {
			return itemOrderings.msgSerial > existingOrderings.msgSerial;
		}
	}

	PresenceMap.prototype.put = function(item) {
		if(item.action === 'enter' || item.action === 'update') {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'present';
		}
		var map = this.map, key = memberKey(item);
		/* we've seen this member, so do not remove it at the end of sync */
		if(this.residualMembers)
			delete this.residualMembers[key];

		/* compare the timestamp of the new item with any existing member (or ABSENT witness) */
		var existingItem = map[key];
		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}
		map[key] = item;
		return true;

	};

	PresenceMap.prototype.values = function() {
		var map = this.map, result = [];
		for(var key in map) {
			var item = map[key];
			if(item.action != 'absent')
				result.push(item);
		}
		return result;
	};

	PresenceMap.prototype.remove = function(item) {
		var map = this.map, key = memberKey(item);
		var existingItem = map[key];

		if(existingItem && !newerThan(item, existingItem)) {
			return false;
		}

		/* RTP2f */
		if(this.syncInProgress) {
			item = presencemessage["a" /* default */].fromValues(item);
			item.action = 'absent';
			map[key] = item;
		} else {
			delete map[key];
		}

		return true;
	};

	PresenceMap.prototype.startSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		/* we might be called multiple times while a sync is in progress */
		if(!this.syncInProgress) {
			this.residualMembers = utils["a" /* default */].copy(map);
			this.setInProgress(true);
		}
	};

	PresenceMap.prototype.endSync = function() {
		var map = this.map, syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(syncInProgress) {
			/* we can now strip out the ABSENT members, as we have
			 * received all of the out-of-order sync messages */
			for(var memberKey in map) {
				var entry = map[memberKey];
				if(entry.action === 'absent') {
					delete map[memberKey];
				}
			}
			/* any members that were present at the start of the sync,
			 * and have not been seen in sync, can be removed, and leave events emitted */
			this.presence._synthesizeLeaves(utils["a" /* default */].valuesArray(this.residualMembers));
			for(var memberKey in this.residualMembers) {
				delete map[memberKey];
			}
			this.residualMembers = null;

			/* finish, notifying any waiters */
			this.setInProgress(false);
		}
		this.emit('sync');
	};

	PresenceMap.prototype.waitSync = function(callback) {
		var syncInProgress = this.syncInProgress;
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);
		if(!syncInProgress) {
			callback();
			return;
		}
		this.once('sync', callback);
	};

	PresenceMap.prototype.clear = function(callback) {
		this.map = {};
		this.setInProgress(false);
		this.residualMembers = null;
	};

	PresenceMap.prototype.setInProgress = function(inProgress) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);
		this.syncInProgress = inProgress;
		this.presence.syncComplete = !inProgress;
	};

	return RealtimePresence;
})();

/* harmony default export */ var realtimepresence = (realtimepresence_RealtimePresence);

// CONCATENATED MODULE: ./common/lib/client/realtimechannel.js












var realtimechannel_RealtimeChannel = (function() {
	var actions = protocolmessage["a" /* default */].Action;
	var noop = function() {};
	var statechangeOp = 'statechange';
	var syncOp = 'sync';

	/* public constructor */
	function RealtimeChannel(realtime, name, options) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);
		client_channel.call(this, realtime, name, options);
		this.realtime = realtime;
		this.presence = new realtimepresence(this, realtime.options);
		this.connectionManager = realtime.connection.connectionManager;
		this.state = 'initialized';
		this.subscriptions = new eventemitter["a" /* default */]();
		this.syncChannelSerial = undefined;
		this.properties = {
			attachSerial: undefined
		};
		this.setOptions(options);
		this.errorReason = null;
		this._requestedFlags = null;
		this._mode = null;
		/* Temporary; only used for the checkChannelsOnResume option */
		this._attachedMsgIndicator = false;
		this._attachResume = false;
		this._decodingContext = {
			channelOptions: this.channelOptions,
			plugins: realtime.options.plugins || { },
			baseEncodedPreviousPayload: undefined
		};
		this._lastPayload = {
			messageId: null,
			protocolMessageChannelSerial: null,
			decodeFailureRecoveryInProgress: null
		};
		/* Only differences between this and the public event emitter is that this emits an
		 * update event for all ATTACHEDs, whether resumed or not */
		this._allChannelChanges = new eventemitter["a" /* default */]();
	}
	utils["a" /* default */].inherits(RealtimeChannel, client_channel);

	RealtimeChannel.invalidStateError = function(state) {
		return {
			statusCode: 400,
			code: 90001,
			message: 'Channel operation failed as channel state is ' + state
		};
	};

	RealtimeChannel.progressOps = {
		statechange: statechangeOp,
		sync: syncOp
	};

	RealtimeChannel.processListenerArgs = function(args) {
		/* [event], listener, [callback] */
		args = Array.prototype.slice.call(args);
		if(typeof args[0] === 'function') {
			args.unshift(null);
		}
		if(args[args.length - 1] == undefined) {
			args.pop();
		}
		return args;
	};

	RealtimeChannel.prototype.setOptions = function(options, callback) {
		if(!callback) {
			if (this.rest.options.promises) {
				return utils["a" /* default */].promisify(this, 'setOptions', arguments);
			}

			callback = function(err){
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());
				}
			};
		}
		var err = validateChannelOptions(options);
		if(err) {
			callback(err);
			return;
		}
		client_channel.prototype.setOptions.call(this, options);
		if (this._decodingContext)
			this._decodingContext.channelOptions = this.channelOptions;
		if(this._shouldReattachToSetOptions(options)) {
			/* This does not just do _attach(true, null, callback) because that would put us
			 * into the 'attaching' state until we receive the new attached, which is
			 * conceptually incorrect: we are still attached, we just have a pending request to
			 * change some channel params. Per RTL17 going into the attaching state would mean
			 * rejecting messages until we have confirmation that the options have changed,
			 * which would unnecessarily lose message continuity. */
			this.attachImpl();
			this._allChannelChanges.once(function(stateChange) {
				switch(this.event) {
					case 'update':
					case 'attached':
						callback(null);
						return;
					default:
						callback(stateChange.reason);
						return;
				}
			});
		} else {
			callback();
		}
	};

	function validateChannelOptions(options) {
		if(options && 'params' in options && !utils["a" /* default */].isObject(options.params)) {
			return new errorinfo["a" /* default */]('options.params must be an object', 40000, 400);
		}
		if(options && 'modes' in options){
			if(!utils["a" /* default */].isArray(options.modes)){
				return new errorinfo["a" /* default */]('options.modes must be an array', 40000, 400);
			}
			for(var i = 0; i < options.modes.length; i++){
				var currentMode = options.modes[i];
				if(!currentMode || typeof currentMode !== 'string' || !utils["a" /* default */].arrIn(protocolmessage["a" /* default */].channelModes, String.prototype.toUpperCase.call(currentMode))){
					return new errorinfo["a" /* default */]('Invalid channel mode: ' + currentMode, 40000, 400);
				}
			}
		}
	}

	RealtimeChannel.prototype._shouldReattachToSetOptions = function(options) {
		return (this.state === 'attached' || this.state === 'attaching') && (options.params || options.modes);
	};

	RealtimeChannel.prototype.publish = function() {
		var argCount = arguments.length,
			messages = arguments[0],
			callback = arguments[argCount - 1];

		if(typeof(callback) !== 'function') {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'publish', arguments);
			}
			callback = noop;
			++argCount;
		}
		if(!this.connectionManager.activeState()) {
			callback(this.connectionManager.getError());
			return;
		}
		if(argCount == 2) {
			if(utils["a" /* default */].isObject(messages))
				messages = [types_message["a" /* default */].fromValues(messages)];
			else if(utils["a" /* default */].isArray(messages))
				messages = types_message["a" /* default */].fromValuesArray(messages);
			else
				throw new errorinfo["a" /* default */]('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);
		} else {
			messages = [types_message["a" /* default */].fromValues({name: arguments[0], data: arguments[1]})];
		}
		var self = this,
			maxMessageSize = this.realtime.options.maxMessageSize;
		types_message["a" /* default */].encodeArray(messages, this.channelOptions, function(err) {
			if (err) {
				callback(err);
				return;
			}
			/* RSL1i */
			var size = types_message["a" /* default */].getMessagesSize(messages);
			if(size > maxMessageSize) {
				callback(new errorinfo["a" /* default */]('Maximum size of messages that can be published at once exceeded ( was ' + size + ' bytes; limit is ' + maxMessageSize + ' bytes)', 40009, 400));
				return;
			}
			self._publish(messages, callback);
		});
	};

	RealtimeChannel.prototype._publish = function(messages, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);
		var state = this.state;
		switch(state) {
			case 'failed':
			case 'suspended':
				callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError(state)));
				break;
			default:
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);
				var msg = new protocolmessage["a" /* default */]();
				msg.action = actions.MESSAGE;
				msg.channel = this.name;
				msg.messages = messages;
				this.sendMessage(msg, callback);
				break;
		}
	};

	RealtimeChannel.prototype.onEvent = function(messages) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');
		var subscriptions = this.subscriptions;
		for(var i = 0; i < messages.length; i++) {
			var message = messages[i];
			subscriptions.emit(message.name, message);
		}
	};

	RealtimeChannel.prototype.attach = function(flags, callback) {
		if(typeof(flags) === 'function') {
			callback = flags;
			flags = null;
		}
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'attach', arguments);
			}
			callback = function(err) {
				if(err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}
		if(flags) {
			logger["a" /* default */].deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');
			/* If flags requested, always do a re-attach. TODO only do this if
			 * current mode differs from requested mode */
			this._requestedFlags = flags;
		} else if (this.state === 'attached') {
			callback();
			return;
		}

		this._attach(false, null, callback);
	};

	RealtimeChannel.prototype._attach = function(forceReattach, attachReason, callback) {
		if(!callback) {
			callback = function(err) {
				if (err) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());
				}
			}
		}

		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}

		if (this.state !== 'attaching' || forceReattach) {
			this.requestState('attaching', attachReason);
		}

		this.once(function(stateChange) {
			switch(this.event) {
				case 'attached':
					callback();
					break;
				case 'detached':
				case 'suspended':
				case 'failed':
					callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));
					break;
				case 'detaching':
					callback(new errorinfo["a" /* default */]('Attach request superseded by a subsequent detach request', 90000, 409));
					break;
			}
		});
	};

	RealtimeChannel.prototype.attachImpl = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');
		this.setInProgress(statechangeOp, true);
		var attachMsg = protocolmessage["a" /* default */].fromValues({action: actions.ATTACH, channel: this.name, params: this.channelOptions.params});
		if(this._requestedFlags) {
			attachMsg.encodeModesToFlags(this._requestedFlags);
		} else if(this.channelOptions.modes) {
			attachMsg.encodeModesToFlags(utils["a" /* default */].allToUpperCase(this.channelOptions.modes));
		}
		if(this._attachResume) {
			attachMsg.setFlag('ATTACH_RESUME');
		}
		if(this._lastPayload.decodeFailureRecoveryInProgress) {
			attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;
		}
		this.sendMessage(attachMsg, noop);
	};

	RealtimeChannel.prototype.detach = function(callback) {
		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'detach', arguments);
			}
			callback = noop;
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			callback(connectionManager.getError());
			return;
		}
		switch(this.state) {
                        case 'suspended':
                                this.notifyState('detached');
                                callback();
                                break;
			case 'detached':
				callback();
				break;
			case 'failed':
				callback(new errorinfo["a" /* default */]('Unable to detach; channel state = failed', 90001, 400));
				break;
			default:
				this.requestState('detaching');
			case 'detaching':
				this.once(function(stateChange) {
					switch(this.event) {
						case 'detached':
							callback();
							break;
						case 'attached':
						case 'suspended':
						case 'failed':
							callback(stateChange.reason || connectionManager.getError() || new errorinfo["a" /* default */]('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));
							break;
						case 'attaching':
							callback(new errorinfo["a" /* default */]('Detach request superseded by a subsequent attach request', 90000, 409));
							break;
					}
				});
		}
	};

	RealtimeChannel.prototype.detachImpl = function(callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');
		this.setInProgress(statechangeOp, true);
		var msg = protocolmessage["a" /* default */].fromValues({action: actions.DETACH, channel: this.name});
		this.sendMessage(msg, (callback || noop));
	};

	RealtimeChannel.prototype.subscribe = function(/* [event], listener, [callback] */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		var callback = args[2];

		if(!callback) {
			if(this.realtime.options.promises) {
				return utils["a" /* default */].promisify(this, 'subscribe', [event, listener]);
			}
			callback = noop;
		}

		if(this.state === 'failed') {
			callback(errorinfo["a" /* default */].fromValues(RealtimeChannel.invalidStateError('failed')));
			return;
		}

		this.subscriptions.on(event, listener);

		return this.attach(callback);
	};

	RealtimeChannel.prototype.unsubscribe = function(/* [event], listener */) {
		var args = RealtimeChannel.processListenerArgs(arguments);
		var event = args[0];
		var listener = args[1];
		this.subscriptions.off(event, listener);
	};

	RealtimeChannel.prototype.sync = function() {
		/* check preconditions */
		switch(this.state) {
			case 'initialized':
			case 'detaching':
			case 'detached':
				throw new errorinfo["a" /* default */]("Unable to sync to channel; not attached", 40000);
			default:
		}
		var connectionManager = this.connectionManager;
		if(!connectionManager.activeState()) {
			throw connectionManager.getError();
		}

		/* send sync request */
		var syncMessage = protocolmessage["a" /* default */].fromValues({action: actions.SYNC, channel: this.name});
		if(this.syncChannelSerial) {
			syncMessage.channelSerial = this.syncChannelSerial;
		}
		connectionManager.send(syncMessage);
	};

	RealtimeChannel.prototype.sendMessage = function(msg, callback) {
		this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);
	};

	RealtimeChannel.prototype.sendPresence = function(presence, callback) {
		var msg = protocolmessage["a" /* default */].fromValues({
			action: actions.PRESENCE,
			channel: this.name,
			presence: (utils["a" /* default */].isArray(presence) ?
				presencemessage["a" /* default */].fromValuesArray(presence) :
				[presencemessage["a" /* default */].fromValues(presence)])
		});
		this.sendMessage(msg, callback);
	};

	RealtimeChannel.prototype.onMessage = function(message) {
		var syncChannelSerial, isSync = false;
		switch(message.action) {
		case actions.ATTACHED:
			this._attachedMsgIndicator = true;
			this.properties.attachSerial = message.channelSerial;
			this._mode = message.getMode();
			this.params = message.params || {};
			var modesFromFlags = message.decodeModesFromFlags();
			this.modes = (modesFromFlags && utils["a" /* default */].allToLowerCase(modesFromFlags)) || undefined;
			var resumed = message.hasFlag('RESUMED');
			var hasPresence = message.hasFlag('HAS_PRESENCE');
			if(this.state === 'attached') {
				/* attached operations to change options set the inprogress mutex, but leave
				 * channel in the attached state */
				this.setInProgress(statechangeOp, false);
				if(!resumed) {
					/* On a loss of continuity, the presence set needs to be re-synced */
					this.presence.onAttached(hasPresence);
				}
				var change = new channelstatechange(this.state, this.state, resumed, message.error);
				this._allChannelChanges.emit('update', change);
				if(!resumed || this.channelOptions.updateOnAttached) {
					this.emit('update', change);
				}
			} else if(this.state === 'detaching') {
				/* RTL5i: re-send DETACH and remain in the 'detaching' state */
				this.checkPendingState();
			} else {
				this.notifyState('attached', message.error, resumed, hasPresence);
			}
			break;

		case actions.DETACHED:
			var err = message.error ? errorinfo["a" /* default */].fromValues(message.error) : new errorinfo["a" /* default */]('Channel detached', 90001, 404);
			if(this.state === 'detaching') {
				this.notifyState('detached', err);
			} else if(this.state === 'attaching') {
				/* Only retry immediately if we were previously attached. If we were
				 * attaching, go into suspended, fail messages, and wait a few seconds
				 * before retrying */
				this.notifyState('suspended', err);
			} else {
				this.requestState('attaching', err);
			}
			break;

		case actions.SYNC:
			/* syncs can have channelSerials, but might not if the sync is one page long */
			isSync = true;
			syncChannelSerial = this.syncChannelSerial = message.channelSerial;
			/* syncs can happen on channels with no presence data as part of connection
			 * resuming, in which case protocol message has no presence property */
			if(!message.presence) break;
		case actions.PRESENCE:
			var presence = message.presence,
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			var options = this.channelOptions;
			for(var i = 0; i < presence.length; i++) {
				try {
					var presenceMsg = presence[i];
					presencemessage["a" /* default */].decode(presenceMsg, options);
				} catch (e) {
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
				}
				if(!presenceMsg.connectionId) presenceMsg.connectionId = connectionId;
				if(!presenceMsg.timestamp) presenceMsg.timestamp = timestamp;
				if(!presenceMsg.id) presenceMsg.id = id + ':' + i;
			}
			this.presence.setPresence(presence, isSync, syncChannelSerial);
			break;

		case actions.MESSAGE:

			//RTL17
			if(this.state !== 'attached') {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message "' + message.id + '" skipped as this channel "' + this.name + '" state is not "attached" (state is "' + this.state + '").');
				return;
			}

			var messages = message.messages,
				firstMessage = messages[0],
				lastMessage = messages[messages.length - 1],
				id = message.id,
				connectionId = message.connectionId,
				timestamp = message.timestamp;

			if(firstMessage.extras && firstMessage.extras.delta && firstMessage.extras.delta.from !== this._lastPayload.messageId) {
				var msg = 'Delta message decode failure - previous message not available for message "' + message.id + '" on this channel "' + this.name + '".';
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', msg);
				this._startDecodeFailureRecovery(new errorinfo["a" /* default */](msg, 40018, 400));
				break;
			}

			for(var i = 0; i < messages.length; i++) {
				var msg = messages[i];
				try {
					types_message["a" /* default */].decode(msg, this._decodingContext);
				} catch (e) {
					/* decrypt failed .. the most likely cause is that we have the wrong key */
					logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());
					switch(e.code) {
						case 40018:
							/* decode failure */
							this._startDecodeFailureRecovery(e);
							return;
						case 40019:
							/* No vcdiff plugin passed in - no point recovering, give up */
						case 40021:
							/* Browser does not support deltas, similarly no point recovering */
							this.notifyState('failed', e);
							return;
					}
				}
				if(!msg.connectionId) msg.connectionId = connectionId;
				if(!msg.timestamp) msg.timestamp = timestamp;
				if(!msg.id) msg.id = id + ':' + i;
			}
			this._lastPayload.messageId = lastMessage.id;
			this._lastPayload.protocolMessageChannelSerial = message.channelSerial;
			this.onEvent(messages);
			break;

		case actions.ERROR:
			/* there was a channel-specific error */
			var err = message.error;
			if(err && err.code == 80016) {
				/* attach/detach operation attempted on superseded transport handle */
				this.checkPendingState();
			} else {
				this.notifyState('failed', errorinfo["a" /* default */].fromValues(err));
			}
			break;

		default:
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');
			this.connectionManager.abort(connectionerror["a" /* default */].unknownChannelErr);
		}
	};

	RealtimeChannel.prototype._startDecodeFailureRecovery = function(reason) {
		var self = this;
		if(!this._lastPayload.decodeFailureRecoveryInProgress) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');
			this._lastPayload.decodeFailureRecoveryInProgress = true;
			this._attach(true, reason, function() {
				self._lastPayload.decodeFailureRecoveryInProgress = false;
			});
		}
	};

	RealtimeChannel.prototype.onAttached = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);
	};

	RealtimeChannel.prototype.notifyState = function(state, reason, resumed, hasPresence) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);
		this.clearStateTimer();

		if(state === this.state) {
			return;
		}
		this.presence.actOnChannelState(state, hasPresence, reason);
		if(state === 'suspended' && this.connectionManager.state.sendEvents) {
			this.startRetryTimer();
		} else {
			this.cancelRetryTimer();
		}
		if(reason) {
			this.errorReason = reason;
		}
		var change = new channelstatechange(this.state, state, resumed, reason);
		var logLevel = state === 'failed' ? logger["a" /* default */].LOG_ERROR : logger["a" /* default */].LOG_MAJOR;
		logger["a" /* default */].logAction(logLevel, 'Channel state for channel "' + this.name + '"', state + (reason ? ('; reason: ' + reason) : ''));

		/* Note: we don't set inProgress for pending states until the request is actually in progress */
		if(state === 'attached') {
			this.onAttached();
			this.setInProgress(syncOp, hasPresence);
			this.setInProgress(statechangeOp, false);
		} else if(state === 'detached' || state === 'failed' || state === 'suspended') {
			this.setInProgress(statechangeOp, false);
			this.setInProgress(syncOp, false);
		}

		if(state === 'attached') {
			this._attachResume = true;
		} else if(state === 'detaching' || state === 'failed') {
			this._attachResume = false;
		}

		this.state = state;
		this._allChannelChanges.emit(state, change);
		this.emit(state, change);
	};

	RealtimeChannel.prototype.requestState = function(state, reason) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);
		this.notifyState(state, reason);
		/* send the event and await response */
		this.checkPendingState();
	};

	RealtimeChannel.prototype.checkPendingState = function() {
		/* if can't send events, do nothing */
		var cmState = this.connectionManager.state;
		/* Allow attach messages to queue up when synchronizing, since this will be
		 * the state we'll be in when upgrade transport.active triggers a checkpendingstate */
		if(!(cmState.sendEvents || cmState.forceQueueEvents)) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);
			return;
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);
		/* Only start the state timer running when actually sending the event */
		switch(this.state) {
			case 'attaching':
				this.startStateTimerIfNotRunning();
				this.attachImpl();
				break;
			case 'detaching':
				this.startStateTimerIfNotRunning();
				this.detachImpl();
				break;
			case 'attached':
				/* resume any sync operation that was in progress */
				this.sync();
			default:
				break;
		}
	};

	RealtimeChannel.prototype.timeoutPendingState = function() {
		switch(this.state) {
			case 'attaching':
				var err = new errorinfo["a" /* default */]('Channel attach timed out', 90007, 408);
				this.notifyState('suspended', err);
				break;
			case 'detaching':
				var err = new errorinfo["a" /* default */]('Channel detach timed out', 90007, 408);
				this.notifyState('attached', err);
				break;
			default:
				this.checkPendingState();
				break;
		}
	};

	RealtimeChannel.prototype.startStateTimerIfNotRunning = function() {
		var self = this;
		if(!this.stateTimer) {
			this.stateTimer = setTimeout(function() {
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');
				self.stateTimer = null;
				self.timeoutPendingState();
			}, this.realtime.options.timeouts.realtimeRequestTimeout);
		}
	};

	RealtimeChannel.prototype.clearStateTimer = function() {
		var stateTimer = this.stateTimer;
		if(stateTimer) {
			clearTimeout(stateTimer);
			this.stateTimer = null;
		}
	};

	RealtimeChannel.prototype.startRetryTimer = function() {
		var self = this;
		if(this.retryTimer) return;

		this.retryTimer = setTimeout(function() {
			/* If connection is not connected, just leave in suspended, a reattach
			 * will be triggered once it connects again */
			if(self.state === 'suspended' && self.connectionManager.state.sendEvents) {
				self.retryTimer = null;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');
				self.requestState('attaching');
			}
		}, this.realtime.options.timeouts.channelRetryTimeout);
	};

	RealtimeChannel.prototype.cancelRetryTimer = function() {
		if(this.retryTimer) {
			clearTimeout(this.retryTimer);
			this.suspendTimer = null;
		}
	};

	RealtimeChannel.prototype.setInProgress = function(operation, value) {
		this.rest.channels.setInProgress(this, operation, value);
	};

	RealtimeChannel.prototype.history = function(params, callback) {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);
		/* params and callback are optional; see if params contains the callback */
		if(callback === undefined) {
			if(typeof(params) == 'function') {
				callback = params;
				params = null;
			} else {
				if(this.rest.options.promises) {
					return utils["a" /* default */].promisify(this, 'history', arguments);
				}
				callback = noop;
			}
		}

		if(params && params.untilAttach) {
			if(this.state !== 'attached') {
				callback(new errorinfo["a" /* default */]("option untilAttach requires the channel to be attached", 40000, 400));
				return;
			}
			if(!this.properties.attachSerial) {
				callback(new errorinfo["a" /* default */]("untilAttach was specified and channel is attached, but attachSerial is not defined", 40000, 400));
				return;
			}
			delete params.untilAttach;
			params.from_serial = this.properties.attachSerial;
		}

		client_channel.prototype._history.call(this, params, callback);
	};

	RealtimeChannel.prototype.whenState = function(state, listener) {
		return eventemitter["a" /* default */].prototype.whenState.call(this, state, this.state, listener);
	}

	/* @returns null (if can safely be released) | ErrorInfo (if cannot) */
	RealtimeChannel.prototype.getReleaseErr = function() {
		var s = this.state;
		if(s === 'initialized' || s === 'detached' || s === 'failed') {
			return null;
		}
		return new errorinfo["a" /* default */]('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' + s, 90001, 400);
	}

	return RealtimeChannel;
})();

/* harmony default export */ var realtimechannel = (realtimechannel_RealtimeChannel);

// EXTERNAL MODULE: ./common/lib/util/errorreporter.js
var errorreporter = __nested_webpack_require_468187__(23);

// CONCATENATED MODULE: ./common/lib/client/realtime.js










var realtime_Realtime = (function() {

	function Realtime(options) {
		if(!(this instanceof Realtime)){
			return new Realtime(options);
		}

		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime()', '');
		client_rest.call(this, options);
		this.connection = new connection(this, this.options);
		this.channels = new Channels(this);
		if(options.autoConnect !== false)
			this.connect();
	}
	utils["a" /* default */].inherits(Realtime, client_rest);

	Realtime.prototype.connect = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.connect()', '');
		this.connection.connect();
	};

	Realtime.prototype.close = function() {
		logger["a" /* default */].logAction(logger["a" /* default */].LOG_MINOR, 'Realtime.close()', '');
		this.connection.close();
	};

	function Channels(realtime) {
		eventemitter["a" /* default */].call(this);
		this.realtime = realtime;
		this.all = Object.create(null);
		this.inProgress = Object.create(null);
		var self = this;
		realtime.connection.connectionManager.on('transport.active', function() {
			self.onTransportActive();
		});
	}
	utils["a" /* default */].inherits(Channels, eventemitter["a" /* default */]);

	Channels.prototype.onChannelMessage = function(msg) {
		var channelName = msg.channel;
		if(channelName === undefined) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);
			return;
		}
		var channel = this.all[channelName];
		if(!channel) {
			logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);
			return;
		}
		channel.onMessage(msg);
	};

	/* called when a transport becomes connected; reattempt attach/detach
	 * for channels that are attaching or detaching.
	 * Note that this does not use inProgress as inProgress is only channels which have already made
	* at least one attempt to attach/detach */
	Channels.prototype.onTransportActive = function() {
		for(var channelName in this.all) {
			var channel = this.all[channelName];
			if(channel.state === 'attaching' || channel.state === 'detaching') {
				channel.checkPendingState();
			} else if(channel.state === 'suspended') {
				channel.attach();
			}
		}
	};

	Channels.prototype.reattach = function(reason) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			/* NB this should not trigger for merely attaching channels, as they will
			 * be reattached anyway through the onTransportActive checkPendingState */
			if(channel.state === 'attached') {
				channel.requestState('attaching', reason);
			}
		}
	};

	Channels.prototype.resetAttachedMsgIndicators = function() {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached') {
			channel._attachedMsgIndicator = false;
			}
		}
	};

	Channels.prototype.checkAttachedMsgIndicators = function(connectionId) {
		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(channel.state === 'attached' && channel._attachedMsgIndicator === false) {
				var msg = '30s after a resume, found channel which has not received an attached; channelId = ' + channelId + '; connectionId = ' + connectionId;
				logger["a" /* default */].logAction(logger["a" /* default */].LOG_ERROR, 'Channels.checkAttachedMsgIndicators()', msg);
				errorreporter["a" /* default */].report('error', msg, 'channel-no-attached-after-resume');
				channel.requestState('attaching');
			};
		}
	};

	/* Connection interruptions (ie when the connection will no longer queue
	 * events) imply connection state changes for any channel which is either
	 * attached, pending, or will attempt to become attached in the future */
	Channels.prototype.propogateConnectionInterruption = function(connectionState, reason) {
		var connectionStateToChannelState = {
			'closing'  : 'detached',
			'closed'   : 'detached',
			'failed'   : 'failed',
			'suspended': 'suspended'
		};
		var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];
		var toChannelState = connectionStateToChannelState[connectionState];

		for(var channelId in this.all) {
			var channel = this.all[channelId];
			if(utils["a" /* default */].arrIn(fromChannelStates, channel.state)) {
				 channel.notifyState(toChannelState, reason);
			}
		}
	};

	Channels.prototype.get = function(name, channelOptions) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			channel = this.all[name] = new realtimechannel(this.realtime, name, channelOptions);
		} else if(channelOptions) {
			if (channel._shouldReattachToSetOptions(channelOptions)) {
				throw new errorinfo["a" /* default */]("Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.", 40000, 400);
			}
			channel.setOptions(channelOptions);
		}
		return channel;
	};

	/* Included to support certain niche use-cases; most users should ignore this.
	 * Please do not use this unless you know what you're doing */
	Channels.prototype.release = function(name) {
		name = String(name);
		var channel = this.all[name];
		if(!channel) {
			return;
		}
		var releaseErr = channel.getReleaseErr();
		if(releaseErr) {
			throw releaseErr;
		}
		delete this.all[name];
		delete this.inProgress[name];
	};

	/* Records operations currently pending on a transport; used by connectionManager to decide when
	 * it's safe to upgrade. Note that a channel might be in the attaching state without any pending
	 * operations (eg if attached while the connection state is connecting) - such a channel must not
	 * hold up an upgrade, so is not considered inProgress.
	 * Operation is currently one of either 'statechange' or 'sync' */
	Channels.prototype.setInProgress = function(channel, operation, inProgress) {
		this.inProgress[channel.name] = this.inProgress[channel.name] || {};
		this.inProgress[channel.name][operation] = inProgress;
		if(!inProgress && this.hasNopending()) {
			this.emit('nopending');
		}
	};

	Channels.prototype.onceNopending = function(listener) {
		if(this.hasNopending()) {
			listener();
			return;
		}
		this.once('nopending', listener);
	};

	Channels.prototype.hasNopending = function() {
		return utils["a" /* default */].arrEvery(utils["a" /* default */].valuesArray(this.inProgress, true), function(operations) {
			return !utils["a" /* default */].containsValue(operations, true);
		});
	};

	return Realtime;
})();

realtime_Realtime.Promise = function(options) {
	options = defaults["a" /* default */].objectifyOptions(options);
	options.promises = true;
	return new realtime_Realtime(options);
};

realtime_Realtime.Callbacks = realtime_Realtime;

/* harmony default export */ var client_realtime = (realtime_Realtime);

// EXTERNAL MODULE: ./browser/lib/util/msgpack.js
var util_msgpack = __nested_webpack_require_468187__(24);

// CONCATENATED MODULE: ./common/lib/index.js














client_rest.Utils = utils["a" /* default */];
client_rest.BufferUtils = bufferutils["a" /* default */];
client_rest.Crypto = util_crypto["a" /* default */];
client_rest.Defaults = defaults["a" /* default */];
client_rest.Http = http["a" /* default */];
client_rest.Resource = client_resource;
client_rest.Message = types_message["a" /* default */];
client_rest.PresenceMessage = presencemessage["a" /* default */];

client_realtime.Utils = utils["a" /* default */];
client_realtime.BufferUtils = bufferutils["a" /* default */];
client_realtime.Crypto = util_crypto["a" /* default */];
client_realtime.Defaults = defaults["a" /* default */];
client_realtime.Http = http["a" /* default */];
client_realtime.Message = types_message["a" /* default */];
client_realtime.PresenceMessage = presencemessage["a" /* default */];
client_realtime.ProtocolMessage = protocolmessage["a" /* default */];
client_realtime.ConnectionManager = connectionmanager["a" /* default */];

/* harmony default export */ var lib = __webpack_exports__["default"] = ({
  Rest: client_rest,
  Realtime: client_realtime,
  msgpack: util_msgpack["a" /* default */]
});


/***/ })
/******/ ])["default"];
});

/***/ }),

/***/ "./node_modules/ably/promises.js":
/*!***************************************!*\
  !*** ./node_modules/ably/promises.js ***!
  \***************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";

function promisifyOptions(options) {
  if(typeof options == 'string') {
    options = (options.indexOf(':') == -1) ? {token: options} : {key: options};
  }
  options.promises = true;
  return options;
}

/* Please note that the file imported below is only generated after running 
 * the build task. */
var Ably = __webpack_require__(/*! ./browser/static/ably-node */ "./node_modules/ably/browser/static/ably-commonjs.js");

var RestPromise = function(options) {
  return new Ably.Rest(promisifyOptions(options));
}
Object.assign(RestPromise, Ably.Rest);

var RealtimePromise = function(options) {
  return new Ably.Realtime(promisifyOptions(options));
}
Object.assign(RealtimePromise, Ably.Realtime);

module.exports = {
  Rest: RestPromise,
  Realtime: RealtimePromise
};


/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ (function(__unused_webpack_module, exports) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js")
var customInspectSymbol =
  (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('nodejs.util.inspect.custom')
    : null

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    var proto = { foo: function () { return 42 } }
    Object.setPrototypeOf(proto, Uint8Array.prototype)
    Object.setPrototypeOf(arr, proto)
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  Object.setPrototypeOf(buf, Buffer.prototype)
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw new TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof SharedArrayBuffer !== 'undefined' &&
      (isInstance(value, SharedArrayBuffer) ||
      (value && isInstance(value.buffer, SharedArrayBuffer)))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)
Object.setPrototypeOf(Buffer, Uint8Array)

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(buf, Buffer.prototype)

  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}
if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]]
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  Object.setPrototypeOf(newBuf, Buffer.prototype)

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  } else if (typeof val === 'boolean') {
    val = Number(val)
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

// Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219
var hexSliceLookupTable = (function () {
  var alphabet = '0123456789abcdef'
  var table = new Array(256)
  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16
    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j]
    }
  }
  return table
})()


/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, exports) {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "./components/chatroom/chatComponents.module.css":
/*!*******************************************************!*\
  !*** ./components/chatroom/chatComponents.module.css ***!
  \*******************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

var api = __webpack_require__(/*! !../../node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js");
            var content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

            content = content.__esModule ? content.default : content;

            if (typeof content === 'string') {
              content = [[module.id, content, '']];
            }

var options = {};

options.insert = function(element) {
                // These elements should always exist. If they do not,
                // this code should fail.
                var anchorElement = document.querySelector('#__next_css__DO_NOT_USE__');
                var parentNode = anchorElement.parentNode// Normally <head>
                ;
                // Each style tag should be placed right before our
                // anchor. By inserting before and not after, we do not
                // need to track the last inserted element.
                parentNode.insertBefore(element, anchorElement);
            };
options.singleton = false;

var update = api(content, options);


if (true) {
  if (!content.locals || module.hot.invalidate) {
    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {
    if (!a && b || a && !b) {
        return false;
    }
    let p;
    for(p in a){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (a[p] !== b[p]) {
            return false;
        }
    }
    for(p in b){
        if (isNamedExport && p === 'default') {
            continue;
        }
        if (!a[p]) {
            return false;
        }
    }
    return true;
};
    var oldLocals = content.locals;

    module.hot.accept(
      /*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css",
      function () {
        content = __webpack_require__(/*! !!../../node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!../../node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./chatComponents.module.css */ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css");

              content = content.__esModule ? content.default : content;

              if (typeof content === 'string') {
                content = [[module.id, content, '']];
              }

              if (!isEqualLocals(oldLocals, content.locals)) {
                module.hot.invalidate();

                return;
              }

              oldLocals = content.locals;

              update(content);
      }
    )
  }

  module.hot.dispose(function() {
    update();
  });
}

module.exports = content.locals || {};

/***/ }),

/***/ "./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css":
/*!*********************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/css-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[1]!./node_modules/next/dist/compiled/postcss-loader/cjs.js??ruleSet[1].rules[3].oneOf[2].use[2]!./components/chatroom/chatComponents.module.css ***!
  \*********************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Imports
var ___CSS_LOADER_API_IMPORT___ = __webpack_require__(/*! ../../node_modules/next/dist/compiled/css-loader/api.js */ "./node_modules/next/dist/compiled/css-loader/api.js");
var ___CSS_LOADER_EXPORT___ = ___CSS_LOADER_API_IMPORT___(true);
// Module
___CSS_LOADER_EXPORT___.push([module.id, ".chatComponents_chatHolder__2E1AX {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatComponents_chatText__3MREs {\r\n  display: -moz-box;\r\n  display: flex;\r\n  -moz-box-orient: vertical;\r\n  -moz-box-direction: normal;\r\n       flex-direction: column;\r\n  -moz-box-align: start;\r\n       align-items: flex-start;\r\n  grid-gap: 1em;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: -webkit-calc(100vh - 40px - 100px - 100px - 100px);\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.chatComponents_form__3rFIK {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.chatComponents_textarea__2UuLy {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.chatComponents_button__3eZyM {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: -webkit-linear-gradient(left, #363795, #005c97);\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.chatComponents_button__3eZyM:hover {\r\n  background: -webkit-gradient(\r\n    linear,\r\n    left top, right top,\r\n    from(rgba(54, 55, 149, 1)),\r\n    color-stop(62%, rgba(0, 92, 151, 1)),\r\n    to(rgba(0, 125, 205, 1))\r\n  );\r\n  background: -webkit-linear-gradient(\r\n    left,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.chatComponents_button__3eZyM:disabled,\r\n.chatComponents_button__3eZyM:hover:disabled {\r\n  background: -webkit-gradient(linear, left top, right top, from(#363795), to(#005c97));\r\n  background: -webkit-linear-gradient(left, #363795, #005c97);\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.chatComponents_message__1dnoB {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  -moz-box-flex: 0;\r\n       flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n", "",{"version":3,"sources":["webpack://components/chatroom/chatComponents.module.css"],"names":[],"mappings":"AAAA;EACE,aAAa;EACb,6BAA6B;AAC/B;;AAEA;EACE,iBAAa;EAAb,aAAa;EACb,yBAAsB;EAAtB,0BAAsB;OAAtB,sBAAsB;EACtB,qBAAuB;OAAvB,uBAAuB;EACvB,aAAQ;EAAR,QAAQ;EACR,YAAY;EACZ,0DAAkD;EAAlD,kDAAkD;EAClD,gBAAgB;AAClB;;AAEA;EACE,aAAa;EACb,gCAAgC;EAChC,0BAA0B;AAC5B;;AAEA;EACE,YAAY;EACZ,SAAS;EACT;wEACsE;EACtE,gBAAgB;AAClB;;AAEA;EACE,SAAS;EACT,YAAY;EACZ,iBAAiB;EACjB,gBAAgB;EAChB,qFAAuD;EAAvD,2DAAuD;EAAvD,uDAAuD;AACzD;;AAEA;EACE;;;;;;GAKC;EALD;;;;;GAKC;EALD;;;;;GAKC;AACH;;AAEA;;EAEE,qFAAuD;EAAvD,2DAAuD;EAAvD,uDAAuD;EACvD,YAAY;AACd;;AAEA;EACE,yBAAyB;EACzB,YAAY;EACZ,mBAAmB;EACnB,gBAAY;OAAZ,YAAY;EACZ,4BAA4B;AAC9B","sourcesContent":[".chatHolder {\r\n  display: grid;\r\n  grid-template-rows: 1fr 100px;\r\n}\r\n\r\n.chatText {\r\n  display: flex;\r\n  flex-direction: column;\r\n  align-items: flex-start;\r\n  gap: 1em;\r\n  padding: 1em;\r\n  height: calc(100vh - 40px - 100px - 100px - 100px);\r\n  overflow-y: auto;\r\n}\r\n\r\n.form {\r\n  display: grid;\r\n  grid-template-columns: 1fr 100px;\r\n  border-top: 1px solid #eee;\r\n}\r\n\r\n.textarea {\r\n  padding: 1em;\r\n  border: 0;\r\n  font-family: -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen,\r\n    Ubuntu, Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;\r\n  font-size: 1.2em;\r\n}\r\n\r\n.button {\r\n  border: 0;\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size: 1.4em;\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n}\r\n\r\n.button:hover {\r\n  background: linear-gradient(\r\n    90deg,\r\n    rgba(54, 55, 149, 1) 0%,\r\n    rgba(0, 92, 151, 1) 62%,\r\n    rgba(0, 125, 205, 1) 100%\r\n  );\r\n}\r\n\r\n.button:disabled,\r\n.button:hover:disabled {\r\n  background: linear-gradient(to right, #363795, #005c97);\r\n  opacity: 0.5;\r\n}\r\n\r\n.message {\r\n  background-color: #eef5f8;\r\n  padding: 1em;\r\n  border-radius: 10px;\r\n  flex-grow: 0;\r\n  border-bottom-left-radius: 0;\r\n}\r\n"],"sourceRoot":""}]);
// Exports
___CSS_LOADER_EXPORT___.locals = {
	"chatHolder": "chatComponents_chatHolder__2E1AX",
	"chatText": "chatComponents_chatText__3MREs",
	"form": "chatComponents_form__3rFIK",
	"textarea": "chatComponents_textarea__2UuLy",
	"button": "chatComponents_button__3eZyM",
	"message": "chatComponents_message__1dnoB"
};
module.exports = ___CSS_LOADER_EXPORT___;


/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayLikeToArray; }
/* harmony export */ });
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithHoles; }
/* harmony export */ });
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _arrayWithoutHoles; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArray; }
/* harmony export */ });
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _iterableToArrayLimit; }
/* harmony export */ });
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js":
/*!********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableRest; }
/* harmony export */ });
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _nonIterableSpread; }
/* harmony export */ });
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/slicedToArray.js":
/*!******************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js ***!
  \******************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _slicedToArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js");
/* harmony import */ var _iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArrayLimit.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableRest.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js");




function _slicedToArray(arr, i) {
  return (0,_arrayWithHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArrayLimit_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr, i) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr, i) || (0,_nonIterableRest_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js ***!
  \**********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _toConsumableArray; }
/* harmony export */ });
/* harmony import */ var _arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayWithoutHoles.js */ "./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js");
/* harmony import */ var _iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./iterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/iterableToArray.js");
/* harmony import */ var _unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./unsupportedIterableToArray.js */ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js");
/* harmony import */ var _nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./nonIterableSpread.js */ "./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js");




function _toConsumableArray(arr) {
  return (0,_arrayWithoutHoles_js__WEBPACK_IMPORTED_MODULE_0__.default)(arr) || (0,_iterableToArray_js__WEBPACK_IMPORTED_MODULE_1__.default)(arr) || (0,_unsupportedIterableToArray_js__WEBPACK_IMPORTED_MODULE_2__.default)(arr) || (0,_nonIterableSpread_js__WEBPACK_IMPORTED_MODULE_3__.default)();
}

/***/ }),

/***/ "./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js ***!
  \*******************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": function() { return /* binding */ _unsupportedIterableToArray; }
/* harmony export */ });
/* harmony import */ var _arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./arrayLikeToArray.js */ "./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js");

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return (0,_arrayLikeToArray_js__WEBPACK_IMPORTED_MODULE_0__.default)(o, minLen);
}

/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGljL2NodW5rcy9jb21wb25lbnRzX2NoYXRyb29tX2NoYXRDb21wb25lbnRzX2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBLElBQU1FLElBQUksR0FBRyxJQUFJRix1RUFBSixDQUEwQjtBQUFFSyxFQUFBQSxPQUFPLEVBQUU7QUFBWCxDQUExQixDQUFiLEVBRUE7O0FBRU8sU0FBU0MsVUFBVCxDQUFvQkMsV0FBcEIsRUFBaUNDLGlCQUFqQyxFQUFvRDtBQUFBOztBQUN6RCxNQUFNQyxPQUFPLEdBQUdQLElBQUksQ0FBQ1EsUUFBTCxDQUFjQyxHQUFkLENBQWtCSixXQUFsQixDQUFoQjs7QUFFQSxNQUFNSyxPQUFPLEdBQUcsU0FBVkEsT0FBVSxHQUFNO0FBQ3BCSCxJQUFBQSxPQUFPLENBQUNJLFNBQVIsQ0FBa0IsVUFBQ0MsR0FBRCxFQUFTO0FBQ3pCTixNQUFBQSxpQkFBaUIsQ0FBQ00sR0FBRCxDQUFqQjtBQUNELEtBRkQ7QUFHRCxHQUpEOztBQUtBLE1BQU1DLFNBQVMsR0FBRyxTQUFaQSxTQUFZLEdBQU07QUFDdEJOLElBQUFBLE9BQU8sQ0FBQ08sV0FBUjtBQUNELEdBRkQ7O0FBSUEsTUFBTUMsYUFBYSxHQUFHLFNBQWhCQSxhQUFnQixHQUFNO0FBQzFCTCxJQUFBQSxPQUFPO0FBQ1AsV0FBTyxZQUFNO0FBQ1hHLE1BQUFBLFNBQVM7QUFDVixLQUZEO0FBR0QsR0FMRDs7QUFPQWQsRUFBQUEsZ0RBQVMsQ0FBQ2dCLGFBQUQsQ0FBVDtBQUVBLFNBQU8sQ0FBQ1IsT0FBRCxFQUFVUCxJQUFWLENBQVA7QUFDRDs7R0F0QmVJOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDakJoQjtBQUNBO0FBQ0E7OztBQUVBLElB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUNBQW1CO0FBQ3JDLHVDQUF1QyxpQ0FBbUI7QUFDMUQ7QUFDQTtBQUNBLGlCQUFpQixpQ0FBbUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsUUFBUSxNQUFNO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0lBQWdJLGFBQWE7QUFDN0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxzREFBc0QsdUNBQXVDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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TztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscU5BQXFOO0FBQ3JOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsU0FBUztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUMsT0FBTztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRTtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaVFBQWlRO0FBQ2pRLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNlBBQTZQO0FBQzdQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQW9EO0FBQzFFLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnQkFBZ0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0Isb0JBQW9CO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZMQUE2TDtBQUM3TDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa1JBQWtSLFlBQVk7QUFDOVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLGtRQUFrUTtBQUNsUTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVUsOEJBQThCO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsMEJBQTBCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxlQUFlO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLDRCQUE0QixZQUFZLGlDQUFtQixNQUFNLGlDQUFtQjtBQUNwRjtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsUUFBUTtBQUNqQztBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixRQUFRO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEMsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxPQUFPO0FBQ1A7QUFDQSw2Q0FBNkMsaUNBQW1CO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBLGlDQUFtQjtBQUNuQjtBQUNBO0FBQ0EsdUJBQXVCLGlDQUFtQjtBQUMxQztBQUNBO0FBQ0EsWUFBWSxpQ0FBbUI7QUFDL0I7QUFDQTtBQUNBLGFBQWEsaUNBQW1CO0FBQ2hDO0FBQ0E7QUFDQSxlQUFlLGlDQUFtQjtBQUNsQztBQUNBO0FBQ0EsV0FBVyxpQ0FBbUI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixXQUFXO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQ0FBbUI7QUFDOUI7QUFDQTtBQUNBLGtCQUFrQixpQ0FBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwQkFBMEI7QUFDdEY7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5SUFBeUk7QUFDekk7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvTEFBb0wscUJBQXFCLGVBQWU7QUFDeE47QUFDQTtBQUNBLCtGQUErRjtBQUMvRjtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHdCQUF3QjtBQUMxQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQ0FBbUI7QUFDM0M7QUFDQTtBQUNBLDRCQUE0QixpQ0FBbUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxpQkFBaUI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGlDQUFtQjtBQUN6QztBQUNBO0FBQ0Esc0JBQXNCLGlDQUFtQjtBQUN6QztBQUNBO0FBQ0EsdUJBQXVCLGlDQUFtQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxSkFBcUo7QUFDcko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUpBQW1KO0FBQ25KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0pBQW9KO0FBQ3BKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEg7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVIO0FBQ3ZIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUlBQXVJO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxTUFBcU07QUFDck07QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlDQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVM7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsaUJBQWlCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsaUJBQWlCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEVBQUU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixlQUFlO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLHlCQUF5QixRQUFRO0FBQ2pDO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsU0FBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwQkFBMEIsUUFBUTtBQUNsQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGdCQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Es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Ozs7Ozs7Ozs7Ozs7O0FDTnVEO0FBQ0o7QUFDc0I7QUFDbEI7QUFDeEM7QUFDZixTQUFTLDhEQUFpQixTQUFTLDREQUFlLFNBQVMsdUVBQTBCLFNBQVMsOERBQWlCO0FBQy9HOzs7Ozs7Ozs7Ozs7Ozs7O0FDTnFEO0FBQ3RDO0FBQ2Y7QUFDQSxvQ0FBb0MsNkRBQWdCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHNGQUFzRiw2REFBZ0I7QUFDdEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jaGF0cm9vbS9BYmx5UmVhY3RFZmZlY3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY2hhdHJvb20vY2hhdENvbXBvbmVudHMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L2Jyb3dzZXIvc3RhdGljL2FibHktY29tbW9uanMuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9hYmx5L3Byb21pc2VzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9jaGF0cm9vbS9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzP2FjMjgiLCJ3ZWJwYWNrOi8vX05fRS8uL2NvbXBvbmVudHMvY2hhdHJvb20vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5TGlrZVRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9hcnJheVdpdGhIb2xlcy5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2FycmF5V2l0aG91dEhvbGVzLmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5LmpzIiwid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vaXRlcmFibGVUb0FycmF5TGltaXQuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVJlc3QuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9ub25JdGVyYWJsZVNwcmVhZC5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3NsaWNlZFRvQXJyYXkuanMiLCJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS90b0NvbnN1bWFibGVBcnJheS5qcyIsIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vb2ZmZXIgY29tcGFueSBuYW1lIGFuZCBsb2dvXHJcbi8vIHRleHRhcmVhIGZvciBoaXMgb2ZmZXJcclxuLy8gaGlkZGVuIGFuZCBhcHBlYXJcclxuLy8gc3RhdGVzIGZvciByZW5kZXJpbmcgdGhlIHBhZ2VcclxuLy9XZWJTb2NrZXQgY29ubmVjdGlvbnNcclxuLy9BYmx5XHJcbi8vYWRkIGFuZCBJZFxyXG4vL2FkZCBtZXNzYWdlIHN0b3JhZ2UgYW5kIHJldHJpdmFsXHJcbi8vXHJcblxyXG5pbXBvcnQgQWJseSBmcm9tIFwiYWJseS9wcm9taXNlc1wiO1xyXG5pbXBvcnQgeyB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcclxuXHJcbmNvbnN0IGFibHkgPSBuZXcgQWJseS5SZWFsdGltZS5Qcm9taXNlKHsgYXV0aFVybDogXCIvYXBpL2NyZWF0ZVRva2VuUmVxdWVzdFwiIH0pO1xyXG5cclxuLy8gY29uc29sZS5sb2coYWJseSk7XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gdXNlQ2hhbm5lbChjaGFubmVsTmFtZSwgY2FsbGJhY2tPbk1lc3NhZ2UpIHtcclxuICBjb25zdCBjaGFubmVsID0gYWJseS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpO1xyXG5cclxuICBjb25zdCBvbk1vdW50ID0gKCkgPT4ge1xyXG4gICAgY2hhbm5lbC5zdWJzY3JpYmUoKG1zZykgPT4ge1xyXG4gICAgICBjYWxsYmFja09uTWVzc2FnZShtc2cpO1xyXG4gICAgfSk7XHJcbiAgfTtcclxuICBjb25zdCBvblVuTW91bnQgPSAoKSA9PiB7XHJcbiAgICBjaGFubmVsLnVuc3Vic2NyaWJlKCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgdXNlRWZmZWN0SG9vayA9ICgpID0+IHtcclxuICAgIG9uTW91bnQoKTtcclxuICAgIHJldHVybiAoKSA9PiB7XHJcbiAgICAgIG9uVW5Nb3VudCgpO1xyXG4gICAgfTtcclxuICB9O1xyXG5cclxuICB1c2VFZmZlY3QodXNlRWZmZWN0SG9vayk7XHJcblxyXG4gIHJldHVybiBbY2hhbm5lbCwgYWJseV07XHJcbn1cclxuIiwiaW1wb3J0IFJlYWN0LCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tIFwicmVhY3RcIjtcclxuaW1wb3J0IHsgdXNlQ2hhbm5lbCB9IGZyb20gXCIuL0FibHlSZWFjdEVmZmVjdFwiO1xyXG5pbXBvcnQgc3R5bGVzIGZyb20gXCIuLi9jaGF0cm9vbS9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzXCI7XHJcblxyXG5jb25zdCBDaGF0Q29tcG9uZW50ID0gKCkgPT4ge1xyXG4gIGxldCBpbnB1dEJveCA9IG51bGw7XHJcbiAgbGV0IG1lc3NhZ2VFbmQgPSBudWxsO1xyXG5cclxuICBjb25zdCBbbWVzc2FnZVRleHQsIHNldE1lc3NhZ2VUZXh0XSA9IHVzZVN0YXRlKFwiXCIpO1xyXG4gIGNvbnN0IFtyZWNlaXZlZE1lc3NhZ2VzLCBzZXRNZXNzYWdlc10gPSB1c2VTdGF0ZShbXSk7XHJcbiAgY29uc3QgbWVzc2FnZVRleHRJc0VtcHR5ID0gbWVzc2FnZVRleHQudHJpbSgpLmxlbmd0aCA9PT0gMDtcclxuXHJcbiAgY29uc3QgW2NoYW5uZWwsIGFibHldID0gdXNlQ2hhbm5lbChcImNoYXQtZGVtb1wiLCAobWVzc2FnZSkgPT4ge1xyXG4gICAgY29uc3QgaGlzdG9yeSA9IHJlY2VpdmVkTWVzc2FnZXMuc2xpY2UoLTE5OSk7XHJcbiAgICBzZXRNZXNzYWdlcyhbLi4uaGlzdG9yeSwgbWVzc2FnZV0pO1xyXG4gIH0pO1xyXG5cclxuICBjb25zdCBzZW5kQ2hhdE1lc3NhZ2UgPSAobWVzc2FnZVRleHQpID0+IHtcclxuICAgIGNoYW5uZWwucHVibGlzaCh7IG5hbWU6IFwiY2hhdC1tZXNzYWdlXCIsIGRhdGE6IG1lc3NhZ2VUZXh0IH0pO1xyXG4gICAgc2V0TWVzc2FnZVRleHQoXCJcIik7XHJcbiAgICBpbnB1dEJveC5mb2N1cygpO1xyXG4gIH07XHJcblxyXG4gIGNvbnN0IGhhbmRsZUZvcm1TdWJtaXNzaW9uID0gKGV2ZW50KSA9PiB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgc2VuZENoYXRNZXNzYWdlKG1lc3NhZ2VUZXh0KTtcclxuICB9O1xyXG5cclxuICBjb25zdCBoYW5kbGVLZXlQcmVzcyA9IChldmVudCkgPT4ge1xyXG4gICAgaWYgKGV2ZW50LmNoYXJDb2RlICE9PSAxMyB8fCBtZXNzYWdlVGV4dElzRW1wdHkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgc2VuZENoYXRNZXNzYWdlKG1lc3NhZ2VUZXh0KTtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgfTtcclxuXHJcbiAgY29uc3QgbWVzc2FnZXMgPSByZWNlaXZlZE1lc3NhZ2VzLm1hcCgobWVzc2FnZSwgaW5kZXgpID0+IHtcclxuICAgIGNvbnN0IGF1dGhvciA9IG1lc3NhZ2UuY29ubmVjdGlvbklkID09PSBhYmx5LmNvbm5lY3Rpb24uaWQgPyBcIm1lXCIgOiBcIm90aGVyXCI7XHJcblxyXG4gICAgY29uc3QgbWlsbGlzZWNvbmRzID0gbmV3IERhdGUoKTtcclxuICAgIGNvbnN0IHRpbWVTdGFtcCA9IG1pbGxpc2Vjb25kcy50b0RhdGVTdHJpbmcoKTtcclxuXHJcbiAgICAvLyBmdW5jdGlvbiBwYXJzZU1pbGxpc2Vjb25kc0ludG9SZWFkYWJsZVRpbWUobWlsbGlzZWNvbmRzKSB7XHJcbiAgICAvLyAgIC8vR2V0IGhvdXJzIGZyb20gbWlsbGlzZWNvbmRzXHJcbiAgICAvLyAgIHZhciBob3VycyA9IG1pbGxpc2Vjb25kcyAvICgxMDAwICogNjAgKiA2MCk7XHJcbiAgICAvLyAgIHZhciBhYnNvbHV0ZUhvdXJzID0gTWF0aC5mbG9vcihob3Vycyk7XHJcbiAgICAvLyAgIHZhciBoID0gYWJzb2x1dGVIb3VycyA+IDkgPyBhYnNvbHV0ZUhvdXJzIDogXCIwXCIgKyBhYnNvbHV0ZUhvdXJzO1xyXG5cclxuICAgIC8vICAgLy9HZXQgcmVtYWluZGVyIGZyb20gaG91cnMgYW5kIGNvbnZlcnQgdG8gbWludXRlc1xyXG4gICAgLy8gICB2YXIgbWludXRlcyA9IChob3VycyAtIGFic29sdXRlSG91cnMpICogNjA7XHJcbiAgICAvLyAgIHZhciBhYnNvbHV0ZU1pbnV0ZXMgPSBNYXRoLmZsb29yKG1pbnV0ZXMpO1xyXG4gICAgLy8gICB2YXIgbSA9IGFic29sdXRlTWludXRlcyA+IDkgPyBhYnNvbHV0ZU1pbnV0ZXMgOiBcIjBcIiArIGFic29sdXRlTWludXRlcztcclxuXHJcbiAgICAvLyAgIC8vR2V0IHJlbWFpbmRlciBmcm9tIG1pbnV0ZXMgYW5kIGNvbnZlcnQgdG8gc2Vjb25kc1xyXG4gICAgLy8gICB2YXIgc2Vjb25kcyA9IChtaW51dGVzIC0gYWJzb2x1dGVNaW51dGVzKSAqIDYwO1xyXG4gICAgLy8gICB2YXIgYWJzb2x1dGVTZWNvbmRzID0gTWF0aC5mbG9vcihzZWNvbmRzKTtcclxuICAgIC8vICAgdmFyIHMgPSBhYnNvbHV0ZVNlY29uZHMgPiA5ID8gYWJzb2x1dGVTZWNvbmRzIDogXCIwXCIgKyBhYnNvbHV0ZVNlY29uZHM7XHJcblxyXG4gICAgLy8gICByZXR1cm4gaCArIFwiOlwiICsgbSArIFwiOlwiICsgcztcclxuICAgIC8vIH1cclxuXHJcbiAgICAvLyB2YXIgdGltZSA9IHBhcnNlTWlsbGlzZWNvbmRzSW50b1JlYWRhYmxlVGltZShtaWxsaXNlY29uZHMpO1xyXG5cclxuICAgIC8vIGFsZXJ0KHRpbWUpO1xyXG4gICAgLy8gY29uc29sZS5sb2codGltZSk7XHJcblxyXG4gICAgcmV0dXJuIChcclxuICAgICAgPHNwYW5cclxuICAgICAgICBrZXk9e2luZGV4fVxyXG4gICAgICAgIGNsYXNzTmFtZT17c3R5bGVzLm1lc3NhZ2V9XHJcbiAgICAgICAgLy8gdGltZT17bmV3IERhdGUoKS50b1N0cmluZygpfVxyXG4gICAgICAgIGRhdGEtYXV0aG9yPXthdXRob3J9XHJcbiAgICAgID5cclxuICAgICAgICB7bWVzc2FnZS5kYXRhfVxyXG4gICAgICA8L3NwYW4+XHJcbiAgICApO1xyXG4gIH0pO1xyXG5cclxuICB1c2VFZmZlY3QoKCkgPT4ge1xyXG4gICAgbWVzc2FnZUVuZC5zY3JvbGxJbnRvVmlldyh7IGJlaGF2aW91cjogXCJzbW9vdGhcIiB9KTtcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2hhdEhvbGRlcn0+XHJcbiAgICAgIDxkaXYgY2xhc3NOYW1lPXtzdHlsZXMuY2hhdFRleHR9PlxyXG4gICAgICAgIHttZXNzYWdlc31cclxuICAgICAgICB7bmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKX1cclxuICAgICAgICA8ZGl2XHJcbiAgICAgICAgICByZWY9eyhlbGVtZW50KSA9PiB7XHJcbiAgICAgICAgICAgIG1lc3NhZ2VFbmQgPSBlbGVtZW50O1xyXG4gICAgICAgICAgfX1cclxuICAgICAgICA+PC9kaXY+XHJcbiAgICAgIDwvZGl2PlxyXG4gICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlRm9ybVN1Ym1pc3Npb259IGNsYXNzTmFtZT17c3R5bGVzLmZvcm19PlxyXG4gICAgICAgIDx0ZXh0YXJlYVxyXG4gICAgICAgICAgcmVmPXsoZWxlbWVudCkgPT4ge1xyXG4gICAgICAgICAgICBpbnB1dEJveCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICB9fVxyXG4gICAgICAgICAgdmFsdWU9e21lc3NhZ2VUZXh0fVxyXG4gICAgICAgICAgcGxhY2Vob2xkZXI9XCJUeXBlIGEgbWVzc2FnZS4uLlwiXHJcbiAgICAgICAgICAvLyB0aW1lPXtuZXcgRGF0ZSgpLnRvU3RyaW5nKCl9XHJcbiAgICAgICAgICBvbkNoYW5nZT17KGUpID0+IHNldE1lc3NhZ2VUZXh0KGUudGFyZ2V0LnZhbHVlKX1cclxuICAgICAgICAgIG9uS2V5UHJlc3M9e2hhbmRsZUtleVByZXNzfVxyXG4gICAgICAgICAgY2xhc3NOYW1lPXtzdHlsZXMudGV4dGFyZWF9XHJcbiAgICAgICAgPjwvdGV4dGFyZWE+XHJcbiAgICAgICAgPGJ1dHRvblxyXG4gICAgICAgICAgdHlwZT1cInN1Ym1pdFwiXHJcbiAgICAgICAgICBjbGFzc05hbWU9e3N0eWxlcy5idXR0b259XHJcbiAgICAgICAgICBkaXNhYmxlZD17bWVzc2FnZVRleHRJc0VtcHR5fVxyXG4gICAgICAgID5cclxuICAgICAgICAgIFNlbmRcclxuICAgICAgICA8L2J1dHRvbj5cclxuICAgICAgPC9mb3JtPlxyXG4gICAgPC9kaXY+XHJcbiAgKTtcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IENoYXRDb21wb25lbnQ7XHJcbiIsIi8qIVxyXG4gKiBAbGljZW5zZSBDb3B5cmlnaHQgMjAyMSwgQWJseVxyXG4gKiBcclxuICogQWJseSBKYXZhU2NyaXB0IExpYnJhcnkgdjEuMi4xM1xyXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXHJcbiAqIFxyXG4gKiBBYmx5IFJlYWx0aW1lIE1lc3NhZ2luZ1xyXG4gKiBodHRwczovL3d3dy5hYmx5LmNvbVxyXG4gKiBcclxuICogUmVsZWFzZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbmNlIHYyLjBcclxuICovXHJcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XHJcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XHJcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXHJcblx0XHRkZWZpbmUoW10sIGZhY3RvcnkpO1xyXG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxyXG5cdFx0ZXhwb3J0c1tcIkFibHlcIl0gPSBmYWN0b3J5KCk7XHJcblx0ZWxzZVxyXG5cdFx0cm9vdFtcIkFibHlcIl0gPSBmYWN0b3J5KCk7XHJcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XHJcbnJldHVybiAvKioqKioqLyAoZnVuY3Rpb24obW9kdWxlcykgeyAvLyB3ZWJwYWNrQm9vdHN0cmFwXHJcbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxyXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cclxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcclxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XHJcbi8qKioqKiovIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xyXG4vKioqKioqLyBcdFx0fVxyXG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcclxuLyoqKioqKi8gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcclxuLyoqKioqKi8gXHRcdFx0aTogbW9kdWxlSWQsXHJcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxyXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxyXG4vKioqKioqLyBcdFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxyXG4vKioqKioqLyBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXHJcbi8qKioqKiovIFx0XHRtb2R1bGUubCA9IHRydWU7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxyXG4vKioqKioqLyBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xyXG4vKioqKioqLyBcdH1cclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xyXG4vKioqKioqLyBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xyXG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcclxuLyoqKioqKi8gXHRcdH1cclxuLyoqKioqKi8gXHR9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcclxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XHJcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcclxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XHJcbi8qKioqKiovIFx0XHR9XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XHJcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcclxuLyoqKioqKi8gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XHJcbi8qKioqKiovIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xyXG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuLyoqKioqKi8gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XHJcbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XHJcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gbnM7XHJcbi8qKioqKiovIFx0fTtcclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xyXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xyXG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XHJcbi8qKioqKiovIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XHJcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XHJcbi8qKioqKiovIFx0XHRyZXR1cm4gZ2V0dGVyO1xyXG4vKioqKioqLyBcdH07XHJcbi8qKioqKiovXHJcbi8qKioqKiovIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xyXG4vKioqKioqL1xyXG4vKioqKioqLyBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXHJcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcclxuLyoqKioqKi9cclxuLyoqKioqKi9cclxuLyoqKioqKi8gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcclxuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA1MCk7XHJcbi8qKioqKiovIH0pXHJcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXHJcbi8qKioqKiovIChbXHJcbi8qIDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG5cclxudmFyIExvZ2dlciA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgY29uc29sZUxvZ2dlciwgZXJyb3JMb2dnZXI7XHJcblxyXG5cdC8qIENhbid0IGp1c3QgY2hlY2sgZm9yIGNvbnNvbGUgJiYgY29uc29sZS5sb2c7IGZhaWxzIGluIElFIDw9OSAqL1xyXG5cdGlmKCh0eXBlb2YgV2luZG93ID09PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgV29ya2VyR2xvYmFsU2NvcGUgPT09ICd1bmRlZmluZWQnKSAvKiBub2RlICovIHx8XHJcblx0XHQgKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmxvZyAmJiAodHlwZW9mIGdsb2JhbC5jb25zb2xlLmxvZy5hcHBseSA9PT0gJ2Z1bmN0aW9uJykpIC8qIHNlbnNpYmxlIGJyb3dzZXJzICovKSB7XHJcblx0XHRjb25zb2xlTG9nZ2VyID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3VtZW50cyk7IH07XHJcblx0XHRlcnJvckxvZ2dlciA9IGNvbnNvbGUud2FybiA/IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4uYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTsgfSA6IGNvbnNvbGVMb2dnZXI7XHJcblx0fSBlbHNlIGlmKGdsb2JhbC5jb25zb2xlICYmIGdsb2JhbC5jb25zb2xlLmxvZykge1xyXG5cdFx0LyogSUUgPD0gOSB3aXRoIHRoZSBjb25zb2xlIG9wZW4gLS0gY29uc29sZS5sb2cgZG9lcyBub3RcclxuXHRcdCAqIGluaGVyaXQgZnJvbSBGdW5jdGlvbiwgc28gaGFzIG5vIGFwcGx5IG1ldGhvZCAqL1xyXG5cdFx0Y29uc29sZUxvZ2dlciA9IGVycm9yTG9nZ2VyID0gZnVuY3Rpb24oKSB7IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpOyB9O1xyXG5cdH0gZWxzZSB7XHJcblx0XHQvKiBJRSA8PSA5IHdoZW4gZGV2IHRvb2xzIGFyZSBjbG9zZWQgLSB3aW5kb3cuY29uc29sZSBub3QgZXZlbiBkZWZpbmVkICovXHJcblx0XHRjb25zb2xlTG9nZ2VyID0gZXJyb3JMb2dnZXIgPSBmdW5jdGlvbigpIHt9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFkKHN0ciwgdGhyZWUpIHtcclxuXHRcdHJldHVybiAoJzAwMCcgKyBzdHIpLnNsaWNlKC0yLSh0aHJlZSB8fCAwKSk7XHJcblx0fVxyXG5cclxuXHR2YXIgTE9HX05PTkUgID0gMCxcclxuXHRMT0dfRVJST1IgPSAxLFxyXG5cdExPR19NQUpPUiA9IDIsXHJcblx0TE9HX01JTk9SID0gMyxcclxuXHRMT0dfTUlDUk8gPSA0O1xyXG5cclxuXHR2YXIgTE9HX0RFRkFVTFQgPSBMT0dfRVJST1IsXHJcblx0TE9HX0RFQlVHICAgPSBMT0dfTUlDUk87XHJcblxyXG5cdHZhciBsb2dMZXZlbCA9IExPR19ERUZBVUxUO1xyXG5cclxuXHRmdW5jdGlvbiBnZXRIYW5kbGVyKGxvZ2dlcikge1xyXG5cdFx0cmV0dXJuIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nVGltZXN0YW1wcyA/XHJcblx0XHRcdGZ1bmN0aW9uKG1zZykge1xyXG5cdFx0XHRcdHZhciB0aW1lID0gbmV3IERhdGUoKTtcclxuXHRcdFx0XHRsb2dnZXIocGFkKHRpbWUuZ2V0SG91cnMoKSkgKyAnOicgKyBwYWQodGltZS5nZXRNaW51dGVzKCkpICsgJzonICsgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArICcuJyArIHBhZCh0aW1lLmdldE1pbGxpc2Vjb25kcygpLCB0cnVlKSArICcgJyArIG1zZyk7XHJcblx0XHRcdH0gOiBsb2dnZXI7XHJcblx0fVxyXG5cclxuXHR2YXIgbG9nSGFuZGxlciA9IGdldEhhbmRsZXIoY29uc29sZUxvZ2dlciksXHJcblx0XHRsb2dFcnJvckhhbmRsZXIgPSBnZXRIYW5kbGVyKGVycm9yTG9nZ2VyKTtcclxuXHJcblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXHJcblx0ZnVuY3Rpb24gTG9nZ2VyKGFyZ3MpIHt9XHJcblxyXG5cdC8qIHB1YmxpYyBjb25zdGFudHMgKi9cclxuXHRMb2dnZXIuTE9HX05PTkUgICAgPSBMT0dfTk9ORSxcclxuXHRMb2dnZXIuTE9HX0VSUk9SICAgPSBMT0dfRVJST1IsXHJcblx0TG9nZ2VyLkxPR19NQUpPUiAgID0gTE9HX01BSk9SLFxyXG5cdExvZ2dlci5MT0dfTUlOT1IgICA9IExPR19NSU5PUixcclxuXHRMb2dnZXIuTE9HX01JQ1JPICAgPSBMT0dfTUlDUk87XHJcblxyXG5cdExvZ2dlci5MT0dfREVGQVVMVCA9IExPR19ERUZBVUxULFxyXG5cdExvZ2dlci5MT0dfREVCVUcgICA9IExPR19ERUJVRztcclxuXHJcblx0LyogcHVibGljIHN0YXRpYyBmdW5jdGlvbnMgKi9cclxuXHRMb2dnZXIubG9nQWN0aW9uID0gZnVuY3Rpb24obGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkge1xyXG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2cobGV2ZWwpKSB7XHJcblx0XHRcdChsZXZlbCA9PT0gTE9HX0VSUk9SID8gbG9nRXJyb3JIYW5kbGVyIDogbG9nSGFuZGxlcikoJ0FibHk6ICcgKyBhY3Rpb24gKyAnOiAnICsgbWVzc2FnZSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0TG9nZ2VyLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbihvcmlnaW5hbCwgcmVwbGFjZW1lbnQpIHtcclxuXHRcdExvZ2dlci5kZXByZWNhdGVkV2l0aE1zZyhvcmlnaW5hbCwgXCJQbGVhc2UgdXNlICdcIiArIHJlcGxhY2VtZW50ICsgXCInIGluc3RlYWQuXCIpO1xyXG5cdH1cclxuXHJcblx0TG9nZ2VyLmRlcHJlY2F0ZWRXaXRoTXNnID0gZnVuY3Rpb24oZnVuY05hbWUsIG1zZykge1xyXG5cdFx0aWYgKExvZ2dlci5zaG91bGRMb2coTE9HX0VSUk9SKSkge1xyXG5cdFx0XHRsb2dFcnJvckhhbmRsZXIoXCJBYmx5OiBEZXByZWNhdGlvbiB3YXJuaW5nIC0gJ1wiICsgZnVuY05hbWUgKyBcIicgaXMgZGVwcmVjYXRlZCBhbmQgd2lsbCBiZSByZW1vdmVkIGZyb20gYSBmdXR1cmUgdmVyc2lvbi4gXCIgKyBtc2cpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyogV2hlcmUgYSBsb2dnaW5nIG9wZXJhdGlvbiBpcyBleHBlbnNpdmUsIHN1Y2ggYXMgc2VyaWFsaXNhdGlvbiBvZiBkYXRhLCB1c2Ugc2hvdWxkTG9nIHdpbGwgcHJldmVudFxyXG5cdCAgIHRoZSBvYmplY3QgYmVpbmcgc2VyaWFsaXNlZCBpZiB0aGUgbG9nIGxldmVsIHdpbGwgbm90IG91dHB1dCB0aGUgbWVzc2FnZSAqL1xyXG5cdExvZ2dlci5zaG91bGRMb2cgPSBmdW5jdGlvbihsZXZlbCkge1xyXG5cdFx0cmV0dXJuIGxldmVsIDw9IGxvZ0xldmVsO1xyXG5cdH07XHJcblxyXG5cdExvZ2dlci5zZXRMb2cgPSBmdW5jdGlvbihsZXZlbCwgaGFuZGxlcikge1xyXG5cdFx0aWYobGV2ZWwgIT09IHVuZGVmaW5lZCkgbG9nTGV2ZWwgPSBsZXZlbDtcclxuXHRcdGlmKGhhbmRsZXIgIT09IHVuZGVmaW5lZCkgbG9nSGFuZGxlciA9IGxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIExvZ2dlcjtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTG9nZ2VyKTtcclxuXHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXHJcblxyXG4vKioqLyB9KSxcclxuLyogMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG5cclxuXHJcblxyXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xyXG5cclxudmFyIFV0aWxzID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5tc2dwYWNrO1xyXG5cclxuXHRmdW5jdGlvbiBVdGlscygpIHt9XHJcblxyXG5cdGZ1bmN0aW9uIHJhbmRvbVBvc24oYXJyT3JTdHIpIHtcclxuXHRcdHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJPclN0ci5sZW5ndGgpO1xyXG5cdH1cclxuXHJcblx0LypcclxuXHQgKiBBZGQgYSBzZXQgb2YgcHJvcGVydGllcyB0byBhIHRhcmdldCBvYmplY3RcclxuXHQgKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XHJcblx0ICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxyXG5cdCAqICAgICAgICAgYWRkZWQsIGJ5IHJlZmVyZW5jZSBvbmx5XHJcblx0ICovXHJcblx0VXRpbHMubWl4aW4gPSBmdW5jdGlvbih0YXJnZXQpIHtcclxuXHRcdGZvcih2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXTtcclxuXHRcdFx0aWYoIXNvdXJjZSkgeyBicmVhazsgfVxyXG5cdFx0XHRmb3IodmFyIGtleSBpbiBzb3VyY2UpIHtcclxuXHRcdFx0XHRpZihoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xyXG5cdFx0XHRcdFx0dGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0YXJnZXQ7XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQgKiBBZGQgYSBzZXQgb2YgcHJvcGVydGllcyB0byBhIHRhcmdldCBvYmplY3RcclxuXHQgKiB0YXJnZXQ6IHRoZSB0YXJnZXQgb2JqZWN0XHJcblx0ICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxyXG5cdCAqICAgICAgICAgYWRkZWQsIGJ5IHJlZmVyZW5jZSBvbmx5XHJcblx0ICovXHJcblx0VXRpbHMuY29weSA9IGZ1bmN0aW9uKHNyYykge1xyXG5cdFx0cmV0dXJuIFV0aWxzLm1peGluKHt9LCBzcmMpO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGEgZ2l2ZW4gb2JqZWN0IGlzXHJcblx0ICogYW4gYXJyYXkuXHJcblx0ICovXHJcblx0VXRpbHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24ob2IpIHtcclxuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09ICdbb2JqZWN0IEFycmF5XSc7XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQgKiBFbnN1cmVzIHRoYXQgYW4gQXJyYXkgb2JqZWN0IGlzIGFsd2F5cyByZXR1cm5lZFxyXG5cdCAqIHJldHVybmluZyB0aGUgb3JpZ2luYWwgQXJyYXkgb2Ygb2JqIGlzIGFuIEFycmF5XHJcblx0ICogZWxzZSB3cmFwcGluZyB0aGUgb2JqIGluIGEgc2luZ2xlIGVsZW1lbnQgQXJyYXlcclxuXHQgKi9cclxuXHRVdGlscy5lbnN1cmVBcnJheSA9IGZ1bmN0aW9uKG9iaikge1xyXG5cdFx0aWYoVXRpbHMuaXNFbXB0eUFyZyhvYmopKSB7XHJcblx0XHRcdHJldHVybiBbXTtcclxuXHRcdH1cclxuXHRcdGlmKFV0aWxzLmlzQXJyYXkob2JqKSkge1xyXG5cdFx0XHRyZXR1cm4gb2JqO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIFtvYmpdO1xyXG5cdH1cclxuXHJcblx0LyogLi4uT3IgYW4gT2JqZWN0IChpbiB0aGUgbmFycm93IHNlbnNlKSAqL1xyXG5cdFV0aWxzLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2IpIHtcclxuXHRcdHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2IpID09ICdbb2JqZWN0IE9iamVjdF0nO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb250YWluc1xyXG5cdCAqIGFueSBlbnVtZXJhYmxlIHByb3BlcnRpZXMuXHJcblx0ICogb2I6IHRoZSBvYmplY3RcclxuXHQgKi9cclxuXHRVdGlscy5pc0VtcHR5ID0gZnVuY3Rpb24ob2IpIHtcclxuXHRcdGZvcih2YXIgcHJvcCBpbiBvYilcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblx0fTtcclxuXHJcblx0VXRpbHMuaXNPbmx5UHJvcEluID0gZnVuY3Rpb24ob2IsIHByb3BlcnR5KSB7XHJcblx0XHRmb3IodmFyIHByb3AgaW4gb2IpIHtcclxuXHRcdFx0aWYocHJvcCAhPT0gcHJvcGVydHkpIHtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIGFyZ3VtZW50IHRvIGFuIG92ZXJsb2FkZWQgZnVuY3Rpb24gaXNcclxuXHQgKiB1bmRlZmluZWQgKG1pc3NpbmcpIG9yIG51bGwuXHJcblx0ICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4gY29uc3RydWN0aW5nIGZ1bmN0aW9ucyBzdWNoIGFzIChXZWJJREwgdGVybWlub2xvZ3kpOlxyXG5cdCAqICAgb2ZmKFtUcmVhdFVuZGVmaW5lZEFzPU51bGxdIERPTVN0cmluZz8gZXZlbnQpXHJcblx0ICogYXMgeW91IGNhbiB0aGVuIGNvbmZpcm0gdGhlIGFyZ3VtZW50IHVzaW5nOlxyXG5cdCAqICAgVXRpbHMuaXNFbXB0eUFyZyhldmVudClcclxuXHQgKi9cclxuXHJcblx0VXRpbHMuaXNFbXB0eUFyZyA9IGZ1bmN0aW9uKGFyZykge1xyXG5cdFx0cmV0dXJuIGFyZyA9PT0gbnVsbCB8fCBhcmcgPT09IHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdC8qXHJcblx0ICogUGVyZm9ybSBhIHNpbXBsZSBzaGFsbG93IGNsb25lIG9mIGFuIG9iamVjdC5cclxuXHQgKiBSZXN1bHQgaXMgYW4gb2JqZWN0IGlycmVzcGVjdGl2ZSBvZiB3aGV0aGVyXHJcblx0ICogdGhlIGlucHV0IGlzIGFuIG9iamVjdCBvciBhcnJheS4gQWxsXHJcblx0ICogZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb3BpZWQuXHJcblx0ICogb2I6IHRoZSBvYmplY3RcclxuXHQgKi9cclxuXHRVdGlscy5zaGFsbG93Q2xvbmUgPSBmdW5jdGlvbihvYikge1xyXG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBPYmplY3QoKTtcclxuXHRcdGZvcih2YXIgcHJvcCBpbiBvYilcclxuXHRcdFx0cmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0ICogQ2xvbmUgYW4gb2JqZWN0IGJ5IGNyZWF0aW5nIGEgbmV3IG9iamVjdCB3aXRoIHRoZVxyXG5cdCAqIGdpdmVuIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlLiBPcHRpb25hbGx5XHJcblx0ICogYSBzZXQgb2YgYWRkaXRpb25hbCBvd24gcHJvcGVydGllcyBjYW4gYmVcclxuXHQgKiBzdXBwbGllZCB0byBiZSBhZGRlZCB0byB0aGUgbmV3bHkgY3JlYXRlZCBjbG9uZS5cclxuXHQgKiBvYjogICAgICAgICAgICB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxyXG5cdCAqIG93blByb3BlcnRpZXM6IG9wdGlvbmFsIG9iamVjdCB3aXRoIGFkZGl0aW9uYWxcclxuXHQgKiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzIHRvIGFkZFxyXG5cdCAqL1xyXG5cdFV0aWxzLnByb3RvdHlwaWNhbENsb25lID0gZnVuY3Rpb24ob2IsIG93blByb3BlcnRpZXMpIHtcclxuXHRcdGZ1bmN0aW9uIEYoKSB7fVxyXG5cdFx0Ri5wcm90b3R5cGUgPSBvYjtcclxuXHRcdHZhciByZXN1bHQgPSBuZXcgRigpO1xyXG5cdFx0aWYob3duUHJvcGVydGllcylcclxuXHRcdFx0VXRpbHMubWl4aW4ocmVzdWx0LCBvd25Qcm9wZXJ0aWVzKTtcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0LypcclxuXHQgKiBEZWNsYXJlIGEgY29uc3RydWN0b3IgdG8gcmVwcmVzZW50IGEgc3ViY2xhc3NcclxuXHQgKiBvZiBhbm90aGVyIGNvbnN0cnVjdG9yXHJcblx0ICogSWYgcGxhdGZvcm0gaGFzIGEgYnVpbHQtaW4gdmVyc2lvbiB3ZSB1c2UgdGhhdCBmcm9tIFBsYXRmb3JtLCBlbHNlIHdlXHJcblx0ICogZGVmaW5lIGhlcmUgKHNvIGNhbiBtYWtlIHVzZSBvZiBvdGhlciBVdGlscyBmbnMpXHJcblx0ICogU2VlIG5vZGUuanMgdXRpbC5pbmhlcml0c1xyXG5cdCAqL1xyXG5cdFV0aWxzLmluaGVyaXRzID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyB8fCBmdW5jdGlvbihjdG9yLCBzdXBlckN0b3IpIHtcclxuXHRcdGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yO1xyXG5cdFx0Y3Rvci5wcm90b3R5cGUgPSBVdGlscy5wcm90b3R5cGljYWxDbG9uZShzdXBlckN0b3IucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiBjdG9yIH0pO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0ICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBoYXMgYW4gZW51bWVyYWJsZVxyXG5cdCAqIHByb3BlcnR5IHdob3NlIHZhbHVlIGVxdWFscyBhIGdpdmVuIHZhbHVlLlxyXG5cdCAqIG9iOiAgdGhlIG9iamVjdFxyXG5cdCAqIHZhbDogdGhlIHZhbHVlIHRvIGZpbmRcclxuXHQgKi9cclxuXHRVdGlscy5jb250YWluc1ZhbHVlID0gZnVuY3Rpb24ob2IsIHZhbCkge1xyXG5cdFx0Zm9yKHZhciBpIGluIG9iKSB7XHJcblx0XHRcdGlmKG9iW2ldID09IHZhbClcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBmYWxzZTtcclxuXHR9O1xyXG5cclxuXHRVdGlscy5pbnRlcnNlY3QgPSBmdW5jdGlvbihhcnIsIG9iKSB7IHJldHVybiBVdGlscy5pc0FycmF5KG9iKSA/IFV0aWxzLmFyckludGVyc2VjdChhcnIsIG9iKSA6IFV0aWxzLmFyckludGVyc2VjdE9iKGFyciwgb2IpOyB9O1xyXG5cclxuXHRVdGlscy5hcnJJbnRlcnNlY3QgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgbWVtYmVyID0gYXJyMVtpXTtcclxuXHRcdFx0aWYoVXRpbHMuYXJySW5kZXhPZihhcnIyLCBtZW1iZXIpICE9IC0xKVxyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKG1lbWJlcik7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLmFyckludGVyc2VjdE9iID0gZnVuY3Rpb24oYXJyLCBvYikge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgbWVtYmVyID0gYXJyW2ldO1xyXG5cdFx0XHRpZihtZW1iZXIgaW4gb2IpXHJcblx0XHRcdFx0cmVzdWx0LnB1c2gobWVtYmVyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0VXRpbHMuYXJyU3VidHJhY3QgPSBmdW5jdGlvbihhcnIxLCBhcnIyKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYXJyMS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgZWxlbWVudCA9IGFycjFbaV07XHJcblx0XHRcdGlmKFV0aWxzLmFyckluZGV4T2YoYXJyMiwgZWxlbWVudCkgPT0gLTEpXHJcblx0XHRcdFx0cmVzdWx0LnB1c2goZWxlbWVudCk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLmFyckluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxyXG5cdFx0PyBmdW5jdGlvbihhcnIsIGVsZW0sIGZyb21JbmRleCkge1xyXG5cdFx0XHRyZXR1cm4gYXJyLmluZGV4T2YoZWxlbSwgIGZyb21JbmRleCk7XHJcblx0XHR9XHJcblx0XHQ6IGZ1bmN0aW9uKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XHJcblx0XHRcdGZyb21JbmRleCA9IGZyb21JbmRleCB8fCAwO1xyXG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcclxuXHRcdFx0Zm9yKDtmcm9tSW5kZXggPCBsZW47IGZyb21JbmRleCsrKSB7XHJcblx0XHRcdFx0aWYoYXJyW2Zyb21JbmRleF0gPT09IGVsZW0pIHtcclxuXHRcdFx0XHRcdHJldHVybiBmcm9tSW5kZXg7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiAtMTtcclxuXHRcdH07XHJcblxyXG5cdFV0aWxzLmFyckluID0gZnVuY3Rpb24oYXJyLCB2YWwpIHtcclxuXHRcdHJldHVybiBVdGlscy5hcnJJbmRleE9mKGFyciwgdmFsKSAhPT0gLTE7XHJcblx0fTtcclxuXHJcblx0VXRpbHMuYXJyRGVsZXRlVmFsdWUgPSBmdW5jdGlvbihhcnIsIHZhbCkge1xyXG5cdFx0dmFyIGlkeCA9IFV0aWxzLmFyckluZGV4T2YoYXJyLCB2YWwpO1xyXG5cdFx0dmFyIHJlcyA9IChpZHggIT0gLTEpO1xyXG5cdFx0aWYocmVzKVxyXG5cdFx0XHRhcnIuc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRyZXR1cm4gcmVzO1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLmFycldpdGhvdXRWYWx1ZSA9IGZ1bmN0aW9uKGFyciwgdmFsKSB7XHJcblx0XHR2YXIgbmV3QXJyID0gYXJyLnNsaWNlKCk7XHJcblx0XHRVdGlscy5hcnJEZWxldGVWYWx1ZShuZXdBcnIsIHZhbCk7XHJcblx0XHRyZXR1cm4gbmV3QXJyO1xyXG5cdH07XHJcblxyXG5cdC8qXHJcblx0ICogQ29uc3RydWN0IGFuIGFycmF5IG9mIHRoZSBrZXlzIG9mIHRoZSBlbnVtZXJhYmxlXHJcblx0ICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXHJcblx0ICogdG8gb25seSB0aGUgb3duIHByb3BlcnRpZXMuXHJcblx0ICogb2I6ICAgICAgdGhlIG9iamVjdFxyXG5cdCAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XHJcblx0ICovXHJcblx0VXRpbHMua2V5c0FycmF5ID0gZnVuY3Rpb24ob2IsIG93bk9ubHkpIHtcclxuXHRcdHZhciByZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgcHJvcCBpbiBvYikge1xyXG5cdFx0XHRpZihvd25Pbmx5ICYmICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iLCBwcm9wKSkgY29udGludWU7XHJcblx0XHRcdHJlc3VsdC5wdXNoKHByb3ApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cclxuXHQvKlxyXG5cdCAqIENvbnN0cnVjdCBhbiBhcnJheSBvZiB0aGUgdmFsdWVzIG9mIHRoZSBlbnVtZXJhYmxlXHJcblx0ICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXHJcblx0ICogdG8gb25seSB0aGUgb3duIHByb3BlcnRpZXMuXHJcblx0ICogb2I6ICAgICAgdGhlIG9iamVjdFxyXG5cdCAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XHJcblx0ICovXHJcblx0VXRpbHMudmFsdWVzQXJyYXkgPSBmdW5jdGlvbihvYiwgb3duT25seSkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBwcm9wIGluIG9iKSB7XHJcblx0XHRcdGlmKG93bk9ubHkgJiYgIWhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApKSBjb250aW51ZTtcclxuXHRcdFx0cmVzdWx0LnB1c2gob2JbcHJvcF0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cclxuXHRVdGlscy5mb3JJbk93bk5vbk51bGxQcm9wcyA9IGZ1bmN0aW9uKG9iLCBmbikge1xyXG5cdFx0Zm9yICh2YXIgcHJvcCBpbiBvYikge1xyXG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkgJiYgb2JbcHJvcF0pIHtcclxuXHRcdFx0XHRmbihwcm9wKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFV0aWxzLmFyckZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaCA/XHJcblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XHJcblx0XHRcdGFyci5mb3JFYWNoKGZuKTtcclxuXHRcdH0gOlxyXG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xyXG5cdFx0XHR2YXIgbGVuID0gYXJyLmxlbmd0aDtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XHJcblx0XHRcdFx0Zm4oYXJyW2ldLCBpLCBhcnIpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHQvKiBVc2VmdWwgd2hlbiB0aGUgZnVuY3Rpb24gbWF5IG11dGF0ZSB0aGUgYXJyYXkgKi9cclxuXHRVdGlscy5zYWZlQXJyRm9yRWFjaCA9IGZ1bmN0aW9uKGFyciwgZm4pIHtcclxuXHRcdHJldHVybiBVdGlscy5hcnJGb3JFYWNoKGFyci5zbGljZSgpLCBmbik7XHJcblx0fTtcclxuXHJcblx0VXRpbHMuYXJyTWFwID0gQXJyYXkucHJvdG90eXBlLm1hcCA/XHJcblx0XHRmdW5jdGlvbihhcnIsIGZuKSB7XHJcblx0XHRcdHJldHVybiBhcnIubWFwKGZuKTtcclxuXHRcdH0gOlxyXG5cdFx0ZnVuY3Rpb24oYXJyLCBmbilcdHtcclxuXHRcdFx0dmFyIHJlc3VsdCA9IFtdLFxyXG5cdFx0XHRcdGxlbiA9IGFyci5sZW5ndGg7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG5cdFx0XHRcdHJlc3VsdC5wdXNoKGZuKGFycltpXSwgaSwgYXJyKSk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcclxuXHRcdH07XHJcblxyXG5cdFV0aWxzLmFyckZpbHRlciA9IEFycmF5LnByb3RvdHlwZS5maWx0ZXIgP1xyXG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xyXG5cdFx0XHRyZXR1cm4gYXJyLmZpbHRlcihmbik7XHJcblx0XHR9IDpcclxuXHRcdGZ1bmN0aW9uKGFyciwgZm4pXHR7XHJcblx0XHRcdHZhciByZXN1bHQgPSBbXSxcclxuXHRcdFx0XHRsZW4gPSBhcnIubGVuZ3RoO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRpZihmbihhcnJbaV0pKSB7XHJcblx0XHRcdFx0XHRyZXN1bHQucHVzaChhcnJbaV0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fTtcclxuXHJcblx0VXRpbHMuYXJyRXZlcnkgPSBBcnJheS5wcm90b3R5cGUuZXZlcnkgP1xyXG5cdFx0ZnVuY3Rpb24oYXJyLCBmbikge1xyXG5cdFx0XHRyZXR1cm4gYXJyLmV2ZXJ5KGZuKTtcclxuXHRcdH0gOiBmdW5jdGlvbihhcnIsIGZuKSB7XHJcblx0XHRcdHZhciBsZW4gPSBhcnIubGVuZ3RoO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcclxuXHRcdFx0XHRpZighZm4oYXJyW2ldLCBpLCBhcnIpKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdH07XHJcblxyXG5cdFV0aWxzLmFsbFNhbWUgPSBmdW5jdGlvbihhcnIsIHByb3ApIHtcclxuXHRcdGlmKGFyci5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHR9XHJcblx0XHR2YXIgZmlyc3QgPSBhcnJbMF1bcHJvcF07XHJcblx0XHRyZXR1cm4gVXRpbHMuYXJyRXZlcnkoYXJyLCBmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdHJldHVybiBpdGVtW3Byb3BdID09PSBmaXJzdDtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLm5leHRUaWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljaztcclxuXHJcblx0dmFyIGNvbnRlbnRUeXBlcyA9IHtcclxuXHRcdGpzb246ICAgJ2FwcGxpY2F0aW9uL2pzb24nLFxyXG5cdFx0anNvbnA6ICAnYXBwbGljYXRpb24vamF2YXNjcmlwdCcsXHJcblx0XHR4bWw6ICAgICdhcHBsaWNhdGlvbi94bWwnLFxyXG5cdFx0aHRtbDogICAndGV4dC9odG1sJyxcclxuXHRcdG1zZ3BhY2s6ICdhcHBsaWNhdGlvbi94LW1zZ3BhY2snXHJcblx0fTtcclxuXHJcblx0VXRpbHMuZGVmYXVsdEdldEhlYWRlcnMgPSBmdW5jdGlvbihmb3JtYXQpIHtcclxuXHRcdHZhciBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0IHx8ICdqc29uJ107XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRhY2NlcHQ6IGFjY2VwdCxcclxuXHRcdFx0J1gtQWJseS1WZXJzaW9uJzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXBpVmVyc2lvbixcclxuXHRcdFx0J0FibHktQWdlbnQnOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZ2VudFxyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHRVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnMgPSBmdW5jdGlvbihmb3JtYXQpIHtcclxuXHRcdHZhciBhY2NlcHQsIGNvbnRlbnRUeXBlO1xyXG5cdFx0YWNjZXB0ID0gY29udGVudFR5cGUgPSBjb250ZW50VHlwZXNbZm9ybWF0IHx8ICdqc29uJ107XHJcblxyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0YWNjZXB0OiBhY2NlcHQsXHJcblx0XHRcdCdjb250ZW50LXR5cGUnOiBjb250ZW50VHlwZSxcclxuXHRcdFx0J1gtQWJseS1WZXJzaW9uJzogX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXBpVmVyc2lvbixcclxuXHRcdFx0J0FibHktQWdlbnQnOiBfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hZ2VudFxyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHRVdGlscy5hcnJQb3BSYW5kb21FbGVtZW50ID0gZnVuY3Rpb24oYXJyKSB7XHJcblx0XHRyZXR1cm4gYXJyLnNwbGljZShyYW5kb21Qb3NuKGFyciksIDEpWzBdO1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLnRvUXVlcnlTdHJpbmcgPSBmdW5jdGlvbihwYXJhbXMpIHtcclxuXHRcdHZhciBwYXJ0cyA9IFtdO1xyXG5cdFx0aWYocGFyYW1zKSB7XHJcblx0XHRcdGZvcih2YXIga2V5IGluIHBhcmFtcylcclxuXHRcdFx0XHRwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChrZXkpICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHBhcmFtc1trZXldKSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcGFydHMubGVuZ3RoID8gJz8nICsgcGFydHMuam9pbignJicpIDogJyc7XHJcblx0fTtcclxuXHJcblx0VXRpbHMucGFyc2VRdWVyeVN0cmluZyA9IGZ1bmN0aW9uKHF1ZXJ5KSB7XHJcblx0XHR2YXIgbWF0Y2gsXHJcblx0XHRcdHNlYXJjaCA9IC8oW14/Jj1dKyk9PyhbXiZdKikvZyxcclxuXHRcdFx0cmVzdWx0ID0ge307XHJcblxyXG5cdFx0d2hpbGUgKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKVxyXG5cdFx0XHRyZXN1bHRbZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzFdKV0gPSBkZWNvZGVVUklDb21wb25lbnQobWF0Y2hbMl0pO1xyXG5cclxuIFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xyXG5cdFx0LyogSUUgOCAqL1xyXG5cdFx0cmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLmluc3BlY3QgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3Q7XHJcblxyXG5cdFV0aWxzLmlzRXJyb3JJbmZvID0gZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRyZXR1cm4gZXJyLmNvbnN0cnVjdG9yLm5hbWUgPT0gJ0Vycm9ySW5mbydcclxuXHR9O1xyXG5cclxuXHRVdGlscy5pbnNwZWN0RXJyb3IgPSBmdW5jdGlvbih4KSB7XHJcblx0XHQvKiByZWR1bmRhbnQsIGJ1dCBub2RlIHZtY29udGV4dCBpc3N1ZSBtYWtlcyBpbnN0YW5jZW9mIHVucmVsaWFibGUsIGFuZFxyXG5cdFx0ICogY2FuJ3QgdXNlIGp1c3QgY29uc3RydWN0b3IgdGVzdCBhcyBjb3VsZCBiZSBhIFR5cGVFcnJvciBjb25zdHJ1Y3RvciBldGMuICovXHJcblx0XHRyZXR1cm4gKHggJiYgKFV0aWxzLmlzRXJyb3JJbmZvKHgpIHx8XHJcblx0XHRcdHguY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3InIHx8XHJcblx0XHRcdHggaW5zdGFuY2VvZiBFcnJvcikpID9cclxuXHRcdFx0eC50b1N0cmluZygpIDpcclxuXHRcdFx0VXRpbHMuaW5zcGVjdCh4KTtcclxuXHR9O1xyXG5cclxuXHRVdGlscy5pbnNwZWN0Qm9keSA9IGZ1bmN0aW9uKGJvZHkpIHtcclxuXHRcdGlmKHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoYm9keSkpIHtcclxuXHRcdFx0cmV0dXJuIGJvZHkudG9TdHJpbmcoKTtcclxuXHRcdH0gZWxzZSBpZih0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0cmV0dXJuIGJvZHk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KGJvZHkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdC8qIERhdGEgaXMgYXNzdW1lZCB0byBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBidWZmZXIuICovXHJcblx0VXRpbHMuZGF0YVNpemVCeXRlcyA9IGZ1bmN0aW9uKGRhdGEpIHtcclxuXHRcdGlmKHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcclxuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYnl0ZUxlbmd0aChkYXRhKTtcclxuXHRcdH1cclxuXHRcdGlmKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zdHJpbmdCeXRlU2l6ZShkYXRhKTtcclxuXHRcdH1cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIkV4cGVjdGVkIGlucHV0IG9mIFV0aWxzLmRhdGFTaXplQnl0ZXMgdG8gYmUgYSBidWZmZXIgb3Igc3RyaW5nLCBidXQgd2FzOiBcIiArICh0eXBlb2YgZGF0YSkpO1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLmNoZWFwUmFuZFN0ciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XHJcblx0fTtcclxuXHJcblx0LyogVGFrZXMgcGFyYW0gdGhlIG1pbmltdW0gbnVtYmVyIG9mIGJ5dGVzIG9mIGVudHJvcHkgdGhlIHN0cmluZyBtdXN0XHJcblx0ICogaW5jbHVkZSwgbm90IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy4gU3RyaW5nIGxlbmd0aCBwcm9kdWNlZCBpcyBub3RcclxuXHQgKiBndWFyYW50ZWVkLiAqL1xyXG5cdFV0aWxzLnJhbmRvbVN0cmluZyA9IChwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyAmJiB0eXBlb2YgVWludDhBcnJheSAhPT0gJ3VuZGVmaW5lZCcpID9cclxuXHRcdGZ1bmN0aW9uKG51bUJ5dGVzKSB7XHJcblx0XHRcdHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xyXG5cdFx0XHRwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcyh1SW50QXJyKTtcclxuXHRcdFx0cmV0dXJuIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKHVJbnRBcnIpO1xyXG5cdFx0fSA6IGZ1bmN0aW9uKG51bUJ5dGVzKSB7XHJcblx0XHRcdC8qIE9sZCBicm93c2VyOyBmYWxsIGJhY2sgdG8gTWF0aC5yYW5kb20uIENvdWxkIGp1c3QgdXNlIGFcclxuXHRcdFx0ICogQ3J5cHRvSlMgdmVyc2lvbiBvZiB0aGUgYWJvdmUsIGJ1dCB3YW50IHRoaXMgdG8gc3RpbGwgd29yayBpbiBub2NyeXB0b1xyXG5cdFx0XHQgKiB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeSAqL1xyXG5cdFx0XHR2YXIgY2hhcnNldCA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0Q2hhclNldDtcclxuXHRcdFx0LyogYmFzZTY0IGhhcyAzMyUgb3ZlcmhlYWQ7IHJvdW5kIGxlbmd0aCB1cCAqL1xyXG5cdFx0XHR2YXIgbGVuZ3RoID0gTWF0aC5yb3VuZChudW1CeXRlcyAqIDQvMyk7XHJcblx0XHRcdHZhciByZXN1bHQgPSAnJztcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fTtcclxuXHJcblx0VXRpbHMucmFuZG9tSGV4U3RyaW5nID0gKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykgP1xyXG5cdFx0ZnVuY3Rpb24obnVtQnl0ZXMpIHtcclxuXHRcdFx0dmFyIHVJbnRBcnIgPSBuZXcgVWludDhBcnJheShudW1CeXRlcyk7XHJcblx0XHRcdHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzKHVJbnRBcnIpO1xyXG5cdFx0XHRyZXR1cm4gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5oZXhFbmNvZGUodUludEFycik7XHJcblx0XHR9IDogZnVuY3Rpb24obnVtQnl0ZXMpIHtcclxuXHRcdFx0dmFyIGNoYXJzZXQgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmhleENoYXJTZXQ7XHJcblx0XHRcdHZhciBsZW5ndGggPSBudW1CeXRlcyAqIDI7XHJcblx0XHRcdHZhciByZXN1bHQgPSAnJztcclxuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdFx0fTtcclxuXHJcblx0LyogUGljayBuIGVsZW1lbnRzIGF0IHJhbmRvbSB3aXRob3V0IHJlcGxhY2VtZW50IGZyb20gYW4gYXJyYXkgKi9cclxuXHRVdGlscy5hcnJDaG9vc2VOID0gZnVuY3Rpb24oYXJyLCBuKSB7XHJcblx0XHR2YXIgbnVtSXRlbXMgPSBNYXRoLm1pbihuLCBhcnIubGVuZ3RoKSxcclxuXHRcdFx0bXV0YWJsZUFyciA9IGFyci5zbGljZSgpLFxyXG5cdFx0XHRyZXN1bHQgPSBbXTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBudW1JdGVtczsgaSsrKSB7XHJcblx0XHRcdHJlc3VsdC5wdXNoKFV0aWxzLmFyclBvcFJhbmRvbUVsZW1lbnQobXV0YWJsZUFycikpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cclxuXHRVdGlscy50cmltID0gU3RyaW5nLnByb3RvdHlwZS50cmltID8gZnVuY3Rpb24oc3RyKSB7XHJcblx0XHRyZXR1cm4gc3RyLnRyaW0oKTtcclxuXHR9IDogZnVuY3Rpb24oc3RyKSB7XHJcblx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XHJcblx0fTtcclxuXHJcblx0VXRpbHMucHJvbWlzaWZ5ID0gZnVuY3Rpb24ob2IsIGZuTmFtZSwgYXJncykge1xyXG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xyXG5cdFx0XHRvYltmbk5hbWVdLmFwcGx5KG9iLCBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKS5jb25jYXQoZnVuY3Rpb24oZXJyLCByZXMpIHtcclxuXHRcdFx0XHRlcnIgPyByZWplY3QoZXJyKSA6IHJlc29sdmUocmVzKTtcclxuXHRcdFx0fSkpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0VXRpbHMuZGVjb2RlQm9keSA9IGZ1bmN0aW9uKGJvZHksIGZvcm1hdCkge1xyXG5cdFx0cmV0dXJuIChmb3JtYXQgPT0gJ21zZ3BhY2snKSA/IG1zZ3BhY2suZGVjb2RlKGJvZHkpIDogSlNPTi5wYXJzZShTdHJpbmcoYm9keSkpO1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLmVuY29kZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcclxuXHRcdHJldHVybiAoZm9ybWF0ID09ICdtc2dwYWNrJykgPyBtc2dwYWNrLmVuY29kZShib2R5LCB0cnVlKSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xyXG5cdH07XHJcblxyXG5cdFV0aWxzLmFsbFRvTG93ZXJDYXNlID0gZnVuY3Rpb24oYXJyKSB7XHJcblx0XHRyZXR1cm4gVXRpbHMuYXJyTWFwKGFyciwgZnVuY3Rpb24oZWxlbWVudCkge1xyXG5cdFx0XHRyZXR1cm4gZWxlbWVudCAmJiBlbGVtZW50LnRvTG93ZXJDYXNlKCk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRVdGlscy5hbGxUb1VwcGVyQ2FzZSA9IGZ1bmN0aW9uKGFycikge1xyXG5cdFx0cmV0dXJuIFV0aWxzLmFyck1hcChhcnIsIGZ1bmN0aW9uKGVsZW1lbnQpIHtcclxuXHRcdFx0cmV0dXJuIGVsZW1lbnQgJiYgZWxlbWVudC50b1VwcGVyQ2FzZSgpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFV0aWxzO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChVdGlscyk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcblxyXG52YXIgRXJyb3JJbmZvID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRmdW5jdGlvbiBFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSwgY2F1c2UpIHtcclxuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcblx0XHR0aGlzLmNvZGUgPSBjb2RlO1xyXG5cdFx0dGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcclxuXHRcdHRoaXMuY2F1c2UgPSBjYXVzZTtcclxuXHRcdHRoaXMuaHJlZiA9IHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdEVycm9ySW5mby5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciByZXN1bHQgPSAnWycgKyB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XHJcblx0XHRpZih0aGlzLm1lc3NhZ2UpIHJlc3VsdCArPSAnOiAnICsgdGhpcy5tZXNzYWdlO1xyXG5cdFx0aWYodGhpcy5zdGF0dXNDb2RlKSByZXN1bHQgKz0gJzsgc3RhdHVzQ29kZT0nICsgdGhpcy5zdGF0dXNDb2RlO1xyXG5cdFx0aWYodGhpcy5jb2RlKSByZXN1bHQgKz0gJzsgY29kZT0nICsgdGhpcy5jb2RlO1xyXG5cdFx0aWYodGhpcy5jYXVzZSkgcmVzdWx0ICs9ICc7IGNhdXNlPScgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcih0aGlzLmNhdXNlKTtcclxuXHRcdGlmKHRoaXMuaHJlZiAmJiAhKHRoaXMubWVzc2FnZSAmJiB0aGlzLm1lc3NhZ2UuaW5kZXhPZignaGVscC5hYmx5LmlvJykgPiAtMSkpIHJlc3VsdCArPSAnOyBzZWUgJyArIHRoaXMuaHJlZiArICcgJztcclxuXHRcdHJlc3VsdCArPSAnXSc7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdEVycm9ySW5mby5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgRXJyb3JJbmZvKCksIHZhbHVlcyk7XHJcblx0XHRpZiAodmFsdWVzIGluc3RhbmNlb2YgRXJyb3IpIHtcclxuXHRcdFx0LyogRXJyb3IubWVzc2FnZSBpcyBub3QgZW51bWVyYWJsZSwgc28gbWl4aW4gbG9zZXMgdGhlIG1lc3NhZ2UgKi9cclxuXHRcdFx0cmVzdWx0Lm1lc3NhZ2UgPSB2YWx1ZXMubWVzc2FnZTtcclxuXHRcdH1cclxuXHRcdGlmKHJlc3VsdC5jb2RlICYmICFyZXN1bHQuaHJlZikge1xyXG5cdFx0XHRyZXN1bHQuaHJlZiA9ICdodHRwczovL2hlbHAuYWJseS5pby9lcnJvci8nICsgcmVzdWx0LmNvZGU7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBFcnJvckluZm87XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEVycm9ySW5mbyk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwsIHNldEltbWVkaWF0ZSkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbGliX3V0aWxfbXNncGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcblxyXG5cclxuaWYodHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJykge1xyXG5cdGNvbnNvbGUubG9nKFwiV2FybmluZzogdGhpcyBkaXN0cmlidXRpb24gb2YgQWJseSBpcyBpbnRlbmRlZCBmb3IgYnJvd3NlcnMuIE9uIG5vZGVqcywgcGxlYXNlIHVzZSB0aGUgJ2FibHknIHBhY2thZ2Ugb24gbnBtXCIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBhbGxvd0NvbWV0KCkge1xyXG5cdC8qIHhociByZXF1ZXN0cyBmcm9tIGxvY2FsIGZpbGVzIGFyZSB1bnJlbGlhYmxlIGluIHNvbWUgYnJvd3NlcnMsIHN1Y2ggYXMgQ2hyb21lIDY1IGFuZCBoaWdoZXIgLS0gc2VlIGVnXHJcblx0ICogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNDkyNTY0MjkvY2hyb21lLTY1LXVuYWJsZS10by1tYWtlLXBvc3QtcmVxdWVzdHMtZnJvbS1sb2NhbC1maWxlcy10by1mbGFza1xyXG5cdCAqIFNvIGlmIHdlYnNvY2tldHMgYXJlIHN1cHBvcnRlZCwgdGhlbiBqdXN0IGZvcmdldCBhYm91dCBjb21ldCB0cmFuc3BvcnRzIGFuZCB1c2UgdGhhdCAqL1xyXG5cdHZhciBsb2MgPSBnbG9iYWwubG9jYXRpb247XHJcblx0cmV0dXJuICghZ2xvYmFsLldlYlNvY2tldCB8fCAhbG9jIHx8ICFsb2Mub3JpZ2luIHx8IGxvYy5vcmlnaW4uaW5kZXhPZihcImh0dHBcIikgPiAtMSk7XHJcbn1cclxuXHJcbnZhciB1c2VyQWdlbnQgPSBnbG9iYWwubmF2aWdhdG9yICYmIGdsb2JhbC5uYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCk7XHJcbnZhciBjdXJyZW50VXJsID0gZ2xvYmFsLmxvY2F0aW9uICYmIGdsb2JhbC5sb2NhdGlvbi5ocmVmO1xyXG5cclxudmFyIFBsYXRmb3JtID0ge1xyXG4gICAgICAgIGFnZW50OiAnYnJvd3NlcicsXHJcblx0bG9nVGltZXN0YW1wczogdHJ1ZSxcclxuXHR1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcclxuXHRjdXJyZW50VXJsOiBjdXJyZW50VXJsLFxyXG5cdG5vVXBncmFkZTogdXNlckFnZW50ICYmIHVzZXJBZ2VudC5tYXRjaCgvTVNJRVxcczhcXC4wLyksXHJcblx0YmluYXJ5VHlwZTogJ2FycmF5YnVmZmVyJyxcclxuXHRXZWJTb2NrZXQ6IGdsb2JhbC5XZWJTb2NrZXQgfHwgZ2xvYmFsLk1veldlYlNvY2tldCxcclxuXHR4aHJTdXBwb3J0ZWQ6IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCAmJiAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcclxuXHRqc29ucFN1cHBvcnRlZDogdHlwZW9mKGRvY3VtZW50KSAhPT0gJ3VuZGVmaW5lZCcsXHJcblx0YWxsb3dDb21ldDogYWxsb3dDb21ldCgpLFxyXG5cdHN0cmVhbWluZ1N1cHBvcnRlZDogdHJ1ZSxcclxuXHR1c2VQcm90b2NvbEhlYXJ0YmVhdHM6IHRydWUsXHJcblx0Y3JlYXRlSG1hYzogbnVsbCxcclxuXHRtc2dwYWNrOiBfbGliX3V0aWxfbXNncGFja19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLFxyXG5cdHN1cHBvcnRzQmluYXJ5OiAhIWdsb2JhbC5UZXh0RGVjb2RlcixcclxuXHRwcmVmZXJCaW5hcnk6IGZhbHNlLFxyXG5cdEFycmF5QnVmZmVyOiBnbG9iYWwuQXJyYXlCdWZmZXIsXHJcblx0YXRvYjogZ2xvYmFsLmF0b2IsXHJcblx0bmV4dFRpY2s6IHR5cGVvZiBzZXRJbW1lZGlhdGUgIT09ICd1bmRlZmluZWQnID8gZ2xvYmFsLnNldEltbWVkaWF0ZS5iaW5kKGdsb2JhbCkgOiBmdW5jdGlvbihmKSB7IHNldFRpbWVvdXQoZiwgMCk7IH0sXHJcblx0YWRkRXZlbnRMaXN0ZW5lcjogZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIsXHJcblx0aW5zcGVjdDogSlNPTi5zdHJpbmdpZnksXHJcblx0c3RyaW5nQnl0ZVNpemU6IGZ1bmN0aW9uKHN0cikge1xyXG5cdFx0Lyogc3RyLmxlbmd0aCB3aWxsIGJlIGFuIHVuZGVyZXN0aW1hdGUgZm9yIG5vbi1hc2NpaSBzdHJpbmdzLiBCdXQgaWYgd2UncmVcclxuXHRcdCAqIGluIGEgYnJvd3NlciB0b28gb2xkIHRvIHN1cHBvcnQgVGV4dERlY29kZXIsIG5vdCBtdWNoIHdlIGNhbiBkby4gQmV0dGVyXHJcblx0XHQgKiB0byB1bmRlcmVzdGltYXRlLCBzbyBpZiB3ZSBkbyBnbyBvdmVyLXNpemUsIHRoZSBzZXJ2ZXIgd2lsbCByZWplY3QgdGhlXHJcblx0XHQgKiBtZXNzYWdlICovXHJcblx0XHRyZXR1cm4gZ2xvYmFsLlRleHREZWNvZGVyICYmXHJcblx0XHRcdChuZXcgZ2xvYmFsLlRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikpLmxlbmd0aCB8fFxyXG5cdFx0XHRzdHIubGVuZ3RoO1xyXG5cdH0sXHJcblx0VGV4dEVuY29kZXI6IGdsb2JhbC5UZXh0RW5jb2RlcixcclxuXHRUZXh0RGVjb2RlcjogZ2xvYmFsLlRleHREZWNvZGVyLFxyXG5cdFByb21pc2U6IGdsb2JhbC5Qcm9taXNlLFxyXG5cdGdldFJhbmRvbVZhbHVlczogKGZ1bmN0aW9uKGNyeXB0bykge1xyXG5cdFx0aWYgKGNyeXB0byA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gZnVuY3Rpb24oYXJyLCBjYWxsYmFjaykge1xyXG5cdFx0XHRjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGFycik7XHJcblx0XHRcdGlmKGNhbGxiYWNrKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fSkoZ2xvYmFsLmNyeXB0byB8fCBnbG9iYWwubXNDcnlwdG8pIC8vIG1zY3J5cHRvIGZvciBJRTExXHJcbn07XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFBsYXRmb3JtKTtcclxuXHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0Mikuc2V0SW1tZWRpYXRlKSlcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvZnJhZ21lbnRzL3BsYXRmb3JtLWJyb3dzZXIuanNcclxudmFyIHBsYXRmb3JtX2Jyb3dzZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2RlZmF1bHRzLmpzXHJcblxyXG5cclxudmFyIERlZmF1bHRzID0ge1xyXG5cdGludGVybmV0VXBVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHQnLFxyXG5cdGpzb25wSW50ZXJuZXRVcFVybDogJ2h0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLTAtOS5qcycsXHJcblx0LyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcclxuXHQgKiBpbnRlcnNlY3Rpb24gb2YgYmFzZVRyYW5zcG9ydE9yZGVyIGFuZCB0aGUgdHJhbnNwb3J0cyBjbGllbnRPcHRpb24gdGhhdCdzXHJcblx0ICogc3VwcG9ydGVkLiAgVGhpcyBpcyBub3QgcXVpdGUgdGhlIHNhbWUgYXMgdGhlIHByZWZlcmVuY2Ugb3JkZXIgLS0gZS5nLlxyXG5cdCAqIHhocl9wb2xsaW5nIGlzIHByZWZlcnJlZCB0byBqc29ucCwgYnV0IGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQgd2Ugd2FudFxyXG5cdCAqIHRoZSBiYXNlIHRyYW5zcG9ydCB0byBiZSB4aHJfcG9sbGluZywgbm90IGpzb25wICovXHJcblx0ZGVmYXVsdFRyYW5zcG9ydHM6IFsneGhyX3BvbGxpbmcnLCAneGhyX3N0cmVhbWluZycsICdqc29ucCcsICd3ZWJfc29ja2V0J10sXHJcblx0YmFzZVRyYW5zcG9ydE9yZGVyOiBbJ3hocl9wb2xsaW5nJywgJ3hocl9zdHJlYW1pbmcnLCAnanNvbnAnLCAnd2ViX3NvY2tldCddLFxyXG5cdHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcjogWydqc29ucCcsICd4aHJfcG9sbGluZycsICd4aHJfc3RyZWFtaW5nJywgJ3dlYl9zb2NrZXQnXSxcclxuXHR1cGdyYWRlVHJhbnNwb3J0czogWyd4aHJfc3RyZWFtaW5nJywgJ3dlYl9zb2NrZXQnXVxyXG59O1xyXG5cclxuLyogSWYgdXNpbmcgSUU4LCBkb24ndCBhdHRlbXB0IHRvIHVwZ3JhZGUgZnJvbSB4aHJfcG9sbGluZyB0byB4aHJfc3RyZWFtaW5nIC1cclxuKiB3aGlsZSBpdCBjYW4gZG8gc3RyZWFtaW5nLCB0aGUgbG93IG1heCBodHRwLWNvbm5lY3Rpb25zLXBlci1ob3N0IGxpbWl0IG1lYW5zXHJcbiogdGhhdCB0aGUgcG9sbGluZyB0cmFuc3BvcnQgaXMgY3JpcHBsZWQgZHVyaW5nIHRoZSB1cGdyYWRlIHByb2Nlc3MuIFNvIGp1c3RcclxuKiBsZWF2ZSBpdCBhdCB0aGUgYmFzZSB0cmFuc3BvcnQgKi9cclxuaWYocGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5ub1VwZ3JhZGUpIHtcclxuXHREZWZhdWx0cy51cGdyYWRlVHJhbnNwb3J0cyA9IFtdO1xyXG59XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZWZhdWx0cyA9IChEZWZhdWx0cyk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL3V0aWxzLmpzXHJcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9idWZmZXJ1dGlscy5qc1xyXG52YXIgYnVmZmVydXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIuanNcclxudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8uanNcclxudmFyIGVycm9yaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9kZWZhdWx0cy5qc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuZGVmYXVsdHMuRU5WSVJPTk1FTlQgICAgICAgICAgICAgID0gJyc7XHJcbmRlZmF1bHRzLlJFU1RfSE9TVCAgICAgICAgICAgICAgICA9ICdyZXN0LmFibHkuaW8nO1xyXG5kZWZhdWx0cy5SRUFMVElNRV9IT1NUICAgICAgICAgICAgPSAncmVhbHRpbWUuYWJseS5pbyc7XHJcbmRlZmF1bHRzLkZBTExCQUNLX0hPU1RTICAgICAgICAgICA9IFsnQS5hYmx5LXJlYWx0aW1lLmNvbScsICdCLmFibHktcmVhbHRpbWUuY29tJywgJ0MuYWJseS1yZWFsdGltZS5jb20nLCAnRC5hYmx5LXJlYWx0aW1lLmNvbScsICdFLmFibHktcmVhbHRpbWUuY29tJ107XHJcbmRlZmF1bHRzLlBPUlQgICAgICAgICAgICAgICAgICAgICA9IDgwO1xyXG5kZWZhdWx0cy5UTFNfUE9SVCAgICAgICAgICAgICAgICAgPSA0NDM7XHJcbmRlZmF1bHRzLlRJTUVPVVRTID0ge1xyXG5cdC8qIERvY3VtZW50ZWQgYXMgb3B0aW9ucyBwYXJhbXM6ICovXHJcblx0ZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0ICAgOiAxNTAwMCxcclxuXHRzdXNwZW5kZWRSZXRyeVRpbWVvdXQgICAgICA6IDMwMDAwLFxyXG5cdC8qIFVuZG9jdW1lbnRlZCwgYnV0IHBhcnQgb2YgdGhlIGFwaSBhbmQgY2FuIGJlIHVzZWQgYnkgY3VzdG9tZXJzOiAqL1xyXG5cdGh0dHBSZXF1ZXN0VGltZW91dCAgICAgICAgIDogMTUwMDAsXHJcblx0Y2hhbm5lbFJldHJ5VGltZW91dCAgICAgICAgOiAxNTAwMCxcclxuXHRmYWxsYmFja1JldHJ5VGltZW91dCAgICAgICA6IDYwMDAwMCxcclxuXHQvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xyXG5cdGNvbm5lY3Rpb25TdGF0ZVR0bCAgICAgICAgIDogMTIwMDAwLFxyXG5cdHJlYWx0aW1lUmVxdWVzdFRpbWVvdXQgICAgIDogMTAwMDAsXHJcblx0cmVjdlRpbWVvdXQgICAgICAgICAgICAgICAgOiA5MDAwMCxcclxuXHRwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgICA6IDYwMDAsXHJcblx0cGFyYWxsZWxVcGdyYWRlRGVsYXkgICAgICAgOiA2MDAwXHJcbn07XHJcbmRlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50ID0gMztcclxuZGVmYXVsdHMubWF4TWVzc2FnZVNpemUgICAgPSA2NTUzNjtcclxuXHJcbmRlZmF1bHRzLmVycm9yUmVwb3J0aW5nVXJsID0gJ2h0dHBzOi8vZXJyb3JzLmFibHkuaW8vYXBpLzE1L3N0b3JlLyc7XHJcbmRlZmF1bHRzLmVycm9yUmVwb3J0aW5nSGVhZGVycyA9IHtcclxuXHRcIlgtU2VudHJ5LUF1dGhcIjogXCJTZW50cnkgc2VudHJ5X3ZlcnNpb249Nywgc2VudHJ5X2tleT1hMDRlMzNjODY3NGM0NTFmOGEzMTBmYmVjMDI5YWNmNSwgc2VudHJ5X2NsaWVudD1hYmx5LWpzLzAuMVwiLFxyXG5cdFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiXHJcbn07XHJcblxyXG5kZWZhdWx0cy52ZXJzaW9uICAgICAgICAgID0gJzEuMi4xMyc7XHJcbmRlZmF1bHRzLmFwaVZlcnNpb24gICAgICAgPSAnMS4yJztcclxuXHJcbnZhciBhZ2VudCA9ICdhYmx5LWpzLycgKyBkZWZhdWx0cy52ZXJzaW9uO1xyXG5pZiAocGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5hZ2VudCkge1xyXG5cdGFnZW50ICs9ICcgJyArIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uYWdlbnQ7XHJcbn0gXHJcbmRlZmF1bHRzLmFnZW50ID0gYWdlbnQ7XHJcblxyXG5kZWZhdWx0cy5nZXRIb3N0ID0gZnVuY3Rpb24ob3B0aW9ucywgaG9zdCwgd3MpIHtcclxuXHRpZih3cylcclxuXHRcdGhvc3QgPSAoKGhvc3QgPT0gb3B0aW9ucy5yZXN0SG9zdCkgJiYgb3B0aW9ucy5yZWFsdGltZUhvc3QpIHx8IGhvc3QgfHwgb3B0aW9ucy5yZWFsdGltZUhvc3Q7XHJcblx0ZWxzZVxyXG5cdFx0aG9zdCA9IGhvc3QgfHwgb3B0aW9ucy5yZXN0SG9zdDtcclxuXHJcblx0cmV0dXJuIGhvc3Q7XHJcbn07XHJcblxyXG5kZWZhdWx0cy5nZXRQb3J0ID0gZnVuY3Rpb24ob3B0aW9ucywgdGxzKSB7XHJcblx0cmV0dXJuICh0bHMgfHwgb3B0aW9ucy50bHMpID8gb3B0aW9ucy50bHNQb3J0IDogb3B0aW9ucy5wb3J0O1xyXG59O1xyXG5cclxuZGVmYXVsdHMuZ2V0SHR0cFNjaGVtZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRyZXR1cm4gb3B0aW9ucy50bHMgPyAnaHR0cHM6Ly8nIDogJ2h0dHA6Ly8nO1xyXG59O1xyXG5cclxuLy8gY29uc3RydWN0IGVudmlyb25tZW50IGZhbGxiYWNrIGhvc3RzIGFzIHBlciBSU0MxNWlcclxuZGVmYXVsdHMuZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzID0gZnVuY3Rpb24oZW52aXJvbm1lbnQpIHtcclxuXHRyZXR1cm4gW1xyXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWEtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxyXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWItZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxyXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWMtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxyXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWQtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxyXG5cdFx0ZW52aXJvbm1lbnQgKyAnLWUtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nXHJcblx0XTtcclxufTtcclxuXHJcbmRlZmF1bHRzLmdldEZhbGxiYWNrSG9zdHMgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0dmFyIGZhbGxiYWNrSG9zdHMgPSBvcHRpb25zLmZhbGxiYWNrSG9zdHMsXHJcblx0XHRodHRwTWF4UmV0cnlDb3VudCA9IHR5cGVvZihvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50KSAhPT0gJ3VuZGVmaW5lZCcgPyBvcHRpb25zLmh0dHBNYXhSZXRyeUNvdW50IDogZGVmYXVsdHMuaHR0cE1heFJldHJ5Q291bnQ7XHJcblxyXG5cdHJldHVybiBmYWxsYmFja0hvc3RzID8gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyQ2hvb3NlTihmYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCkgOiBbXTtcclxufTtcclxuXHJcbmRlZmF1bHRzLmdldEhvc3RzID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG5cdHJldHVybiBbb3B0aW9ucy5yZXN0SG9zdF0uY29uY2F0KGRlZmF1bHRzLmdldEZhbGxiYWNrSG9zdHMob3B0aW9ucykpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gY2hlY2tIb3N0KGhvc3QpIHtcclxuXHRpZih0eXBlb2YgaG9zdCAhPT0gJ3N0cmluZycpIHtcclxuXHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2hvc3QgbXVzdCBiZSBhIHN0cmluZzsgd2FzIGEgJyArIHR5cGVvZiBob3N0LCA0MDAwMCwgNDAwKTtcclxuXHR9O1xyXG5cdGlmKCFob3N0Lmxlbmd0aCkge1xyXG5cdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnaG9zdCBtdXN0IG5vdCBiZSB6ZXJvLWxlbmd0aCcsIDQwMDAwLCA0MDApO1xyXG5cdH07XHJcbn1cclxuXHJcbmRlZmF1bHRzLm9iamVjdGlmeU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0aWYodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcclxuXHRcdHJldHVybiAob3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEpID8ge3Rva2VuOiBvcHRpb25zfSA6IHtrZXk6IG9wdGlvbnN9O1xyXG5cdH1cclxuXHRyZXR1cm4gb3B0aW9ucztcclxufTtcclxuXHJcbmRlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0LyogRGVwcmVjYXRlZCBvcHRpb25zICovXHJcblx0aWYob3B0aW9ucy5ob3N0KSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnaG9zdCcsICdyZXN0SG9zdCcpO1xyXG5cdFx0b3B0aW9ucy5yZXN0SG9zdCA9IG9wdGlvbnMuaG9zdDtcclxuXHR9XHJcblx0aWYob3B0aW9ucy53c0hvc3QpIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCd3c0hvc3QnLCAncmVhbHRpbWVIb3N0Jyk7XHJcblx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMud3NIb3N0O1xyXG5cdH1cclxuXHRpZihvcHRpb25zLnF1ZXVlRXZlbnRzKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgncXVldWVFdmVudHMnLCAncXVldWVNZXNzYWdlcycpO1xyXG5cdFx0b3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gb3B0aW9ucy5xdWV1ZUV2ZW50cztcclxuXHR9XHJcblxyXG5cdGlmKG9wdGlvbnMuZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQpIHtcclxuXHRcdC8qIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGFuZCBmYWxsYmFja0hvc3RzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgYXMgcGVyIFRPM2s3ICovXHJcblx0XHRpZihvcHRpb25zLmZhbGxiYWNrSG9zdHMpIHtcclxuXHRcdFx0dmFyIG1zZyA9ICdmYWxsYmFja0hvc3RzIGFuZCBmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBjYW5ub3QgYm90aCBiZSBzZXQnO1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgbXNnKTtcclxuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMDAwLCA0MDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qIGRlZmF1bHQgZmFsbGJhY2tzIGNhbid0IGJlIHVzZWQgd2l0aCBjdXN0b20gcG9ydHMgKi9cclxuXHRcdGlmKG9wdGlvbnMucG9ydCB8fCBvcHRpb25zLnRsc1BvcnQpIHtcclxuXHRcdFx0dmFyIG1zZyA9ICdmYWxsYmFja0hvc3RzVXNlRGVmYXVsdCBjYW5ub3QgYmUgc2V0IHdoZW4gcG9ydCBvciB0bHNQb3J0IGFyZSBzZXQnO1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgbXNnKTtcclxuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMDAwLCA0MDApO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qIGVtaXQgYW4gYXBwcm9wcmlhdGUgZGVwcmVjYXRpb24gd2FybmluZyAqL1xyXG5cdFx0aWYob3B0aW9ucy5lbnZpcm9ubWVudCkge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZFdpdGhNc2coJ2ZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0JywgJ1RoZXJlIGlzIG5vIGxvbmdlciBhIG5lZWQgdG8gc2V0IHRoaXMgd2hlbiB0aGUgZW52aXJvbm1lbnQgb3B0aW9uIGlzIGFsc28gc2V0IHNpbmNlIHRoZSBsaWJyYXJ5IHdpbGwgbm93IGdlbmVyYXRlIHRoZSBjb3JyZWN0IGZhbGxiYWNrIGhvc3RzIHVzaW5nIHRoZSBlbnZpcm9ubWVudCBvcHRpb24uJyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnZmFsbGJhY2tIb3N0czogQWJseS5EZWZhdWx0cy5GQUxMQkFDS19IT1NUUycpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qIHVzZSB0aGUgZGVmYXVsdCBmYWxsYmFjayBob3N0cyBhcyByZXF1ZXN0ZWQgKi9cclxuXHRcdG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IGRlZmF1bHRzLkZBTExCQUNLX0hPU1RTO1xyXG5cdH1cclxuXHJcblx0aWYob3B0aW9ucy5yZWNvdmVyID09PSB0cnVlKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgne3JlY292ZXI6IHRydWV9JywgJ3tyZWNvdmVyOiBmdW5jdGlvbihsYXN0Q29ubmVjdGlvbkRldGFpbHMsIGNiKSB7IGNiKHRydWUpOyB9fScpO1xyXG5cdFx0b3B0aW9ucy5yZWNvdmVyID0gZnVuY3Rpb24obGFzdENvbm5lY3Rpb25EZXRhaWxzLCBjYikgeyBjYih0cnVlKTsgfTtcclxuXHR9XHJcblxyXG5cdGlmKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ2Nsb3NlT25VbmxvYWQgd2FzIHRydWUgYW5kIGEgc2Vzc2lvbiByZWNvdmVyeSBmdW5jdGlvbiB3YXMgc2V0IC0gdGhlc2UgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSwgc28gdW5zZXR0aW5nIHRoZSBsYXR0ZXInKTtcclxuXHRcdG9wdGlvbnMucmVjb3ZlciA9IG51bGw7XHJcblx0fVxyXG5cclxuXHRpZighKCdjbG9zZU9uVW5sb2FkJyBpbiBvcHRpb25zKSkge1xyXG5cdFx0LyogSGF2ZSBjbG9zZU9uVW5sb2FkIGRlZmF1bHQgdG8gdHJ1ZSB1bmxlc3Mgd2UgaGF2ZSBhbnkgaW5kaWNhdGlvbiB0aGF0XHJcblx0XHQgKiB0aGUgdXNlciBtYXkgd2FudCB0byByZWNvdmVyIHRoZSBjb25uZWN0aW9uICovXHJcblx0XHRvcHRpb25zLmNsb3NlT25VbmxvYWQgPSAhb3B0aW9ucy5yZWNvdmVyO1xyXG5cdH1cclxuXHJcblx0aWYob3B0aW9ucy50cmFuc3BvcnRzICYmIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckluKG9wdGlvbnMudHJhbnNwb3J0cywgJ3hocicpKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgndHJhbnNwb3J0czogW1wieGhyXCJdJywgJ3RyYW5zcG9ydHM6IFtcInhocl9zdHJlYW1pbmdcIl0nKTtcclxuXHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckRlbGV0ZVZhbHVlKG9wdGlvbnMudHJhbnNwb3J0cywgJ3hocicpO1xyXG5cdFx0b3B0aW9ucy50cmFuc3BvcnRzLnB1c2goJ3hocl9zdHJlYW1pbmcnKTtcclxuXHR9XHJcblxyXG5cdGlmKCEoJ3F1ZXVlTWVzc2FnZXMnIGluIG9wdGlvbnMpKVxyXG5cdFx0b3B0aW9ucy5xdWV1ZU1lc3NhZ2VzID0gdHJ1ZTtcclxuXHJcblx0LyogaW5mZXIgaG9zdHMgYW5kIGZhbGxiYWNrcyBiYXNlZCBvbiB0aGUgY29uZmlndXJlZCBlbnZpcm9ubWVudCAqL1xyXG5cdHZhciBlbnZpcm9ubWVudCA9IChvcHRpb25zLmVudmlyb25tZW50ICYmIFN0cmluZyhvcHRpb25zLmVudmlyb25tZW50KS50b0xvd2VyQ2FzZSgpKSB8fCBkZWZhdWx0cy5FTlZJUk9OTUVOVDtcclxuXHR2YXIgcHJvZHVjdGlvbiA9ICFlbnZpcm9ubWVudCB8fCAoZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJyk7XHJcblxyXG5cdGlmKCFvcHRpb25zLmZhbGxiYWNrSG9zdHMgJiYgIW9wdGlvbnMucmVzdEhvc3QgJiYgIW9wdGlvbnMucmVhbHRpbWVIb3N0ICYmICFvcHRpb25zLnBvcnQgJiYgIW9wdGlvbnMudGxzUG9ydCkge1xyXG5cdFx0b3B0aW9ucy5mYWxsYmFja0hvc3RzID0gcHJvZHVjdGlvbiA/IGRlZmF1bHRzLkZBTExCQUNLX0hPU1RTIDogZGVmYXVsdHMuZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KTtcclxuXHR9XHJcblxyXG5cdGlmKCFvcHRpb25zLnJlYWx0aW1lSG9zdCkge1xyXG5cdFx0LyogcHJlZmVyIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIHJlc3RIb3N0IGFzIGEgY3VzdG9tIHJlc3RIb3N0IHR5cGljYWxseSBpbmRpY2F0ZXNcclxuXHRcdCAqIGEgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnQgaXMgYmVpbmcgdXNlZCB0aGF0IGNhbid0IGJlIGluZmVycmVkIGJ5IHRoZSBsaWJyYXJ5ICovXHJcblx0XHRpZihvcHRpb25zLnJlc3RIb3N0KSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19XQVJOLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdyZXN0SG9zdCBpcyBzZXQgdG8gXCInICsgb3B0aW9ucy5yZXN0SG9zdCArICdcIiBidXQgcmVhbHRpbWVIb3N0IGlzIG5vdCBzZXQsIHNvIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIFwiJyArIG9wdGlvbnMucmVzdEhvc3QgKyAnXCIgdG9vLiBJZiB0aGlzIGlzIG5vdCB3aGF0IHlvdSB3YW50LCBwbGVhc2Ugc2V0IHJlYWx0aW1lSG9zdCBleHBsaWNpdGx5LicpO1xyXG5cdFx0XHRvcHRpb25zLnJlYWx0aW1lSG9zdCA9IG9wdGlvbnMucmVzdEhvc3RcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdG9wdGlvbnMucmVhbHRpbWVIb3N0ID0gcHJvZHVjdGlvbiA/IGRlZmF1bHRzLlJFQUxUSU1FX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIGRlZmF1bHRzLlJFQUxUSU1FX0hPU1Q7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRpZighb3B0aW9ucy5yZXN0SG9zdCkge1xyXG5cdFx0b3B0aW9ucy5yZXN0SG9zdCA9IHByb2R1Y3Rpb24gPyBkZWZhdWx0cy5SRVNUX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIGRlZmF1bHRzLlJFU1RfSE9TVDtcclxuXHR9XHJcblxyXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2goKG9wdGlvbnMuZmFsbGJhY2tIb3N0cyB8fCBbXSkuY29uY2F0KG9wdGlvbnMucmVzdEhvc3QsIG9wdGlvbnMucmVhbHRpbWVIb3N0KSwgY2hlY2tIb3N0KTtcclxuXHJcblx0b3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IGRlZmF1bHRzLlBPUlQ7XHJcblx0b3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IGRlZmF1bHRzLlRMU19QT1JUO1xyXG5cdG9wdGlvbnMubWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplIHx8IGRlZmF1bHRzLm1heE1lc3NhZ2VTaXplO1xyXG5cdGlmKCEoJ3RscycgaW4gb3B0aW9ucykpIG9wdGlvbnMudGxzID0gdHJ1ZTtcclxuXHJcblx0LyogQWxsb3cgdmFsdWVzIHBhc3NlZCBpbiBvcHRpb25zIHRvIG92ZXJyaWRlIGRlZmF1bHQgdGltZW91dHMgKi9cclxuXHRvcHRpb25zLnRpbWVvdXRzID0ge307XHJcblx0Zm9yKHZhciBwcm9wIGluIGRlZmF1bHRzLlRJTUVPVVRTKSB7XHJcblx0XHRvcHRpb25zLnRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBkZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcclxuXHR9O1xyXG5cclxuXHRpZigndXNlQmluYXJ5UHJvdG9jb2wnIGluIG9wdGlvbnMpIHtcclxuXHRcdG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzQmluYXJ5ICYmIG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2w7XHJcblx0fSBlbHNlIHtcclxuXHRcdG9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByZWZlckJpbmFyeTtcclxuXHR9XHJcblxyXG5cdGlmKG9wdGlvbnMuY2xpZW50SWQpIHtcclxuXHRcdHZhciBoZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzID0gb3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xyXG5cdFx0aGVhZGVyc1snWC1BYmx5LUNsaWVudElkJ10gPSBidWZmZXJ1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5iYXNlNjRFbmNvZGUoYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udXRmOEVuY29kZShvcHRpb25zLmNsaWVudElkKSk7XHJcblx0fVxyXG5cclxuXHRpZighKCdpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcnIGluIG9wdGlvbnMpKSB7XHJcblx0XHRvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XHJcblx0fVxyXG5cclxuXHRpZihvcHRpb25zLnByb21pc2VzICYmICFwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLlByb21pc2UpIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAne3Byb21pc2VzOiB0cnVlfSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gUHJvbWlzZSBjb25zdHJ1Y3RvciBmb3VuZDsgZGlzYWJsaW5nIHByb21pc2VzJyk7XHJcblx0XHRvcHRpb25zLnByb21pc2VzID0gZmFsc2U7XHJcblx0fVxyXG5cclxuICAgICAgICBpZihvcHRpb25zLmFnZW50cykge1xyXG4gICAgICAgICAgZm9yKHZhciBrZXkgaW4gb3B0aW9ucy5hZ2VudHMpIHtcclxuICAgICAgICAgICAgZGVmYXVsdHMuYWdlbnQgKz0gJyAnICsga2V5ICsgJy8nICsgb3B0aW9ucy5hZ2VudHNba2V5XTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG5cdHJldHVybiBvcHRpb25zO1xyXG59O1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgdXRpbF9kZWZhdWx0cyA9IF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKGRlZmF1bHRzKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMyKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfaGV4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfZW5jX3V0ZjhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzMpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18pO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTgpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfZW5jX2Jhc2U2NF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIEJ1ZmZlclV0aWxzID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBBcnJheUJ1ZmZlciA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uQXJyYXlCdWZmZXI7XHJcblx0dmFyIGF0b2IgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmF0b2I7XHJcblx0dmFyIFRleHRFbmNvZGVyID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5UZXh0RW5jb2RlcjtcclxuXHR2YXIgVGV4dERlY29kZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRleHREZWNvZGVyO1xyXG5cdHZhciBiYXNlNjRDaGFyU2V0ID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nO1xyXG5cdHZhciBoZXhDaGFyU2V0ID0gJzAxMjM0NTY3ODlhYmNkZWYnO1xyXG5cclxuXHRmdW5jdGlvbiBpc1dvcmRBcnJheShvYikgeyByZXR1cm4gb2IgIT09IG51bGwgJiYgb2IgIT09IHVuZGVmaW5lZCAmJiBvYi5zaWdCeXRlcyAhPT0gdW5kZWZpbmVkOyB9XHJcblx0ZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcihvYikgeyByZXR1cm4gb2IgIT09IG51bGwgJiYgb2IgIT09IHVuZGVmaW5lZCAmJiBvYi5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7IH1cclxuXHRmdW5jdGlvbiBpc1R5cGVkQXJyYXkob2IpIHsgcmV0dXJuIEFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2IpOyB9XHJcblxyXG5cdC8vIGh0dHBzOi8vZ2lzdC5naXRodWJ1c2VyY29udGVudC5jb20vam9ubGVpZ2h0b24vOTU4ODQxL3Jhdy9mMjAwZTMwZGZlOTUyMTJjMDE2NWNjZjFhZTAwMGNhNTFlOWRlODAzL2dpc3RmaWxlMS5qc1xyXG5cdGZ1bmN0aW9uIHVpbnQ4Vmlld1RvQmFzZTY0KGJ5dGVzKSB7XHJcblx0XHR2YXIgYmFzZTY0ICAgID0gJydcclxuXHRcdHZhciBlbmNvZGluZ3MgPSBiYXNlNjRDaGFyU2V0O1xyXG5cclxuXHRcdHZhciBieXRlTGVuZ3RoICAgID0gYnl0ZXMuYnl0ZUxlbmd0aFxyXG5cdFx0dmFyIGJ5dGVSZW1haW5kZXIgPSBieXRlTGVuZ3RoICUgM1xyXG5cdFx0dmFyIG1haW5MZW5ndGggICAgPSBieXRlTGVuZ3RoIC0gYnl0ZVJlbWFpbmRlclxyXG5cclxuXHRcdHZhciBhLCBiLCBjLCBkXHJcblx0XHR2YXIgY2h1bmtcclxuXHJcblx0XHQvLyBNYWluIGxvb3AgZGVhbHMgd2l0aCBieXRlcyBpbiBjaHVua3Mgb2YgM1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYWluTGVuZ3RoOyBpID0gaSArIDMpIHtcclxuXHRcdFx0Ly8gQ29tYmluZSB0aGUgdGhyZWUgYnl0ZXMgaW50byBhIHNpbmdsZSBpbnRlZ2VyXHJcblx0XHRcdGNodW5rID0gKGJ5dGVzW2ldIDw8IDE2KSB8IChieXRlc1tpICsgMV0gPDwgOCkgfCBieXRlc1tpICsgMl1cclxuXHJcblx0XHRcdC8vIFVzZSBiaXRtYXNrcyB0byBleHRyYWN0IDYtYml0IHNlZ21lbnRzIGZyb20gdGhlIHRyaXBsZXRcclxuXHRcdFx0YSA9IChjaHVuayAmIDE2NTE1MDcyKSA+PiAxOCAvLyAxNjUxNTA3MiA9ICgyXjYgLSAxKSA8PCAxOFxyXG5cdFx0XHRiID0gKGNodW5rICYgMjU4MDQ4KSAgID4+IDEyIC8vIDI1ODA0OCAgID0gKDJeNiAtIDEpIDw8IDEyXHJcblx0XHRcdGMgPSAoY2h1bmsgJiA0MDMyKSAgICAgPj4gIDYgLy8gNDAzMiAgICAgPSAoMl42IC0gMSkgPDwgNlxyXG5cdFx0XHRkID0gY2h1bmsgJiA2MyAgICAgICAgICAgICAgIC8vIDYzICAgICAgID0gMl42IC0gMVxyXG5cclxuXHRcdFx0Ly8gQ29udmVydCB0aGUgcmF3IGJpbmFyeSBzZWdtZW50cyB0byB0aGUgYXBwcm9wcmlhdGUgQVNDSUkgZW5jb2RpbmdcclxuXHRcdFx0YmFzZTY0ICs9IGVuY29kaW5nc1thXSArIGVuY29kaW5nc1tiXSArIGVuY29kaW5nc1tjXSArIGVuY29kaW5nc1tkXVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIERlYWwgd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzIGFuZCBwYWRkaW5nXHJcblx0XHRpZiAoYnl0ZVJlbWFpbmRlciA9PSAxKSB7XHJcblx0XHRcdGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF1cclxuXHJcblx0XHRcdGEgPSAoY2h1bmsgJiAyNTIpID4+IDIgLy8gMjUyID0gKDJeNiAtIDEpIDw8IDJcclxuXHJcblx0XHRcdC8vIFNldCB0aGUgNCBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cclxuXHRcdFx0YiA9IChjaHVuayAmIDMpICAgPDwgNCAvLyAzICAgPSAyXjIgLSAxXHJcblxyXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgJz09J1xyXG5cdFx0fSBlbHNlIGlmIChieXRlUmVtYWluZGVyID09IDIpIHtcclxuXHRcdFx0Y2h1bmsgPSAoYnl0ZXNbbWFpbkxlbmd0aF0gPDwgOCkgfCBieXRlc1ttYWluTGVuZ3RoICsgMV1cclxuXHJcblx0XHRcdGEgPSAoY2h1bmsgJiA2NDUxMikgPj4gMTAgLy8gNjQ1MTIgPSAoMl42IC0gMSkgPDwgMTBcclxuXHRcdFx0YiA9IChjaHVuayAmIDEwMDgpICA+PiAgNCAvLyAxMDA4ICA9ICgyXjYgLSAxKSA8PCA0XHJcblxyXG5cdFx0XHQvLyBTZXQgdGhlIDIgbGVhc3Qgc2lnbmlmaWNhbnQgYml0cyB0byB6ZXJvXHJcblx0XHRcdGMgPSAoY2h1bmsgJiAxNSkgICAgPDwgIDIgLy8gMTUgICAgPSAyXjQgLSAxXHJcblxyXG5cdFx0XHRiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nXHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGJhc2U2NFxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gYmFzZTY0VG9BcnJheUJ1ZmZlcihiYXNlNjQpIHtcclxuXHRcdHZhciBiaW5hcnlfc3RyaW5nID0gIGF0b2IoYmFzZTY0KTtcclxuXHRcdHZhciBsZW4gPSBiaW5hcnlfc3RyaW5nLmxlbmd0aDtcclxuXHRcdHZhciBieXRlcyA9IG5ldyBVaW50OEFycmF5KCBsZW4gKTtcclxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspICAgICAgICB7XHJcblx0XHRcdHZhciBhc2NpaSA9IGJpbmFyeV9zdHJpbmcuY2hhckNvZGVBdChpKTtcclxuXHRcdFx0Ynl0ZXNbaV0gPSBhc2NpaTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBieXRlcy5idWZmZXI7XHJcblx0fVxyXG5cclxuXHQvKiBNb3N0IEJ1ZmZlclV0aWxzIG1ldGhvZHMgdGhhdCByZXR1cm4gYSBiaW5hcnkgb2JqZWN0IHJldHVybiBhbiBBcnJheUJ1ZmZlclxyXG5cdCAqIGlmIHN1cHBvcnRlZCwgZWxzZSBhIENyeXB0b0pTIFdvcmRBcnJheS4gVGhlIGV4Y2VwdGlvbiBpcyB0b0J1ZmZlciwgd2hpY2hcclxuXHQgKiByZXR1cm5zIGEgVWludDhBcnJheSAoYW5kIHdvbid0IHdvcmsgb24gYnJvd3NlcnMgdG9vIG9sZCB0byBzdXBwb3J0IGl0KSAqL1xyXG5cdGZ1bmN0aW9uIEJ1ZmZlclV0aWxzKCkge31cclxuXHJcblx0QnVmZmVyVXRpbHMuYmFzZTY0Q2hhclNldCA9IGJhc2U2NENoYXJTZXQ7XHJcblx0QnVmZmVyVXRpbHMuaGV4Q2hhclNldCA9IGhleENoYXJTZXQ7XHJcblxyXG5cdHZhciBpc0J1ZmZlciA9IEJ1ZmZlclV0aWxzLmlzQnVmZmVyID0gZnVuY3Rpb24oYnVmKSB7IHJldHVybiBpc0FycmF5QnVmZmVyKGJ1ZikgfHwgaXNXb3JkQXJyYXkoYnVmKSB8fCBpc1R5cGVkQXJyYXkoYnVmKTsgfTtcclxuXHJcblx0LyogSW4gYnJvd3NlcnMsIHJldHVybnMgYSBVaW50OEFycmF5ICovXHJcblx0dmFyIHRvQnVmZmVyID0gQnVmZmVyVXRpbHMudG9CdWZmZXIgPSBmdW5jdGlvbihidWYpIHtcclxuXHRcdGlmKCFBcnJheUJ1ZmZlcikge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBjb252ZXJ0IHRvIEJ1ZmZlcjogYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBuZWNlc3NhcnkgdHlwZXNcIik7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoaXNBcnJheUJ1ZmZlcihidWYpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVWludDhBcnJheShidWYpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKGlzVHlwZWRBcnJheShidWYpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgVWludDhBcnJheShidWYuYnVmZmVyKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZihpc1dvcmRBcnJheShidWYpKSB7XHJcblx0XHRcdC8qIEJhY2twb3J0ZWQgZnJvbSB1bnJlbGVhc2VkIENyeXB0b0pTXHJcblx0XHRcdCogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvc291cmNlL2Jyb3dzZS9icmFuY2hlcy8zLngvc3JjL2xpYi10eXBlZGFycmF5cy5qcz9yPTY2MSAqL1xyXG5cdFx0XHR2YXIgYXJyYXlCdWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnVmLnNpZ0J5dGVzKTtcclxuXHRcdFx0dmFyIHVpbnQ4VmlldyA9IG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKTtcclxuXHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLnNpZ0J5dGVzOyBpKyspIHtcclxuXHRcdFx0XHR1aW50OFZpZXdbaV0gPSAoYnVmLndvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHVpbnQ4VmlldztcclxuXHRcdH07XHJcblxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiQnVmZmVyVXRpbHMudG9CdWZmZXIgZXhwZWN0ZWQgYW4gYXJyYXlidWZmZXIsIHR5cGVkIGFycmF5LCBvciBDcnlwdG9KUyB3b3JkYXJyYXlcIik7XHJcblx0fTtcclxuXHJcblx0QnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uKGJ1Zikge1xyXG5cdFx0aWYoaXNBcnJheUJ1ZmZlcihidWYpKSB7XHJcblx0XHRcdHJldHVybiBidWY7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gdG9CdWZmZXIoYnVmKS5idWZmZXI7XHJcblx0fTtcclxuXHJcblx0QnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkgPSBmdW5jdGlvbihidWYpIHtcclxuXHRcdGlmKGlzVHlwZWRBcnJheShidWYpKSB7XHJcblx0XHRcdGJ1ZiA9IGJ1Zi5idWZmZXI7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gaXNXb3JkQXJyYXkoYnVmKSA/IGJ1ZiA6IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEuY3JlYXRlKGJ1Zik7XHJcblx0fTtcclxuXHJcblx0QnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlID0gZnVuY3Rpb24oYnVmKSB7XHJcblx0XHRpZihpc1dvcmRBcnJheShidWYpKSB7XHJcblx0XHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInN0cmluZ2lmeVwiXSkoYnVmKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB1aW50OFZpZXdUb0Jhc2U2NCh0b0J1ZmZlcihidWYpKTtcclxuXHR9O1xyXG5cclxuXHRCdWZmZXJVdGlscy5iYXNlNjREZWNvZGUgPSBmdW5jdGlvbihzdHIpIHtcclxuXHRcdGlmKEFycmF5QnVmZmVyICYmIGF0b2IpIHtcclxuXHRcdFx0cmV0dXJuIGJhc2U2NFRvQXJyYXlCdWZmZXIoc3RyKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcInBhcnNlXCJdKShzdHIpO1xyXG5cdH07XHJcblxyXG5cdEJ1ZmZlclV0aWxzLmhleEVuY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xyXG5cdFx0YnVmID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmKTtcclxuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInN0cmluZ2lmeVwiXSkoYnVmKTtcclxuXHR9O1xyXG5cclxuXHRCdWZmZXJVdGlscy5oZXhEZWNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuXHRcdHZhciB3b3JkQXJyYXkgPSBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19oZXhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcInBhcnNlXCJdKShzdHJpbmcpO1xyXG5cdFx0cmV0dXJuIEFycmF5QnVmZmVyID8gQnVmZmVyVXRpbHMudG9BcnJheUJ1ZmZlcih3b3JkQXJyYXkpIDogd29yZEFycmF5O1xyXG5cdH07XHJcblxyXG5cdEJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcpIHtcclxuXHRcdGlmKFRleHRFbmNvZGVyKSB7XHJcblx0XHRcdHJldHVybiAobmV3IFRleHRFbmNvZGVyKCkpLmVuY29kZShzdHJpbmcpLmJ1ZmZlcjtcclxuXHRcdH1cclxuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVwiXSkoc3RyaW5nKTtcclxuXHR9O1xyXG5cclxuXHQvKiBGb3IgdXRmOCBkZWNvZGluZyB3ZSBhcHBseSBzbGlnaHRseSBzdHJpY3RlciBpbnB1dCB2YWxpZGF0aW9uIHRoYW4gdG9cclxuXHQgKiBoZXhFbmNvZGUvYmFzZTY0RW5jb2RlL2V0YzogaW4gdGhvc2Ugd2UgYWNjZXB0IGFueXRoaW5nIHRoYXQgQnVmZmVyLmZyb21cclxuXHQgKiBjYW4gdGFrZSAoaW4gcGFydGljdWxhciBhbGxvd2luZyBzdHJpbmdzLCB3aGljaCBhcmUganVzdCBpbnRlcnByZXRlZCBhc1xyXG5cdCAqIGJpbmFyeSk7IGhlcmUgd2UgZW5zdXJlIHRoYXQgdGhlIGlucHV0IGlzIGFjdHVhbGx5IGEgYnVmZmVyIHNpbmNlIHRyeWluZ1xyXG5cdCAqIHRvIHV0ZjgtZGVjb2RlIGEgc3RyaW5nIHRvIGFub3RoZXIgc3RyaW5nIGlzIGFsbW9zdCBjZXJ0YWlubHkgYSBtaXN0YWtlICovXHJcblx0QnVmZmVyVXRpbHMudXRmOERlY29kZSA9IGZ1bmN0aW9uKGJ1Zikge1xyXG5cdFx0aWYoIWlzQnVmZmVyKGJ1ZikpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiRXhwZWN0ZWQgaW5wdXQgb2YgdXRmOGRlY29kZSB0byBiZSBhbiBhcnJheWJ1ZmZlciwgdHlwZWQgYXJyYXksIG9yIENyeXB0b0pTIHdvcmRhcnJheVwiKTtcclxuXHRcdH1cclxuXHRcdGlmKFRleHREZWNvZGVyICYmICFpc1dvcmRBcnJheShidWYpKSB7XHJcblx0XHRcdHJldHVybiAobmV3IFRleHREZWNvZGVyKCkpLmRlY29kZShidWYpO1xyXG5cdFx0fVxyXG5cdFx0YnVmID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmKTtcclxuXHRcdHJldHVybiBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY191dGY4X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJzdHJpbmdpZnlcIl0pKGJ1Zik7XHJcblx0fTtcclxuXHJcblx0QnVmZmVyVXRpbHMuYnVmZmVyQ29tcGFyZSA9IGZ1bmN0aW9uKGJ1ZjEsIGJ1ZjIpIHtcclxuXHRcdGlmKCFidWYxKSByZXR1cm4gLTE7XHJcblx0XHRpZighYnVmMikgcmV0dXJuIDE7XHJcblx0XHRidWYxID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmMSk7XHJcblx0XHRidWYyID0gQnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoYnVmMik7XHJcblx0XHRidWYxLmNsYW1wKCk7IGJ1ZjIuY2xhbXAoKTtcclxuXHJcblx0XHR2YXIgY21wID0gYnVmMS5zaWdCeXRlcyAtIGJ1ZjIuc2lnQnl0ZXM7XHJcblx0XHRpZihjbXAgIT0gMCkgcmV0dXJuIGNtcDtcclxuXHRcdGJ1ZjEgPSBidWYxLndvcmRzOyBidWYyID0gYnVmMi53b3JkcztcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBidWYxLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGNtcCA9IGJ1ZjFbaV0gLSBidWYyW2ldO1xyXG5cdFx0XHRpZihjbXAgIT0gMCkgcmV0dXJuIGNtcDtcclxuXHRcdH1cclxuXHRcdHJldHVybiAwO1xyXG5cdH07XHJcblxyXG5cdEJ1ZmZlclV0aWxzLmJ5dGVMZW5ndGggPSBmdW5jdGlvbihidWYpIHtcclxuXHRcdGlmKGlzQXJyYXlCdWZmZXIoYnVmKSB8fCBpc1R5cGVkQXJyYXkoYnVmKSkge1xyXG5cdFx0XHRyZXR1cm4gYnVmLmJ5dGVMZW5ndGhcclxuXHRcdH0gZWxzZSBpZihpc1dvcmRBcnJheShidWYpKSB7XHJcblx0XHRcdHJldHVybiBidWYuc2lnQnl0ZXM7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyogUmV0dXJucyBBcnJheUJ1ZmZlciBvbiBicm93c2VyIGFuZCBCdWZmZXIgb24gTm9kZS5qcyAqL1xyXG5cdEJ1ZmZlclV0aWxzLnR5cGVkQXJyYXlUb0J1ZmZlciA9IGZ1bmN0aW9uKHR5cGVkQXJyYXkpIHtcclxuXHRcdHJldHVybiB0eXBlZEFycmF5LmJ1ZmZlcjtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gQnVmZmVyVXRpbHM7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEJ1ZmZlclV0aWxzKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxuXHJcblxyXG52YXIgSHR0cCA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5cdGZ1bmN0aW9uIEh0dHAoKSB7fVxyXG5cclxuXHR2YXIgbm93ID0gRGF0ZS5ub3cgfHwgZnVuY3Rpb24oKSB7XHJcblx0XHQvKiBJRSA4ICovXHJcblx0XHRyZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gc2hvdWxkRmFsbGJhY2soZXJyKSB7XHJcblx0XHR2YXIgc3RhdHVzQ29kZSA9IGVyci5zdGF0dXNDb2RlO1xyXG5cdFx0LyogNDAwICsgbm8gY29kZSA9IGEgZ2VuZXJpYyB4aHIgb25lcnJvci4gQnJvd3NlciBkb2Vzbid0IGdpdmUgdXMgZW5vdWdoXHJcblx0XHQgKiBkZXRhaWwgdG8ga25vdyB3aGV0aGVyIGl0J3MgZmFsbGJhY2stZml4YWJsZSwgYnV0IGl0IG1heSBiZSAoZWcgaWYgYVxyXG5cdFx0ICogbmV0d29yayBpc3N1ZSksIHNvIHRyeSBqdXN0IGluIGNhc2UgKi9cclxuXHRcdHJldHVybiAoc3RhdHVzQ29kZSA9PT0gNDA4ICYmICFlcnIuY29kZSkgfHxcclxuXHRcdFx0KHN0YXR1c0NvZGUgPT09IDQwMCAmJiAhZXJyLmNvZGUpICAgICAgfHxcclxuXHRcdFx0KHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPD0gNTA0KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGdldEhvc3RzKGNsaWVudCkge1xyXG5cdFx0LyogSWYgd2UncmUgYSBjb25uZWN0ZWQgcmVhbHRpbWUgY2xpZW50LCB0cnkgdGhlIGVuZHBvaW50IHdlJ3JlIGNvbm5lY3RlZFxyXG5cdFx0ICogdG8gZmlyc3QgLS0gYnV0IHN0aWxsIGhhdmUgZmFsbGJhY2tzLCBiZWluZyBjb25uZWN0ZWQgaXMgbm90IGFuIGFic29sdXRlXHJcblx0XHQgKiBndWFyYW50ZWUgdGhhdCBhIGRhdGFjZW50ZXIgaGFzIGZyZWUgY2FwYWNpdHkgdG8gc2VydmljZSBSRVNUIHJlcXVlc3RzLiAqL1xyXG5cdFx0dmFyIGNvbm5lY3Rpb24gPSBjbGllbnQuY29ubmVjdGlvbixcclxuXHRcdFx0Y29ubmVjdGlvbkhvc3QgPSBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuaG9zdDtcclxuXHJcblx0XHRpZihjb25uZWN0aW9uSG9zdCkge1xyXG5cdFx0XHRyZXR1cm4gW2Nvbm5lY3Rpb25Ib3N0XS5jb25jYXQoX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEZhbGxiYWNrSG9zdHMoY2xpZW50Lm9wdGlvbnMpKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3RzKGNsaWVudC5vcHRpb25zKTtcclxuXHR9XHJcblx0SHR0cC5fZ2V0SG9zdHMgPSBnZXRIb3N0cztcclxuXHJcblx0SHR0cC5tZXRob2RzID0gWydnZXQnLCAnZGVsZXRlJywgJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ107XHJcblx0SHR0cC5tZXRob2RzV2l0aG91dEJvZHkgPSBbJ2dldCcsICdkZWxldGUnXTtcclxuXHRIdHRwLm1ldGhvZHNXaXRoQm9keSA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJTdWJ0cmFjdChIdHRwLm1ldGhvZHMsIEh0dHAubWV0aG9kc1dpdGhvdXRCb2R5KTtcclxuXHJcblx0LyogLSBIdHRwLmdldCwgSHR0cC5wb3N0LCBIdHRwLnB1dCwgLi4uXHJcblx0ICogUGVyZm9ybSBhbiBIVFRQIHJlcXVlc3QgZm9yIGEgZ2l2ZW4gcGF0aCBhZ2FpbnN0IHByaW1lIGFuZCBmYWxsYmFjayBBYmx5IGhvc3RzXHJcblx0ICogQHBhcmFtIHJlc3RcclxuXHQgKiBAcGFyYW0gcGF0aCB0aGUgZnVsbCBwYXRoXHJcblx0ICogQHBhcmFtIGhlYWRlcnMgb3B0aW9uYWwgaGFzaCBvZiBoZWFkZXJzXHJcblx0ICogW29ubHkgZm9yIG1ldGhvZHMgd2l0aCBib2R5OiBAcGFyYW0gYm9keSBvYmplY3Qgb3IgYnVmZmVyIGNvbnRhaW5pbmcgcmVxdWVzdCBib2R5XVxyXG5cdCAqIEBwYXJhbSBwYXJhbXMgb3B0aW9uYWwgaGFzaCBvZiBwYXJhbXNcclxuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwgcmVzcG9uc2UpXHJcblx0ICpcclxuXHQgKiAtIEh0dHAuZ2V0VXJpLCBIdHRwLnBvc3RVcmksIEh0dHAucHV0VXJpLCAuLi5cclxuXHQgKiBQZXJmb3JtIGFuIEhUVFAgcmVxdWVzdCBmb3IgYSBnaXZlbiBmdWxsIFVSSVxyXG5cdCAqIEBwYXJhbSByZXN0XHJcblx0ICogQHBhcmFtIHVyaSB0aGUgZnVsbCBVUklcclxuXHQgKiBAcGFyYW0gaGVhZGVycyBvcHRpb25hbCBoYXNoIG9mIGhlYWRlcnNcclxuXHQgKiBbb25seSBmb3IgbWV0aG9kcyB3aXRoIGJvZHk6IEBwYXJhbSBib2R5IG9iamVjdCBvciBidWZmZXIgY29udGFpbmluZyByZXF1ZXN0IGJvZHldXHJcblx0ICogQHBhcmFtIHBhcmFtcyBvcHRpb25hbCBoYXNoIG9mIHBhcmFtc1xyXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCByZXNwb25zZSlcclxuXHQgKi9cclxuXHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChIdHRwLm1ldGhvZHNXaXRob3V0Qm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRIdHRwW21ldGhvZF0gPSBmdW5jdGlvbihyZXN0LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHRcdEh0dHBbJ2RvJ10obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBudWxsLCBwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHRcdH07XHJcblx0XHRIdHRwW21ldGhvZCArICdVcmknXSA9IGZ1bmN0aW9uKHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaykge1xyXG5cdFx0XHRIdHRwLmRvVXJpKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBudWxsLCBwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHRcdH07XHJcblx0fSk7XHJcblxyXG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKEh0dHAubWV0aG9kc1dpdGhCb2R5LCBmdW5jdGlvbihtZXRob2QpIHtcclxuXHRcdEh0dHBbbWV0aG9kXSA9IGZ1bmN0aW9uKHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdFx0SHR0cFsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xyXG5cdFx0fTtcclxuXHRcdEh0dHBbbWV0aG9kICsgJ1VyaSddID0gZnVuY3Rpb24ocmVzdCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xyXG5cdFx0fTtcclxuXHR9KTtcclxuXHJcblx0LyogVW5saWtlIGZvciBkb1VyaSwgdGhlICdyZXN0JyBwYXJhbSBoZXJlIGlzIG1hbmRhdG9yeSwgYXMgaXQncyB1c2VkIHRvIGdlbmVyYXRlIHRoZSBob3N0cyAqL1xyXG5cdEh0dHBbJ2RvJ10gPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHBhdGgsIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcclxuXHRcdHZhciB1cmlGcm9tSG9zdCA9ICh0eXBlb2YocGF0aCkgPT0gJ2Z1bmN0aW9uJykgPyBwYXRoIDogZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gcmVzdC5iYXNlVXJpKGhvc3QpICsgcGF0aDsgfTtcclxuXHRcdHZhciBiaW5hcnkgPSAoaGVhZGVycyAmJiBoZWFkZXJzLmFjY2VwdCAhPSAnYXBwbGljYXRpb24vanNvbicpO1xyXG5cdFx0dmFyIGRvQXJncyA9IGFyZ3VtZW50cztcclxuXHJcblx0XHR2YXIgY3VycmVudEZhbGxiYWNrID0gcmVzdC5fY3VycmVudEZhbGxiYWNrO1xyXG5cdFx0aWYoY3VycmVudEZhbGxiYWNrKSB7XHJcblx0XHRcdGlmKGN1cnJlbnRGYWxsYmFjay52YWxpZFVudGlsID4gbm93KCkpIHtcclxuXHRcdFx0XHQvKiBVc2Ugc3RvcmVkIGZhbGxiYWNrICovXHJcblx0XHRcdFx0SHR0cC5SZXF1ZXN0KG1ldGhvZCwgcmVzdCwgdXJpRnJvbUhvc3QoY3VycmVudEZhbGxiYWNrLmhvc3QpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0aWYoZXJyICYmIHNob3VsZEZhbGxiYWNrKGVycikpIHtcclxuXHRcdFx0XHRcdFx0LyogdW5zdG9yZSB0aGUgZmFsbGJhY2sgYW5kIHN0YXJ0IGZyb20gdGhlIHRvcCB3aXRoIHRoZSBkZWZhdWx0IHNlcXVlbmNlICovXHJcblx0XHRcdFx0XHRcdHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XHJcblx0XHRcdFx0XHRcdEh0dHBbJ2RvJ10uYXBwbHkoSHR0cCwgZG9BcmdzKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2FsbGJhY2suYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0LyogRmFsbGJhY2sgZXhwaXJlZDsgcmVtb3ZlIGl0IGFuZCBmYWxsdGhyb3VnaCB0byBub3JtYWwgc2VxdWVuY2UgKi9cclxuXHRcdFx0XHRyZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGhvc3RzID0gZ2V0SG9zdHMocmVzdCk7XHJcblxyXG5cdFx0LyogaWYgdGhlcmUgaXMgb25seSBvbmUgaG9zdCBkbyBpdCAqL1xyXG5cdFx0aWYoaG9zdHMubGVuZ3RoID09IDEpIHtcclxuXHRcdFx0SHR0cC5kb1VyaShtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGhvc3RzWzBdKSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjayk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBob3N0cyBpcyBhbiBhcnJheSB3aXRoIHByZWZlcnJlZCBob3N0IHBsdXMgYXQgbGVhc3Qgb25lIGZhbGxiYWNrICovXHJcblx0XHR2YXIgdHJ5QUhvc3QgPSBmdW5jdGlvbihjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2Vzcykge1xyXG5cdFx0XHR2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XHJcblx0XHRcdEh0dHAuZG9VcmkobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChob3N0KSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIgJiYgc2hvdWxkRmFsbGJhY2soZXJyKSAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcclxuXHRcdFx0XHRcdHRyeUFIb3N0KGNhbmRpZGF0ZUhvc3RzLCB0cnVlKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYocGVyc2lzdE9uU3VjY2Vzcykge1xyXG5cdFx0XHRcdFx0LyogUlNDMTVmICovXHJcblx0XHRcdFx0XHRyZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSB7XHJcblx0XHRcdFx0XHRcdGhvc3Q6IGhvc3QsXHJcblx0XHRcdFx0XHRcdHZhbGlkVW50aWw6IG5vdygpICsgcmVzdC5vcHRpb25zLnRpbWVvdXRzLmZhbGxiYWNrUmV0cnlUaW1lb3V0XHJcblx0XHRcdFx0XHR9O1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjay5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0XHR0cnlBSG9zdChob3N0cyk7XHJcblx0fTtcclxuXHJcblx0SHR0cC5kb1VyaSA9IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHRIdHRwLlJlcXVlc3QobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdEh0dHAuc3VwcG9ydHNBdXRoSGVhZGVycyA9IGZhbHNlO1xyXG5cdEh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA9IGZhbHNlO1xyXG5cdHJldHVybiBIdHRwO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChIdHRwKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcblxyXG5cclxuXHJcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XHJcblxyXG52YXIgRXZlbnRFbWl0dGVyID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cclxuXHRmdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XHJcblx0XHR0aGlzLmFueSA9IFtdO1xyXG5cdFx0dGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cdFx0dGhpcy5hbnlPbmNlID0gW107XHJcblx0XHR0aGlzLmV2ZW50c09uY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cdH1cclxuXHJcblx0LyogQ2FsbCB0aGUgbGlzdGVuZXIsIGNhdGNoIGFueSBleGNlcHRpb25zIGFuZCBsb2csIGJ1dCBjb250aW51ZSBvcGVyYXRpb24qL1xyXG5cdGZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHRsaXN0ZW5lci5hcHBseShldmVudFRoaXMsIGFyZ3MpO1xyXG5cdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0V2ZW50RW1pdHRlci5lbWl0KCknLCAnVW5leHBlY3RlZCBsaXN0ZW5lciBleGNlcHRpb246ICcgKyBlICsgJzsgc3RhY2sgPSAnICsgKGUgJiYgZS5zdGFjaykpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVtb3ZlIGxpc3RlbmVycyB0aGF0IG1hdGNoIGxpc3RlbmVyXHJcblx0ICogQHBhcmFtIHRhcmdldExpc3RlbmVycyBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBhcnJheXMgb3IgZXZlbnQgb2JqZWN0cyB3aXRoIGFycmF5cyBvZiBsaXN0ZW5lcnNcclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIGNhbGxiYWNrIHRvIHJlbW92ZVxyXG5cdCAqIEBwYXJhbSBldmVudEZpbHRlciAob3B0aW9uYWwpIGV2ZW50IG5hbWUgaW5zdHJ1Y3RpbmcgdGhlIGZ1bmN0aW9uIHRvIG9ubHkgcmVtb3ZlIGxpc3RlbmVycyBmb3IgdGhlIHNwZWNpZmllZCBldmVudFxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHRhcmdldExpc3RlbmVycywgbGlzdGVuZXIsIGV2ZW50RmlsdGVyKSB7XHJcblx0XHR2YXIgbGlzdGVuZXJzLCBpZHgsIGV2ZW50TmFtZSwgdGFyZ2V0TGlzdGVuZXJzSW5kZXg7XHJcblxyXG5cdFx0Zm9yICh0YXJnZXRMaXN0ZW5lcnNJbmRleCA9IDA7IHRhcmdldExpc3RlbmVyc0luZGV4IDwgdGFyZ2V0TGlzdGVuZXJzLmxlbmd0aDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXgrKykge1xyXG5cdFx0XHRsaXN0ZW5lcnMgPSB0YXJnZXRMaXN0ZW5lcnNbdGFyZ2V0TGlzdGVuZXJzSW5kZXhdO1xyXG5cdFx0XHRpZiAoZXZlbnRGaWx0ZXIpIHsgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTsgfVxyXG5cclxuXHRcdFx0aWYgKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkobGlzdGVuZXJzKSkge1xyXG5cdFx0XHRcdHdoaWxlICgoaWR4ID0gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihsaXN0ZW5lcnMsIGxpc3RlbmVyKSkgIT09IC0xKSB7XHJcblx0XHRcdFx0XHRsaXN0ZW5lcnMuc3BsaWNlKGlkeCwgMSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8qIElmIGV2ZW50cyBvYmplY3QgaGFzIGFuIGV2ZW50IG5hbWUga2V5IHdpdGggbm8gbGlzdGVuZXJzIHRoZW5cclxuXHRcdFx0XHQgICByZW1vdmUgdGhlIGtleSB0byBzdG9wIHRoZSBsaXN0IGdyb3dpbmcgaW5kZWZpbml0ZWx5ICovXHJcblx0XHRcdFx0aWYgKGV2ZW50RmlsdGVyICYmIChsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSkge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIGlmIChfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc09iamVjdChsaXN0ZW5lcnMpKSB7XHJcblx0XHRcdFx0LyogZXZlbnRzICovXHJcblx0XHRcdFx0Zm9yIChldmVudE5hbWUgaW4gbGlzdGVuZXJzKSB7XHJcblx0XHRcdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcclxuXHRcdFx0XHRcdFx0cmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogQWRkIGFuIGV2ZW50IGxpc3RlbmVyXHJcblx0ICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHRvIGxpc3RlbiB0b1xyXG5cdCAqICAgICAgICBpZiBub3Qgc3VwcGxpZWQsIGFsbCBldmVudHMgdHJpZ2dlciBhIGNhbGwgdG8gdGhlIGxpc3RlbmVyXHJcblx0ICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcclxuXHQgKi9cclxuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XHJcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHRoaXMuYW55LnB1c2goZXZlbnQpO1xyXG5cdFx0fSBlbHNlIGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcoZXZlbnQpKSB7XHJcblx0XHRcdHRoaXMuYW55LnB1c2gobGlzdGVuZXIpO1xyXG5cdFx0fSBlbHNlIGlmKF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkoZXZlbnQpKSB7XHJcblx0XHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdFx0X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChldmVudCwgZnVuY3Rpb24oZXYpIHtcclxuXHRcdFx0XHRzZWxmLm9uKGV2LCBsaXN0ZW5lcik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIGxpc3RlbmVycyA9ICh0aGlzLmV2ZW50c1tldmVudF0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XSA9IFtdKSk7XHJcblx0XHRcdGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBSZW1vdmUgb25lIG9yIG1vcmUgZXZlbnQgbGlzdGVuZXJzXHJcblx0ICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50IHdob3NlIGxpc3RlbmVyXHJcblx0ICogICAgICAgIGlzIHRvIGJlIHJlbW92ZWQuIElmIG5vdCBzdXBwbGllZCwgdGhlIGxpc3RlbmVyIGlzXHJcblx0ICogICAgICAgIHRyZWF0ZWQgYXMgYW4gJ2FueScgbGlzdGVuZXJcclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgKG9wdGlvbmFsKSB0aGUgbGlzdGVuZXIgdG8gcmVtb3ZlLiBJZiBub3RcclxuXHQgKiAgICAgICAgc3VwcGxpZWQsIGFsbCBsaXN0ZW5lcnMgYXJlIHJlbW92ZWQuXHJcblx0ICovXHJcblx0RXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcclxuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMCB8fCAoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhldmVudCkgJiYgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhsaXN0ZW5lcikpKSB7XHJcblx0XHRcdHRoaXMuYW55ID0gW107XHJcblx0XHRcdHRoaXMuZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHRcdFx0dGhpcy5hbnlPbmNlID0gW107XHJcblx0XHRcdHRoaXMuZXZlbnRzT25jZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkge1xyXG5cdFx0XHRpZih0eXBlb2YoZXZlbnQpID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHQvKiB3ZSB0YWtlIHRoaXMgdG8gYmUgdGhlIGxpc3RlbmVyIGFuZCB0cmVhdCB0aGUgZXZlbnQgYXMgXCJhbnlcIiAuLiAqL1xyXG5cdFx0XHRcdGxpc3RlbmVyID0gZXZlbnQ7XHJcblx0XHRcdFx0ZXZlbnQgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8qIC4uLiBvciB3ZSB0YWtlIGV2ZW50IHRvIGJlIHRoZSBhY3R1YWwgZXZlbnQgbmFtZSBhbmQgbGlzdGVuZXIgdG8gYmUgYWxsICovXHJcblx0XHR9XHJcblxyXG5cdFx0aWYobGlzdGVuZXIgJiYgX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNFbXB0eUFyZyhldmVudCkpIHtcclxuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KGV2ZW50KSkge1xyXG5cdFx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goZXZlbnQsIGZ1bmN0aW9uKGV2KSB7XHJcblx0XHRcdFx0c2VsZi5vZmYoZXYsIGxpc3RlbmVyKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogXCJub3JtYWxcIiBjYXNlIHdoZXJlIGV2ZW50IGlzIGFuIGFjdHVhbCBldmVudCAqL1xyXG5cdFx0aWYobGlzdGVuZXIpIHtcclxuXHRcdFx0cmVtb3ZlTGlzdGVuZXIoW3RoaXMuZXZlbnRzLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lciwgZXZlbnQpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuZXZlbnRzW2V2ZW50XTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBhcnJheSBvZiBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gZXZlbnQ7IGV4Y2x1ZGVzIG9uY2UgZXZlbnRzXHJcblx0ICogQHBhcmFtIGV2ZW50IChvcHRpb25hbCkgdGhlIG5hbWUgb2YgdGhlIGV2ZW50LCBvciBub25lIGZvciAnYW55J1xyXG5cdCAqIEByZXR1cm4gYXJyYXkgb2YgZXZlbnRzLCBvciBudWxsIGlmIG5vbmVcclxuXHQgKi9cclxuXHRFdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcblx0XHRpZihldmVudCkge1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJzID0gKHRoaXMuZXZlbnRzW2V2ZW50XSB8fCBbXSk7XHJcblx0XHRcdGlmKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXHJcblx0XHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmV2ZW50c09uY2VbZXZlbnRdKTtcclxuXHRcdFx0cmV0dXJuIGxpc3RlbmVycy5sZW5ndGggPyBsaXN0ZW5lcnMgOiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuYW55Lmxlbmd0aCA/IHRoaXMuYW55IDogbnVsbDtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBFbWl0IGFuIGV2ZW50XHJcblx0ICogQHBhcmFtIGV2ZW50IHRoZSBldmVudCBuYW1lXHJcblx0ICogQHBhcmFtIGFyZ3MgdGhlIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxyXG5cdCAqL1xyXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50ICAvKiAsIGFyZ3MuLi4gKi8pIHtcclxuXHRcdHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcclxuXHRcdHZhciBldmVudFRoaXMgPSB7ZXZlbnQ6ZXZlbnR9O1xyXG5cdFx0dmFyIGxpc3RlbmVycyA9IFtdO1xyXG5cclxuXHRcdGlmKHRoaXMuYW55T25jZS5sZW5ndGgpIHtcclxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueU9uY2UpO1xyXG5cdFx0XHR0aGlzLmFueU9uY2UgPSBbXTtcclxuXHRcdH1cclxuXHRcdGlmKHRoaXMuYW55Lmxlbmd0aCkge1xyXG5cdFx0XHRBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShsaXN0ZW5lcnMsIHRoaXMuYW55KTtcclxuXHRcdH1cclxuXHRcdHZhciBldmVudHNPbmNlTGlzdGVuZXJzID0gdGhpcy5ldmVudHNPbmNlW2V2ZW50XTtcclxuXHRcdGlmKGV2ZW50c09uY2VMaXN0ZW5lcnMpIHtcclxuXHRcdFx0QXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNPbmNlTGlzdGVuZXJzKTtcclxuXHRcdFx0ZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XHJcblx0XHR9XHJcblx0XHR2YXIgZXZlbnRzTGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdO1xyXG5cdFx0aWYoZXZlbnRzTGlzdGVuZXJzKSB7XHJcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcclxuXHRcdH1cclxuXHJcblx0XHRfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKGxpc3RlbmVycywgZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuXHRcdFx0Y2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGFyZ3MpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogTGlzdGVuIGZvciBhIHNpbmdsZSBvY2N1cnJlbmNlIG9mIGFuIGV2ZW50XHJcblx0ICogQHBhcmFtIGV2ZW50IHRoZSBuYW1lIG9mIHRoZSBldmVudCB0byBsaXN0ZW4gdG9cclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGJlIGNhbGxlZFxyXG5cdCAqL1xyXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xyXG5cdFx0dmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCwgc2VsZiA9IHRoaXM7XHJcblx0XHRpZigoYXJnQ291bnQgPT09IDAgfHwgKGFyZ0NvdW50ID09PSAxICYmIHR5cGVvZiBldmVudCAhPT0gJ2Z1bmN0aW9uJykpICYmIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUHJvbWlzZSkge1xyXG5cdFx0XHRyZXR1cm4gbmV3IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XHJcblx0XHRcdFx0c2VsZi5vbmNlKGV2ZW50LCByZXNvbHZlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0XHRpZihhcmd1bWVudHMubGVuZ3RoID09IDEgJiYgdHlwZW9mKGV2ZW50KSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdHRoaXMuYW55T25jZS5wdXNoKGV2ZW50KTtcclxuXHRcdH0gZWxzZSBpZihfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5QXJnKGV2ZW50KSkge1xyXG5cdFx0XHR0aGlzLmFueU9uY2UucHVzaChsaXN0ZW5lcik7XHJcblx0XHR9IGVsc2UgaWYoX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShldmVudCkpe1xyXG5cdFx0XHR2YXIgbGlzdGVuZXJXcmFwcGVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cdFx0XHRcdF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goZXZlbnQsIGZ1bmN0aW9uKGV2KSB7XHJcblx0XHRcdFx0XHRzZWxmLm9mZihldiwgbGlzdGVuZXJXcmFwcGVyKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcclxuXHRcdFx0fTtcclxuXHRcdFx0X3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChldmVudCwgZnVuY3Rpb24oZXYpIHtcclxuXHRcdFx0XHRzZWxmLm9uKGV2LCBsaXN0ZW5lcldyYXBwZXIpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBsaXN0ZW5lcnMgPSAodGhpcy5ldmVudHNPbmNlW2V2ZW50XSB8fCAodGhpcy5ldmVudHNPbmNlW2V2ZW50XSA9IFtdKSk7XHJcblx0XHRcdGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBQcml2YXRlIEFQSVxyXG5cdCAqXHJcblx0ICogTGlzdGVuIGZvciBhIHNpbmdsZSBvY2N1cnJlbmNlIG9mIGEgc3RhdGUgZXZlbnQgYW5kIGZpcmUgaW1tZWRpYXRlbHkgaWYgY3VycmVudFN0YXRlIG1hdGNoZXMgdGFyZ2V0U3RhdGVcclxuXHQgKiBAcGFyYW0gdGFyZ2V0U3RhdGUgdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGV2ZW50IHRvIGxpc3RlbiB0b1xyXG5cdCAqIEBwYXJhbSBjdXJyZW50U3RhdGUgdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgc3RhdGUgb2YgdGhpcyBvYmplY3RcclxuXHQgKiBAcGFyYW0gbGlzdGVuZXIgdGhlIGxpc3RlbmVyIHRvIGJlIGNhbGxlZFxyXG5cdCAqL1xyXG5cdEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24odGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSwgbGlzdGVuZXIgLyogLi4ubGlzdGVuZXJBcmdzICovKSB7XHJcblx0XHR2YXIgZXZlbnRUaGlzID0ge2V2ZW50OnRhcmdldFN0YXRlfSxcclxuXHRcdFx0c2VsZiA9IHRoaXMsXHJcblx0XHRcdGxpc3RlbmVyQXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMyk7XHJcblxyXG5cdFx0aWYoKHR5cGVvZih0YXJnZXRTdGF0ZSkgIT09ICdzdHJpbmcnKSB8fCAodHlwZW9mKGN1cnJlbnRTdGF0ZSkgIT09ICdzdHJpbmcnKSkge1xyXG5cdFx0XHR0aHJvdyhcIndoZW5TdGF0ZSByZXF1aXJlcyBhIHZhbGlkIGV2ZW50IFN0cmluZyBhcmd1bWVudFwiKTtcclxuXHRcdH1cclxuXHRcdGlmKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJyAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlByb21pc2UpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xyXG5cdFx0XHRcdEV2ZW50RW1pdHRlci5wcm90b3R5cGUud2hlblN0YXRlLmFwcGx5KHNlbGYsIFt0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlLCByZXNvbHZlXS5jb25jYXQobGlzdGVuZXJBcmdzKSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdFx0aWYodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xyXG5cdFx0XHRjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgbGlzdGVuZXJBcmdzKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMub25jZSh0YXJnZXRTdGF0ZSwgbGlzdGVuZXIpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIEV2ZW50RW1pdHRlcjtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRXZlbnRFbWl0dGVyKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3ByZXNlbmNlbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIFByb3RvY29sTWVzc2FnZSA9IChmdW5jdGlvbigpIHtcclxuXHJcblx0ZnVuY3Rpb24gUHJvdG9jb2xNZXNzYWdlKCkge1xyXG5cdFx0dGhpcy5hY3Rpb24gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmZsYWdzID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMudGltZXN0YW1wID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5jb3VudCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuZXJyb3IgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY29ubmVjdGlvblNlcmlhbCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY2hhbm5lbCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY2hhbm5lbFNlcmlhbCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMubXNnU2VyaWFsID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5tZXNzYWdlcyA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMucHJlc2VuY2UgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmF1dGggPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnBhcmFtcyA9IHVuZGVmaW5lZDtcclxuXHR9XHJcblxyXG5cdHZhciBhY3Rpb25zID0gUHJvdG9jb2xNZXNzYWdlLkFjdGlvbiA9IHtcclxuXHRcdCdIRUFSVEJFQVQnIDogMCxcclxuXHRcdCdBQ0snIDogMSxcclxuXHRcdCdOQUNLJyA6IDIsXHJcblx0XHQnQ09OTkVDVCcgOiAzLFxyXG5cdFx0J0NPTk5FQ1RFRCcgOiA0LFxyXG5cdFx0J0RJU0NPTk5FQ1QnIDogNSxcclxuXHRcdCdESVNDT05ORUNURUQnIDogNixcclxuXHRcdCdDTE9TRScgOiA3LFxyXG5cdFx0J0NMT1NFRCcgOiA4LFxyXG5cdFx0J0VSUk9SJyA6IDksXHJcblx0XHQnQVRUQUNIJyA6IDEwLFxyXG5cdFx0J0FUVEFDSEVEJyA6IDExLFxyXG5cdFx0J0RFVEFDSCcgOiAxMixcclxuXHRcdCdERVRBQ0hFRCcgOiAxMyxcclxuXHRcdCdQUkVTRU5DRScgOiAxNCxcclxuXHRcdCdNRVNTQUdFJyA6IDE1LFxyXG5cdFx0J1NZTkMnIDogMTYsXHJcblx0XHQnQVVUSCcgOiAxN1xyXG5cdH07XHJcblxyXG5cdFByb3RvY29sTWVzc2FnZS5jaGFubmVsTW9kZXMgPSBbICdQUkVTRU5DRScsICdQVUJMSVNIJywgJ1NVQlNDUklCRScsICdQUkVTRU5DRV9TVUJTQ1JJQkUnIF07XHJcblxyXG5cdFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lID0gW107XHJcblx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJGb3JFYWNoKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ua2V5c0FycmF5KFByb3RvY29sTWVzc2FnZS5BY3Rpb24sIHRydWUpLCBmdW5jdGlvbihuYW1lKSB7XHJcblx0XHRQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZVthY3Rpb25zW25hbWVdXSA9IG5hbWU7XHJcblx0fSk7XHJcblxyXG5cdHZhciBmbGFncyA9IHtcclxuXHRcdC8qIENoYW5uZWwgYXR0YWNoIHN0YXRlIGZsYWdzICovXHJcblx0XHQnSEFTX1BSRVNFTkNFJzogICAgICAgMSA8PCAwLFxyXG5cdFx0J0hBU19CQUNLTE9HJzogICAgICAgIDEgPDwgMSxcclxuXHRcdCdSRVNVTUVEJzogICAgICAgICAgICAxIDw8IDIsXHJcblx0XHQnVFJBTlNJRU5UJzogICAgICAgICAgMSA8PCA0LFxyXG5cdFx0J0FUVEFDSF9SRVNVTUUnOiAgICAgIDEgPDwgNSxcclxuXHRcdC8qIENoYW5uZWwgbW9kZSBmbGFncyAqL1xyXG5cdFx0J1BSRVNFTkNFJzogICAgICAgICAgIDEgPDwgMTYsXHJcblx0XHQnUFVCTElTSCc6ICAgICAgICAgICAgMSA8PCAxNyxcclxuXHRcdCdTVUJTQ1JJQkUnOiAgICAgICAgICAxIDw8IDE4LFxyXG5cdFx0J1BSRVNFTkNFX1NVQlNDUklCRSc6IDEgPDwgMTlcclxuXHR9O1xyXG5cdHZhciBmbGFnTmFtZXMgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmtleXNBcnJheShmbGFncyk7XHJcblx0ZmxhZ3MuTU9ERV9BTEwgPSBmbGFncy5QUkVTRU5DRSB8IGZsYWdzLlBVQkxJU0ggfCBmbGFncy5TVUJTQ1JJQkUgfCBmbGFncy5QUkVTRU5DRV9TVUJTQ1JJQkU7XHJcblxyXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuaGFzRmxhZyA9IGZ1bmN0aW9uKGZsYWcpIHtcclxuXHRcdHJldHVybiAoKHRoaXMuZmxhZ3MgJiBmbGFnc1tmbGFnXSkgPiAwKTtcclxuXHR9O1xyXG5cclxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLnNldEZsYWcgPSBmdW5jdGlvbihmbGFnKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5mbGFncyA9IHRoaXMuZmxhZ3MgfCBmbGFnc1tmbGFnXTtcclxuXHR9O1xyXG5cclxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmdldE1vZGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmZsYWdzICYmICh0aGlzLmZsYWdzICYgZmxhZ3MuTU9ERV9BTEwpO1xyXG5cdH07XHJcblxyXG5cdFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZW5jb2RlTW9kZXNUb0ZsYWdzID0gZnVuY3Rpb24obW9kZXMpIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChtb2RlcywgZnVuY3Rpb24obW9kZSkge1xyXG5cdFx0XHRzZWxmLnNldEZsYWcobW9kZSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmRlY29kZU1vZGVzRnJvbUZsYWdzID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbW9kZXMgPSBbXSxcclxuXHRcdFx0c2VsZiA9IHRoaXM7XHJcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckZvckVhY2goUHJvdG9jb2xNZXNzYWdlLmNoYW5uZWxNb2RlcywgZnVuY3Rpb24obW9kZSkge1xyXG5cdFx0XHRpZihzZWxmLmhhc0ZsYWcobW9kZSkpIHtcclxuXHRcdFx0XHRtb2Rlcy5wdXNoKG1vZGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB1bmRlZmluZWQ7XHJcblx0fTtcclxuXHJcblx0UHJvdG9jb2xNZXNzYWdlLnNlcmlhbGl6ZSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZW5jb2RlQm9keTtcclxuXHJcblx0UHJvdG9jb2xNZXNzYWdlLmRlc2VyaWFsaXplID0gZnVuY3Rpb24oc2VyaWFsaXplZCwgZm9ybWF0KSB7XHJcblx0XHR2YXIgZGVzZXJpYWxpemVkID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWNvZGVCb2R5KHNlcmlhbGl6ZWQsIGZvcm1hdCk7XHJcblx0XHRyZXR1cm4gUHJvdG9jb2xNZXNzYWdlLmZyb21EZXNlcmlhbGl6ZWQoZGVzZXJpYWxpemVkKTtcclxuXHR9O1xyXG5cclxuXHRQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZCA9IGZ1bmN0aW9uKGRlc2VyaWFsaXplZCkge1xyXG5cdFx0dmFyIGVycm9yID0gZGVzZXJpYWxpemVkLmVycm9yO1xyXG5cdFx0aWYoZXJyb3IpIGRlc2VyaWFsaXplZC5lcnJvciA9IF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKGVycm9yKTtcclxuXHRcdHZhciBtZXNzYWdlcyA9IGRlc2VyaWFsaXplZC5tZXNzYWdlcztcclxuXHRcdGlmKG1lc3NhZ2VzKSBmb3IodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIG1lc3NhZ2VzW2ldID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKG1lc3NhZ2VzW2ldKTtcclxuXHRcdHZhciBwcmVzZW5jZSA9IGRlc2VyaWFsaXplZC5wcmVzZW5jZTtcclxuXHRcdGlmKHByZXNlbmNlKSBmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspIHByZXNlbmNlW2ldID0gX3ByZXNlbmNlbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMocHJlc2VuY2VbaV0sIHRydWUpO1xyXG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubWl4aW4obmV3IFByb3RvY29sTWVzc2FnZSgpLCBkZXNlcmlhbGl6ZWQpO1xyXG5cdH07XHJcblxyXG5cdFByb3RvY29sTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgUHJvdG9jb2xNZXNzYWdlKCksIHZhbHVlcyk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xyXG5cdFx0aWYgKGFycmF5KSB7XHJcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRyZXN1bHQucHVzaChhcnJheVtpXS50b1N0cmluZygpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuICdbICcgKyByZXN1bHQuam9pbignLCAnKSArICcgXSc7XHJcblx0fVxyXG5cclxuXHR2YXIgc2ltcGxlQXR0cmlidXRlcyA9ICdpZCBjaGFubmVsIGNoYW5uZWxTZXJpYWwgY29ubmVjdGlvbklkIGNvbm5lY3Rpb25LZXkgY29ubmVjdGlvblNlcmlhbCBjb3VudCBtc2dTZXJpYWwgdGltZXN0YW1wJy5zcGxpdCgnICcpO1xyXG5cclxuXHRQcm90b2NvbE1lc3NhZ2Uuc3RyaW5naWZ5ID0gZnVuY3Rpb24obXNnKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gJ1tQcm90b2NvbE1lc3NhZ2UnO1xyXG5cdFx0aWYobXNnLmFjdGlvbiAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgYWN0aW9uPScgKyBQcm90b2NvbE1lc3NhZ2UuQWN0aW9uTmFtZVttc2cuYWN0aW9uXSB8fCBmYWxzZTtcclxuXHJcblx0XHR2YXIgYXR0cmlidXRlO1xyXG5cdFx0Zm9yICh2YXIgYXR0cmliSW5kZXggPSAwOyBhdHRyaWJJbmRleCA8IHNpbXBsZUF0dHJpYnV0ZXMubGVuZ3RoOyBhdHRyaWJJbmRleCsrKSB7XHJcblx0XHRcdGF0dHJpYnV0ZSA9IHNpbXBsZUF0dHJpYnV0ZXNbYXR0cmliSW5kZXhdO1xyXG5cdFx0XHRpZihtc2dbYXR0cmlidXRlXSAhPT0gdW5kZWZpbmVkKVxyXG5cdFx0XHRcdHJlc3VsdCArPSAnOyAnICsgYXR0cmlidXRlICsgJz0nICsgbXNnW2F0dHJpYnV0ZV07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYobXNnLm1lc3NhZ2VzKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgbWVzc2FnZXM9JyArIHRvU3RyaW5nQXJyYXkoX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzQXJyYXkobXNnLm1lc3NhZ2VzKSk7XHJcblx0XHRpZihtc2cucHJlc2VuY2UpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBwcmVzZW5jZT0nICsgdG9TdHJpbmdBcnJheShfcHJlc2VuY2VtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlc0FycmF5KG1zZy5wcmVzZW5jZSkpO1xyXG5cdFx0aWYobXNnLmVycm9yKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgZXJyb3I9JyArIF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKG1zZy5lcnJvcikudG9TdHJpbmcoKTtcclxuXHRcdGlmKG1zZy5hdXRoICYmIG1zZy5hdXRoLmFjY2Vzc1Rva2VuKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgdG9rZW49JyArIG1zZy5hdXRoLmFjY2Vzc1Rva2VuO1xyXG5cdFx0aWYobXNnLmZsYWdzKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgZmxhZ3M9JyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRmlsdGVyKGZsYWdOYW1lcywgZnVuY3Rpb24oZmxhZykge1xyXG5cdFx0XHRcdHJldHVybiBtc2cuaGFzRmxhZyhmbGFnKTtcclxuXHRcdFx0fSkuam9pbignLCcpO1xyXG5cdFx0aWYobXNnLnBhcmFtcykge1xyXG5cdFx0XHR2YXIgc3RyaW5naWZpZWRQYXJhbXMgPSAnJztcclxuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mb3JJbk93bk5vbk51bGxQcm9wcyhtc2cucGFyYW1zLCBmdW5jdGlvbihwcm9wKSB7XHJcblx0XHRcdFx0aWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRcdHN0cmluZ2lmaWVkUGFyYW1zICs9ICc7ICc7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHN0cmluZ2lmaWVkUGFyYW1zICs9IHByb3AgKyAnPScgKyBtc2cucGFyYW1zW3Byb3BdO1xyXG5cdFx0XHR9KTtcclxuXHRcdFx0aWYgKHN0cmluZ2lmaWVkUGFyYW1zLmxlbmd0aCA+IDApIHtcclxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgcGFyYW1zPVsnICsgc3RyaW5naWZpZWRQYXJhbXMgKyAnXSc7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJlc3VsdCArPSAnXSc7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdC8qIE9ubHkgdmFsaWQgZm9yIGNoYW5uZWwgbWVzc2FnZXMgKi9cclxuXHRQcm90b2NvbE1lc3NhZ2UuaXNEdXBsaWNhdGUgPSBmdW5jdGlvbihhLCBiKSB7XHJcblx0XHRpZiAoYSAmJiBiKSB7XHJcblx0XHRcdGlmICgoYS5hY3Rpb24gPT09IGFjdGlvbnMuTUVTU0FHRSB8fCBhLmFjdGlvbiA9PT0gYWN0aW9ucy5QUkVTRU5DRSkgJiZcclxuXHRcdFx0XHQoYS5hY3Rpb24gPT09IGIuYWN0aW9uKSAmJlxyXG5cdFx0XHRcdChhLmNoYW5uZWwgPT09IGIuY2hhbm5lbCkgJiZcclxuXHRcdFx0XHQoYS5pZCA9PT0gYi5pZCkpIHtcclxuXHRcdFx0XHRpZiAoYS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpIHtcclxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHRcdH0gZWxzZSBpZiAoYS5tZXNzYWdlcy5sZW5ndGggPT09IGIubWVzc2FnZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGEubWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdFx0dmFyIGFNZXNzYWdlID0gYS5tZXNzYWdlc1tpXTtcclxuXHRcdFx0XHRcdFx0dmFyIGJNZXNzYWdlID0gYi5tZXNzYWdlc1tpXTtcclxuXHRcdFx0XHRcdFx0aWYgKChhTWVzc2FnZS5leHRyYXMgJiYgYU1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGFNZXNzYWdlLmV4dHJhcy5kZWx0YS5mb3JtYXQpICE9PVxyXG5cdFx0XHRcdFx0XHRcdChiTWVzc2FnZS5leHRyYXMgJiYgYk1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGJNZXNzYWdlLmV4dHJhcy5kZWx0YS5mb3JtYXQpKSB7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBQcm90b2NvbE1lc3NhZ2U7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByb3RvY29sTWVzc2FnZSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDkgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRmdW5jdGlvbiBNZXNzYWdlKCkge1xyXG5cdFx0dGhpcy5uYW1lID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5pZCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMudGltZXN0YW1wID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5jbGllbnRJZCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5kYXRhID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5lbmNvZGluZyA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuZXh0cmFzID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5zaXplID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcclxuXHQgKiBAcmV0dXJuIHsqfVxyXG5cdCAqL1xyXG5cdE1lc3NhZ2UucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9IHtcclxuXHRcdFx0bmFtZTogdGhpcy5uYW1lLFxyXG5cdFx0XHRpZDogdGhpcy5pZCxcclxuXHRcdFx0Y2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXHJcblx0XHRcdGNvbm5lY3Rpb25JZDogdGhpcy5jb25uZWN0aW9uSWQsXHJcblx0XHRcdGNvbm5lY3Rpb25LZXk6IHRoaXMuY29ubmVjdGlvbktleSxcclxuXHRcdFx0ZW5jb2Rpbmc6IHRoaXMuZW5jb2RpbmcsXHJcblx0XHRcdGV4dHJhczogdGhpcy5leHRyYXNcclxuXHRcdH07XHJcblxyXG5cdFx0LyogZW5jb2RlIGRhdGEgdG8gYmFzZTY0IGlmIHByZXNlbnQgYW5kIHdlJ3JlIHJldHVybmluZyByZWFsIEpTT047XHJcblx0XHQgKiBhbHRob3VnaCBtc2dwYWNrIGNhbGxzIHRvSlNPTigpLCB3ZSBrbm93IGl0IGlzIGEgc3RyaW5naWZ5KClcclxuXHRcdCAqIGNhbGwgaWYgaXQgaGFzIGEgbm9uLWVtcHR5IGFyZ3VtZW50cyBsaXN0ICovXHJcblx0XHR2YXIgZGF0YSA9IHRoaXMuZGF0YTtcclxuXHRcdGlmKGRhdGEgJiYgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihkYXRhKSkge1xyXG5cdFx0XHRpZihhcmd1bWVudHMubGVuZ3RoID4gMCkge1xyXG5cdFx0XHRcdC8qIHN0cmluZ2lmeSBjYWxsICovXHJcblx0XHRcdFx0dmFyIGVuY29kaW5nID0gdGhpcy5lbmNvZGluZztcclxuXHRcdFx0XHRyZXN1bHQuZW5jb2RpbmcgPSBlbmNvZGluZyA/IChlbmNvZGluZyArICcvYmFzZTY0JykgOiAnYmFzZTY0JztcclxuXHRcdFx0XHRkYXRhID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlNjRFbmNvZGUoZGF0YSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0LyogQ2FsbGVkIGJ5IG1zZ3BhY2suIHRvQnVmZmVyIHJldHVybnMgYSBkYXRhdHlwZSB1bmRlcnN0YW5kYWJsZSBieVxyXG5cdFx0XHRcdCAqIHRoYXQgcGxhdGZvcm0ncyBtc2dwYWNrIGltcGxlbWVudGF0aW9uIChCdWZmZXIgaW4gbm9kZSwgVWludDhBcnJheVxyXG5cdFx0XHRcdCAqIGluIGJyb3dzZXJzKSAqL1xyXG5cdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvQnVmZmVyKGRhdGEpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXN1bHQuZGF0YSA9IGRhdGE7XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdE1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gJ1tNZXNzYWdlJztcclxuXHRcdGlmKHRoaXMubmFtZSlcclxuXHRcdFx0cmVzdWx0ICs9ICc7IG5hbWU9JyArIHRoaXMubmFtZTtcclxuXHRcdGlmKHRoaXMuaWQpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBpZD0nICsgdGhpcy5pZDtcclxuXHRcdGlmKHRoaXMudGltZXN0YW1wKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcclxuXHRcdGlmKHRoaXMuY2xpZW50SWQpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcclxuXHRcdGlmKHRoaXMuY29ubmVjdGlvbklkKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgY29ubmVjdGlvbklkPScgKyB0aGlzLmNvbm5lY3Rpb25JZDtcclxuXHRcdGlmKHRoaXMuZW5jb2RpbmcpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcclxuXHRcdGlmKHRoaXMuZXh0cmFzKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgZXh0cmFzID0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xyXG5cdFx0aWYodGhpcy5kYXRhKSB7XHJcblx0XHRcdGlmICh0eXBlb2YodGhpcy5kYXRhKSA9PSAnc3RyaW5nJylcclxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xyXG5cdFx0XHRlbHNlIGlmIChwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKHRoaXMuZGF0YSkpXHJcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGJ1ZmZlcik9JyArIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XHJcblx0XHR9XHJcblx0XHRpZih0aGlzLmV4dHJhcylcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGV4dHJhcz0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xyXG5cdFx0cmVzdWx0ICs9ICddJztcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZS5lbmNyeXB0ID0gZnVuY3Rpb24obXNnLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIGRhdGEgPSBtc2cuZGF0YSxcclxuXHRcdFx0ZW5jb2RpbmcgPSBtc2cuZW5jb2RpbmcsXHJcblx0XHRcdGNpcGhlciA9IG9wdGlvbnMuY2hhbm5lbENpcGhlcjtcclxuXHJcblx0XHRlbmNvZGluZyA9IGVuY29kaW5nID8gKGVuY29kaW5nICsgJy8nKSA6ICcnO1xyXG5cdFx0aWYoIXBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNCdWZmZXIoZGF0YSkpIHtcclxuXHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXRmOEVuY29kZShTdHJpbmcoZGF0YSkpO1xyXG5cdFx0XHRlbmNvZGluZyA9IGVuY29kaW5nICsgJ3V0Zi04Lyc7XHJcblx0XHR9XHJcblx0XHRjaXBoZXIuZW5jcnlwdChkYXRhLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcclxuXHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdG1zZy5kYXRhID0gZGF0YTtcclxuXHRcdFx0bXNnLmVuY29kaW5nID0gZW5jb2RpbmcgKyAnY2lwaGVyKycgKyBjaXBoZXIuYWxnb3JpdGhtO1xyXG5cdFx0XHRjYWxsYmFjayhudWxsLCBtc2cpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZS5lbmNvZGUgPSBmdW5jdGlvbihtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgZGF0YSA9IG1zZy5kYXRhLCBlbmNvZGluZyxcclxuXHRcdFx0bmF0aXZlRGF0YVR5cGUgPSB0eXBlb2YoZGF0YSkgPT0gJ3N0cmluZycgfHwgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZDtcclxuXHJcblx0XHRpZiAoIW5hdGl2ZURhdGFUeXBlKSB7XHJcblx0XHRcdGlmIChfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzT2JqZWN0KGRhdGEpIHx8IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNBcnJheShkYXRhKSkge1xyXG5cdFx0XHRcdG1zZy5kYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XHJcblx0XHRcdFx0bXNnLmVuY29kaW5nID0gKGVuY29kaW5nID0gbXNnLmVuY29kaW5nKSA/IChlbmNvZGluZyArICcvanNvbicpIDogJ2pzb24nO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0RhdGEgdHlwZSBpcyB1bnN1cHBvcnRlZCcsIDQwMDEzLCA0MDApO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYob3B0aW9ucyAhPSBudWxsICYmIG9wdGlvbnMuY2lwaGVyKSB7XHJcblx0XHRcdE1lc3NhZ2UuZW5jcnlwdChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIG1zZyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZS5lbmNvZGVBcnJheSA9IGZ1bmN0aW9uKG1lc3NhZ2VzLCBvcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIHByb2Nlc3NlZCA9IDA7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdE1lc3NhZ2UuZW5jb2RlKG1lc3NhZ2VzW2ldLCBvcHRpb25zLCBmdW5jdGlvbihlcnIsIG1zZykge1xyXG5cdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHByb2Nlc3NlZCsrO1xyXG5cdFx0XHRcdGlmIChwcm9jZXNzZWQgPT0gbWVzc2FnZXMubGVuZ3RoKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCBtZXNzYWdlcyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRNZXNzYWdlLnNlcmlhbGl6ZSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZW5jb2RlQm9keTtcclxuXHJcblx0TWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbihtZXNzYWdlLCBjb250ZXh0KSB7XHJcblx0XHQvKiBUaGUgc2Vjb25kIGFyZ3VtZW50IGNvdWxkIGJlIGVpdGhlciBFbmNvZGluZ0RlY29kaW5nQ29udGV4dCB0aGF0IGNvbnRhaW5zIENoYW5uZWxPcHRpb25zIG9yIENoYW5uZWxPcHRpb25zICovXHJcblx0XHRpZighY29udGV4dCB8fCAhY29udGV4dC5jaGFubmVsT3B0aW9ucykge1xyXG5cdFx0XHR2YXIgY2hhbm5lbE9wdGlvbnMgPSBjb250ZXh0O1xyXG5cdFx0XHRjb250ZXh0ID0ge1xyXG5cdFx0XHRcdGNoYW5uZWxPcHRpb25zOiBjaGFubmVsT3B0aW9ucyxcclxuXHRcdFx0XHRwbHVnaW5zOiB7IH0sXHJcblx0XHRcdFx0YmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHVuZGVmaW5lZFxyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBsYXN0UGF5bG9hZCA9IG1lc3NhZ2UuZGF0YTtcclxuXHRcdHZhciBlbmNvZGluZyA9IG1lc3NhZ2UuZW5jb2Rpbmc7XHJcblx0XHRpZihlbmNvZGluZykge1xyXG5cdFx0XHR2YXIgeGZvcm1zID0gZW5jb2Rpbmcuc3BsaXQoJy8nKSxcclxuXHRcdFx0XHRsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCwgZW5jb2RpbmdzVG9Qcm9jZXNzID0geGZvcm1zLmxlbmd0aCxcclxuXHRcdFx0XHRkYXRhID0gbWVzc2FnZS5kYXRhO1xyXG5cclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHR3aGlsZSgobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSBlbmNvZGluZ3NUb1Byb2Nlc3MpID4gMCkge1xyXG5cdFx0XHRcdFx0dmFyIG1hdGNoID0geGZvcm1zWy0tZW5jb2RpbmdzVG9Qcm9jZXNzXS5tYXRjaCgvKFtcXC1cXHddKykoXFwrKFtcXHdcXC1dKykpPy8pO1xyXG5cdFx0XHRcdFx0aWYoIW1hdGNoKSBicmVhaztcclxuXHRcdFx0XHRcdHZhciB4Zm9ybSA9IG1hdGNoWzFdO1xyXG5cdFx0XHRcdFx0c3dpdGNoKHhmb3JtKSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2Jhc2U2NCc6XHJcblx0XHRcdFx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RGVjb2RlKFN0cmluZyhkYXRhKSk7XHJcblx0XHRcdFx0XHRcdFx0aWYobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPT0geGZvcm1zLmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBheWxvYWQgPSBkYXRhO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0Y2FzZSAndXRmLTgnOlxyXG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnV0ZjhEZWNvZGUoZGF0YSk7XHJcblx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2pzb24nOlxyXG5cdFx0XHRcdFx0XHRcdGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xyXG5cdFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHRcdFx0XHRjYXNlICdjaXBoZXInOlxyXG5cdFx0XHRcdFx0XHRcdGlmKGNvbnRleHQuY2hhbm5lbE9wdGlvbnMgIT0gbnVsbCAmJiBjb250ZXh0LmNoYW5uZWxPcHRpb25zLmNpcGhlcikge1xyXG5cdFx0XHRcdFx0XHRcdFx0dmFyIHhmb3JtQWxnb3JpdGhtID0gbWF0Y2hbM10sIGNpcGhlciA9IGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcjtcclxuXHRcdFx0XHRcdFx0XHRcdC8qIGRvbid0IGF0dGVtcHQgdG8gZGVjcnlwdCB1bmxlc3MgdGhlIGNpcGhlciBwYXJhbXMgYXJlIGNvbXBhdGlibGUgKi9cclxuXHRcdFx0XHRcdFx0XHRcdGlmKHhmb3JtQWxnb3JpdGhtICE9IGNpcGhlci5hbGdvcml0aG0pIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZGVjcnlwdCBtZXNzYWdlIHdpdGggZ2l2ZW4gY2lwaGVyOyBpbmNvbXBhdGlibGUgY2lwaGVyIHBhcmFtcycpO1xyXG5cdFx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YSA9IGNpcGhlci5kZWNyeXB0KGRhdGEpO1xyXG5cdFx0XHRcdFx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsJyk7XHJcblx0XHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHRjYXNlICd2Y2RpZmYnOlxyXG5cdFx0XHRcdFx0XHRcdGlmKCFjb250ZXh0LnBsdWdpbnMgfHwgIWNvbnRleHQucGx1Z2lucy52Y2RpZmYpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ01pc3NpbmcgVmNkaWZmIGRlY29kZXIgKGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5LWZvcmtzL3ZjZGlmZi1kZWNvZGVyKScsIDQwMDE5LCA0MDApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRpZih0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ0RlbHRhIGRlY29kaW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyIChuZWVkIEFycmF5QnVmZmVyICYgVWludDhBcnJheSknLCA0MDAyMCwgNDAwKTtcclxuXHRcdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdFx0XHRcdHZhciBkZWx0YUJhc2UgPSBjb250ZXh0LmJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkO1xyXG5cdFx0XHRcdFx0XHRcdFx0aWYodHlwZW9mIGRlbHRhQmFzZSA9PT0gJ3N0cmluZycpIHtcclxuXHRcdFx0XHRcdFx0XHRcdFx0ZGVsdGFCYXNlID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51dGY4RW5jb2RlKGRlbHRhQmFzZSk7XHJcblx0XHRcdFx0XHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdFx0XHRcdFx0LyogdmNkaWZmIGV4cGVjdHMgVWludDhBcnJheXMsIGNhbid0IGNvcHkgd2l0aCBBcnJheUJ1ZmZlcnMuIChhbHNvLCBpZiB3ZVxyXG5cdFx0XHRcdFx0XHRcdFx0ICogZG9uJ3QgaGF2ZSBhIFRleHREZWNvZGVyLCBkZWx0YUJhc2UgbWlnaHQgYmUgYSBXb3JkQXJyYXkgaGVyZSwgc28gbmVlZFxyXG5cdFx0XHRcdFx0XHRcdFx0ICogdG8gcHJvY2VzcyBpdCBpbnRvIGEgYnVmZmVyIGFueXdheSkgKi9cclxuXHRcdFx0XHRcdFx0XHRcdGRlbHRhQmFzZSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGVsdGFCYXNlKTtcclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvQnVmZmVyKGRhdGEpO1xyXG5cclxuXHRcdFx0XHRcdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnR5cGVkQXJyYXlUb0J1ZmZlcihjb250ZXh0LnBsdWdpbnMudmNkaWZmLmRlY29kZShkYXRhLCBkZWx0YUJhc2UpKTtcclxuXHRcdFx0XHRcdFx0XHRcdGxhc3RQYXlsb2FkID0gZGF0YTtcclxuXHRcdFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRcdFx0XHRcdHRocm93IG5ldyBfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1ZjZGlmZiBkZWx0YSBkZWNvZGUgZmFpbGVkIHdpdGggJyArIGUsIDQwMDE4LCA0MDApO1xyXG5cdFx0XHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGVuY29kaW5nXCIpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHR0aHJvdyBuZXcgX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdFcnJvciBwcm9jZXNzaW5nIHRoZSAnICsgeGZvcm0gKyAnIGVuY29kaW5nLCBkZWNvZGVyIHJldHVybmVkIOKAmCcgKyBlLm1lc3NhZ2UgKyAn4oCZJywgZS5jb2RlIHx8IDQwMDEzLCA0MDApO1xyXG5cdFx0XHR9IGZpbmFsbHkge1xyXG5cdFx0XHRcdG1lc3NhZ2UuZW5jb2RpbmcgPSAobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPD0gMCkgPyBudWxsIDogeGZvcm1zLnNsaWNlKDAsIGxhc3RQcm9jZXNzZWRFbmNvZGluZ0luZGV4KS5qb2luKCcvJyk7XHJcblx0XHRcdFx0bWVzc2FnZS5kYXRhID0gZGF0YTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0Y29udGV4dC5iYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZCA9IGxhc3RQYXlsb2FkO1xyXG5cdH07XHJcblxyXG5cdE1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uKGJvZHksIG9wdGlvbnMsIGZvcm1hdCkge1xyXG5cdFx0aWYoZm9ybWF0KSB7XHJcblx0XHRcdGJvZHkgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYm9keS5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgbXNnID0gYm9keVtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldKTtcclxuXHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ01lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSgpJywgZS50b1N0cmluZygpKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGJvZHk7XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgTWVzc2FnZSgpLCB2YWx1ZXMpO1xyXG5cdH07XHJcblxyXG5cdE1lc3NhZ2UuZnJvbVZhbHVlc0FycmF5ID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcblx0XHR2YXIgY291bnQgPSB2YWx1ZXMubGVuZ3RoLCByZXN1bHQgPSBuZXcgQXJyYXkoY291bnQpO1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHJlc3VsdFtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpIHtcclxuXHRcdGlmKG9wdGlvbnMgJiYgb3B0aW9ucy5jaXBoZXIgJiYgIW9wdGlvbnMuY2lwaGVyLmNoYW5uZWxDaXBoZXIpIHtcclxuXHRcdFx0aWYoIXBsYXRmb3JtX2NyeXB0b19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZCcpO1xyXG5cdFx0XHR2YXIgY2lwaGVyID0gcGxhdGZvcm1fY3J5cHRvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0Q2lwaGVyKG9wdGlvbnMuY2lwaGVyKTtcclxuXHRcdFx0b3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xyXG5cdFx0XHRvcHRpb25zLmNoYW5uZWxDaXBoZXIgPSBjaXBoZXIuY2lwaGVyO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0TWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uKGVuY29kZWQsIG9wdGlvbnMpIHtcclxuXHRcdHZhciBtc2cgPSBNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCk7XHJcblx0XHRub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpO1xyXG5cdFx0LyogaWYgZGVjb2RpbmcgZmFpbHMgYXQgYW55IHBvaW50LCBjYXRjaCBhbmQgcmV0dXJuIHRoZSBtZXNzYWdlIGRlY29kZWQgdG9cclxuXHRcdCAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0TWVzc2FnZS5kZWNvZGUobXNnLCBvcHRpb25zKTtcclxuXHRcdH0gY2F0Y2goZSkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtc2c7XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24oZW5jb2RlZEFycmF5LCBvcHRpb25zKSB7XHJcblx0XHRub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpO1xyXG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyTWFwKGVuY29kZWRBcnJheSwgZnVuY3Rpb24oZW5jb2RlZCkge1xyXG5cdFx0XHRyZXR1cm4gTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIGdldE1lc3NhZ2VTaXplKG1zZykge1xyXG5cdFx0dmFyIHNpemUgPSAwO1xyXG5cdFx0aWYobXNnLm5hbWUpIHtcclxuXHRcdFx0c2l6ZSArPSBtc2cubmFtZS5sZW5ndGg7XHJcblx0XHR9XHJcblx0XHRpZihtc2cuY2xpZW50SWQpIHtcclxuXHRcdFx0c2l6ZSArPSBtc2cuY2xpZW50SWQubGVuZ3RoO1xyXG5cdFx0fVxyXG5cdFx0aWYobXNnLmV4dHJhcykge1xyXG5cdFx0XHRzaXplICs9IEpTT04uc3RyaW5naWZ5KG1zZy5leHRyYXMpLmxlbmd0aDtcclxuXHRcdH1cclxuXHRcdGlmKG1zZy5kYXRhKSB7XHJcblx0XHRcdHNpemUgKz0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kYXRhU2l6ZUJ5dGVzKG1zZy5kYXRhKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzaXplO1xyXG5cdH07XHJcblxyXG5cdC8qIFRoaXMgc2hvdWxkIGJlIGNhbGxlZCBvbiBlbmNvZGUoKWQgKGFuZCBlbmNyeXB0KClkKSBNZXNzYWdlcyAoYXMgaXRcclxuXHQgKiBhc3N1bWVzIHRoZSBkYXRhIGlzIGEgc3RyaW5nIG9yIGJ1ZmZlcikgKi9cclxuXHRNZXNzYWdlLmdldE1lc3NhZ2VzU2l6ZSA9IGZ1bmN0aW9uKG1lc3NhZ2VzKSB7XHJcblx0XHR2YXIgbXNnLCB0b3RhbCA9IDA7XHJcblx0XHRmb3IodmFyIGk9MDsgaTxtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRtc2cgPSBtZXNzYWdlc1tpXTtcclxuXHRcdFx0dG90YWwgKz0gKG1zZy5zaXplIHx8IChtc2cuc2l6ZSA9IGdldE1lc3NhZ2VTaXplKG1zZykpKVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRvdGFsO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBNZXNzYWdlO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChNZXNzYWdlKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmICh0cnVlKSB7XHJcblx0XHQvLyBDb21tb25KU1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XHJcblx0fVxyXG5cdGVsc2Uge31cclxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcclxuXHJcblx0KGZ1bmN0aW9uICgpIHtcclxuXHQgICAgLy8gQ2hlY2sgaWYgdHlwZWQgYXJyYXlzIGFyZSBzdXBwb3J0ZWRcclxuXHQgICAgaWYgKHR5cGVvZiBBcnJheUJ1ZmZlciAhPSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICByZXR1cm47XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuXHJcblx0ICAgIC8vIFJlZmVyZW5jZSBvcmlnaW5hbCBpbml0XHJcblx0ICAgIHZhciBzdXBlckluaXQgPSBXb3JkQXJyYXkuaW5pdDtcclxuXHJcblx0ICAgIC8vIEF1Z21lbnQgV29yZEFycmF5LmluaXQgdG8gaGFuZGxlIHR5cGVkIGFycmF5c1xyXG5cdCAgICB2YXIgc3ViSW5pdCA9IFdvcmRBcnJheS5pbml0ID0gZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcclxuXHQgICAgICAgIC8vIENvbnZlcnQgYnVmZmVycyB0byB1aW50OFxyXG5cdCAgICAgICAgaWYgKHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XHJcblx0ICAgICAgICBpZiAoXHJcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDhBcnJheSB8fFxyXG5cdCAgICAgICAgICAgICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB8fFxyXG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBJbnQxNkFycmF5IHx8XHJcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQxNkFycmF5IHx8XHJcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcclxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDMyQXJyYXkgfHxcclxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgRmxvYXQzMkFycmF5IHx8XHJcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxyXG5cdCAgICAgICAgKSB7XHJcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSA9IG5ldyBVaW50OEFycmF5KHR5cGVkQXJyYXkuYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkuYnl0ZUxlbmd0aCk7XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgLy8gSGFuZGxlIFVpbnQ4QXJyYXlcclxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcblx0ICAgICAgICAgICAgdmFyIHR5cGVkQXJyYXlCeXRlTGVuZ3RoID0gdHlwZWRBcnJheS5ieXRlTGVuZ3RoO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBFeHRyYWN0IGJ5dGVzXHJcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gW107XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZEFycmF5Qnl0ZUxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IHR5cGVkQXJyYXlbaV0gPDwgKDI0IC0gKGkgJSA0KSAqIDgpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGlzIHdvcmQgYXJyYXlcclxuXHQgICAgICAgICAgICBzdXBlckluaXQuY2FsbCh0aGlzLCB3b3JkcywgdHlwZWRBcnJheUJ5dGVMZW5ndGgpO1xyXG5cdCAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAvLyBFbHNlIGNhbGwgbm9ybWFsIGluaXRcclxuXHQgICAgICAgICAgICBzdXBlckluaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xyXG5cdH0oKSk7XHJcblxyXG5cclxuXHRyZXR1cm4gQ3J5cHRvSlMubGliLldvcmRBcnJheTtcclxuXHJcbn0pKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxMSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg5KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgUHJlc2VuY2VNZXNzYWdlID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5tc2dwYWNrO1xyXG5cclxuXHRmdW5jdGlvbiB0b0FjdGlvblZhbHVlKGFjdGlvblN0cmluZykge1xyXG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihQcmVzZW5jZU1lc3NhZ2UuQWN0aW9ucywgYWN0aW9uU3RyaW5nKVxyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUHJlc2VuY2VNZXNzYWdlKCkge1xyXG5cdFx0dGhpcy5hY3Rpb24gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmlkID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy50aW1lc3RhbXAgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmRhdGEgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmVuY29kaW5nID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5zaXplID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0UHJlc2VuY2VNZXNzYWdlLkFjdGlvbnMgPSBbXHJcblx0XHQnYWJzZW50JyxcclxuXHRcdCdwcmVzZW50JyxcclxuXHRcdCdlbnRlcicsXHJcblx0XHQnbGVhdmUnLFxyXG5cdFx0J3VwZGF0ZSdcclxuXHRdO1xyXG5cclxuXHQvKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBwcmVzZW5jZU1lc3NhZ2UgaXMgc3ludGhlc2l6ZWQsIGkuZS4gd2FzIG5vdCBhY3R1YWxseVxyXG5cdCAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXHJcblx0ICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXHJcblx0ICogY29tcGFyZWQgZm9yIG5ld25lc3MgYnkgaWQgbGV4aWNvZ3JhcGhpY2FsbHkgLSBSVFAyYjFcclxuXHQgKi9cclxuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLmlzU3ludGhlc2l6ZWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLmlkLnN1YnN0cmluZyh0aGlzLmNvbm5lY3Rpb25JZC5sZW5ndGgsIDApICE9PSB0aGlzLmNvbm5lY3Rpb25JZDtcclxuXHR9O1xyXG5cclxuXHQvKiBSVFAyYjIgKi9cclxuXHRQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLnBhcnNlSWQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBwYXJ0cyA9IHRoaXMuaWQuc3BsaXQoJzonKTtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNvbm5lY3Rpb25JZDogcGFydHNbMF0sXHJcblx0XHRcdG1zZ1NlcmlhbDogcGFyc2VJbnQocGFydHNbMV0sIDEwKSxcclxuXHRcdFx0aW5kZXg6IHBhcnNlSW50KHBhcnRzWzJdLCAxMClcclxuXHRcdH07XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcclxuXHQgKiBAcmV0dXJuIHsqfVxyXG5cdCAqL1xyXG5cdFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0ge1xyXG5cdFx0XHRjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcclxuXHRcdFx0LyogQ29udmVydCBwcmVzZW5jZSBhY3Rpb24gYmFjayB0byBhbiBpbnQgZm9yIHNlbmRpbmcgdG8gQWJseSAqL1xyXG5cdFx0XHRhY3Rpb246IHRvQWN0aW9uVmFsdWUodGhpcy5hY3Rpb24pLFxyXG5cdFx0XHRlbmNvZGluZzogdGhpcy5lbmNvZGluZ1xyXG5cdFx0fTtcclxuXHJcblx0XHQvKiBlbmNvZGUgZGF0YSB0byBiYXNlNjQgaWYgcHJlc2VudCBhbmQgd2UncmUgcmV0dXJuaW5nIHJlYWwgSlNPTjtcclxuXHRcdCAqIGFsdGhvdWdoIG1zZ3BhY2sgY2FsbHMgdG9KU09OKCksIHdlIGtub3cgaXQgaXMgYSBzdHJpbmdpZnkoKVxyXG5cdFx0ICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cclxuXHRcdHZhciBkYXRhID0gdGhpcy5kYXRhO1xyXG5cdFx0aWYoZGF0YSAmJiBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKGRhdGEpKSB7XHJcblx0XHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XHJcblx0XHRcdFx0Lyogc3RyaW5naWZ5IGNhbGwgKi9cclxuXHRcdFx0XHR2YXIgZW5jb2RpbmcgPSB0aGlzLmVuY29kaW5nO1xyXG5cdFx0XHRcdHJlc3VsdC5lbmNvZGluZyA9IGVuY29kaW5nID8gKGVuY29kaW5nICsgJy9iYXNlNjQnKSA6ICdiYXNlNjQnO1xyXG5cdFx0XHRcdGRhdGEgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmJhc2U2NEVuY29kZShkYXRhKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHQvKiBDYWxsZWQgYnkgbXNncGFjay4gdG9CdWZmZXIgcmV0dXJucyBhIGRhdGF0eXBlIHVuZGVyc3RhbmRhYmxlIGJ5XHJcblx0XHRcdFx0ICogdGhhdCBwbGF0Zm9ybSdzIG1zZ3BhY2sgaW1wbGVtZW50YXRpb24gKEJ1ZmZlciBpbiBub2RlLCBVaW50OEFycmF5XHJcblx0XHRcdFx0ICogaW4gYnJvd3NlcnMpICovXHJcblx0XHRcdFx0ZGF0YSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9CdWZmZXIoZGF0YSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJlc3VsdC5kYXRhID0gZGF0YTtcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0UHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9ICdbUHJlc2VuY2VNZXNzYWdlJztcclxuXHRcdHJlc3VsdCArPSAnOyBhY3Rpb249JyArIHRoaXMuYWN0aW9uO1xyXG5cdFx0aWYodGhpcy5pZClcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xyXG5cdFx0aWYodGhpcy50aW1lc3RhbXApXHJcblx0XHRcdHJlc3VsdCArPSAnOyB0aW1lc3RhbXA9JyArIHRoaXMudGltZXN0YW1wO1xyXG5cdFx0aWYodGhpcy5jbGllbnRJZClcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xyXG5cdFx0aWYodGhpcy5jb25uZWN0aW9uSWQpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xyXG5cdFx0aWYodGhpcy5lbmNvZGluZylcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGVuY29kaW5nPScgKyB0aGlzLmVuY29kaW5nO1xyXG5cdFx0aWYodGhpcy5kYXRhKSB7XHJcblx0XHRcdGlmICh0eXBlb2YodGhpcy5kYXRhKSA9PSAnc3RyaW5nJylcclxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YT0nICsgdGhpcy5kYXRhO1xyXG5cdFx0XHRlbHNlIGlmIChwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQnVmZmVyKHRoaXMuZGF0YSkpXHJcblx0XHRcdFx0cmVzdWx0ICs9ICc7IGRhdGEgKGJ1ZmZlcik9JyArIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0XHRyZXN1bHQgKz0gJzsgZGF0YSAoanNvbik9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZGF0YSk7XHJcblx0XHR9XHJcblx0XHRyZXN1bHQgKz0gJ10nO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cdFByZXNlbmNlTWVzc2FnZS5lbmNvZGUgPSBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVuY29kZTtcclxuXHRQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlID0gX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5kZWNvZGU7XHJcblxyXG5cdFByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSwgb3B0aW9ucywgZm9ybWF0KSB7XHJcblx0XHRpZihmb3JtYXQpIHtcclxuXHRcdFx0Ym9keSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhciBtc2cgPSBib2R5W2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoYm9keVtpXSwgdHJ1ZSk7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0UHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMpO1xyXG5cdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYm9keTtcclxuXHR9O1xyXG5cclxuXHQvKiBDcmVhdGVzIGEgUHJlc2VuY2VNZXNzYWdlIGZyb20gc3BlY2lmaWVkIHZhbHVlcywgd2l0aCBhIHN0cmluZyBwcmVzZW5jZSBhY3Rpb24gKi9cclxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uKHZhbHVlcywgc3RyaW5naWZ5QWN0aW9uKSB7XHJcblx0XHRpZihzdHJpbmdpZnlBY3Rpb24pIHtcclxuXHRcdFx0dmFsdWVzLmFjdGlvbiA9IFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zW3ZhbHVlcy5hY3Rpb25dXHJcblx0XHR9XHJcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbihuZXcgUHJlc2VuY2VNZXNzYWdlKCksIHZhbHVlcyk7XHJcblx0fTtcclxuXHJcblx0UHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xyXG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBQcmVzZW5jZU1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cclxuXHRQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQgPSBmdW5jdGlvbihlbmNvZGVkLCBvcHRpb25zKSB7XHJcblx0XHR2YXIgbXNnID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCwgdHJ1ZSk7XHJcblx0XHQvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xyXG5cdFx0ICogdGhlIGZ1bGxlc3QgZXh0ZW50IHBvc3NpYmxlICovXHJcblx0XHR0cnkge1xyXG5cdFx0XHRQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XHJcblx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1ByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBtc2c7XHJcblx0fTtcclxuXHJcblx0UHJlc2VuY2VNZXNzYWdlLmZyb21FbmNvZGVkQXJyYXkgPSBmdW5jdGlvbihlbmNvZGVkQXJyYXksIG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyck1hcChlbmNvZGVkQXJyYXksIGZ1bmN0aW9uKGVuY29kZWQpIHtcclxuXHRcdFx0cmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdFByZXNlbmNlTWVzc2FnZS5nZXRNZXNzYWdlc1NpemUgPSBfbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldE1lc3NhZ2VzU2l6ZTtcclxuXHJcblx0cmV0dXJuIFByZXNlbmNlTWVzc2FnZTtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoUHJlc2VuY2VNZXNzYWdlKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgezsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoKTtcclxuXHR9XHJcblx0ZWxzZSB7fVxyXG59KHRoaXMsIGZ1bmN0aW9uICgpIHtcclxuXHJcblx0LypnbG9iYWxzIHdpbmRvdywgZ2xvYmFsLCByZXF1aXJlKi9cclxuXHJcblx0LyoqXHJcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxyXG5cdCAqL1xyXG5cdHZhciBDcnlwdG9KUyA9IENyeXB0b0pTIHx8IChmdW5jdGlvbiAoTWF0aCwgdW5kZWZpbmVkKSB7XHJcblxyXG5cdCAgICB2YXIgY3J5cHRvO1xyXG5cclxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3NlcilcclxuXHQgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jcnlwdG8pIHtcclxuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5jcnlwdG87XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIE5hdGl2ZSAoZXhwZXJpbWVudGFsIElFIDExKSBjcnlwdG8gZnJvbSB3aW5kb3cgKEJyb3dzZXIpXHJcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tc0NyeXB0bykge1xyXG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93Lm1zQ3J5cHRvO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICAvLyBOYXRpdmUgY3J5cHRvIGZyb20gZ2xvYmFsIChOb2RlSlMpXHJcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnICYmIGdsb2JhbC5jcnlwdG8pIHtcclxuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbC5jcnlwdG87XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW1wb3J0IHZpYSByZXF1aXJlIChOb2RlSlMpXHJcblx0ICAgIGlmICghY3J5cHRvICYmIFwiZnVuY3Rpb25cIiA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ1KTtcclxuXHQgICAgICAgIH0gY2F0Y2ggKGVycikge31cclxuXHQgICAgfVxyXG5cclxuXHQgICAgLypcclxuXHQgICAgICogQ3J5cHRvZ3JhcGhpY2FsbHkgc2VjdXJlIHBzZXVkb3JhbmRvbSBudW1iZXIgZ2VuZXJhdG9yXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEFzIE1hdGgucmFuZG9tKCkgaXMgY3J5cHRvZ3JhcGhpY2FsbHkgbm90IHNhZmUgdG8gdXNlXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgY3J5cHRvU2VjdXJlUmFuZG9tSW50ID0gZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgaWYgKGNyeXB0bykge1xyXG5cdCAgICAgICAgICAgIC8vIFVzZSBnZXRSYW5kb21WYWx1ZXMgbWV0aG9kIChCcm93c2VyKVxyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdCAgICAgICAgICAgICAgICB0cnkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KDEpKVswXTtcclxuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gVXNlIHJhbmRvbUJ5dGVzIG1ldGhvZCAoTm9kZUpTKVxyXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLnJhbmRvbUJ5dGVzID09PSAnZnVuY3Rpb24nKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRyeSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnJlYWRJbnQzMkxFKCk7XHJcblx0ICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge31cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOYXRpdmUgY3J5cHRvIG1vZHVsZSBjb3VsZCBub3QgYmUgdXNlZCB0byBnZXQgc2VjdXJlIHJhbmRvbSBudW1iZXIuJyk7XHJcblx0ICAgIH07XHJcblxyXG5cdCAgICAvKlxyXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsbCBvZiBPYmplY3QuY3JlYXRlXHJcblxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIGZ1bmN0aW9uIEYoKSB7fVxyXG5cclxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHN1YnR5cGU7XHJcblxyXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xyXG5cclxuXHQgICAgICAgICAgICBzdWJ0eXBlID0gbmV3IEYoKTtcclxuXHJcblx0ICAgICAgICAgICAgRi5wcm90b3R5cGUgPSBudWxsO1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0oKSlcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBDcnlwdG9KUyBuYW1lc3BhY2UuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgQyA9IHt9O1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIExpYnJhcnkgbmFtZXNwYWNlLlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cclxuXHQgICAgICovXHJcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZSA9IChmdW5jdGlvbiAoKSB7XHJcblxyXG5cclxuXHQgICAgICAgIHJldHVybiB7XHJcblx0ICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICogQ3JlYXRlcyBhIG5ldyBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoaXMgb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cclxuXHQgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogICAgIHZhciBNeVR5cGUgPSBDcnlwdG9KUy5saWIuQmFzZS5leHRlbmQoe1xyXG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiAgICAgICAgIG1ldGhvZDogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcclxuXHQgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gU3Bhd25cclxuXHQgICAgICAgICAgICAgICAgdmFyIHN1YnR5cGUgPSBjcmVhdGUodGhpcyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBBdWdtZW50XHJcblx0ICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcclxuXHQgICAgICAgICAgICAgICAgaWYgKCFzdWJ0eXBlLmhhc093blByb3BlcnR5KCdpbml0JykgfHwgdGhpcy5pbml0ID09PSBzdWJ0eXBlLmluaXQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUuaW5pdCA9IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBJbml0aWFsaXplcidzIHByb3RvdHlwZSBpcyB0aGUgc3VidHlwZSBvYmplY3RcclxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0LnByb3RvdHlwZSA9IHN1YnR5cGU7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBSZWZlcmVuY2Ugc3VwZXJ0eXBlXHJcblx0ICAgICAgICAgICAgICAgIHN1YnR5cGUuJHN1cGVyID0gdGhpcztcclxuXHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBzdWJ0eXBlO1xyXG5cdCAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAqIEV4dGVuZHMgdGhpcyBvYmplY3QgYW5kIHJ1bnMgdGhlIGluaXQgbWV0aG9kLlxyXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBuZXcgb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgaW5zdGFuY2UgPSBNeVR5cGUuY3JlYXRlKCk7XHJcblx0ICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgY3JlYXRlOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSA9IHRoaXMuZXh0ZW5kKCk7XHJcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcblx0ICAgICAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAgICAgLyoqXHJcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cclxuXHQgICAgICAgICAgICAgKiBPdmVycmlkZSB0aGlzIG1ldGhvZCB0byBhZGQgc29tZSBsb2dpYyB3aGVuIHlvdXIgb2JqZWN0cyBhcmUgY3JlYXRlZC5cclxuXHQgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XHJcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgICogICAgICAgICAgICAgLy8gLi4uXHJcblx0ICAgICAgICAgICAgICogICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICogICAgIH0pO1xyXG5cdCAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIHByb3BlcnRpZXMgdG8gbWl4IGluLlxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xyXG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZSdcclxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XHJcblx0ICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgbWl4SW46IGZ1bmN0aW9uIChwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGZvciAodmFyIHByb3BlcnR5TmFtZSBpbiBwcm9wZXJ0aWVzKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gcHJvcGVydGllc1twcm9wZXJ0eU5hbWVdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBJRSB3b24ndCBjb3B5IHRvU3RyaW5nIHVzaW5nIHRoZSBsb29wIGFib3ZlXHJcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0aGlzLnRvU3RyaW5nID0gcHJvcGVydGllcy50b1N0cmluZztcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgY2xvbmUuXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XHJcblx0ICAgICAgICAgICAgICovXHJcblx0ICAgICAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH07XHJcblx0ICAgIH0oKSk7XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcHJvcGVydHkge0FycmF5fSB3b3JkcyBUaGUgYXJyYXkgb2YgMzItYml0IHdvcmRzLlxyXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5ID0gQmFzZS5leHRlbmQoe1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgd29yZCBhcnJheS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzaWdCeXRlcyAoT3B0aW9uYWwpIFRoZSBudW1iZXIgb2Ygc2lnbmlmaWNhbnQgYnl0ZXMgaW4gdGhlIHdvcmRzLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZSgpO1xyXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xyXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10sIDYpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XHJcblx0ICAgICAgICAgICAgd29yZHMgPSB0aGlzLndvcmRzID0gd29yZHMgfHwgW107XHJcblxyXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyA9IHNpZ0J5dGVzO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGlzIHdvcmQgYXJyYXkgdG8gYSBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtFbmNvZGVyfSBlbmNvZGVyIChPcHRpb25hbCkgVGhlIGVuY29kaW5nIHN0cmF0ZWd5IHRvIHVzZS4gRGVmYXVsdDogQ3J5cHRvSlMuZW5jLkhleFxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheSArICcnO1xyXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkudG9TdHJpbmcoKTtcclxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgdG9TdHJpbmc6IGZ1bmN0aW9uIChlbmNvZGVyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbmNhdGVuYXRlcyBhIHdvcmQgYXJyYXkgdG8gdGhpcyB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhpcyB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjb25jYXQ6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICB2YXIgdGhpc1dvcmRzID0gdGhpcy53b3JkcztcclxuXHQgICAgICAgICAgICB2YXIgdGhhdFdvcmRzID0gd29yZEFycmF5LndvcmRzO1xyXG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xyXG5cdCAgICAgICAgICAgIHZhciB0aGF0U2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXHJcblx0ICAgICAgICAgICAgdGhpcy5jbGFtcCgpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb25jYXRcclxuXHQgICAgICAgICAgICBpZiAodGhpc1NpZ0J5dGVzICUgNCkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSBieXRlIGF0IGEgdGltZVxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdGhhdEJ5dGUgPSAodGhhdFdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdIHw9IHRoYXRCeXRlIDw8ICgyNCAtICgodGhpc1NpZ0J5dGVzICsgaSkgJSA0KSAqIDgpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gQ29weSBvbmUgd29yZCBhdCBhIHRpbWVcclxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gPSB0aGF0V29yZHNbaSA+Pj4gMl07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgdGhpcy5zaWdCeXRlcyArPSB0aGF0U2lnQnl0ZXM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIFJlbW92ZXMgaW5zaWduaWZpY2FudCBiaXRzLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjbGFtcDogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHRoaXMud29yZHM7XHJcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gdGhpcy5zaWdCeXRlcztcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ2xhbXBcclxuXHQgICAgICAgICAgICB3b3Jkc1tzaWdCeXRlcyA+Pj4gMl0gJj0gMHhmZmZmZmZmZiA8PCAoMzIgLSAoc2lnQnl0ZXMgJSA0KSAqIDgpO1xyXG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgd29yZCBhcnJheS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSB3b3JkQXJyYXkuY2xvbmUoKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICB2YXIgY2xvbmUgPSBCYXNlLmNsb25lLmNhbGwodGhpcyk7XHJcblx0ICAgICAgICAgICAgY2xvbmUud29yZHMgPSB0aGlzLndvcmRzLnNsaWNlKDApO1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHdvcmQgYXJyYXkgZmlsbGVkIHdpdGggcmFuZG9tIGJ5dGVzLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuQnl0ZXMgVGhlIG51bWJlciBvZiByYW5kb20gYnl0ZXMgdG8gZ2VuZXJhdGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHJhbmRvbTogZnVuY3Rpb24gKG5CeXRlcykge1xyXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xyXG5cclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5CeXRlczsgaSArPSA0KSB7XHJcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3J5cHRvU2VjdXJlUmFuZG9tSW50KCkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSk7XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogRW5jb2RlciBuYW1lc3BhY2UuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYyA9IHt9O1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEhleCBlbmNvZGluZyBzdHJhdGVneS5cclxuXHQgICAgICovXHJcblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIGhleCBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xyXG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ29udmVydFxyXG5cdCAgICAgICAgICAgIHZhciBoZXhDaGFycyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYml0ZSA9ICh3b3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XHJcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgPj4+IDQpLnRvU3RyaW5nKDE2KSk7XHJcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgaGV4IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkhleC5wYXJzZShoZXhTdHJpbmcpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGhleFN0cikge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcclxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhleFN0ckxlbmd0aDsgaSArPSAyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDNdIHw9IHBhcnNlSW50KGhleFN0ci5zdWJzdHIoaSwgMiksIDE2KSA8PCAoMjQgLSAoaSAlIDgpICogNCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBoZXhTdHJMZW5ndGggLyAyKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBMYXRpbjEgZW5jb2Rpbmcgc3RyYXRlZ3kuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBMYXRpbjEgc3RyaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcclxuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcclxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xQ2hhcnMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xyXG5cdCAgICAgICAgICAgICAgICBsYXRpbjFDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYml0ZSkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGxhdGluMUNoYXJzLmpvaW4oJycpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhdGluMVN0ciBUaGUgTGF0aW4xIHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkxhdGluMS5wYXJzZShsYXRpbjFTdHJpbmcpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcblx0ICAgICAgICAgICAgdmFyIGxhdGluMVN0ckxlbmd0aCA9IGxhdGluMVN0ci5sZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcclxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDJdIHw9IChsYXRpbjFTdHIuY2hhckNvZGVBdChpKSAmIDB4ZmYpIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGxhdGluMVN0ckxlbmd0aCk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0ZjggPSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi04IHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi04IHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjhTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmOC5zdHJpbmdpZnkod29yZEFycmF5KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcblx0ICAgICAgICAgICAgdHJ5IHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XHJcblx0ICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01hbGZvcm1lZCBVVEYtOCBkYXRhJyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTggc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmOC5wYXJzZSh1dGY4U3RyaW5nKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGY4U3RyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIExhdGluMS5wYXJzZSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQodXRmOFN0cikpKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBYnN0cmFjdCBidWZmZXJlZCBibG9jayBhbGdvcml0aG0gdGVtcGxhdGUuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfbWluQnVmZmVyU2l6ZSBUaGUgbnVtYmVyIG9mIGJsb2NrcyB0aGF0IHNob3VsZCBiZSBrZXB0IHVucHJvY2Vzc2VkIGluIHRoZSBidWZmZXIuIERlZmF1bHQ6IDBcclxuXHQgICAgICovXHJcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IEJhc2UuZXh0ZW5kKHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5yZXNldCgpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXHJcblx0ICAgICAgICAgICAgdGhpcy5fZGF0YSA9IG5ldyBXb3JkQXJyYXkuaW5pdCgpO1xyXG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEFkZHMgbmV3IGRhdGEgdG8gdGhpcyBibG9jayBhbGdvcml0aG0ncyBidWZmZXIuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCgnZGF0YScpO1xyXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uX2FwcGVuZCh3b3JkQXJyYXkpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBfYXBwZW5kOiBmdW5jdGlvbiAoZGF0YSkge1xyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcclxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAgZGF0YSA9IFV0ZjgucGFyc2UoZGF0YSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcclxuXHQgICAgICAgICAgICB0aGlzLl9kYXRhLmNvbmNhdChkYXRhKTtcclxuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogUHJvY2Vzc2VzIGF2YWlsYWJsZSBkYXRhIGJsb2Nrcy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IGRvRmx1c2ggV2hldGhlciBhbGwgYmxvY2tzIGFuZCBwYXJ0aWFsIGJsb2NrcyBzaG91bGQgYmUgcHJvY2Vzc2VkLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHByb2Nlc3NlZCBkYXRhLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcygpO1xyXG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBfcHJvY2VzczogZnVuY3Rpb24gKGRvRmx1c2gpIHtcclxuXHQgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcclxuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcclxuXHQgICAgICAgICAgICB2YXIgZGF0YVNpZ0J5dGVzID0gZGF0YS5zaWdCeXRlcztcclxuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XHJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XHJcblx0ICAgICAgICAgICAgdmFyIG5CbG9ja3NSZWFkeSA9IGRhdGFTaWdCeXRlcyAvIGJsb2NrU2l6ZUJ5dGVzO1xyXG5cdCAgICAgICAgICAgIGlmIChkb0ZsdXNoKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3NcclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5jZWlsKG5CbG9ja3NSZWFkeSk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXHJcblx0ICAgICAgICAgICAgICAgIC8vIGxlc3MgdGhlIG51bWJlciBvZiBibG9ja3MgdGhhdCBtdXN0IHJlbWFpbiBpbiB0aGUgYnVmZmVyXHJcblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGgubWF4KChuQmxvY2tzUmVhZHkgfCAwKSAtIHRoaXMuX21pbkJ1ZmZlclNpemUsIDApO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gQ291bnQgd29yZHMgcmVhZHlcclxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvdW50IGJ5dGVzIHJlYWR5XHJcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBQcm9jZXNzIGJsb2Nrc1xyXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBvZmZzZXQgPSAwOyBvZmZzZXQgPCBuV29yZHNSZWFkeTsgb2Zmc2V0ICs9IGJsb2NrU2l6ZSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1hbGdvcml0aG0gbG9naWNcclxuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xyXG5cdCAgICAgICAgICAgICAgICBwcm9jZXNzZWRXb3JkcyA9IGRhdGFXb3Jkcy5zcGxpY2UoMCwgbldvcmRzUmVhZHkpO1xyXG5cdCAgICAgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5CeXRlc1JlYWR5O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHByb2Nlc3NlZCB3b3Jkc1xyXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIG9iamVjdC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgY2xvbmUgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLmNsb25lKCk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgICAgIGNsb25lLl9kYXRhID0gdGhpcy5fZGF0YS5jbG9uZSgpO1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9taW5CdWZmZXJTaXplOiAwXHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFic3RyYWN0IGhhc2hlciB0ZW1wbGF0ZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGhhc2hlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMTYgKDUxMiBiaXRzKVxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKCksXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgaGFzaGVyLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoZXIgPSBDcnlwdG9KUy5hbGdvLlNIQTI1Ni5jcmVhdGUoKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xyXG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xyXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnJlc2V0KCk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtaGFzaGVyIGxvZ2ljXHJcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIFRoZSBtZXNzYWdlIHRvIGFwcGVuZC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtIYXNoZXJ9IFRoaXMgaGFzaGVyLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIGhhc2hlci51cGRhdGUoJ21lc3NhZ2UnKTtcclxuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcclxuXHQgICAgICAgICAgICAvLyBBcHBlbmRcclxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQobWVzc2FnZVVwZGF0ZSk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxyXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogRmluYWxpemVzIHRoZSBoYXNoIGNvbXB1dGF0aW9uLlxyXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgKE9wdGlvbmFsKSBBIGZpbmFsIG1lc3NhZ2UgdXBkYXRlLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIGhhc2ggPSBoYXNoZXIuZmluYWxpemUoKTtcclxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xyXG5cdCAgICAgICAgICogICAgIHZhciBoYXNoID0gaGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xyXG5cdCAgICAgICAgICAgIC8vIEZpbmFsIG1lc3NhZ2UgdXBkYXRlXHJcblx0ICAgICAgICAgICAgaWYgKG1lc3NhZ2VVcGRhdGUpIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcclxuXHQgICAgICAgICAgICB2YXIgaGFzaCA9IHRoaXMuX2RvRmluYWxpemUoKTtcclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge0hhc2hlcn0gaGFzaGVyIFRoZSBoYXNoZXIgdG8gY3JlYXRlIGEgaGVscGVyIGZvci5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtGdW5jdGlvbn0gVGhlIHNob3J0Y3V0IGZ1bmN0aW9uLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAobWVzc2FnZSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBuZXcgaGFzaGVyLmluaXQoY2ZnKS5maW5hbGl6ZShtZXNzYWdlKTtcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENyZWF0ZXMgYSBzaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge0Z1bmN0aW9ufSBUaGUgc2hvcnRjdXQgZnVuY3Rpb24uXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBIbWFjU0hBMjU2ID0gQ3J5cHRvSlMubGliLkhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIF9jcmVhdGVIbWFjSGVscGVyOiBmdW5jdGlvbiAoaGFzaGVyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBrZXkpIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbyA9IHt9O1xyXG5cclxuXHQgICAgcmV0dXJuIEM7XHJcblx0fShNYXRoKSk7XHJcblxyXG5cclxuXHRyZXR1cm4gQ3J5cHRvSlM7XHJcblxyXG59KSk7XHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcblxyXG5cclxuXHJcbnZhciBDb25uZWN0aW9uRXJyb3IgPSB7XHJcblx0ZGlzY29ubmVjdGVkOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XHJcblx0XHRzdGF0dXNDb2RlOiA0MDAsXHJcblx0XHRjb2RlOiA4MDAwMyxcclxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZSdcclxuXHR9KSxcclxuXHRzdXNwZW5kZWQ6IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHtcclxuXHRcdHN0YXR1c0NvZGU6IDQwMCxcclxuXHRcdGNvZGU6IDgwMDAyLFxyXG5cdFx0bWVzc2FnZTogJ0Nvbm5lY3Rpb24gdG8gc2VydmVyIHVuYXZhaWxhYmxlJ1xyXG5cdH0pLFxyXG5cdGZhaWxlZDogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xyXG5cdFx0c3RhdHVzQ29kZTogNDAwLFxyXG5cdFx0Y29kZTogODAwMDAsXHJcblx0XHRtZXNzYWdlOiAnQ29ubmVjdGlvbiBmYWlsZWQgb3IgZGlzY29ubmVjdGVkIGJ5IHNlcnZlcidcclxuXHR9KSxcclxuXHRjbG9zaW5nOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XHJcblx0XHRzdGF0dXNDb2RlOiA0MDAsXHJcblx0XHRjb2RlOiA4MDAxNyxcclxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIGNsb3NpbmcnXHJcblx0fSksXHJcblx0Y2xvc2VkOiBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XHJcblx0XHRzdGF0dXNDb2RlOiA0MDAsXHJcblx0XHRjb2RlOiA4MDAxNyxcclxuXHRcdG1lc3NhZ2U6ICdDb25uZWN0aW9uIGNsb3NlZCdcclxuXHR9KSxcclxuXHR1bmtub3duQ29ubmVjdGlvbkVycjogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xyXG5cdFx0c3RhdHVzQ29kZTogNTAwLFxyXG5cdFx0Y29kZTogNTAwMDIsXHJcblx0XHRtZXNzYWdlOiAnSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvcidcclxuXHR9KSxcclxuXHR1bmtub3duQ2hhbm5lbEVycjogX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xyXG5cdFx0c3RhdHVzQ29kZTogNTAwLFxyXG5cdFx0Y29kZTogNTAwMDEsXHJcblx0XHRtZXNzYWdlOiAnSW50ZXJuYWwgY2hhbm5lbCBlcnJvcidcclxuXHR9KVxyXG59O1xyXG5cclxuQ29ubmVjdGlvbkVycm9yLmlzUmV0cmlhYmxlID0gZnVuY3Rpb24oZXJyKSB7XHJcblx0aWYgKCFlcnIuc3RhdHVzQ29kZSB8fCAhZXJyLmNvZGUgfHwgZXJyLnN0YXR1c0NvZGUgPj0gNTAwKSB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0dmFyIHJldHJpYWJsZSA9IGZhbHNlO1xyXG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0udmFsdWVzQXJyYXkoQ29ubmVjdGlvbkVycm9yKS5mb3JFYWNoKGZ1bmN0aW9uKGNvbm5FcnIpIHtcclxuXHRcdGlmIChjb25uRXJyLmNvZGUgJiYgY29ubkVyci5jb2RlID09IGVyci5jb2RlKSB7XHJcblx0XHRcdHJldHJpYWJsZSA9IHRydWU7XHJcblx0XHR9XHJcblx0fSk7XHJcblx0cmV0dXJuIHJldHJpYWJsZTtcclxufTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29ubmVjdGlvbkVycm9yKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMTQgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL2xvZ2dlci5qc1xyXG52YXIgbG9nZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXHJcbnZhciBwbGF0Zm9ybV9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcclxudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2h0dHAuanNcclxudmFyIGh0dHAgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9tdWx0aWNhc3Rlci5qc1xyXG52YXIgbXVsdGljYXN0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2J1ZmZlcnV0aWxzLmpzXHJcbnZhciBidWZmZXJ1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9lcnJvcmluZm8uanNcclxudmFyIGVycm9yaW5mbyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvYmFzZTY0LmpzXHJcbi8qXHJcbiBDb3B5cmlnaHQgKGMpIDIwMDggRnJlZCBQYWxtZXIgZnJlZC5wYWxtZXJfYXRfZ21haWwuY29tXHJcblxyXG4gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb25cclxuIG9idGFpbmluZyBhIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uXHJcbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXRcclxuIHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLFxyXG4gY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcclxuIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxyXG4gU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmdcclxuIGNvbmRpdGlvbnM6XHJcblxyXG4gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmVcclxuIGluY2x1ZGVkIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxyXG5cclxuIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsXHJcbiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVNcclxuIE9GIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EXHJcbiBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVFxyXG4gSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksXHJcbiBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkdcclxuIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1JcclxuIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cclxuICovXHJcbnZhciBCYXNlNjQgPSAoZnVuY3Rpb24oKSB7XHJcblx0ZnVuY3Rpb24gU3RyaW5nQnVmZmVyKClcclxuXHR7XHJcblx0XHR0aGlzLmJ1ZmZlciA9IFtdO1xyXG5cdH1cclxuXHJcblx0U3RyaW5nQnVmZmVyLnByb3RvdHlwZS5hcHBlbmQgPSBmdW5jdGlvbiBhcHBlbmQoc3RyaW5nKVxyXG5cdHtcclxuXHRcdHRoaXMuYnVmZmVyLnB1c2goc3RyaW5nKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdFN0cmluZ0J1ZmZlci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpXHJcblx0e1xyXG5cdFx0cmV0dXJuIHRoaXMuYnVmZmVyLmpvaW4oXCJcIik7XHJcblx0fTtcclxuXHJcblx0dmFyIEJhc2U2NCA9XHJcblx0e1xyXG5cdFx0Y29kZXggOiBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCIsXHJcblxyXG5cdFx0ZW5jb2RlIDogZnVuY3Rpb24gKGlucHV0KVxyXG5cdFx0e1xyXG5cdFx0XHR2YXIgb3V0cHV0ID0gbmV3IFN0cmluZ0J1ZmZlcigpO1xyXG5cdFx0XHR2YXIgY29kZXggPSBCYXNlNjQuY29kZXg7XHJcblxyXG5cdFx0XHR2YXIgZW51bWVyYXRvciA9IG5ldyBVdGY4RW5jb2RlRW51bWVyYXRvcihpbnB1dCk7XHJcblx0XHRcdHdoaWxlIChlbnVtZXJhdG9yLm1vdmVOZXh0KCkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR2YXIgY2hyMSA9IGVudW1lcmF0b3IuY3VycmVudDtcclxuXHJcblx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xyXG5cdFx0XHRcdHZhciBjaHIyID0gZW51bWVyYXRvci5jdXJyZW50O1xyXG5cclxuXHRcdFx0XHRlbnVtZXJhdG9yLm1vdmVOZXh0KCk7XHJcblx0XHRcdFx0dmFyIGNocjMgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XHJcblxyXG5cdFx0XHRcdHZhciBlbmMxID0gY2hyMSA+PiAyO1xyXG5cdFx0XHRcdHZhciBlbmMyID0gKChjaHIxICYgMykgPDwgNCkgfCAoY2hyMiA+PiA0KTtcclxuXHRcdFx0XHR2YXIgZW5jMyA9ICgoY2hyMiAmIDE1KSA8PCAyKSB8IChjaHIzID4+IDYpO1xyXG5cdFx0XHRcdHZhciBlbmM0ID0gY2hyMyAmIDYzO1xyXG5cclxuXHRcdFx0XHRpZiAoaXNOYU4oY2hyMikpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0ZW5jMyA9IGVuYzQgPSA2NDtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZSBpZiAoaXNOYU4oY2hyMykpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0ZW5jNCA9IDY0O1xyXG5cdFx0XHRcdH1cclxuXHJcblx0XHRcdFx0b3V0cHV0LmFwcGVuZChjb2RleC5jaGFyQXQoZW5jMSkgKyBjb2RleC5jaGFyQXQoZW5jMikgKyBjb2RleC5jaGFyQXQoZW5jMykgKyBjb2RleC5jaGFyQXQoZW5jNCkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRyZXR1cm4gb3V0cHV0LnRvU3RyaW5nKCk7XHJcblx0XHR9LFxyXG5cclxuXHRcdGRlY29kZSA6IGZ1bmN0aW9uIChpbnB1dClcclxuXHRcdHtcclxuXHRcdFx0dmFyIG91dHB1dCA9IG5ldyBTdHJpbmdCdWZmZXIoKTtcclxuXHJcblx0XHRcdHZhciBlbnVtZXJhdG9yID0gbmV3IEJhc2U2NERlY29kZUVudW1lcmF0b3IoaW5wdXQpO1xyXG5cdFx0XHR3aGlsZSAoZW51bWVyYXRvci5tb3ZlTmV4dCgpKVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIGNoYXJDb2RlID0gZW51bWVyYXRvci5jdXJyZW50O1xyXG5cclxuXHRcdFx0XHRpZiAoY2hhckNvZGUgPCAxMjgpXHJcblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpKTtcclxuXHRcdFx0XHRlbHNlIGlmICgoY2hhckNvZGUgPiAxOTEpICYmIChjaGFyQ29kZSA8IDIyNCkpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xyXG5cdFx0XHRcdFx0dmFyIGNoYXJDb2RlMiA9IGVudW1lcmF0b3IuY3VycmVudDtcclxuXHJcblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoKChjaGFyQ29kZSAmIDMxKSA8PCA2KSB8IChjaGFyQ29kZTIgJiA2MykpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdGVudW1lcmF0b3IubW92ZU5leHQoKTtcclxuXHRcdFx0XHRcdHZhciBjaGFyQ29kZTIgPSBlbnVtZXJhdG9yLmN1cnJlbnQ7XHJcblxyXG5cdFx0XHRcdFx0ZW51bWVyYXRvci5tb3ZlTmV4dCgpO1xyXG5cdFx0XHRcdFx0dmFyIGNoYXJDb2RlMyA9IGVudW1lcmF0b3IuY3VycmVudDtcclxuXHJcblx0XHRcdFx0XHRvdXRwdXQuYXBwZW5kKFN0cmluZy5mcm9tQ2hhckNvZGUoKChjaGFyQ29kZSAmIDE1KSA8PCAxMikgfCAoKGNoYXJDb2RlMiAmIDYzKSA8PCA2KSB8IChjaGFyQ29kZTMgJiA2MykpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHJldHVybiBvdXRwdXQudG9TdHJpbmcoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBVdGY4RW5jb2RlRW51bWVyYXRvcihpbnB1dClcclxuXHR7XHJcblx0XHR0aGlzLl9pbnB1dCA9IGlucHV0O1xyXG5cdFx0dGhpcy5faW5kZXggPSAtMTtcclxuXHRcdHRoaXMuX2J1ZmZlciA9IFtdO1xyXG5cdH1cclxuXHJcblx0VXRmOEVuY29kZUVudW1lcmF0b3IucHJvdG90eXBlID1cclxuXHR7XHJcblx0XHRjdXJyZW50OiBOdW1iZXIuTmFOLFxyXG5cclxuXHRcdG1vdmVOZXh0OiBmdW5jdGlvbigpXHJcblx0XHR7XHJcblx0XHRcdGlmICh0aGlzLl9idWZmZXIubGVuZ3RoID4gMClcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IHRoaXMuX2J1ZmZlci5zaGlmdCgpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2UgaWYgKHRoaXMuX2luZGV4ID49ICh0aGlzLl9pbnB1dC5sZW5ndGggLSAxKSlcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHRoaXMuY3VycmVudCA9IE51bWJlci5OYU47XHJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGVsc2VcclxuXHRcdFx0e1xyXG5cdFx0XHRcdHZhciBjaGFyQ29kZSA9IHRoaXMuX2lucHV0LmNoYXJDb2RlQXQoKyt0aGlzLl9pbmRleCk7XHJcblxyXG5cdFx0XHRcdC8vIFwiXFxyXFxuXCIgLT4gXCJcXG5cIlxyXG5cdFx0XHRcdC8vXHJcblx0XHRcdFx0aWYgKChjaGFyQ29kZSA9PSAxMykgJiYgKHRoaXMuX2lucHV0LmNoYXJDb2RlQXQodGhpcy5faW5kZXggKyAxKSA9PSAxMCkpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0Y2hhckNvZGUgPSAxMDtcclxuXHRcdFx0XHRcdHRoaXMuX2luZGV4ICs9IDI7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRpZiAoY2hhckNvZGUgPCAxMjgpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gY2hhckNvZGU7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGVsc2UgaWYgKChjaGFyQ29kZSA+IDEyNykgJiYgKGNoYXJDb2RlIDwgMjA0OCkpXHJcblx0XHRcdFx0e1xyXG5cdFx0XHRcdFx0dGhpcy5jdXJyZW50ID0gKGNoYXJDb2RlID4+IDYpIHwgMTkyO1xyXG5cdFx0XHRcdFx0dGhpcy5fYnVmZmVyLnB1c2goKGNoYXJDb2RlICYgNjMpIHwgMTI4KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdHtcclxuXHRcdFx0XHRcdHRoaXMuY3VycmVudCA9IChjaGFyQ29kZSA+PiAxMikgfCAyMjQ7XHJcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaCgoKGNoYXJDb2RlID4+IDYpICYgNjMpIHwgMTI4KTtcclxuXHRcdFx0XHRcdHRoaXMuX2J1ZmZlci5wdXNoKChjaGFyQ29kZSAmIDYzKSB8IDEyOCk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIEJhc2U2NERlY29kZUVudW1lcmF0b3IoaW5wdXQpXHJcblx0e1xyXG5cdFx0dGhpcy5faW5wdXQgPSBpbnB1dDtcclxuXHRcdHRoaXMuX2luZGV4ID0gLTE7XHJcblx0XHR0aGlzLl9idWZmZXIgPSBbXTtcclxuXHR9XHJcblxyXG5cdEJhc2U2NERlY29kZUVudW1lcmF0b3IucHJvdG90eXBlID1cclxuXHR7XHJcblx0XHRjdXJyZW50OiA2NCxcclxuXHJcblx0XHRtb3ZlTmV4dDogZnVuY3Rpb24oKVxyXG5cdFx0e1xyXG5cdFx0XHRpZiAodGhpcy5fYnVmZmVyLmxlbmd0aCA+IDApXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSB0aGlzLl9idWZmZXIuc2hpZnQoKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRlbHNlIGlmICh0aGlzLl9pbmRleCA+PSAodGhpcy5faW5wdXQubGVuZ3RoIC0gMSkpXHJcblx0XHRcdHtcclxuXHRcdFx0XHR0aGlzLmN1cnJlbnQgPSA2NDtcclxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdFx0ZWxzZVxyXG5cdFx0XHR7XHJcblx0XHRcdFx0dmFyIGVuYzEgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xyXG5cdFx0XHRcdHZhciBlbmMyID0gQmFzZTY0LmNvZGV4LmluZGV4T2YodGhpcy5faW5wdXQuY2hhckF0KCsrdGhpcy5faW5kZXgpKTtcclxuXHRcdFx0XHR2YXIgZW5jMyA9IEJhc2U2NC5jb2RleC5pbmRleE9mKHRoaXMuX2lucHV0LmNoYXJBdCgrK3RoaXMuX2luZGV4KSk7XHJcblx0XHRcdFx0dmFyIGVuYzQgPSBCYXNlNjQuY29kZXguaW5kZXhPZih0aGlzLl9pbnB1dC5jaGFyQXQoKyt0aGlzLl9pbmRleCkpO1xyXG5cclxuXHRcdFx0XHR2YXIgY2hyMSA9IChlbmMxIDw8IDIpIHwgKGVuYzIgPj4gNCk7XHJcblx0XHRcdFx0dmFyIGNocjIgPSAoKGVuYzIgJiAxNSkgPDwgNCkgfCAoZW5jMyA+PiAyKTtcclxuXHRcdFx0XHR2YXIgY2hyMyA9ICgoZW5jMyAmIDMpIDw8IDYpIHwgZW5jNDtcclxuXHJcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gY2hyMTtcclxuXHJcblx0XHRcdFx0aWYgKGVuYzMgIT0gNjQpXHJcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaChjaHIyKTtcclxuXHJcblx0XHRcdFx0aWYgKGVuYzQgIT0gNjQpXHJcblx0XHRcdFx0XHR0aGlzLl9idWZmZXIucHVzaChjaHIzKTtcclxuXHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gQmFzZTY0O1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgYmFzZTY0ID0gKEJhc2U2NCk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vbm9kZV9tb2R1bGVzL2NyeXB0by1qcy9idWlsZC9obWFjLXNoYTI1Ni5qc1xyXG52YXIgaG1hY19zaGEyNTYgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDM4KTtcclxudmFyIGhtYWNfc2hhMjU2X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGhtYWNfc2hhMjU2KTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9ub2RlX21vZHVsZXMvY3J5cHRvLWpzL2J1aWxkL2VuYy1iYXNlNjQuanNcclxudmFyIGVuY19iYXNlNjQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuXHJcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvYXV0aC5qc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBhdXRoX0F1dGggPSAoZnVuY3Rpb24oKSB7XHJcblx0dmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XHJcblx0ZnVuY3Rpb24gbm9vcCgpIHt9XHJcblx0ZnVuY3Rpb24gcmFuZG9tKCkgeyByZXR1cm4gKCcwMDAwMDAnICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogMUUxNikpLnNsaWNlKC0xNik7IH1cclxuXHRmdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcclxuXHRcdC8qIEEgY2xpZW50IGF1dGggY2FsbGJhY2sgbWF5IGdpdmUgZXJyb3JzIGluIGFueSBudW1iZXIgb2YgZm9ybWF0czsgbm9ybWFsaXNlIHRvIGFuIGVycm9yaW5mbyAqL1xyXG5cdFx0aWYoIXV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzRXJyb3JJbmZvKGVycikpIHtcclxuXHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10odXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVyciksIGVyci5jb2RlIHx8IDQwMTcwLCBlcnIuc3RhdHVzQ29kZSB8fCA0MDEpO1xyXG5cdFx0fVxyXG5cdFx0LyogbmV0d29yayBlcnJvcnMgd2lsbCBub3QgaGF2ZSBhbiBpbmhlcmVudCBlcnJvciBjb2RlICovXHJcblx0XHRpZighZXJyLmNvZGUpIHtcclxuXHRcdFx0aWYoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xyXG5cdFx0XHRcdGVyci5jb2RlID0gNDAzMDA7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXJyLmNvZGUgPSA0MDE3MDtcclxuXHRcdFx0XHQvKiBub3JtYWxpc2Ugc3RhdHVzQ29kZSB0byA0MDEgcGVyIFJTQTRlICovXHJcblx0XHRcdFx0ZXJyLnN0YXR1c0NvZGUgPSA0MDE7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHJldHVybiBlcnI7XHJcblx0fVxyXG5cclxuXHR2YXIgaG1hYywgdG9CYXNlNjQ7XHJcblx0aWYocGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jcmVhdGVIbWFjKSB7XHJcblx0XHR0b0Jhc2U2NCA9IGZ1bmN0aW9uKHN0cikgeyByZXR1cm4gKEJ1ZmZlci5mcm9tKHN0ciwgJ2FzY2lpJykpLnRvU3RyaW5nKCdiYXNlNjQnKTsgfTtcclxuXHRcdGhtYWMgPSBmdW5jdGlvbih0ZXh0LCBrZXkpIHtcclxuXHRcdFx0dmFyIGluc3QgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNyZWF0ZUhtYWMoJ1NIQTI1NicsIGtleSk7XHJcblx0XHRcdGluc3QudXBkYXRlKHRleHQpO1xyXG5cdFx0XHRyZXR1cm4gaW5zdC5kaWdlc3QoJ2Jhc2U2NCcpO1xyXG5cdFx0fTtcclxuXHR9IGVsc2Uge1xyXG5cdFx0dG9CYXNlNjQgPSBiYXNlNjQuZW5jb2RlO1xyXG5cdFx0aG1hYyA9IGZ1bmN0aW9uKHRleHQsIGtleSkge1xyXG5cdFx0XHRyZXR1cm4gT2JqZWN0KGVuY19iYXNlNjRbXCJzdHJpbmdpZnlcIl0pKGhtYWNfc2hhMjU2X2RlZmF1bHQoKSh0ZXh0LCBrZXkpKTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBjMTRuKGNhcGFiaWxpdHkpIHtcclxuXHRcdGlmKCFjYXBhYmlsaXR5KVxyXG5cdFx0XHRyZXR1cm4gJyc7XHJcblxyXG5cdFx0aWYodHlwZW9mKGNhcGFiaWxpdHkpID09ICdzdHJpbmcnKVxyXG5cdFx0XHRjYXBhYmlsaXR5ID0gSlNPTi5wYXJzZShjYXBhYmlsaXR5KTtcclxuXHJcblx0XHR2YXIgYzE0bkNhcGFiaWxpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cdFx0dmFyIGtleXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5rZXlzQXJyYXkoY2FwYWJpbGl0eSwgdHJ1ZSk7XHJcblx0XHRpZigha2V5cylcclxuXHRcdFx0cmV0dXJuICcnO1xyXG5cdFx0a2V5cy5zb3J0KCk7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjMTRuQ2FwYWJpbGl0eVtrZXlzW2ldXSA9IGNhcGFiaWxpdHlba2V5c1tpXV0uc29ydCgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KGMxNG5DYXBhYmlsaXR5KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGxvZ0FuZFZhbGlkYXRlVG9rZW5BdXRoTWV0aG9kKGF1dGhPcHRpb25zKSB7XHJcblx0XHRpZihhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2spIHtcclxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcclxuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy5hdXRoVXJsKSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybCcpO1xyXG5cdFx0fSBlbHNlIGlmKGF1dGhPcHRpb25zLmtleSkge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcclxuXHRcdH0gZWxzZSBpZihhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcclxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5Jyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbXNnID0gJ2F1dGhPcHRpb25zIG11c3QgaW5jbHVkZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzJztcclxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykge1xyXG5cdFx0cmV0dXJuICd1c2VUb2tlbkF1dGgnIGluIG9wdGlvbnMgJiYgIW9wdGlvbnMudXNlVG9rZW5BdXRoO1xyXG5cdH1cclxuXHJcblx0LyogUlNBNCAqL1xyXG5cdGZ1bmN0aW9uIHVzZVRva2VuQXV0aChvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gb3B0aW9ucy51c2VUb2tlbkF1dGggfHxcclxuXHRcdFx0KCFiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykgJiZcclxuXHRcdFx0IChvcHRpb25zLmF1dGhDYWxsYmFjayB8fFxyXG5cdFx0XHQgIG9wdGlvbnMuYXV0aFVybCAgICAgIHx8XHJcblx0XHRcdCAgb3B0aW9ucy50b2tlbiAgICAgICAgfHxcclxuXHRcdFx0ICBvcHRpb25zLnRva2VuRGV0YWlscykpXHJcblx0fVxyXG5cclxuXHQvKiBSU0E0YSAqL1xyXG5cdGZ1bmN0aW9uIG5vV2F5VG9SZW5ldyhvcHRpb25zKSB7XHJcblx0XHRyZXR1cm4gIW9wdGlvbnMua2V5ICYmXHJcblx0XHRcdCFvcHRpb25zLmF1dGhDYWxsYmFjayAmJlxyXG5cdFx0XHQhb3B0aW9ucy5hdXRoVXJsO1xyXG5cdH1cclxuXHJcblx0dmFyIHRySWQgPSAwO1xyXG5cdGZ1bmN0aW9uIGdldFRva2VuUmVxdWVzdElkKCkge1xyXG5cdFx0cmV0dXJuIHRySWQrKztcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEF1dGgoY2xpZW50LCBvcHRpb25zKSB7XHJcblx0XHR0aGlzLmNsaWVudCA9IGNsaWVudDtcclxuXHRcdHRoaXMudG9rZW5QYXJhbXMgPSBvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcyB8fCB7fTtcclxuXHRcdC8qIFRoZSBpZCBvZiB0aGUgY3VycmVudCB0b2tlbiByZXF1ZXN0IGlmIG9uZSBpcyBpbiBwcm9ncmVzcywgZWxzZSBudWxsICovXHJcblx0XHR0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XHJcblx0XHR0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xyXG5cclxuXHRcdGlmKHVzZVRva2VuQXV0aChvcHRpb25zKSkge1xyXG5cdFx0XHQvKiBUb2tlbiBhdXRoICovXHJcblx0XHRcdGlmKG9wdGlvbnMua2V5ICYmICFobWFjKSB7XHJcblx0XHRcdFx0dmFyIG1zZyA9ICdjbGllbnQtc2lkZSB0b2tlbiByZXF1ZXN0IHNpZ25pbmcgbm90IHN1cHBvcnRlZCc7XHJcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihub1dheVRvUmVuZXcob3B0aW9ucykpIHtcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCAnV2FybmluZzogbGlicmFyeSBpbml0aWFsaXplZCB3aXRoIGEgdG9rZW4gbGl0ZXJhbCB3aXRob3V0IGFueSB3YXkgdG8gcmVuZXcgdGhlIHRva2VuIHdoZW4gaXQgZXhwaXJlcyAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpLiBTZWUgaHR0cHM6Ly9oZWxwLmFibHkuaW8vZXJyb3IvNDAxNzEgZm9yIGhlbHAnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLl9zYXZlVG9rZW5PcHRpb25zKG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zLCBvcHRpb25zKTtcclxuXHRcdFx0bG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QodGhpcy5hdXRoT3B0aW9ucyk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHQvKiBCYXNpYyBhdXRoICovXHJcblx0XHRcdGlmKCFvcHRpb25zLmtleSkge1xyXG5cdFx0XHRcdHZhciBtc2cgPSAnTm8gYXV0aGVudGljYXRpb24gb3B0aW9ucyBwcm92aWRlZDsgbmVlZCBvbmUgb2Y6IGtleSwgYXV0aFVybCwgb3IgYXV0aENhbGxiYWNrIChvciBmb3IgdGVzdGluZyBvbmx5LCB0b2tlbiBvciB0b2tlbkRldGFpbHMpJztcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xyXG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10obXNnLCA0MDE2MCwgNDAxKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoKCknLCAnYW5vbnltb3VzLCB1c2luZyBiYXNpYyBhdXRoJyk7XHJcblx0XHRcdHRoaXMuX3NhdmVCYXNpY09wdGlvbnMob3B0aW9ucyk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbnN0cnVjdHMgdGhlIGxpYnJhcnkgdG8gZ2V0IGEgdG9rZW4gaW1tZWRpYXRlbHkgYW5kIGVuc3VyZXMgVG9rZW4gQXV0aFxyXG5cdCAqIGlzIHVzZWQgZm9yIGFsbCBmdXR1cmUgcmVxdWVzdHMsIHN0b3JpbmcgdGhlIHRva2VuUGFyYW1zIGFuZCBhdXRoT3B0aW9uc1xyXG5cdCAqIGdpdmVuIGFzIHRoZSBuZXcgZGVmYXVsdHMgZm9yIHN1YnNlcXVlbnQgdXNlLlxyXG5cdCAqXHJcblx0ICogQHBhcmFtIHRva2VuUGFyYW1zXHJcblx0ICogYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIHBhcmFtZXRlcnMgZm9yIHRoZSByZXF1ZXN0ZWQgdG9rZW46XHJcblx0ICpcclxuXHQgKiAtIHR0bDogICAgICAgIChvcHRpb25hbCkgdGhlIHJlcXVlc3RlZCBsaWZlIG9mIGFueSBuZXcgdG9rZW4gaW4gbXMuIElmIG5vbmVcclxuXHQgKiAgICAgICAgICAgICAgIGlzIHNwZWNpZmllZCBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZVxyXG5cdCAqICAgICAgICAgICAgICAgaXMgMjRob3VyczsgYW55IHJlcXVlc3QgZXhjZWVlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWRcclxuXHQgKiAgICAgICAgICAgICAgIHdpdGggYW4gZXJyb3IuXHJcblx0ICpcclxuXHQgKiAtIGNhcGFiaWxpdHk6IChvcHRpb25hbCkgdGhlIGNhcGFiaWxpdHkgdG8gYXNzb2NpYXRlIHdpdGggdGhlIGFjY2VzcyB0b2tlbi5cclxuXHQgKiAgICAgICAgICAgICAgIElmIG5vbmUgaXMgc3BlY2lmaWVkLCBhIHRva2VuIHdpbGwgYmUgcmVxdWVzdGVkIHdpdGggYWxsIG9mIHRoZVxyXG5cdCAqICAgICAgICAgICAgICAgY2FwYWJpbGl0aWVzIG9mIHRoZSBzcGVjaWZpZWQga2V5LlxyXG5cdCAqXHJcblx0ICogLSBjbGllbnRJZDogICAob3B0aW9uYWwpIGEgY2xpZW50IElkIHRvIGFzc29jaWF0ZSB3aXRoIHRoZSB0b2tlblxyXG5cdCAqXHJcblx0ICogLSB0aW1lc3RhbXA6ICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXHJcblx0ICogICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBhdXRoT3B0aW9uc1xyXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIGF1dGggb3B0aW9ucyByZWxldmFudCB0byB0b2tlbiBhdXRoOlxyXG5cdCAqXHJcblx0ICogLSBxdWVyeVRpbWUgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBBYmx5IHN5c3RlbSBzaG91bGQgYmVcclxuXHQgKiAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5LlxyXG5cdCAqXHJcblx0ICogLSB0b2tlbkRldGFpbHM6IChvcHRpb25hbCkgb2JqZWN0OiBBbiBhdXRoZW50aWNhdGVkIFRva2VuRGV0YWlscyBvYmplY3QuXHJcblx0ICpcclxuXHQgKiAtIHRva2VuOiAgICAgICAgKG9wdGlvbmFsKSBzdHJpbmc6IHRoZSBgdG9rZW5gIHByb3BlcnR5IG9mIGEgdG9rZW5EZXRhaWxzIG9iamVjdFxyXG5cdCAqXHJcblx0ICogLSBhdXRoQ2FsbGJhY2s6ICAob3B0aW9uYWwpIGEgSmF2YVNjcmlwdCBjYWxsYmFjayB0byBiZSBjYWxsZWQgdG8gZ2V0IGF1dGggaW5mb3JtYXRpb24uXHJcblx0ICogICAgICAgICAgICAgICAgICBhdXRoQ2FsbGJhY2sgc2hvdWxkIGJlIGEgZnVuY3Rpb24gb2YgKHRva2VuUGFyYW1zLCBjYWxsYmFjaykgdGhhdCBjYWxsc1xyXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIGNhbGxiYWNrIHdpdGggKGVyciwgcmVzdWx0KSwgd2hlcmUgcmVzdWx0IGlzIGFueSBvZjpcclxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlblJlcXVlc3Qgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLmNyZWF0ZVRva2VuUmVxdWVzdCBjYWxsKSxcclxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbkRldGFpbHMgb2JqZWN0IChpZSB0aGUgcmVzdWx0IG9mIGEgcmVzdC5hdXRoLnJlcXVlc3RUb2tlbiBjYWxsKSxcclxuXHQgKiAgICAgICAgICAgICAgICAgIC0gYSB0b2tlbiBzdHJpbmdcclxuXHQgKlxyXG5cdCAqIC0gYXV0aFVybDogICAgICAgKG9wdGlvbmFsKSBhIFVSTCB0byBiZSB1c2VkIHRvIEdFVCBvciBQT1NUIGEgc2V0IG9mIHRva2VuIHJlcXVlc3RcclxuXHQgKiAgICAgICAgICAgICAgICAgIHBhcmFtcywgdG8gb2J0YWluIGEgc2lnbmVkIHRva2VuIHJlcXVlc3QuXHJcblx0ICpcclxuXHQgKiAtIGF1dGhIZWFkZXJzOiAgIChvcHRpb25hbCkgYSBzZXQgb2YgYXBwbGljYXRpb24tc3BlY2lmaWMgaGVhZGVycyB0byBiZSBhZGRlZCB0byBhbnkgcmVxdWVzdFxyXG5cdCAqICAgICAgICAgICAgICAgICAgbWFkZSB0byB0aGUgYXV0aFVybC5cclxuXHQgKlxyXG5cdCAqIC0gYXV0aFBhcmFtczogICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBxdWVyeSBwYXJhbXMgdG8gYmUgYWRkZWQgdG8gYW55XHJcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0IG1hZGUgdG8gdGhlIGF1dGhVcmwuXHJcblx0ICpcclxuXHQgKlxyXG5cdCAqIC0gcmVxdWVzdEhlYWRlcnMgKG9wdGlvbmFsLCB1bnN1cHBvcnRlZCwgZm9yIHRlc3Rpbmcgb25seSkgZXh0cmEgaGVhZGVycyB0byBhZGQgdG8gdGhlXHJcblx0ICogICAgICAgICAgICAgICAgICByZXF1ZXN0VG9rZW4gcmVxdWVzdFxyXG5cdCAqXHJcblx0ICogQHBhcmFtIGNhbGxiYWNrIChlcnIsIHRva2VuRGV0YWlscylcclxuXHQgKi9cclxuXHRBdXRoLnByb3RvdHlwZS5hdXRob3JpemUgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xyXG5cdFx0aWYodHlwZW9mKHRva2VuUGFyYW1zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xyXG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xyXG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcclxuXHRcdH0gZWxzZSBpZih0eXBlb2YoYXV0aE9wdGlvbnMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XHJcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmKCFjYWxsYmFjaykge1xyXG5cdFx0XHRpZih0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnYXV0aG9yaXplJywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0LyogUlNBMTBhOiBhdXRob3JpemUoKSBjYWxsIGltcGxpZXMgdG9rZW4gYXV0aC4gSWYgYSBrZXkgaXMgcGFzc2VkIGl0LCB3ZVxyXG5cdFx0ICoganVzdCBjaGVjayBpZiBpdCBkb2Vzbid0IGNsYXNoIGFuZCBhc3N1bWUgd2UncmUgZ2VuZXJhdGluZyBhIHRva2VuIGZyb20gaXQgKi9cclxuXHRcdGlmKGF1dGhPcHRpb25zICYmIGF1dGhPcHRpb25zLmtleSAmJiAodGhpcy5hdXRoT3B0aW9ucy5rZXkgIT09IGF1dGhPcHRpb25zLmtleSkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIHVwZGF0ZSBhdXRoIG9wdGlvbnMgd2l0aCBpbmNvbXBhdGlibGUga2V5JywgNDAxMDIsIDQwMSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoYXV0aE9wdGlvbnMgJiYgKCdmb3JjZScgaW4gYXV0aE9wdGlvbnMpKSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGguYXV0aG9yaXplJywgJ0RlcHJlY2F0aW9uIHdhcm5pbmc6IHNwZWNpZnlpbmcge2ZvcmNlOiB0cnVlfSBpbiBhdXRoT3B0aW9ucyBpcyBubyBsb25nZXIgbmVjZXNzYXJ5LCBhdXRob3JpemUoKSBub3cgYWx3YXlzIGdldHMgYSBuZXcgdG9rZW4uIFBsZWFzZSByZW1vdmUgdGhpcywgYXMgaW4gdmVyc2lvbiAxLjAgYW5kIGxhdGVyLCBoYXZpbmcgYSBub24tbnVsbCBhdXRoT3B0aW9ucyB3aWxsIG92ZXJ3cml0ZSBzdG9yZWQgbGlicmFyeSBhdXRoT3B0aW9ucywgd2hpY2ggbWF5IG5vdCBiZSB3aGF0IHlvdSB3YW50Jyk7XHJcblx0XHRcdC8qIEVtdWxhdGUgdGhlIG9sZCBiZWhhdmlvdXI6IGlmICdmb3JjZScgd2FzIHRoZSBvbmx5IG1lbWJlciBvZiBhdXRoT3B0aW9ucyxcclxuXHRcdFx0ICogc2V0IGl0IHRvIG51bGwgc28gaXQgZG9lc24ndCBvdmVyd3JpdGUgc3RvcmVkLiBUT0RPOiByZW1vdmUgaW4gdmVyc2lvbiAxLjAgKi9cclxuXHRcdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPbmx5UHJvcEluKGF1dGhPcHRpb25zLCAnZm9yY2UnKSkge1xyXG5cdFx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2ZvcmNlTmV3VG9rZW4odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBmdW5jdGlvbihlcnIsIHRva2VuRGV0YWlscykge1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRpZihzZWxmLmNsaWVudC5jb25uZWN0aW9uKSB7XHJcblx0XHRcdFx0XHQvKiBXZSBpbnRlcnByZXQgUlNBNGQgYXMgaW5jbHVkaW5nIHJlcXVlc3RzIG1hZGUgYnkgYSBjbGllbnQgbGliIHRvXHJcblx0XHRcdFx0XHQgKiBhdXRoZW50aWNhdGUgdHJpZ2dlcmVkIGJ5IGFuIGV4cGxpY2l0IGF1dGhvcml6ZSgpIG9yIGFuIEFVVEggcmVjZWl2ZWQgZnJvbVxyXG5cdFx0XHRcdFx0ICogYWJseSwgbm90IGp1c3QgY29ubmVjdC1zZXF1ZW5jZS10cmlnZ2VyZWQgdG9rZW4gZmV0Y2hlcyAqL1xyXG5cdFx0XHRcdFx0c2VsZi5jbGllbnQuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogUlRDOFxyXG5cdFx0XHQgKiAtIFdoZW4gYXV0aG9yaXplIGNhbGxlZCBieSBhbiBlbmQgdXNlciBhbmQgaGF2ZSBhIHJlYWx0aW1lIGNvbm5lY3Rpb24sXHJcblx0XHRcdCAqIGRvbid0IGNhbGwgYmFjayB0aWxsIG5ldyB0b2tlbiBoYXMgdGFrZW4gZWZmZWN0LlxyXG5cdFx0XHQgKiAtIFVzZSBzZWxmLmNsaWVudC5jb25uZWN0aW9uIGFzIGEgcHJveHkgZm9yIChzZWxmLmNsaWVudCBpbnN0YW5jZW9mIFJlYWx0aW1lKSxcclxuXHRcdFx0ICogd2hpY2ggZG9lc24ndCB3b3JrIGluIG5vZGUgYXMgUmVhbHRpbWUgaXNuJ3QgcGFydCBvZiB0aGUgdm0gY29udGV4dCBmb3IgUmVzdCBjbGllbnRzICovXHJcblx0XHRcdGlmKHNlbGYuY2xpZW50LmNvbm5lY3Rpb24pIHtcclxuXHRcdFx0XHRzZWxmLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjayk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5EZXRhaWxzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSlcclxuXHR9O1xyXG5cclxuXHRBdXRoLnByb3RvdHlwZS5hdXRob3Jpc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdBdXRoLmF1dGhvcmlzZScsICdBdXRoLmF1dGhvcml6ZScpO1xyXG5cdFx0dGhpcy5hdXRob3JpemUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR9O1xyXG5cclxuXHQvKiBGb3IgaW50ZXJuYWwgdXNlLCBlZyBieSBjb25uZWN0aW9uTWFuYWdlciAtIHVzZWZ1bCB3aGVuIHdhbnQgdG8gY2FsbCBiYWNrXHJcblx0ICogYXMgc29vbiBhcyB3ZSBoYXZlIHRoZSBuZXcgdG9rZW4sIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGl0IHRvIHRha2VcclxuXHQgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXHJcblx0QXV0aC5wcm90b3R5cGUuX2ZvcmNlTmV3VG9rZW4gPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0LyogZ2V0IHJpZCBvZiBjdXJyZW50IHRva2VuIGV2ZW4gaWYgc3RpbGwgdmFsaWQgKi9cclxuXHRcdHRoaXMudG9rZW5EZXRhaWxzID0gbnVsbDtcclxuXHJcblx0XHQvKiBfc2F2ZSBub3JtYWxpc2VzIHRoZSB0b2tlblBhcmFtcyBhbmQgYXV0aE9wdGlvbnMgYW5kIHVwZGF0ZXMgdGhlIGF1dGhcclxuXHRcdCAqIG9iamVjdC4gQWxsIHN1YnNlcXVlbnQgb3BlcmF0aW9ucyBzaG91bGQgdXNlIHRoZSB2YWx1ZXMgb24gYHRoaXNgLFxyXG5cdFx0ICogbm90IHRoZSBwYXNzZWQgaW4gb25lcy4gKi9cclxuXHRcdHRoaXMuX3NhdmVUb2tlbk9wdGlvbnModG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zKTtcclxuXHJcblx0XHRsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcclxuXHJcblx0XHR0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyh0cnVlLCBmdW5jdGlvbihlcnIsIHRva2VuRGV0YWlscykge1xyXG5cdFx0XHQvKiBSU0ExMGcgKi9cclxuXHRcdFx0ZGVsZXRlIHNlbGYudG9rZW5QYXJhbXMudGltZXN0YW1wO1xyXG5cdFx0XHRkZWxldGUgc2VsZi5hdXRoT3B0aW9ucy5xdWVyeVRpbWU7XHJcblx0XHRcdGNhbGxiYWNrKGVyciwgdG9rZW5EZXRhaWxzKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogUmVxdWVzdCBhbiBhY2Nlc3MgdG9rZW5cclxuXHQgKiBAcGFyYW0gYXV0aE9wdGlvbnNcclxuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcmVxdWVzdCBvcHRpb25zOlxyXG5cdCAqIC0ga2V5OiAgICAgICAgICAgdGhlIGtleSB0byB1c2UuXHJcblx0ICpcclxuXHQgKiAtIGF1dGhDYWxsYmFjazogIChvcHRpb25hbCkgYSBKYXZhU2NyaXB0IGNhbGxiYWNrIHRvIGJlIGNhbGxlZCB0byBnZXQgYXV0aCBpbmZvcm1hdGlvbi5cclxuXHQgKiAgICAgICAgICAgICAgICAgIGF1dGhDYWxsYmFjayBzaG91bGQgYmUgYSBmdW5jdGlvbiBvZiAodG9rZW5QYXJhbXMsIGNhbGxiYWNrKSB0aGF0IGNhbGxzXHJcblx0ICogICAgICAgICAgICAgICAgICB0aGUgY2FsbGJhY2sgd2l0aCAoZXJyLCByZXN1bHQpLCB3aGVyZSByZXN1bHQgaXMgYW55IG9mOlxyXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuUmVxdWVzdCBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGguY3JlYXRlVG9rZW5SZXF1ZXN0IGNhbGwpLFxyXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuRGV0YWlscyBvYmplY3QgKGllIHRoZSByZXN1bHQgb2YgYSByZXN0LmF1dGgucmVxdWVzdFRva2VuIGNhbGwpLFxyXG5cdCAqICAgICAgICAgICAgICAgICAgLSBhIHRva2VuIHN0cmluZ1xyXG5cdCAqXHJcblx0ICogLSBhdXRoVXJsOiAgICAgICAob3B0aW9uYWwpIGEgVVJMIHRvIGJlIHVzZWQgdG8gR0VUIG9yIFBPU1QgYSBzZXQgb2YgdG9rZW4gcmVxdWVzdFxyXG5cdCAqICAgICAgICAgICAgICAgICAgcGFyYW1zLCB0byBvYnRhaW4gYSBzaWduZWQgdG9rZW4gcmVxdWVzdC5cclxuXHQgKlxyXG5cdCAqIC0gYXV0aEhlYWRlcnM6ICAgKG9wdGlvbmFsKSBhIHNldCBvZiBhcHBsaWNhdGlvbi1zcGVjaWZpYyBoZWFkZXJzIHRvIGJlIGFkZGVkIHRvIGFueSByZXF1ZXN0XHJcblx0ICogICAgICAgICAgICAgICAgICBtYWRlIHRvIHRoZSBhdXRoVXJsLlxyXG5cdCAqXHJcblx0ICogLSBhdXRoUGFyYW1zOiAgICAob3B0aW9uYWwpIGEgc2V0IG9mIGFwcGxpY2F0aW9uLXNwZWNpZmljIHF1ZXJ5IHBhcmFtcyB0byBiZSBhZGRlZCB0byBhbnlcclxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3QgbWFkZSB0byB0aGUgYXV0aFVybC5cclxuXHQgKlxyXG5cdCAqIC0gcXVlcnlUaW1lICAgICAgKG9wdGlvbmFsKSBib29sZWFuIGluZGljYXRpbmcgdGhhdCB0aGUgYWJseSBzeXN0ZW0gc2hvdWxkIGJlXHJcblx0ICogICAgICAgICAgICAgICAgICBxdWVyaWVkIGZvciB0aGUgY3VycmVudCB0aW1lIHdoZW4gbm9uZSBpcyBzcGVjaWZpZWQgZXhwbGljaXRseVxyXG5cdCAqXHJcblx0ICogLSByZXF1ZXN0SGVhZGVycyAob3B0aW9uYWwsIHVuc3VwcG9ydGVkLCBmb3IgdGVzdGluZyBvbmx5KSBleHRyYSBoZWFkZXJzIHRvIGFkZCB0byB0aGVcclxuXHQgKiAgICAgICAgICAgICAgICAgIHJlcXVlc3RUb2tlbiByZXF1ZXN0XHJcblx0ICpcclxuXHQgKiBAcGFyYW0gdG9rZW5QYXJhbXNcclxuXHQgKiBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgcGFyYW1ldGVycyBmb3IgdGhlIHJlcXVlc3RlZCB0b2tlbjpcclxuXHQgKiAtIHR0bDogICAgICAgICAgKG9wdGlvbmFsKSB0aGUgcmVxdWVzdGVkIGxpZmUgb2YgdGhlIHRva2VuIGluIG1pbGxpc2Vjb25kcy4gSWYgbm9uZSBpcyBzcGVjaWZpZWRcclxuXHQgKiAgICAgICAgICAgICAgICAgIGEgZGVmYXVsdCBvZiAxIGhvdXIgaXMgcHJvdmlkZWQuIFRoZSBtYXhpbXVtIGxpZmV0aW1lIGlzIDI0aG91cnM7IGFueSByZXF1ZXN0XHJcblx0ICogICAgICAgICAgICAgICAgICBleGNlZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxyXG5cdCAqXHJcblx0ICogLSBjYXBhYmlsaXR5OiAgICAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXHJcblx0ICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcclxuXHQgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cclxuXHQgKlxyXG5cdCAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJZCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxyXG5cdCAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxyXG5cdCAqXHJcblx0ICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXHJcblx0ICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBjYWxsYmFjayAoZXJyLCB0b2tlbkRldGFpbHMpXHJcblx0ICovXHJcblx0QXV0aC5wcm90b3R5cGUucmVxdWVzdFRva2VuID0gZnVuY3Rpb24odG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xyXG5cdFx0Lyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cclxuXHRcdGlmKHR5cGVvZih0b2tlblBhcmFtcykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcclxuXHRcdFx0Y2FsbGJhY2sgPSB0b2tlblBhcmFtcztcclxuXHRcdFx0YXV0aE9wdGlvbnMgPSB0b2tlblBhcmFtcyA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRlbHNlIGlmKHR5cGVvZihhdXRoT3B0aW9ucykgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcclxuXHRcdFx0Y2FsbGJhY2sgPSBhdXRoT3B0aW9ucztcclxuXHRcdFx0YXV0aE9wdGlvbnMgPSBudWxsO1xyXG5cdFx0fVxyXG5cdFx0aWYoIWNhbGxiYWNrICYmIHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAncmVxdWVzdFRva2VuJywgYXJndW1lbnRzKTtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBSU0E4ZTogaWYgYXV0aE9wdGlvbnMgcGFzc2VkIGluLCB0aGV5J3JlIHVzZWQgaW5zdGVhZCBvZiBzdG9yZWQsIGRvbid0IG1lcmdlIHRoZW0gKi9cclxuXHRcdGF1dGhPcHRpb25zID0gYXV0aE9wdGlvbnMgfHwgdGhpcy5hdXRoT3B0aW9ucztcclxuXHRcdHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uY29weSh0aGlzLnRva2VuUGFyYW1zKTtcclxuXHRcdGNhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcclxuXHJcblx0XHQvKiBmaXJzdCBzZXQgdXAgd2hhdGV2ZXIgY2FsbGJhY2sgd2lsbCBiZSB1c2VkIHRvIGdldCBzaWduZWRcclxuXHRcdCAqIHRva2VuIHJlcXVlc3RzICovXHJcblx0XHR2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xyXG5cclxuXHRcdGlmKGF1dGhPcHRpb25zLmF1dGhDYWxsYmFjaykge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcclxuXHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XHJcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XHJcblx0XHRcdHRva2VuUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24ocGFyYW1zLCBjYikge1xyXG5cdFx0XHRcdHZhciBhdXRoSGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHthY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluJ30sIGF1dGhPcHRpb25zLmF1dGhIZWFkZXJzKSxcclxuXHRcdFx0XHRcdHVzZVBvc3QgPSBhdXRoT3B0aW9ucy5hdXRoTWV0aG9kICYmIGF1dGhPcHRpb25zLmF1dGhNZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gJ3Bvc3QnO1xyXG5cdFx0XHRcdGlmKCF1c2VQb3N0KSB7XHJcblx0XHRcdFx0XHQvKiBDb21iaW5lIGF1dGhQYXJhbXMgd2l0aCBhbnkgcXMgcGFyYW1zIGdpdmVuIGluIHRoZSBhdXRoVXJsICovXHJcblx0XHRcdFx0XHR2YXIgcXVlcnlJZHggPSBhdXRoT3B0aW9ucy5hdXRoVXJsLmluZGV4T2YoJz8nKTtcclxuXHRcdFx0XHRcdGlmKHF1ZXJ5SWR4ID4gLTEpIHtcclxuXHRcdFx0XHRcdFx0dmFyIHByb3ZpZGVkUXNQYXJhbXMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wYXJzZVF1ZXJ5U3RyaW5nKGF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UocXVlcnlJZHgpKTtcclxuXHRcdFx0XHRcdFx0YXV0aE9wdGlvbnMuYXV0aFVybCA9IGF1dGhPcHRpb25zLmF1dGhVcmwuc2xpY2UoMCwgcXVlcnlJZHgpO1xyXG5cdFx0XHRcdFx0XHQvKiBJbiBjYXNlIG9mIGNvbmZsaWN0LCBhdXRoUGFyYW1zIHRha2UgcHJlY2VkZW5jZSBvdmVyIHFzIHBhcmFtcyBpbiB0aGUgYXV0aFVybCAqL1xyXG5cdFx0XHRcdFx0XHRhdXRoT3B0aW9ucy5hdXRoUGFyYW1zID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocHJvdmlkZWRRc1BhcmFtcywgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8qIFJTQThjMiAqL1xyXG5cdFx0XHRcdHZhciBhdXRoUGFyYW1zID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oe30sIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMgfHwge30sIHBhcmFtcyk7XHJcblx0XHRcdFx0dmFyIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XHJcblx0XHRcdFx0XHR2YXIgY29udGVudFR5cGU7XHJcblx0XHRcdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQgRXJyb3I6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xyXG5cdFx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnRva2VuUmVxdWVzdENhbGxiYWNrJywgJ1JlY2VpdmVkOyBjb250ZW50LXR5cGU6ICcgKyBjb250ZW50VHlwZSArICc7IGJvZHk6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0Qm9keShib2R5KSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihlcnIgfHwgdW5wYWNrZWQpIHJldHVybiBjYihlcnIsIGJvZHkpO1xyXG5cdFx0XHRcdFx0aWYoYnVmZmVydXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNCdWZmZXIoYm9keSkpIGJvZHkgPSBib2R5LnRvU3RyaW5nKCk7XHJcblx0XHRcdFx0XHRpZighY29udGVudFR5cGUpIHtcclxuXHRcdFx0XHRcdFx0Y2IobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnYXV0aFVybCByZXNwb25zZSBpcyBtaXNzaW5nIGEgY29udGVudC10eXBlIGhlYWRlcicsIDQwMTcwLCA0MDEpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0dmFyIGpzb24gPSBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPiAtMSxcclxuXHRcdFx0XHRcdFx0dGV4dCA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ3RleHQvcGxhaW4nKSA+IC0xIHx8IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2p3dCcpID4gLTE7XHJcblx0XHRcdFx0XHRpZighanNvbiAmJiAhdGV4dCkge1xyXG5cdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdhdXRoVXJsIHJlc3BvbmRlZCB3aXRoIHVuYWNjZXB0YWJsZSBjb250ZW50LXR5cGUgJyArIGNvbnRlbnRUeXBlICsgJywgc2hvdWxkIGJlIGVpdGhlciB0ZXh0L3BsYWluLCBhcHBsaWNhdGlvbi9qd3Qgb3IgYXBwbGljYXRpb24vanNvbicsIDQwMTcwLCA0MDEpKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0aWYoanNvbikge1xyXG5cdFx0XHRcdFx0XHRpZihib2R5Lmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcclxuXHRcdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdhdXRoVXJsIHJlc3BvbnNlIGV4Y2VlZGVkIG1heCBwZXJtaXR0ZWQgbGVuZ3RoJywgNDAxNzAsIDQwMSkpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRcdGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xyXG5cdFx0XHRcdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRcdFx0XHRjYihuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmV4cGVjdGVkIGVycm9yIHByb2Nlc3NpbmcgYXV0aFVSTCByZXNwb25zZTsgZXJyID0gJyArIGUubWVzc2FnZSwgNDAxNzAsIDQwMSkpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0Y2IobnVsbCwgYm9keSwgY29udGVudFR5cGUpO1xyXG5cdFx0XHRcdH07XHJcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZXF1ZXN0aW5nIHRva2VuIGZyb20gJyArIGF1dGhPcHRpb25zLmF1dGhVcmwgKyAnOyBQYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShhdXRoUGFyYW1zKSArICc7IG1ldGhvZDogJyArICh1c2VQb3N0ID8gJ1BPU1QnIDogJ0dFVCcpKTtcclxuXHRcdFx0XHRpZih1c2VQb3N0KSB7XHJcblx0XHRcdFx0XHQvKiBzZW5kIGJvZHkgZm9ybS1lbmNvZGVkICovXHJcblx0XHRcdFx0XHR2YXIgaGVhZGVycyA9IGF1dGhIZWFkZXJzIHx8IHt9O1xyXG5cdFx0XHRcdFx0aGVhZGVyc1snY29udGVudC10eXBlJ10gPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcclxuXHRcdFx0XHRcdHZhciBib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10udG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTsgLyogc2xpY2UgaXMgdG8gcmVtb3ZlIHRoZSBpbml0aWFsICc/JyAqL1xyXG5cdFx0XHRcdFx0aHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5wb3N0VXJpKGNsaWVudCwgYXV0aE9wdGlvbnMuYXV0aFVybCwgaGVhZGVycywgYm9keSwge30sIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2spO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldFVyaShjbGllbnQsIGF1dGhPcHRpb25zLmF1dGhVcmwsIGF1dGhIZWFkZXJzIHx8IHt9LCBhdXRoUGFyYW1zLCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHR9IGVsc2UgaWYoYXV0aE9wdGlvbnMua2V5KSB7XHJcblx0XHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggY2xpZW50LXNpZGUgc2lnbmluZycpO1xyXG5cdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uKHBhcmFtcywgY2IpIHsgc2VsZi5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCBhdXRoT3B0aW9ucywgY2IpOyB9O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIG1zZyA9IFwiTmVlZCBhIG5ldyB0b2tlbiwgYnV0IGF1dGhPcHRpb25zIGRvZXMgbm90IGluY2x1ZGUgYW55IHdheSB0byByZXF1ZXN0IG9uZSAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpXCI7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGgoKScsICdsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscCcpO1xyXG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzEsIDQwMykpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Lyogbm9ybWFsaXNlIHRva2VuIHBhcmFtcyAqL1xyXG5cdFx0aWYoJ2NhcGFiaWxpdHknIGluIHRva2VuUGFyYW1zKVxyXG5cdFx0XHR0b2tlblBhcmFtcy5jYXBhYmlsaXR5ID0gYzE0bih0b2tlblBhcmFtcy5jYXBhYmlsaXR5KTtcclxuXHJcblx0XHR2YXIgdG9rZW5SZXF1ZXN0ID0gZnVuY3Rpb24oc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpIHtcclxuXHRcdFx0dmFyIGtleU5hbWUgPSBzaWduZWRUb2tlblBhcmFtcy5rZXlOYW1lLFxyXG5cdFx0XHRcdHBhdGggPSAnL2tleXMvJyArIGtleU5hbWUgKyAnL3JlcXVlc3RUb2tlbicsXHJcblx0XHRcdFx0dG9rZW5VcmkgPSBmdW5jdGlvbihob3N0KSB7IHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7IH07XHJcblxyXG5cdFx0XHR2YXIgcmVxdWVzdEhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoKTtcclxuXHRcdFx0aWYoYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHJlcXVlc3RIZWFkZXJzLCBhdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycyk7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkucmVxdWVzdFRva2VuJywgJ1NlbmRpbmcgUE9TVCB0byAnICsgcGF0aCArICc7IFRva2VuIHBhcmFtczogJyArIEpTT04uc3RyaW5naWZ5KHNpZ25lZFRva2VuUGFyYW1zKSk7XHJcblx0XHRcdHNpZ25lZFRva2VuUGFyYW1zID0gSlNPTi5zdHJpbmdpZnkoc2lnbmVkVG9rZW5QYXJhbXMpO1xyXG5cdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnBvc3QoY2xpZW50LCB0b2tlblVyaSwgcmVxdWVzdEhlYWRlcnMsIHNpZ25lZFRva2VuUGFyYW1zLCBudWxsLCB0b2tlbkNiKTtcclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSBmYWxzZSxcclxuXHRcdFx0dGltZW91dExlbmd0aCA9IHRoaXMuY2xpZW50Lm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCxcclxuXHRcdFx0dG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHR0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcclxuXHRcdFx0XHR2YXIgbXNnID0gJ1Rva2VuIHJlcXVlc3QgY2FsbGJhY2sgdGltZWQgb3V0IGFmdGVyICcgKyAodGltZW91dExlbmd0aCAvIDEwMDApICsgJyBzZWNvbmRzJztcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcclxuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzAsIDQwMSkpO1xyXG5cdFx0XHR9LCB0aW1lb3V0TGVuZ3RoKTtcclxuXHJcblx0XHR0b2tlblJlcXVlc3RDYWxsYmFjayh0b2tlblBhcmFtcywgZnVuY3Rpb24oZXJyLCB0b2tlblJlcXVlc3RPckRldGFpbHMsIGNvbnRlbnRUeXBlKSB7XHJcblx0XHRcdGlmKHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQpIHJldHVybjtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dCk7XHJcblxyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3Rva2VuIHJlcXVlc3Qgc2lnbmluZyBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGVycikpO1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKiB0aGUgcmVzcG9uc2UgZnJvbSB0aGUgY2FsbGJhY2sgbWlnaHQgYmUgYSB0b2tlbiBzdHJpbmcsIGEgc2lnbmVkIHJlcXVlc3Qgb3IgYSB0b2tlbiBkZXRhaWxzICovXHJcblx0XHRcdGlmKHR5cGVvZih0b2tlblJlcXVlc3RPckRldGFpbHMpID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdGlmKHRva2VuUmVxdWVzdE9yRGV0YWlscy5sZW5ndGggPT09IDApIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHN0cmluZyBpcyBlbXB0eScsIDQwMTcwLCA0MDEpKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLmxlbmd0aCA+IE1BWF9UT0tFTl9MRU5HVEgpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHN0cmluZyBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCAod2FzICcgKyB0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoICsgJyBieXRlcyknLCA0MDE3MCwgNDAxKSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcgfHwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAnbnVsbCcpIHtcclxuXHRcdFx0XHRcdC8qIGNvbW1vbiBmYWlsdXJlIG1vZGUgd2l0aCBwb29ybHktaW1wbGVtZW50ZWQgYXV0aENhbGxiYWNrcyAqL1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVG9rZW4gc3RyaW5nIHdhcyBsaXRlcmFsIG51bGwvdW5kZWZpbmVkJywgNDAxNzAsIDQwMSkpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZigodG9rZW5SZXF1ZXN0T3JEZXRhaWxzWzBdID09PSAneycpICYmICEoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vand0JykgPiAtMSkpIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHdhcyBkb3VibGUtZW5jb2RlZDsgbWFrZSBzdXJlIHlvdVxcJ3JlIG5vdCBKU09OLWVuY29kaW5nIGFuIGFscmVhZHkgZW5jb2RlZCB0b2tlbiByZXF1ZXN0IG9yIGRldGFpbHMnLCA0MDE3MCwgNDAxKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHt0b2tlbjogdG9rZW5SZXF1ZXN0T3JEZXRhaWxzfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZih0eXBlb2YodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSAhPT0gJ29iamVjdCcpIHtcclxuXHRcdFx0XHR2YXIgbXNnID0gJ0V4cGVjdGVkIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgdG8gY2FsbCBiYWNrIHdpdGggYSB0b2tlbiBzdHJpbmcgb3IgdG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCwgYnV0IGdvdCBhICcgKyB0eXBlb2YodG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcclxuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzAsIDQwMSkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHR2YXIgb2JqZWN0U2l6ZSA9IEpTT04uc3RyaW5naWZ5KHRva2VuUmVxdWVzdE9yRGV0YWlscykubGVuZ3RoO1xyXG5cdFx0XHRpZihvYmplY3RTaXplID4gTUFYX1RPS0VOX0xFTkdUSCAmJiAhYXV0aE9wdGlvbnMuc3VwcHJlc3NNYXhMZW5ndGhDaGVjaykge1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Rva2VuIHJlcXVlc3QvZGV0YWlscyBvYmplY3QgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBzdHJpbmdpZmllZCBzaXplICh3YXMgJyArIG9iamVjdFNpemUgKyAnIGJ5dGVzKScsIDQwMTcwLCA0MDEpKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoJ2lzc3VlZCcgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSB7XHJcblx0XHRcdFx0LyogYSB0b2tlbkRldGFpbHMgb2JqZWN0ICovXHJcblx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoISgna2V5TmFtZScgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSkge1xyXG5cdFx0XHRcdHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0JztcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcclxuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxNzAsIDQwMSkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKiBpdCdzIGEgdG9rZW4gcmVxdWVzdCwgc28gbWFrZSB0aGUgcmVxdWVzdCAqL1xyXG5cdFx0XHR0b2tlblJlcXVlc3QodG9rZW5SZXF1ZXN0T3JEZXRhaWxzLCBmdW5jdGlvbihlcnIsIHRva2VuUmVzcG9uc2UsIGhlYWRlcnMsIHVucGFja2VkKSB7XHJcblx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3Rva2VuIHJlcXVlc3QgQVBJIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoIXVucGFja2VkKSB0b2tlblJlc3BvbnNlID0gSlNPTi5wYXJzZSh0b2tlblJlc3BvbnNlKTtcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndG9rZW4gcmVjZWl2ZWQnKTtcclxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlblJlc3BvbnNlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxyXG5cdCAqIE5PVEUgdGhpcyBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGtleSB2YWx1ZSBpcyBhdmFpbGFibGUgbG9jYWxseS5cclxuXHQgKiBPdGhlcndpc2UsIHNpZ25lZCB0b2tlbiByZXF1ZXN0cyBtdXN0IGJlIG9idGFpbmVkIGZyb20gdGhlIGtleVxyXG5cdCAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cclxuXHQgKlxyXG5cdCAqIEBwYXJhbSBhdXRoT3B0aW9uc1xyXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XHJcblx0ICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgYSBrZXkgcGFzc2VkIGluIGNvbnN0cnVjdGluZ1xyXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxyXG5cdCAqXHJcblx0ICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcclxuXHQgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XHJcblx0ICpcclxuXHQgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxyXG5cdCAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3RcclxuXHQgKlxyXG5cdCAqIEBwYXJhbSB0b2tlblBhcmFtc1xyXG5cdCAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxyXG5cdCAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXHJcblx0ICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxyXG5cdCAqICAgICAgICAgICAgICAgICAgZXhjZWVlZGluZyB0aGF0IGxpZmV0aW1lIHdpbGwgYmUgcmVqZWN0ZWQgd2l0aCBhbiBlcnJvci5cclxuXHQgKlxyXG5cdCAqIC0gY2FwYWJpbGl0eTogICAgKG9wdGlvbmFsKSB0aGUgY2FwYWJpbGl0eSB0byBhc3NvY2lhdGUgd2l0aCB0aGUgYWNjZXNzIHRva2VuLlxyXG5cdCAqICAgICAgICAgICAgICAgICAgSWYgbm9uZSBpcyBzcGVjaWZpZWQsIGEgdG9rZW4gd2lsbCBiZSByZXF1ZXN0ZWQgd2l0aCBhbGwgb2YgdGhlXHJcblx0ICogICAgICAgICAgICAgICAgICBjYXBhYmlsaXRpZXMgb2YgdGhlIHNwZWNpZmllZCBrZXkuXHJcblx0ICpcclxuXHQgKiAtIGNsaWVudElkOiAgICAgIChvcHRpb25hbCkgYSBjbGllbnQgSWQgdG8gYXNzb2NpYXRlIHdpdGggdGhlIHRva2VuOyBpZiBub3RcclxuXHQgKiAgICAgICAgICAgICAgICAgIHNwZWNpZmllZCwgYSBjbGllbnRJZCBwYXNzZWQgaW4gY29uc3RydWN0aW5nIHRoZSBSZXN0IGludGVyZmFjZSB3aWxsIGJlIHVzZWRcclxuXHQgKlxyXG5cdCAqIC0gdGltZXN0YW1wOiAgICAgKG9wdGlvbmFsKSB0aGUgdGltZSBpbiBtcyBzaW5jZSB0aGUgZXBvY2guIElmIG5vbmUgaXMgc3BlY2lmaWVkLFxyXG5cdCAqICAgICAgICAgICAgICAgICAgdGhlIHN5c3RlbSB3aWxsIGJlIHF1ZXJpZWQgZm9yIGEgdGltZSB2YWx1ZSB0byB1c2UuXHJcblx0ICpcclxuXHQgKi9cclxuXHRBdXRoLnByb3RvdHlwZS5jcmVhdGVUb2tlblJlcXVlc3QgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0XHQvKiBzaHVmZmxlIGFuZCBub3JtYWxpc2UgYXJndW1lbnRzIGFzIG5lY2Vzc2FyeSAqL1xyXG5cdFx0aWYodHlwZW9mKHRva2VuUGFyYW1zKSA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xyXG5cdFx0XHRjYWxsYmFjayA9IHRva2VuUGFyYW1zO1xyXG5cdFx0XHRhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcclxuXHRcdH0gZWxzZSBpZih0eXBlb2YoYXV0aE9wdGlvbnMpID09ICdmdW5jdGlvbicgJiYgIWNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XHJcblx0XHRcdGF1dGhPcHRpb25zID0gbnVsbDtcclxuXHRcdH1cclxuXHRcdGlmKCFjYWxsYmFjayAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2NyZWF0ZVRva2VuUmVxdWVzdCcsIGFyZ3VtZW50cyk7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogUlNBOWg6IGlmIGF1dGhPcHRpb25zIHBhc3NlZCBpbiwgdGhleSdyZSB1c2VkIGluc3RlYWQgb2Ygc3RvcmVkLCBkb24ndCBtZXJnZSB0aGVtICovXHJcblx0XHRhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XHJcblx0XHR0b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zIHx8IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNvcHkodGhpcy50b2tlblBhcmFtcyk7XHJcblxyXG5cdFx0dmFyIGtleSA9IGF1dGhPcHRpb25zLmtleTtcclxuXHRcdGlmKCFrZXkpIHtcclxuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnTm8ga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGtleVBhcnRzID0ga2V5LnNwbGl0KCc6JyksXHJcblx0XHRcdGtleU5hbWUgPSBrZXlQYXJ0c1swXSxcclxuXHRcdFx0a2V5U2VjcmV0ID0ga2V5UGFydHNbMV07XHJcblxyXG5cdFx0aWYoIWtleVNlY3JldCkge1xyXG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdJbnZhbGlkIGtleSBzcGVjaWZpZWQnLCA0MDEwMSwgNDAzKSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0b2tlblBhcmFtcy5jbGllbnRJZCA9PT0gJycpIHtcclxuXHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgY2Fu4oCZdCBiZSBhbiBlbXB0eSBzdHJpbmcnLCA0MDAxMiwgNDAwKSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZignY2FwYWJpbGl0eScgaW4gdG9rZW5QYXJhbXMpIHtcclxuXHRcdFx0dG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHJlcXVlc3QgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7IGtleU5hbWU6IGtleU5hbWUgfSwgdG9rZW5QYXJhbXMpLFxyXG5cdFx0XHRjbGllbnRJZCA9IHRva2VuUGFyYW1zLmNsaWVudElkIHx8ICcnLFxyXG5cdFx0XHR0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgJycsXHJcblx0XHRcdGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8ICcnLFxyXG5cdFx0XHRzZWxmID0gdGhpcztcclxuXHJcblx0XHQoZnVuY3Rpb24oYXV0aG9yaXNlQ2IpIHtcclxuXHRcdFx0aWYocmVxdWVzdC50aW1lc3RhbXApIHtcclxuXHRcdFx0XHRhdXRob3Jpc2VDYigpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fTtcclxuXHRcdFx0c2VsZi5nZXRUaW1lc3RhbXAoYXV0aE9wdGlvbnMgJiYgYXV0aE9wdGlvbnMucXVlcnlUaW1lLCBmdW5jdGlvbihlcnIsIHRpbWUpIHtcclxuXHRcdFx0XHRpZihlcnIpIHtjYWxsYmFjayhlcnIpOyByZXR1cm47fVxyXG5cdFx0XHRcdHJlcXVlc3QudGltZXN0YW1wID0gdGltZTtcclxuXHRcdFx0XHRhdXRob3Jpc2VDYigpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0pKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHQvKiBub25jZSAqL1xyXG5cdFx0XHQvKiBOT1RFOiB0aGVyZSBpcyBubyBleHBlY3RhdGlvbiB0aGF0IHRoZSBjbGllbnRcclxuXHRcdFx0ICogc3BlY2lmaWVzIHRoZSBub25jZTsgdGhpcyBpcyBkb25lIGJ5IHRoZSBsaWJyYXJ5XHJcblx0XHRcdCAqIEhvd2V2ZXIsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gYnkgdGhlIGNsaWVudFxyXG5cdFx0XHQgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXHJcblx0XHRcdHZhciBub25jZSA9IHJlcXVlc3Qubm9uY2UgfHwgKHJlcXVlc3Qubm9uY2UgPSByYW5kb20oKSksXHJcblx0XHRcdFx0dGltZXN0YW1wID0gcmVxdWVzdC50aW1lc3RhbXA7XHJcblxyXG5cdFx0XHR2YXIgc2lnblRleHRcclxuXHRcdFx0PVx0cmVxdWVzdC5rZXlOYW1lICsgJ1xcbidcclxuXHRcdFx0K1x0dHRsICsgJ1xcbidcclxuXHRcdFx0K1x0Y2FwYWJpbGl0eSArICdcXG4nXHJcblx0XHRcdCtcdGNsaWVudElkICsgJ1xcbidcclxuXHRcdFx0K1x0dGltZXN0YW1wICsgJ1xcbidcclxuXHRcdFx0K1x0bm9uY2UgKyAnXFxuJztcclxuXHJcblx0XHRcdC8qIG1hYyAqL1xyXG5cdFx0XHQvKiBOT1RFOiB0aGVyZSBpcyBubyBleHBlY3RhdGlvbiB0aGF0IHRoZSBjbGllbnRcclxuXHRcdFx0ICogc3BlY2lmaWVzIHRoZSBtYWM7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxyXG5cdFx0XHQgKiBIb3dldmVyLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcclxuXHRcdFx0ICogc2ltcGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLiAqL1xyXG5cdFx0XHRyZXF1ZXN0Lm1hYyA9IHJlcXVlc3QubWFjIHx8IGhtYWMoc2lnblRleHQsIGtleVNlY3JldCk7XHJcblxyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuUmVxdWVzdCgpJywgJ2dlbmVyYXRlZCBzaWduZWQgcmVxdWVzdCcpO1xyXG5cdFx0XHRjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIEdldCB0aGUgYXV0aCBxdWVyeSBwYXJhbXMgdG8gdXNlIGZvciBhIHdlYnNvY2tldCBjb25uZWN0aW9uLFxyXG5cdCAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xyXG5cdCAqL1xyXG5cdEF1dGgucHJvdG90eXBlLmdldEF1dGhQYXJhbXMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0aWYodGhpcy5tZXRob2QgPT0gJ2Jhc2ljJylcclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwge2tleTogdGhpcy5rZXl9KTtcclxuXHRcdGVsc2VcclxuXHRcdFx0dGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XHJcblx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB7YWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW59KTtcclxuXHRcdFx0fSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxyXG5cdCAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xyXG5cdCAqL1xyXG5cdEF1dGgucHJvdG90eXBlLmdldEF1dGhIZWFkZXJzID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdGlmKHRoaXMubWV0aG9kID09ICdiYXNpYycpIHtcclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwge2F1dGhvcml6YXRpb246ICdCYXNpYyAnICsgdGhpcy5iYXNpY0tleX0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGZ1bmN0aW9uKGVyciwgdG9rZW5EZXRhaWxzKSB7XHJcblx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB7YXV0aG9yaXphdGlvbjogJ0JlYXJlciAnICsgdG9CYXNlNjQodG9rZW5EZXRhaWxzLnRva2VuKX0pO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBHZXQgdGhlIGN1cnJlbnQgdGltZSBiYXNlZCBvbiB0aGUgbG9jYWwgY2xvY2ssXHJcblx0ICogb3IgaWYgdGhlIG9wdGlvbiBxdWVyeVRpbWUgaXMgdHJ1ZSwgcmV0dXJuIHRoZSBzZXJ2ZXIgdGltZS5cclxuXHQgKiBUaGUgc2VydmVyIHRpbWUgb2Zmc2V0IGZyb20gdGhlIGxvY2FsIHRpbWUgaXMgc3RvcmVkIHNvIHRoYXRcclxuXHQgKiBvbmx5IG9uZSByZXF1ZXN0IHRvIHRoZSBzZXJ2ZXIgdG8gZ2V0IHRoZSB0aW1lIGlzIGV2ZXIgbmVlZGVkXHJcblx0ICovXHJcblx0QXV0aC5wcm90b3R5cGUuZ2V0VGltZXN0YW1wID0gZnVuY3Rpb24ocXVlcnlUaW1lLCBjYWxsYmFjaykge1xyXG5cdFx0aWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpICYmIChxdWVyeVRpbWUgfHwgdGhpcy5hdXRoT3B0aW9ucy5xdWVyeVRpbWUpKSB7XHJcblx0XHRcdHRoaXMuY2xpZW50LnRpbWUoY2FsbGJhY2spO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRBdXRoLnByb3RvdHlwZS5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vdygpICsgKHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgfHwgMCk7XHJcblx0fTtcclxuXHJcblx0QXV0aC5wcm90b3R5cGUuaXNUaW1lT2Zmc2V0U2V0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5jbGllbnQuc2VydmVyVGltZU9mZnNldCAhPT0gbnVsbDtcclxuXHR9O1xyXG5cclxuXHRBdXRoLnByb3RvdHlwZS5fc2F2ZUJhc2ljT3B0aW9ucyA9IGZ1bmN0aW9uKGF1dGhPcHRpb25zKSB7XHJcblx0XHR0aGlzLm1ldGhvZCA9ICdiYXNpYyc7XHJcblx0XHR0aGlzLmtleSA9IGF1dGhPcHRpb25zLmtleTtcclxuXHRcdHRoaXMuYmFzaWNLZXkgPSB0b0Jhc2U2NChhdXRoT3B0aW9ucy5rZXkpO1xyXG5cdFx0dGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHt9O1xyXG5cdFx0aWYoJ2NsaWVudElkJyBpbiBhdXRoT3B0aW9ucykge1xyXG5cdFx0XHR0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0QXV0aC5wcm90b3R5cGUuX3NhdmVUb2tlbk9wdGlvbnMgPSBmdW5jdGlvbih0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpIHtcclxuXHRcdHRoaXMubWV0aG9kID0gJ3Rva2VuJztcclxuXHJcblx0XHRpZih0b2tlblBhcmFtcykge1xyXG5cdFx0XHQvKiBXZSB0ZW1wb3JhcmlseSBwZXJzaXN0IHRva2VuUGFyYW1zLnRpbWVzdGFtcCBpbiBjYXNlIGEgbmV3IHRva2VuIG5lZWRzXHJcblx0XHRcdCAqIHRvIGJlIHJlcXVlc3RlZCwgdGhlbiBudWxsIGl0IG91dCBpbiB0aGUgY2FsbGJhY2sgb2ZcclxuXHRcdFx0ICogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIGZvciBSU0ExMGcgY29tcGxpYW5jZSAqL1xyXG5cdFx0XHR0aGlzLnRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXM7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoYXV0aE9wdGlvbnMpIHtcclxuXHRcdFx0Lyogbm9ybWFsaXNlICovXHJcblx0XHRcdGlmKGF1dGhPcHRpb25zLnRva2VuKSB7XHJcblx0XHRcdFx0Lyogb3B0aW9ucy50b2tlbiBtYXkgY29udGFpbiBhIHRva2VuIHN0cmluZyBvciwgZm9yIGNvbnZlbmllbmNlLCBhIFRva2VuRGV0YWlscyAqL1xyXG5cdFx0XHRcdGF1dGhPcHRpb25zLnRva2VuRGV0YWlscyA9ICh0eXBlb2YoYXV0aE9wdGlvbnMudG9rZW4pID09PSAnc3RyaW5nJykgPyB7dG9rZW46IGF1dGhPcHRpb25zLnRva2VufSA6IGF1dGhPcHRpb25zLnRva2VuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihhdXRoT3B0aW9ucy50b2tlbkRldGFpbHMpIHtcclxuXHRcdFx0XHR0aGlzLnRva2VuRGV0YWlscyA9IGF1dGhPcHRpb25zLnRva2VuRGV0YWlscztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoJ2NsaWVudElkJyBpbiBhdXRoT3B0aW9ucykge1xyXG5cdFx0XHRcdHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucztcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxyXG5cdCAqIHByb2dyZXNzLCBtYWtpbmcgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHdhaXQgZm9yIHRoZSBuZXcgb25lICovXHJcblx0QXV0aC5wcm90b3R5cGUuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24oZm9yY2VTdXBlcnNlZGUsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXMsXHJcblx0XHRcdHRva2VuID0gdGhpcy50b2tlbkRldGFpbHM7XHJcblxyXG5cdFx0aWYodG9rZW4pIHtcclxuXHRcdFx0aWYodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuLmNsaWVudElkKSkge1xyXG5cdFx0XHRcdC8qIDQwMyB0byB0cmlnZ2VyIGEgcGVybWFuZW50bHkgZmFpbGVkIGNsaWVudCAtIFJTQTE1YyAqL1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ01pc21hdGNoIGJldHdlZW4gY2xpZW50SWQgaW4gdG9rZW4gKCcgKyB0b2tlbi5jbGllbnRJZCArICcpIGFuZCBjdXJyZW50IGNsaWVudElkICgnICsgdGhpcy5jbGllbnRJZCArICcpJywgNDAxMDIsIDQwMykpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKiBSU0E0YjEgLS0gaWYgd2UgaGF2ZSBhIHNlcnZlciB0aW1lIG9mZnNldCBzZXQgYWxyZWFkeSwgd2UgY2FuXHJcblx0XHRcdCAqIGF1dG9yZW1vdmUgZXhwaXJlZCB0b2tlbnMuIEVsc2UganVzdCB1c2UgdGhlIGNhY2hlZCB0b2tlbi4gSWYgaXQgaXNcclxuXHRcdFx0ICogZXhwaXJlZCBBYmx5IHdpbGwgdGVsbCB1cyBhbmQgd2UnbGwgZGlzY2FyZCBpdCB0aGVuLiAqL1xyXG5cdFx0XHRpZighdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSB8fCAhdG9rZW4uZXhwaXJlcyB8fCAodG9rZW4uZXhwaXJlcyA+PSB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpKSB7XHJcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ3VzaW5nIGNhY2hlZCB0b2tlbjsgZXhwaXJlcyA9ICcgKyB0b2tlbi5leHBpcmVzKTtcclxuXHRcdFx0XHRjYWxsYmFjayhudWxsLCB0b2tlbik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8qIGV4cGlyZWQsIHNvIHJlbW92ZSBhbmQgZmFsbHRocm91Z2ggdG8gZ2V0dGluZyBhIG5ldyBvbmUgKi9cclxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQXV0aC5nZXRUb2tlbigpJywgJ2RlbGV0aW5nIGV4cGlyZWQgdG9rZW4nKTtcclxuXHRcdFx0dGhpcy50b2tlbkRldGFpbHMgPSBudWxsO1xyXG5cdFx0fVxyXG5cclxuXHRcdCh0aGlzLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgfHwgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IE9iamVjdChtdWx0aWNhc3RlcltcImFcIiAvKiBkZWZhdWx0ICovXSkoKSkpLnB1c2goY2FsbGJhY2spO1xyXG5cdFx0aWYodGhpcy5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgIT09IG51bGwgJiYgIWZvcmNlU3VwZXJzZWRlKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBSZXF1ZXN0IGEgbmV3IHRva2VuICovXHJcblx0XHR2YXIgdG9rZW5SZXF1ZXN0SWQgPSB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IGdldFRva2VuUmVxdWVzdElkKCk7XHJcblx0XHR0aGlzLnJlcXVlc3RUb2tlbih0aGlzLnRva2VuUGFyYW1zLCB0aGlzLmF1dGhPcHRpb25zLCBmdW5jdGlvbihlcnIsIHRva2VuUmVzcG9uc2UpIHtcclxuXHRcdFx0aWYoc2VsZi5jdXJyZW50VG9rZW5SZXF1ZXN0SWQgPiB0b2tlblJlcXVlc3RJZCkge1xyXG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0F1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKCknLCAnRGlzY2FyZGluZyB0b2tlbiByZXF1ZXN0IHJlc3BvbnNlOyBvdmVydGFrZW4gYnkgbmV3ZXIgb25lJyk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHNlbGYuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcclxuXHRcdFx0dmFyIGNhbGxiYWNrcyA9IHNlbGYud2FpdGluZ0ZvclRva2VuUmVxdWVzdCB8fCBub29wO1xyXG5cdFx0XHRzZWxmLndhaXRpbmdGb3JUb2tlblJlcXVlc3QgPSBudWxsO1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRjYWxsYmFja3MoZXJyKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2tzKG51bGwsIChzZWxmLnRva2VuRGV0YWlscyA9IHRva2VuUmVzcG9uc2UpKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cclxuXHQvKiBVc2VyLXNldDogY2hlY2sgdHlwZXMsICcqJyBpcyBkaXNhbGxvd2VkLCB0aHJvdyBhbnkgZXJyb3JzICovXHJcblx0QXV0aC5wcm90b3R5cGUuX3VzZXJTZXRDbGllbnRJZCA9IGZ1bmN0aW9uKGNsaWVudElkKSB7XHJcblx0XHRpZighKHR5cGVvZihjbGllbnRJZCkgPT09ICdzdHJpbmcnIHx8IGNsaWVudElkID09PSBudWxsKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XHJcblx0XHR9IGVsc2UgaWYoY2xpZW50SWQgPT09ICcqJykge1xyXG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDYW7igJl0IHVzZSBcIipcIiBhcyBhIGNsaWVudElkIGFzIHRoYXQgc3RyaW5nIGlzIHJlc2VydmVkLiAoVG8gY2hhbmdlIHRoZSBkZWZhdWx0IHRva2VuIHJlcXVlc3QgYmVoYXZpb3VyIHRvIHVzZSBhIHdpbGRjYXJkIGNsaWVudElkLCBpbnN0YW50aWF0ZSB0aGUgbGlicmFyeSB3aXRoIHtkZWZhdWx0VG9rZW5QYXJhbXM6IHtjbGllbnRJZDogXCIqXCJ9fSksIG9yIGlmIGNhbGxpbmcgYXV0aG9yaXplKCksIHBhc3MgaXQgaW4gYXMgYSB0b2tlblBhcmFtOiBhdXRob3JpemUoe2NsaWVudElkOiBcIipcIn0sIGF1dGhPcHRpb25zKScsIDQwMDEyLCA0MDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dmFyIGVyciA9IHRoaXMuX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcclxuXHRcdFx0aWYoZXJyKSB0aHJvdyBlcnI7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyogQWJseS1zZXQ6IG5vIHR5cGVjaGVja2luZywgJyonIGlzIGFsbG93ZWQgYnV0IG5vdCBzZXQgb24gdGhpcy5jbGllbnRJZCksIHJldHVybiBlcnJvcnMgdG8gdGhlIGNhbGxlciAqL1xyXG5cdEF1dGgucHJvdG90eXBlLl91bmNoZWNrZWRTZXRDbGllbnRJZCA9IGZ1bmN0aW9uKGNsaWVudElkKSB7XHJcblx0XHRpZih0aGlzLl90b2tlbkNsaWVudElkTWlzbWF0Y2goY2xpZW50SWQpKSB7XHJcblx0XHRcdC8qIFNob3VsZCBuZXZlciBoYXBwZW4gaW4gbm9ybWFsIGNpcmN1bXN0YW5jZXMgYXMgcmVhbHRpbWUgc2hvdWxkXHJcblx0XHRcdCAqIHJlY29nbmlzZSBtaXNtYXRjaCBhbmQgcmV0dXJuIGFuIGVycm9yICovXHJcblx0XHRcdHZhciBtc2cgPSAnVW5leHBlY3RlZCBjbGllbnRJZCBtaXNtYXRjaDogY2xpZW50IGhhcyAnICsgdGhpcy5jbGllbnRJZCArICcsIHJlcXVlc3RlZCAnICsgY2xpZW50SWQ7XHJcblx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgNDAxMDIsIDQwMSk7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0F1dGguX3VuY2hlY2tlZFNldENsaWVudElkKCknLCBtc2cpO1xyXG5cdFx0XHRyZXR1cm4gZXJyO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0LyogUlNBN2E0OiBpZiBvcHRpb25zLmNsaWVudElkIGlzIHByb3ZpZGVkIGFuZCBpcyBub3RcclxuXHRcdFx0ICogbnVsbCwgaXQgb3ZlcnJpZGVzIGRlZmF1bHRUb2tlblBhcmFtcy5jbGllbnRJZCAqL1xyXG5cdFx0XHR0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRBdXRoLnByb3RvdHlwZS5fdG9rZW5DbGllbnRJZE1pc21hdGNoID0gZnVuY3Rpb24odG9rZW5DbGllbnRJZCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuY2xpZW50SWQgJiZcclxuXHRcdFx0KHRoaXMuY2xpZW50SWQgIT09ICcqJykgJiZcclxuXHRcdFx0dG9rZW5DbGllbnRJZCAmJlxyXG5cdFx0XHQodG9rZW5DbGllbnRJZCAhPT0gJyonKSAmJlxyXG5cdFx0XHQodGhpcy5jbGllbnRJZCAhPT0gdG9rZW5DbGllbnRJZCk7XHJcblx0fTtcclxuXHJcblx0QXV0aC5pc1Rva2VuRXJyID0gZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdHJldHVybiBlcnJvci5jb2RlICYmIChlcnJvci5jb2RlID49IDQwMTQwKSAmJiAoZXJyb3IuY29kZSA8IDQwMTUwKTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gQXV0aDtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGF1dGggPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChhdXRoX0F1dGgpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIENvbWV0VHJhbnNwb3J0ID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHR2YXIgUkVRX1NFTkQgPSAwLFxyXG5cdFx0UkVRX1JFQ1YgPSAxLFxyXG5cdFx0UkVRX1JFQ1ZfUE9MTCA9IDIsXHJcblx0XHRSRVFfUkVDVl9TVFJFQU0gPSAzO1xyXG5cclxuXHQvKiBUT0RPOiBjYW4gcmVtb3ZlIG9uY2UgcmVhbHRpbWUgc2VuZHMgcHJvdG9jb2wgbWVzc2FnZSByZXNwb25zZXMgZm9yIGNvbWV0IGVycm9ycyAqL1xyXG5cdGZ1bmN0aW9uIHNob3VsZEJlRXJyb3JBY3Rpb24oZXJyKSB7XHJcblx0XHR2YXIgVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTID0gWzgwMDE1LCA4MDAxNywgODAwMzBdO1xyXG5cdFx0aWYoZXJyLmNvZGUpIHtcclxuXHRcdFx0aWYoX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihlcnIpKSByZXR1cm4gZmFsc2U7XHJcblx0XHRcdGlmKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4oVU5SRVNPTFZBQkxFX0VSUk9SX0NPREVTLCBlcnIuY29kZSkpIHJldHVybiB0cnVlO1xyXG5cdFx0XHRyZXR1cm4gKGVyci5jb2RlID49IDQwMDAwICYmIGVyci5jb2RlIDwgNTAwMDApO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0LyogTGlrZWx5IGEgbmV0d29yayBvciB0cmFuc3BvcnQgZXJyb3Igb2Ygc29tZSBraW5kLiBDZXJ0YWlubHkgbm90IGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpIHtcclxuXHRcdC8qIGVyciB3aWxsIGJlIGVpdGhlciBhIGxlZ2FjeSAobm9uLXByb3RvY29sbWVzc2FnZSkgY29tZXQgZXJyb3IgcmVzcG9uc2VcclxuXHRcdCAqICh3aGljaCB3aWxsIGhhdmUgYW4gZXJyLmNvZGUpLCBvciBhIHhoci9uZXR3b3JrIGVycm9yICh3aGljaCB3b24ndCkuICovXHJcblx0XHRpZihzaG91bGRCZUVycm9yQWN0aW9uKGVycikpIHtcclxuXHRcdFx0cmV0dXJuIFtfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uLkVSUk9SLCBlcnJvcjogZXJyfSldO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIFtfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7YWN0aW9uOiBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uLkRJU0NPTk5FQ1RFRCwgZXJyb3I6IGVycn0pXTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdC8qXHJcblx0ICogQSBiYXNlIGNvbWV0IHRyYW5zcG9ydCBjbGFzc1xyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIENvbWV0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcclxuXHRcdC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCwgc28ganVzdCBmYWxsIGJhY2sgdG8gZGVmYXVsdCAqL1xyXG5cdFx0cGFyYW1zLmZvcm1hdCA9IHVuZGVmaW5lZDtcclxuXHRcdHBhcmFtcy5oZWFydGJlYXRzID0gdHJ1ZTtcclxuXHRcdF90cmFuc3BvcnRfdHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcclxuXHRcdC8qIHN0cmVhbWluZyBkZWZhdWx0cyB0byB0cnVlICovXHJcblx0XHR0aGlzLnN0cmVhbSA9ICgnc3RyZWFtJyBpbiBwYXJhbXMpID8gcGFyYW1zLnN0cmVhbSA6IHRydWU7XHJcblx0XHR0aGlzLnNlbmRSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdHRoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xyXG5cdFx0dGhpcy5wZW5kaW5nQ2FsbGJhY2sgPSBudWxsO1xyXG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xyXG5cdH1cclxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKENvbWV0VHJhbnNwb3J0LCBfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcclxuXHJcblx0Q29tZXRUcmFuc3BvcnQuUkVRX1NFTkQgPSBSRVFfU0VORDtcclxuXHRDb21ldFRyYW5zcG9ydC5SRVFfUkVDViA9IFJFUV9SRUNWO1xyXG5cdENvbWV0VHJhbnNwb3J0LlJFUV9SRUNWX1BPTEwgPSBSRVFfUkVDVl9QT0xMO1xyXG5cdENvbWV0VHJhbnNwb3J0LlJFUV9SRUNWX1NUUkVBTSA9IFJFUV9SRUNWX1NUUkVBTTtcclxuXHJcblx0LyogcHVibGljIGluc3RhbmNlIG1ldGhvZHMgKi9cclxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xyXG5cdFx0X3RyYW5zcG9ydF90cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBwYXJhbXMgPSB0aGlzLnBhcmFtcywgb3B0aW9ucyA9IHBhcmFtcy5vcHRpb25zO1xyXG5cdFx0dmFyIGhvc3QgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3Qob3B0aW9ucywgcGFyYW1zLmhvc3QpO1xyXG5cdFx0dmFyIHBvcnQgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFBvcnQob3B0aW9ucyk7XHJcblx0XHR2YXIgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XHJcblxyXG5cdFx0dGhpcy5iYXNlVXJpID0gY29tZXRTY2hlbWUgKyBob3N0ICsgJzonICsgcG9ydCArICcvY29tZXQvJztcclxuXHRcdHZhciBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgJ2Nvbm5lY3QnO1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyBjb25uZWN0VXJpKTtcclxuXHRcdHRoaXMuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoc2VsZi5pc0Rpc3Bvc2VkKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHNlbGYuYXV0aFBhcmFtcyA9IGF1dGhQYXJhbXM7XHJcblx0XHRcdHZhciBjb25uZWN0UGFyYW1zID0gc2VsZi5wYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcclxuXHRcdFx0aWYoJ3N0cmVhbScgaW4gY29ubmVjdFBhcmFtcykgc2VsZi5zdHJlYW0gPSBjb25uZWN0UGFyYW1zLnN0cmVhbTtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdjb25uZWN0UGFyYW1zOicgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcykpO1xyXG5cclxuXHRcdFx0LyogdGhpcyB3aWxsIGJlIHRoZSAncmVjdlJlcXVlc3QnIHNvIHRoaXMgY29ubmVjdGlvbiBjYW4gc3RyZWFtIG1lc3NhZ2VzICovXHJcblx0XHRcdHZhciBwcmVjb25uZWN0ZWQgPSBmYWxzZSxcclxuXHRcdFx0XHRjb25uZWN0UmVxdWVzdCA9IHNlbGYucmVjdlJlcXVlc3QgPSBzZWxmLmNyZWF0ZVJlcXVlc3QoY29ubmVjdFVyaSwgbnVsbCwgY29ubmVjdFBhcmFtcywgbnVsbCwgKHNlbGYuc3RyZWFtID8gUkVRX1JFQ1ZfU1RSRUFNIDogUkVRX1JFQ1YpKTtcclxuXHJcblx0XHRcdGNvbm5lY3RSZXF1ZXN0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xyXG5cdFx0XHRcdGlmKCFzZWxmLnJlY3ZSZXF1ZXN0KSB7XHJcblx0XHRcdFx0XHQvKiB0aGUgdHJhbnNwb3J0IHdhcyBkaXNwb3NlZCBiZWZvcmUgd2UgY29ubmVjdGVkICovXHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCFwcmVjb25uZWN0ZWQpIHtcclxuXHRcdFx0XHRcdHByZWNvbm5lY3RlZCA9IHRydWU7XHJcblx0XHRcdFx0XHRzZWxmLmVtaXQoJ3ByZWNvbm5lY3QnKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0c2VsZi5vbkRhdGEoZGF0YSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRjb25uZWN0UmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIF9ib2R5LCBoZWFkZXJzKSB7XHJcblx0XHRcdFx0aWYoIXNlbGYucmVjdlJlcXVlc3QpIHtcclxuXHRcdFx0XHRcdC8qIHRoZSB0cmFuc3BvcnQgd2FzIGRpc3Bvc2VkIGJlZm9yZSB3ZSBjb25uZWN0ZWQgKi9cclxuXHRcdFx0XHRcdGVyciA9IGVyciB8fCBuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdSZXF1ZXN0IGNhbmNlbGxlZCcsIDgwMDAzLCA0MDApO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzZWxmLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcclxuXHRcdFx0XHQvKiBDb25uZWN0IHJlcXVlc3QgbWF5IGNvbXBsZXRlIHdpdGhvdXQgYSBlbWl0dGluZyAnZGF0YScgZXZlbnQgc2luY2UgdGhhdCBpcyBub3RcclxuXHRcdFx0XHQgKiBlbWl0dGVkIGZvciBlLmcuIGEgbm9uLXN0cmVhbWVkIGVycm9yIHJlc3BvbnNlLiBTdGlsbCBpbXBsaWVzIHByZWNvbm5lY3QuICovXHJcblx0XHRcdFx0aWYoIXByZWNvbm5lY3RlZCAmJiAhZXJyKSB7XHJcblx0XHRcdFx0XHRwcmVjb25uZWN0ZWQgPSB0cnVlO1xyXG5cdFx0XHRcdFx0c2VsZi5lbWl0KCdwcmVjb25uZWN0Jyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHNlbGYub25BY3Rpdml0eSgpO1xyXG5cdFx0XHRcdGlmKGVycikge1xyXG5cdFx0XHRcdFx0aWYoZXJyLmNvZGUpIHtcclxuXHRcdFx0XHRcdFx0LyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXHJcblx0XHRcdFx0XHRcdCAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXHJcblx0XHRcdFx0XHRcdCAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cclxuXHRcdFx0XHRcdFx0c2VsZi5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0LyogQSBuZXR3b3JrL3hociBlcnJvci4gRG9uJ3QgYm90aGVyIHdyYXBwaW5nIGluIGEgcHJvdG9jb2wgbWVzc2FnZSxcclxuXHRcdFx0XHRcdFx0ICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cclxuXHRcdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRzZWxmLnJlY3YoKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0fSk7XHJcblx0XHRcdGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0Q2xvc2UgPSBmdW5jdGlvbigpIHtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKScpO1xyXG5cdFx0dGhpcy5fcmVxdWVzdENsb3NlT3JEaXNjb25uZWN0KHRydWUpO1xyXG5cdH07XHJcblxyXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3REaXNjb25uZWN0KCknKTtcclxuXHRcdHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdChmYWxzZSk7XHJcblx0fTtcclxuXHJcblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLl9yZXF1ZXN0Q2xvc2VPckRpc2Nvbm5lY3QgPSBmdW5jdGlvbihjbG9zaW5nKSB7XHJcblx0XHR2YXIgY2xvc2VPckRpc2Nvbm5lY3RVcmkgPSBjbG9zaW5nID8gdGhpcy5jbG9zZVVyaSA6IHRoaXMuZGlzY29ubmVjdFVyaTtcclxuXHRcdGlmKGNsb3NlT3JEaXNjb25uZWN0VXJpKSB7XHJcblx0XHRcdHZhciBzZWxmID0gdGhpcyxcclxuXHRcdFx0XHRyZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFJFUV9TRU5EKTtcclxuXHJcblx0XHRcdHJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVycikge1xyXG5cdFx0XHRcdGlmKGVycikge1xyXG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3QnICsgKGNsb3NpbmcgPyAnQ2xvc2UoKScgOiAnRGlzY29ubmVjdCgpJyksICdyZXF1ZXN0IHJldHVybmVkIGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcclxuXHRcdFx0XHRcdHNlbGYuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHRcdHJlcXVlc3QuZXhlYygpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29tZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xyXG5cdFx0aWYoIXRoaXMuaXNEaXNwb3NlZCkge1xyXG5cdFx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xyXG5cdFx0XHRpZih0aGlzLnJlY3ZSZXF1ZXN0KSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdhYm9ydGluZyByZWN2IHJlcXVlc3QnKTtcclxuXHRcdFx0XHR0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XHJcblx0XHRcdFx0dGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XHJcblx0XHRcdH1cclxuXHRcdFx0LyogSW4gYWxtb3N0IGFsbCBjYXNlcyB0aGUgdHJhbnNwb3J0IHdpbGwgYmUgZmluaXNoZWQgYmVmb3JlIGl0J3NcclxuXHRcdFx0ICogZGlzcG9zZWQuIEZpbmlzaCBoZXJlIGp1c3QgdG8gbWFrZSBzdXJlLiAqL1xyXG5cdFx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgX2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRpc2Nvbm5lY3RlZCk7XHJcblx0XHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzZWxmLmVtaXQoJ2Rpc3Bvc2VkJyk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHQvKiBpZiB0aGlzIHRyYW5zcG9ydCBoYXMgYmVlbiBkaXNwb3NlZCB3aGlsc3QgYXdhaXRpbmcgY29ubmVjdGlvbiwgZG8gbm90aGluZyAqL1xyXG5cdFx0aWYodGhpcy5pc0Rpc3Bvc2VkKSB7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHQvKiB0aGUgY29ubmVjdGlvbktleSBpbiBhIGNvbWV0IGNvbm5lY3RlZCByZXNwb25zZSBpcyByZWFsbHlcclxuXHRcdCAqIDxpbnN0SWQ+LTxjb25uZWN0aW9uS2V5PiAqL1xyXG5cdFx0dmFyIGNvbm5lY3Rpb25TdHIgPSBtZXNzYWdlLmNvbm5lY3Rpb25LZXk7XHJcblx0XHRfdHJhbnNwb3J0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnByb3RvdHlwZS5vbkNvbm5lY3QuY2FsbCh0aGlzLCBtZXNzYWdlKTtcclxuXHJcblx0XHR2YXIgYmFzZUNvbm5lY3Rpb25VcmkgPSAgdGhpcy5iYXNlVXJpICsgY29ubmVjdGlvblN0cjtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb21ldFRyYW5zcG9ydC5vbkNvbm5lY3QoKScsICdiYXNlVXJpID0gJyArIGJhc2VDb25uZWN0aW9uVXJpICsgJzsgY29ubmVjdGlvbktleSA9ICcgKyBtZXNzYWdlLmNvbm5lY3Rpb25LZXkpO1xyXG5cdFx0dGhpcy5zZW5kVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3NlbmQnO1xyXG5cdFx0dGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3JlY3YnO1xyXG5cdFx0dGhpcy5jbG9zZVVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9jbG9zZSc7XHJcblx0XHR0aGlzLmRpc2Nvbm5lY3RVcmkgPSBiYXNlQ29ubmVjdGlvblVyaSArICcvZGlzY29ubmVjdCc7XHJcblx0fTtcclxuXHJcblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHRpZih0aGlzLnNlbmRSZXF1ZXN0KSB7XHJcblx0XHRcdC8qIHRoZXJlIGlzIGEgcGVuZGluZyBzZW5kLCBzbyBxdWV1ZSB0aGlzIG1lc3NhZ2UgKi9cclxuXHRcdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcclxuXHRcdFx0dGhpcy5wZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0Lyogc2VuZCB0aGlzLCBwbHVzIGFueSBwZW5kaW5nLCBub3cgKi9cclxuXHRcdHZhciBwZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcclxuXHRcdHBlbmRpbmdJdGVtcy5wdXNoKG1lc3NhZ2UpO1xyXG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc2VuZEl0ZW1zKHBlbmRpbmdJdGVtcyk7XHJcblx0fTtcclxuXHJcblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRBbnlQZW5kaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXM7XHJcblxyXG5cdFx0aWYoIXBlbmRpbmdJdGVtcykge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xyXG5cdFx0dGhpcy5zZW5kSXRlbXMocGVuZGluZ0l0ZW1zKTtcclxuXHR9XHJcblxyXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5zZW5kSXRlbXMgPSBmdW5jdGlvbihpdGVtcykge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxyXG5cdFx0XHRzZW5kUmVxdWVzdCA9IHRoaXMuc2VuZFJlcXVlc3QgPSBzZWxmLmNyZWF0ZVJlcXVlc3Qoc2VsZi5zZW5kVXJpLCBudWxsLCBzZWxmLmF1dGhQYXJhbXMsIHRoaXMuZW5jb2RlUmVxdWVzdChpdGVtcyksIFJFUV9TRU5EKTtcclxuXHJcblx0XHRzZW5kUmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIGRhdGEpIHtcclxuXHRcdFx0aWYoZXJyKSBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQuc2VuZEl0ZW1zKCknLCAnb24gY29tcGxldGU6IGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcclxuXHRcdFx0c2VsZi5zZW5kUmVxdWVzdCA9IG51bGw7XHJcblxyXG5cdFx0XHQvKiB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LCBldmVuIGlmIGEgbmFjaywgaXMgdXN1YWxseSBhIHByb3RvY29sIHJlc3BvbnNlXHJcblx0XHRcdCAqIGNvbnRhaW5lZCBpbiB0aGUgZGF0YS4gQW4gZXJyIGlzIGFub21vbG91cywgYW5kIGluZGljYXRlcyBzb21lIGlzc3VlIHdpdGggdGhlXHJcblx0XHRcdCAqIG5ldHdvcmssdHJhbnNwb3J0LCBvciBjb25uZWN0aW9uICovXHJcblx0XHRcdGlmKGVycikge1xyXG5cdFx0XHRcdGlmKGVyci5jb2RlKSB7XHJcblx0XHRcdFx0XHQvKiBBIHByb3RvY29sIGVycm9yIHJlY2VpdmVkIGZyb20gcmVhbHRpbWUuIFRPRE86IG9uY2UgcmVhbHRpbWVcclxuXHRcdFx0XHRcdCAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXHJcblx0XHRcdFx0XHQgKiBhYmxlIHRvIHJlbW92ZSB0aGlzICovXHJcblx0XHRcdFx0XHRzZWxmLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXHJcblx0XHRcdFx0XHQgKiBqdXN0IGRpc2Nvbm5lY3QgdGhlIHRyYW5zcG9ydCAqL1xyXG5cdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoZGF0YSkge1xyXG5cdFx0XHRcdHNlbGYub25EYXRhKGRhdGEpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihzZWxmLnBlbmRpbmdJdGVtcykge1xyXG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHQvKiBJZiB0aGVyZSdzIGEgbmV3IHNlbmQgcmVxdWVzdCBieSBub3csIGFueSBwZW5kaW5nIGl0ZW1zIHdpbGwgaGF2ZVxyXG5cdFx0XHRcdFx0ICogYmVlbiBwaWNrZWQgdXAgYnkgdGhhdDsgYW55IG5ldyBvbmVzIGFkZGVkIHNpbmNlIHRoZW4gd2lsbCBiZVxyXG5cdFx0XHRcdFx0ICogcGlja2VkIHVwIGFmdGVyIHRoYXQgb25lIGNvbXBsZXRlcyAqL1xyXG5cdFx0XHRcdFx0aWYoIXNlbGYuc2VuZFJlcXVlc3QpIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5zZW5kQW55UGVuZGluZygpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHRcdHNlbmRSZXF1ZXN0LmV4ZWMoKTtcclxuXHR9O1xyXG5cclxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVjdiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0LyogZG8gbm90aGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgcmVxdWVzdCwgd2hpY2ggbWlnaHQgYmUgc3RyZWFtaW5nICovXHJcblx0XHRpZih0aGlzLnJlY3ZSZXF1ZXN0KVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0LyogSWYgd2UncmUgbm8gbG9uZ2VyIGNvbm5lY3RlZCwgZG8gbm90aGluZyAqL1xyXG5cdFx0aWYoIXRoaXMuaXNDb25uZWN0ZWQpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHR2YXIgc2VsZiA9IHRoaXMsXHJcblx0XHRcdHJlY3ZSZXF1ZXN0ID0gdGhpcy5yZWN2UmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdCh0aGlzLnJlY3ZVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgbnVsbCwgKHNlbGYuc3RyZWFtID8gUkVRX1JFQ1ZfU1RSRUFNIDogUkVRX1JFQ1ZfUE9MTCkpO1xyXG5cclxuXHRcdHJlY3ZSZXF1ZXN0Lm9uKCdkYXRhJywgZnVuY3Rpb24oZGF0YSkge1xyXG5cdFx0XHRzZWxmLm9uRGF0YShkYXRhKTtcclxuXHRcdH0pO1xyXG5cdFx0cmVjdlJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdHNlbGYucmVjdlJlcXVlc3QgPSBudWxsO1xyXG5cdFx0XHQvKiBBIHJlcXVlc3QgY29tcGxldGluZyBtdXN0IGJlIGNvbnNpZGVyZWQgYWN0aXZpdHksIGFzIHJlYWx0aW1lIHNlbmRzXHJcblx0XHRcdCAqIGhlYXJ0YmVhdHMgZXZlcnkgMTVzIHNpbmNlIGEgcmVxdWVzdCBiZWdhbiwgbm90IGV2ZXJ5IDE1cyBhYnNvbHV0ZWx5ICovXHJcblx0XHRcdHNlbGYub25BY3Rpdml0eSgpO1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIuY29kZSkge1xyXG5cdFx0XHRcdFx0LyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXHJcblx0XHRcdFx0XHQgKiBjb25zaXN0ZW5kbHkgc2VuZHMgZXJyb3JzIHdyYXBwZWQgaW4gcHJvdG9jb2wgbWVzc2FnZXMsIHNob3VsZCBiZVxyXG5cdFx0XHRcdFx0ICogYWJsZSB0byByZW1vdmUgdGhpcyAqL1xyXG5cdFx0XHRcdFx0c2VsZi5vbkRhdGEocHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHQvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxyXG5cdFx0XHRcdFx0ICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cclxuXHRcdFx0XHRcdHNlbGYuZGlzY29ubmVjdChlcnIpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzZWxmLnJlY3YoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHRcdHJlY3ZSZXF1ZXN0LmV4ZWMoKTtcclxuXHR9O1xyXG5cclxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XHJcblx0XHR0cnkge1xyXG5cdFx0XHR2YXIgaXRlbXMgPSB0aGlzLmRlY29kZVJlc3BvbnNlKHJlc3BvbnNlRGF0YSk7XHJcblx0XHRcdGlmKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcclxuXHRcdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspXHJcblx0XHRcdFx0XHR0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tRGVzZXJpYWxpemVkKGl0ZW1zW2ldKSk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb21ldFRyYW5zcG9ydC5vbkRhdGEoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgZXZlbnQ6ICcgKyBlLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZW5jb2RlUmVxdWVzdCA9IGZ1bmN0aW9uKHJlcXVlc3RJdGVtcykge1xyXG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RJdGVtcyk7XHJcblx0fTtcclxuXHJcblx0Q29tZXRUcmFuc3BvcnQucHJvdG90eXBlLmRlY29kZVJlc3BvbnNlID0gZnVuY3Rpb24ocmVzcG9uc2VEYXRhKSB7XHJcblx0XHRpZih0eXBlb2YocmVzcG9uc2VEYXRhKSA9PSAnc3RyaW5nJylcclxuXHRcdFx0cmVzcG9uc2VEYXRhID0gSlNPTi5wYXJzZShyZXNwb25zZURhdGEpO1xyXG5cdFx0cmV0dXJuIHJlc3BvbnNlRGF0YTtcclxuXHR9O1xyXG5cclxuXHQvKiBGb3IgY29tZXQsIHdlIGNvdWxkIGRvIHRoZSBhdXRoIHVwZGF0ZSBieSBhYm9ydGluZyB0aGUgY3VycmVudCByZWN2IGFuZFxyXG5cdCAqIHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cclxuXHQgKiBQcm9ibGVtIGlzIEpTT05QIC0geW91IGNhbid0IGNhbmNlbCB0cnVseSBhYm9ydCBhIHJlY3Ygb25jZSBzdGFydGVkLiBTb1xyXG5cdCAqIHdlIG5lZWQgdG8gc2VuZCBhbiBBVVRIIGZvciBqc29ucC4gSW4gd2hpY2ggY2FzZSBpdCdzIHNpbXBsZXIgdG8ga2VlcCBhbGxcclxuXHQgKiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcclxuXHQgKiBpbnN0ZWFkLCBhbmQgZG9uJ3QgbmVlZCB0byBhYm9ydCB0aGUgcmVjdiAqL1xyXG5cdENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24odG9rZW5EZXRhaWxzKSB7XHJcblx0XHR0aGlzLmF1dGhQYXJhbXMgPSB7YWNjZXNzX3Rva2VuOiB0b2tlbkRldGFpbHMudG9rZW59O1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBDb21ldFRyYW5zcG9ydDtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29tZXRUcmFuc3BvcnQpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxuXHJcbnZhciBXZWJTdG9yYWdlID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBzZXNzaW9uU3VwcG9ydGVkLFxyXG5cdFx0bG9jYWxTdXBwb3J0ZWQsXHJcblx0XHR0ZXN0ID0gJ2FibHlqcy1zdG9yYWdlLXRlc3QnO1xyXG5cclxuXHQvKiBFdmVuIGp1c3QgYWNjZXNzaW5nIHRoZSBzZXNzaW9uL2xvY2FsU3RvcmFnZSBvYmplY3QgY2FuIHRocm93IGFcclxuXHQgKiBzZWN1cml0eSBleGNlcHRpb24gaW4gc29tZSBjaXJjdW1zdGFuY2VzIHdpdGggc29tZSBicm93c2Vycy4gSW5cclxuXHQgKiBvdGhlcnMsIGNhbGxpbmcgc2V0SXRlbSB3aWxsIHRocm93LiBTbyBoYXZlIHRvIGNoZWNrIGluIHRoaXNcclxuXHQgKiBzb21ld2hhdCByb3VuZGFib3V0IHdheS4gKElmIHVuc3VwcG9ydGVkIG9yIG5vIGdsb2JhbCBvYmplY3QsXHJcblx0ICogd2lsbCB0aHJvdyBvbiBhY2Nlc3NpbmcgYSBwcm9wZXJ0eSBvZiB1bmRlZmluZWQpICovXHJcblx0dHJ5IHtcclxuXHRcdGdsb2JhbC5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xyXG5cdFx0Z2xvYmFsLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XHJcblx0XHRzZXNzaW9uU3VwcG9ydGVkID0gdHJ1ZTtcclxuXHR9IGNhdGNoKGUpIHtcclxuXHRcdHNlc3Npb25TdXBwb3J0ZWQgPSBmYWxzZTtcclxuXHR9XHJcblxyXG5cdHRyeSB7XHJcblx0XHRnbG9iYWwubG9jYWxTdG9yYWdlLnNldEl0ZW0odGVzdCwgdGVzdCk7XHJcblx0XHRnbG9iYWwubG9jYWxTdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XHJcblx0XHRsb2NhbFN1cHBvcnRlZCA9IHRydWU7XHJcblx0fSBjYXRjaChlKSB7XHJcblx0XHRsb2NhbFN1cHBvcnRlZCA9IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gV2ViU3RvcmFnZSgpIHt9XHJcblxyXG5cdGZ1bmN0aW9uIHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikge1xyXG5cdFx0cmV0dXJuIHNlc3Npb24gPyBnbG9iYWwuc2Vzc2lvblN0b3JhZ2UgOiBnbG9iYWwubG9jYWxTdG9yYWdlO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2V0KG5hbWUsIHZhbHVlLCB0dGwsIHNlc3Npb24pIHtcclxuXHRcdHZhciB3cmFwcGVkVmFsdWUgPSB7dmFsdWU6IHZhbHVlfTtcclxuXHRcdGlmKHR0bCkge1xyXG5cdFx0XHR3cmFwcGVkVmFsdWUuZXhwaXJlcyA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSArIHR0bDtcclxuXHRcdH1cclxuXHRcdHJldHVybiBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnNldEl0ZW0obmFtZSwgSlNPTi5zdHJpbmdpZnkod3JhcHBlZFZhbHVlKSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXQobmFtZSwgc2Vzc2lvbikge1xyXG5cdFx0dmFyIHJhd0l0ZW0gPSBzdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLmdldEl0ZW0obmFtZSk7XHJcblx0XHRpZighcmF3SXRlbSkgcmV0dXJuIG51bGw7XHJcblx0XHR2YXIgd3JhcHBlZFZhbHVlID0gSlNPTi5wYXJzZShyYXdJdGVtKTtcclxuXHRcdGlmKHdyYXBwZWRWYWx1ZS5leHBpcmVzICYmICh3cmFwcGVkVmFsdWUuZXhwaXJlcyA8IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSkpIHtcclxuXHRcdFx0c3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xyXG5cdFx0XHRyZXR1cm4gbnVsbDtcclxuXHRcdH1cclxuXHRcdHJldHVybiB3cmFwcGVkVmFsdWUudmFsdWU7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiByZW1vdmUobmFtZSwgc2Vzc2lvbikge1xyXG5cdFx0cmV0dXJuIHN0b3JhZ2VJbnRlcmZhY2Uoc2Vzc2lvbikucmVtb3ZlSXRlbShuYW1lKTtcclxuXHR9XHJcblxyXG5cdGlmKGxvY2FsU3VwcG9ydGVkKSB7XHJcblx0XHRXZWJTdG9yYWdlLnNldCAgICA9IGZ1bmN0aW9uKG5hbWUsIHZhbHVlLCB0dGwpIHsgcmV0dXJuIHNldChuYW1lLCB2YWx1ZSwgdHRsLCBmYWxzZSk7IH07XHJcblx0XHRXZWJTdG9yYWdlLmdldCAgICA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIGdldChuYW1lLCBmYWxzZSk7IH07XHJcblx0XHRXZWJTdG9yYWdlLnJlbW92ZSA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuIHJlbW92ZShuYW1lLCBmYWxzZSk7IH07XHJcblx0fVxyXG5cclxuXHRpZihzZXNzaW9uU3VwcG9ydGVkKSB7XHJcblx0XHRXZWJTdG9yYWdlLnNldFNlc3Npb24gICAgPSBmdW5jdGlvbihuYW1lLCB2YWx1ZSwgdHRsKSB7IHJldHVybiBzZXQobmFtZSwgdmFsdWUsIHR0bCwgdHJ1ZSk7IH07XHJcblx0XHRXZWJTdG9yYWdlLmdldFNlc3Npb24gICAgPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiBnZXQobmFtZSwgdHJ1ZSk7IH07XHJcblx0XHRXZWJTdG9yYWdlLnJlbW92ZVNlc3Npb24gPSBmdW5jdGlvbihuYW1lKSB7IHJldHVybiByZW1vdmUobmFtZSwgdHJ1ZSk7IH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gV2ViU3RvcmFnZTtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoV2ViU3RvcmFnZSk7XHJcblxyXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbnZhciBnO1xyXG5cclxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcclxuZyA9IChmdW5jdGlvbigpIHtcclxuXHRyZXR1cm4gdGhpcztcclxufSkoKTtcclxuXHJcbnRyeSB7XHJcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXHJcblx0ZyA9IGcgfHwgbmV3IEZ1bmN0aW9uKFwicmV0dXJuIHRoaXNcIikoKTtcclxufSBjYXRjaCAoZSkge1xyXG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXHJcblx0aWYgKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpIGcgPSB3aW5kb3c7XHJcbn1cclxuXHJcbi8vIGcgY2FuIHN0aWxsIGJlIHVuZGVmaW5lZCwgYnV0IG5vdGhpbmcgdG8gZG8gYWJvdXQgaXQuLi5cclxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3NcclxuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxyXG5cclxubW9kdWxlLmV4cG9ydHMgPSBnO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAxOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHRydWUpIHtcclxuXHRcdC8vIENvbW1vbkpTXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcclxuXHR9XHJcblx0ZWxzZSB7fVxyXG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xyXG5cclxuXHQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcclxuXHQgICAgdmFyIENfbGliID0gQy5saWI7XHJcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XHJcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEJhc2U2NCBlbmNvZGluZyBzdHJhdGVneS5cclxuXHQgICAgICovXHJcblx0ICAgIHZhciBCYXNlNjQgPSBDX2VuYy5CYXNlNjQgPSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBCYXNlNjQgc3RyaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgYmFzZTY0U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5zdHJpbmdpZnkod29yZEFycmF5KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xyXG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcclxuXHQgICAgICAgICAgICB2YXIgbWFwID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89JztcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcclxuXHQgICAgICAgICAgICB3b3JkQXJyYXkuY2xhbXAoKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ29udmVydFxyXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRDaGFycyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTIgPSAod29yZHNbKGkgKyAxKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDEpICUgNCkgKiA4KSkgJiAweGZmO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTMgPSAod29yZHNbKGkgKyAyKSA+Pj4gMl0gPj4+ICgyNCAtICgoaSArIDIpICUgNCkgKiA4KSkgJiAweGZmO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgdmFyIHRyaXBsZXQgPSAoYnl0ZTEgPDwgMTYpIHwgKGJ5dGUyIDw8IDgpIHwgYnl0ZTM7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGJhc2U2NENoYXJzLnB1c2gobWFwLmNoYXJBdCgodHJpcGxldCA+Pj4gKDYgKiAoMyAtIGopKSkgJiAweDNmKSk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXHJcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XHJcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XHJcblx0ICAgICAgICAgICAgICAgIHdoaWxlIChiYXNlNjRDaGFycy5sZW5ndGggJSA0KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGJhc2U2NENoYXJzLmpvaW4oJycpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgQmFzZTY0IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGJhc2U2NFN0ciBUaGUgQmFzZTY0IHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGJhc2U2NFN0cikge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICAgICAgICAgIHZhciBiYXNlNjRTdHJMZW5ndGggPSBiYXNlNjRTdHIubGVuZ3RoO1xyXG5cdCAgICAgICAgICAgIHZhciBtYXAgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nO1xyXG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcclxuXHJcblx0ICAgICAgICAgICAgaWYgKCFyZXZlcnNlTWFwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBtYXAubGVuZ3RoOyBqKyspIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwW21hcC5jaGFyQ29kZUF0KGopXSA9IGo7XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xyXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nQ2hhciA9IG1hcC5jaGFyQXQoNjQpO1xyXG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xyXG5cdCAgICAgICAgICAgICAgICBpZiAocGFkZGluZ0luZGV4ICE9PSAtMSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYmFzZTY0U3RyTGVuZ3RoID0gcGFkZGluZ0luZGV4O1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHBhcnNlTG9vcChiYXNlNjRTdHIsIGJhc2U2NFN0ckxlbmd0aCwgcmV2ZXJzZU1hcCk7XHJcblxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cclxuXHQgICAgZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XHJcblx0ICAgICAgdmFyIHdvcmRzID0gW107XHJcblx0ICAgICAgdmFyIG5CeXRlcyA9IDA7XHJcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xyXG5cdCAgICAgICAgICBpZiAoaSAlIDQpIHtcclxuXHQgICAgICAgICAgICAgIHZhciBiaXRzMSA9IHJldmVyc2VNYXBbYmFzZTY0U3RyLmNoYXJDb2RlQXQoaSAtIDEpXSA8PCAoKGkgJSA0KSAqIDIpO1xyXG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xyXG5cdCAgICAgICAgICAgICAgdmFyIGJpdHNDb21iaW5lZCA9IGJpdHMxIHwgYml0czI7XHJcblx0ICAgICAgICAgICAgICB3b3Jkc1tuQnl0ZXMgPj4+IDJdIHw9IGJpdHNDb21iaW5lZCA8PCAoMjQgLSAobkJ5dGVzICUgNCkgKiA4KTtcclxuXHQgICAgICAgICAgICAgIG5CeXRlcysrO1xyXG5cdCAgICAgICAgICB9XHJcblx0ICAgICAgfVxyXG5cdCAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xyXG5cdCAgICB9XHJcblx0fSgpKTtcclxuXHJcblxyXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuQmFzZTY0O1xyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDE5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjgpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIENyeXB0byA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgREVGQVVMVF9BTEdPUklUSE0gPSAnYWVzJztcclxuXHR2YXIgREVGQVVMVF9LRVlMRU5HVEggPSAyNTY7IC8vIGJpdHNcclxuXHR2YXIgREVGQVVMVF9NT0RFID0gJ2NiYyc7XHJcblx0dmFyIERFRkFVTFRfQkxPQ0tMRU5HVEggPSAxNjsgLy8gYnl0ZXNcclxuXHR2YXIgREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyA9IDQ7IC8vIDMyLWJpdCB3b3Jkc1xyXG5cdHZhciBVSU5UMzJfU1VQID0gMHgxMDAwMDAwMDA7XHJcblx0dmFyIElOVDMyX1NVUCA9IDB4ODAwMDAwMDA7XHJcblxyXG5cdC8qKlxyXG5cdCAqIEludGVybmFsOiBnZW5lcmF0ZSBhbiBhcnJheSBvZiBzZWN1cmUgcmFuZG9tIHdvcmRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxlbmd0aCBvZiBieXRlc1xyXG5cdCAqIEBwYXJhbSBieXRlc1xyXG5cdCAqIEBwYXJhbSBjYWxsYmFja1xyXG5cdCAqL1xyXG5cdHZhciBnZW5lcmF0ZVJhbmRvbTtcclxuXHRpZihwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVdvcmRBcnJheSkge1xyXG5cdFx0Z2VuZXJhdGVSYW5kb20gPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVdvcmRBcnJheTtcclxuXHR9IGVsc2UgaWYodHlwZW9mIFVpbnQzMkFycmF5ICE9PSAndW5kZWZpbmVkJyAmJiBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFJhbmRvbVZhbHVlcykge1xyXG5cdFx0dmFyIGJsb2NrUmFuZG9tQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoREVGQVVMVF9CTE9DS0xFTkdUSF9XT1JEUyk7XHJcblx0XHRnZW5lcmF0ZVJhbmRvbSA9IGZ1bmN0aW9uKGJ5dGVzLCBjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgd29yZHMgPSBieXRlcyAvIDQsIG5hdGl2ZUFycmF5ID0gKHdvcmRzID09IERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMpID8gYmxvY2tSYW5kb21BcnJheSA6IG5ldyBVaW50MzJBcnJheSh3b3Jkcyk7XHJcblx0XHRcdHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0UmFuZG9tVmFsdWVzKG5hdGl2ZUFycmF5LCBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkobmF0aXZlQXJyYXkpKVxyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fSBlbHNlIHtcclxuXHRcdGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24oYnl0ZXMsIGNhbGxiYWNrKSB7XHJcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01BSk9SLCAnQWJseS5DcnlwdG8uZ2VuZXJhdGVSYW5kb20oKScsICdXYXJuaW5nOiB0aGUgYnJvd3NlciB5b3UgYXJlIHVzaW5nIGRvZXMgbm90IHN1cHBvcnQgc2VjdXJlIGNyeXB0b2dyYXBoaWNhbGx5IHNlY3VyZSByYW5kb21uZXNzIGdlbmVyYXRpb247IGZhbGxpbmcgYmFjayB0byBpbnNlY3VyZSBNYXRoLnJhbmRvbSgpJyk7XHJcblx0XHRcdHZhciB3b3JkcyA9IGJ5dGVzIC8gNCwgYXJyYXkgPSBuZXcgQXJyYXkod29yZHMpO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xyXG5cdFx0XHRcdC8qIGNyeXB0b2pzIHdvcmRhcnJheXMgdXNlIHNpZ25lZCBpbnRzLiBXaGVuIFdvcmRBcnJheS5jcmVhdGUgaXMgZmVkIGFcclxuXHRcdFx0XHQqIFVpbnQzMkFycmF5IHVuc2lnbmVkIGFyZSBjb252ZXJ0ZWQgdG8gc2lnbmVkIGF1dG9tYXRpY2FsbHksIGJ1dCB3aGVuXHJcblx0XHRcdFx0KiBmZWQgYSBub3JtYWwgYXJyYXkgdGhleSBhcmVuJ3QsIHNvIG5lZWQgdG8gZG8gc28gb3Vyc2VsdmVzIGJ5XHJcblx0XHRcdFx0KiBzdWJ0cmFjdGluZyBJTlQzMl9TVVAgKi9cclxuXHRcdFx0XHRhcnJheVtpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIFVJTlQzMl9TVVApIC0gSU5UMzJfU1VQO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRjYWxsYmFjayhudWxsLCBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShhcnJheSkpO1xyXG5cdFx0fTtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEludGVybmFsOiBjYWxjdWxhdGUgdGhlIHBhZGRlZCBsZW5ndGggb2YgYSBnaXZlbiBwbGFpbnRleHRcclxuXHQgKiB1c2luZyBQS0NTNS5cclxuXHQgKiBAcGFyYW0gcGxhaW50ZXh0TGVuZ3RoXHJcblx0ICogQHJldHVyblxyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpIHtcclxuXHRcdHJldHVybiAocGxhaW50ZXh0TGVuZ3RoICsgREVGQVVMVF9CTE9DS0xFTkdUSCkgJiAtREVGQVVMVF9CTE9DS0xFTkdUSDtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIEludGVybmFsOiBjaGVja3MgdGhhdCB0aGUgY2lwaGVyUGFyYW1zIGFyZSBhIHZhbGlkIGNvbWJpbmF0aW9uLiBDdXJyZW50bHlcclxuXHQgKiBqdXN0IGNoZWNrcyB0aGF0IHRoZSBjYWxjdWxhdGVkIGtleUxlbmd0aCBpcyBhIHZhbGlkIG9uZSBmb3IgYWVzLWNiY1xyXG5cdCAqL1xyXG5cdGZ1bmN0aW9uIHZhbGlkYXRlQ2lwaGVyUGFyYW1zKHBhcmFtcykge1xyXG5cdFx0aWYocGFyYW1zLmFsZ29yaXRobSA9PT0gJ2FlcycgJiYgcGFyYW1zLm1vZGUgPT09ICdjYmMnKSB7XHJcblx0XHRcdGlmKHBhcmFtcy5rZXlMZW5ndGggPT09IDEyOCB8fCBwYXJhbXMua2V5TGVuZ3RoID09PSAyNTYpIHtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBrZXkgbGVuZ3RoICcgKyBwYXJhbXMua2V5TGVuZ3RoICsgJyBmb3IgYWVzLWNiYyBlbmNyeXB0aW9uLiBFbmNyeXB0aW9uIGtleSBtdXN0IGJlIDEyOCBvciAyNTYgYml0cyAoMTYgb3IgMzIgQVNDSUkgY2hhcmFjdGVycyknKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIG5vcm1hbGlzZUJhc2U2NChzdHJpbmcpIHtcclxuXHRcdC8qIHVybC1zYWZlIGJhc2U2NCBzdHJpbmdzIHVzZSBfIGFuZCAtIGluc3RyZWFkIG9mIC8gYW5kICsgKi9cclxuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSgnXycsICcvJykucmVwbGFjZSgnLScsICcrJyk7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBJbnRlcm5hbDogYSBibG9jayBjb250YWluaW5nIHplcm9zXHJcblx0ICovXHJcblx0dmFyIGVtcHR5QmxvY2sgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMCwwLDAsMF0pO1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnRlcm5hbDogb2J0YWluIHRoZSBwa2NzNSBwYWRkaW5nIHN0cmluZyBmb3IgYSBnaXZlbiBwYWRkZWQgbGVuZ3RoO1xyXG5cdCAqL1xyXG5cdHZhciBwa2NzNVBhZGRpbmcgPSBbXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgxMDEwMTAxMCwweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMF0sIDE2KSxcclxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAxMDAwMDAwXSwgMSksXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMjAyMDAwMF0sIDIpLFxyXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDMwMzAzMDBdLCAzKSxcclxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA0MDQwNDA0XSwgNCksXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNTA1MDUwNSwweDA1MDAwMDAwXSwgNSksXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNjA2MDYwNiwweDA2MDYwMDAwXSwgNiksXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNzA3MDcwNywweDA3MDcwNzAwXSwgNyksXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwODA4MDgwOCwweDA4MDgwODA4XSwgOCksXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwOTA5MDkwOSwweDA5MDkwOTA5LDB4MDkwMDAwMDBdLCA5KSxcclxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBhMGEwYTBhLDB4MGEwYTBhMGEsMHgwYTBhMDAwMF0sIDEwKSxcclxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBiMGIwYjBiLDB4MGIwYjBiMGIsMHgwYjBiMGIwMF0sIDExKSxcclxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBjMGMwYzBjLDB4MGMwYzBjMGMsMHgwYzBjMGMwY10sIDEyKSxcclxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBkMGQwZDBkLDB4MGQwZDBkMGQsMHgwZDBkMGQwZCwweDBkMDAwMDAwXSwgMTMpLFxyXG5cdFx0Y3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MGUwZTBlMGUsMHgwZTBlMGUwZSwweDBlMGUwZTBlLDB4MGUwZTAwMDBdLCAxNCksXHJcblx0XHRjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwZjBmMGYwZiwweDBmMGYwZjBmLDB4MGYwZjBmMGYsMHgwZjBmMGYwZl0sIDE1KSxcclxuXHRcdGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDEwMTAxMDEwLDB4MTAxMDEwMTAsMHgxMDEwMTAxMCwweDEwMTAxMDEwXSwgMTYpXHJcblx0XTtcclxuXHJcblx0LyoqXHJcblx0ICogVXRpbGl0eSBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGZvciBtZXNzYWdlIHBheWxvYWQgZW5jcnlwdGlvbi5cclxuXHQgKlxyXG5cdCAqIFRoaXMgY2xhc3Mgc3VwcG9ydHMgQUVTL0NCQy9QS0NTNSB3aXRoIGEgZGVmYXVsdCBrZXlsZW5ndGggb2YgMTI4IGJpdHNcclxuXHQgKiBidXQgc3VwcG9ydGluZyBvdGhlciBrZXlsZW5ndGhzLiBPdGhlciBhbGdvcml0aG1zIGFuZCBjaGFpbmluZyBtb2RlcyBhcmVcclxuXHQgKiBub3Qgc3VwcG9ydGVkIGRpcmVjdGx5LCBidXQgc3VwcG9ydGFibGUgYnkgZXh0ZW5kaW5nL2ltcGxlbWVudGluZyB0aGUgYmFzZVxyXG5cdCAqIGNsYXNzZXMgYW5kIGludGVyZmFjZXMgaGVyZS5cclxuXHQgKlxyXG5cdCAqIFNlY3VyZSByYW5kb20gZGF0YSBmb3IgY3JlYXRpb24gb2YgSW5pdGlhbGl6YXRpb24gVmVjdG9ycyAoSVZzKSBhbmQga2V5c1xyXG5cdCAqIGlzIG9idGFpbmVkIGZyb20gd2luZG93LmNyeXB0by5nZXRSYW5kb21WYWx1ZXMgaWYgYXZhaWxhYmxlLCBvciBmcm9tXHJcblx0ICogTWF0aC5yYW5kb20oKSBpZiBub3QuIENsaWVudHMgd2hvIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBNYXRoLnJhbmRvbSgpXHJcblx0ICogc2hvdWxkIHBvbHlmaWxsIHdpbmRvdy5jcnlwdG8uZ2V0UmFuZG9tVmFsdWVzIHdpdGggYSBsaWJyYXJ5IHRoYXQgc2VlZHNcclxuXHQgKiBhIFBSTkcgd2l0aCByZWFsIGVudHJvcHkuXHJcblx0ICpcclxuXHQgKiBFYWNoIG1lc3NhZ2UgcGF5bG9hZCBpcyBlbmNyeXB0ZWQgd2l0aCBhbiBJViBpbiBDQkMgbW9kZSwgYW5kIHRoZSBJViBpc1xyXG5cdCAqIGNvbmNhdGVuYXRlZCB3aXRoIHRoZSByZXN1bHRpbmcgcmF3IGNpcGhlcnRleHQgdG8gY29uc3RydWN0IHRoZSBcImNpcGhlcnRleHRcIlxyXG5cdCAqIGRhdGEgcGFzc2VkIHRvIHRoZSByZWNpcGllbnQuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gQ3J5cHRvKCkge31cclxuXHJcblx0LyoqXHJcblx0ICogQSBjbGFzcyBlbmNhcHN1bGF0aW5nIHRoZSBjbGllbnQtc3BlY2lmaWFibGUgcGFyYW1ldGVycyBmb3JcclxuXHQgKiB0aGUgY2lwaGVyLlxyXG5cdCAqXHJcblx0ICogYWxnb3JpdGhtIGlzIHRoZSBuYW1lIG9mIHRoZSBhbGdvcml0aG0gaW4gdGhlIGRlZmF1bHQgc3lzdGVtIHByb3ZpZGVyLFxyXG5cdCAqIG9yIHRoZSBsb3dlci1jYXNlZCB2ZXJzaW9uIG9mIGl0OyBlZyBcImFlc1wiIG9yIFwiQUVTXCIuXHJcblx0ICpcclxuXHQgKiBDbGllbnRzIGFyZSByZWNvbW1lbmRlZCB0byBub3QgY2FsbCB0aGlzIGRpcmVjdGx5LCBidXQgaW5zdGVhZCB0byB1c2UgdGhlXHJcblx0ICogQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMgaGVscGVyLCB3aGljaCB3aWxsIGZpbGwgaW4gYW55IGZpZWxkcyBub3Qgc3VwcGxpZWRcclxuXHQgKiB3aXRoIGRlZmF1bHQgdmFsdWVzIGFuZCB2YWxpZGF0aW9uIHRoZSByZXN1bHQuXHJcblx0ICovXHJcblx0ZnVuY3Rpb24gQ2lwaGVyUGFyYW1zKCkge1xyXG5cdFx0dGhpcy5hbGdvcml0aG0gPSBudWxsO1xyXG5cdFx0dGhpcy5rZXlMZW5ndGggPSBudWxsO1xyXG5cdFx0dGhpcy5tb2RlID0gbnVsbDtcclxuXHRcdHRoaXMua2V5ID0gbnVsbDtcclxuXHR9XHJcblx0Q3J5cHRvLkNpcGhlclBhcmFtcyA9IENpcGhlclBhcmFtcztcclxuXHJcblx0LyoqXHJcblx0ICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xyXG5cdCAqIGluIGFueSBub3QgcHJvdmlkZWQgd2l0aCBkZWZhdWx0IHZhbHVlcywgY2FsY3VsYXRpbmcgYSBrZXlMZW5ndGggZnJvbVxyXG5cdCAqIHRoZSBzdXBwbGllZCBrZXksIGFuZCB2YWxpZGF0aW5nIHRoZSByZXN1bHQuXHJcblx0ICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcclxuXHQgKiBrZXksIGFzIGVpdGhlciBhIGJpbmFyeSAoQXJyYXlCdWZmZXIsIEFycmF5LCBXb3JkQXJyYXkpIG9yIGFcclxuXHQgKiBiYXNlNjQtZW5jb2RlZCBzdHJpbmcuIE1heSBvcHRpb25hbGx5IGFsc28gY29udGFpbjogYWxnb3JpdGhtIChkZWZhdWx0cyB0b1xyXG5cdCAqIEFFUyksIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxyXG5cdCAqL1xyXG5cdENyeXB0by5nZXREZWZhdWx0UGFyYW1zID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcblx0XHR2YXIga2V5O1xyXG5cdFx0LyogQmFja3dhcmQgY29tcGF0aWJpbGl0eSAqL1xyXG5cdFx0aWYoKHR5cGVvZihwYXJhbXMpID09PSAnZnVuY3Rpb24nKSB8fCAodHlwZW9mKHBhcmFtcykgPT09ICdzdHJpbmcnKSkge1xyXG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlcHJlY2F0ZWQoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKGtleSwgY2FsbGJhY2spJywgJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pJyk7XHJcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0Q3J5cHRvLmdlbmVyYXRlUmFuZG9tS2V5KGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0XHRcdFx0cGFyYW1zKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pKTtcclxuXHRcdFx0XHR9KVxyXG5cdFx0XHR9IGVsc2UgaWYodHlwZW9mIGFyZ3VtZW50c1sxXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGFyZ3VtZW50c1sxXShudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7a2V5OiBwYXJhbXN9KSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoIXBhcmFtcy5rZXkpIHtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXkgaXMgcmVxdWlyZWQnKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZW9mKHBhcmFtcy5rZXkpID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRrZXkgPSBPYmplY3QoY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1tcInBhcnNlXCJdKShub3JtYWxpc2VCYXNlNjQocGFyYW1zLmtleSkpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0a2V5ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShwYXJhbXMua2V5KTsgLy8gRXhwZWN0IGtleSB0byBiZSBhbiBBcnJheSwgQXJyYXlCdWZmZXIsIG9yIFdvcmRBcnJheSBhdCB0aGlzIHBvaW50XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNpcGhlclBhcmFtcyA9IG5ldyBDaXBoZXJQYXJhbXMoKTtcclxuXHRcdGNpcGhlclBhcmFtcy5rZXkgPSBrZXk7XHJcblx0XHRjaXBoZXJQYXJhbXMuYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSB8fCBERUZBVUxUX0FMR09SSVRITTtcclxuXHRcdGNpcGhlclBhcmFtcy5rZXlMZW5ndGggPSBrZXkud29yZHMubGVuZ3RoICogKDQgKiA4KTtcclxuXHRcdGNpcGhlclBhcmFtcy5tb2RlID0gcGFyYW1zLm1vZGUgfHwgREVGQVVMVF9NT0RFO1xyXG5cclxuXHRcdGlmKHBhcmFtcy5rZXlMZW5ndGggJiYgcGFyYW1zLmtleUxlbmd0aCAhPT0gY2lwaGVyUGFyYW1zLmtleUxlbmd0aCkge1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zOiBhIGtleUxlbmd0aCBvZiAnICsgcGFyYW1zLmtleUxlbmd0aCArICcgd2FzIHNwZWNpZmllZCwgYnV0IHRoZSBrZXkgYWN0dWFsbHkgaGFzIGxlbmd0aCAnICsgY2lwaGVyUGFyYW1zLmtleUxlbmd0aCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcclxuXHRcdHJldHVybiBjaXBoZXJQYXJhbXM7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogR2VuZXJhdGUgYSByYW5kb20gZW5jcnlwdGlvbiBrZXkgZnJvbSB0aGUgc3VwcGxpZWQga2V5bGVuZ3RoIChvciB0aGVcclxuXHQgKiBkZWZhdWx0IGtleUxlbmd0aCBpZiBub25lIHN1cHBsaWVkKSBhcyBhIENyeXB0b0pTIFdvcmRBcnJheVxyXG5cdCAqIEBwYXJhbSBrZXlMZW5ndGggKG9wdGlvbmFsKSB0aGUgcmVxdWlyZWQga2V5TGVuZ3RoIGluIGJpdHNcclxuXHQgKiBAcGFyYW0gY2FsbGJhY2sgKGVyciwga2V5KVxyXG5cdCAqL1xyXG5cdENyeXB0by5nZW5lcmF0ZVJhbmRvbUtleSA9IGZ1bmN0aW9uKGtleUxlbmd0aCwgY2FsbGJhY2spIHtcclxuXHRcdGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2Yoa2V5TGVuZ3RoKSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGNhbGxiYWNrID0ga2V5TGVuZ3RoO1xyXG5cdFx0XHRrZXlMZW5ndGggPSB1bmRlZmluZWQ7XHJcblx0XHR9XHJcblx0XHRnZW5lcmF0ZVJhbmRvbSgoa2V5TGVuZ3RoIHx8IERFRkFVTFRfS0VZTEVOR1RIKSAvIDgsIGNhbGxiYWNrKTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBJbnRlcm5hbDsgZ2V0IGEgQ2hhbm5lbENpcGhlciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2lwaGVyUGFyYW1zXHJcblx0ICogQHBhcmFtIHBhcmFtcyBlaXRoZXIgYSBDaXBoZXJQYXJhbXMgaW5zdGFuY2Ugb3Igc29tZSBzdWJzZXQgb2YgaXRzXHJcblx0ICogZmllbGRzIHRoYXQgaW5jbHVkZXMgYSBrZXlcclxuXHQgKi9cclxuXHRDcnlwdG8uZ2V0Q2lwaGVyID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcblx0XHR2YXIgY2lwaGVyUGFyYW1zID0gKHBhcmFtcyBpbnN0YW5jZW9mIENpcGhlclBhcmFtcykgP1xyXG5cdFx0ICAgICAgICAgICAgICAgICAgIHBhcmFtcyA6XHJcblx0XHQgICAgICAgICAgICAgICAgICAgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMocGFyYW1zKTtcclxuXHJcblx0XHRyZXR1cm4ge2NpcGhlclBhcmFtczogY2lwaGVyUGFyYW1zLCBjaXBoZXI6IG5ldyBDQkNDaXBoZXIoY2lwaGVyUGFyYW1zLCBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTLCBwYXJhbXMuaXYpfTtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBDQkNDaXBoZXIocGFyYW1zLCBibG9ja0xlbmd0aFdvcmRzLCBpdikge1xyXG5cdFx0dGhpcy5hbGdvcml0aG0gPSBwYXJhbXMuYWxnb3JpdGhtICsgJy0nICsgU3RyaW5nKHBhcmFtcy5rZXlMZW5ndGgpICsgJy0nICsgcGFyYW1zLm1vZGU7XHJcblx0XHR0aGlzLmNqc0FsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tXFxkKyQvLCAnJyk7XHJcblx0XHR0aGlzLmtleSA9IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0udG9Xb3JkQXJyYXkocGFyYW1zLmtleSk7XHJcblx0XHRpZihpdikge1xyXG5cdFx0XHR0aGlzLml2ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShpdikuY2xvbmUoKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuYmxvY2tMZW5ndGhXb3JkcyA9IGJsb2NrTGVuZ3RoV29yZHM7XHJcblx0fVxyXG5cclxuXHRDQkNDaXBoZXIucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQsIGNhbGxiYWNrKSB7XHJcblx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5lbmNyeXB0KCknLCAnJyk7XHJcblx0XHRwbGFpbnRleHQgPSBwbGF0Zm9ybV9idWZmZXJ1dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRvV29yZEFycmF5KHBsYWludGV4dCk7XHJcblx0XHR2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcGxhaW50ZXh0LnNpZ0J5dGVzLFxyXG5cdFx0XHRwYWRkZWRMZW5ndGggPSBnZXRQYWRkZWRMZW5ndGgocGxhaW50ZXh0TGVuZ3RoKSxcclxuXHRcdFx0c2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0dmFyIHRoZW4gPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0c2VsZi5nZXRJdihmdW5jdGlvbihlcnIsIGl2KSB7XHJcblx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dmFyIGNpcGhlck91dCA9IHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHBsYWludGV4dC5jb25jYXQocGtjczVQYWRkaW5nW3BhZGRlZExlbmd0aCAtIHBsYWludGV4dExlbmd0aF0pKTtcclxuXHRcdFx0XHR2YXIgY2lwaGVydGV4dCA9IGl2LmNvbmNhdChjaXBoZXJPdXQpO1xyXG5cdFx0XHRcdGNhbGxiYWNrKG51bGwsIGNpcGhlcnRleHQpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblxyXG5cdFx0aWYgKCF0aGlzLmVuY3J5cHRDaXBoZXIpIHtcclxuXHRcdFx0aWYodGhpcy5pdikge1xyXG5cdFx0XHRcdHRoaXMuZW5jcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3IodGhpcy5rZXksIHsgaXY6IHRoaXMuaXYgfSk7XHJcblx0XHRcdFx0dGhlbigpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uKGVyciwgaXYpIHtcclxuXHRcdFx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2VsZi5lbmNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bc2VsZi5janNBbGdvcml0aG1dLmNyZWF0ZUVuY3J5cHRvcihzZWxmLmtleSwgeyBpdjogaXYgfSk7XHJcblx0XHRcdFx0XHRzZWxmLml2ID0gaXY7XHJcblx0XHRcdFx0XHR0aGVuKCk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoZW4oKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDQkNDaXBoZXIucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XHJcblx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5kZWNyeXB0KCknLCAnJyk7XHJcblx0XHRjaXBoZXJ0ZXh0ID0gcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1dvcmRBcnJheShjaXBoZXJ0ZXh0KTtcclxuXHRcdHZhciBibG9ja0xlbmd0aFdvcmRzID0gdGhpcy5ibG9ja0xlbmd0aFdvcmRzLFxyXG5cdFx0XHRjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzLFxyXG5cdFx0XHRpdiA9IGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgwLCBibG9ja0xlbmd0aFdvcmRzKSksXHJcblx0XHRcdGNpcGhlcnRleHRCb2R5ID0gY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoY2lwaGVydGV4dFdvcmRzLnNsaWNlKGJsb2NrTGVuZ3RoV29yZHMpKTtcclxuXHJcblx0XHR2YXIgZGVjcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVEZWNyeXB0b3IodGhpcy5rZXksIHsgaXY6IGl2IH0pO1xyXG5cdFx0dmFyIHBsYWludGV4dCA9IGRlY3J5cHRDaXBoZXIucHJvY2VzcyhjaXBoZXJ0ZXh0Qm9keSk7XHJcblx0XHR2YXIgZXBpbG9ndWUgPSBkZWNyeXB0Q2lwaGVyLmZpbmFsaXplKCk7XHJcblx0XHRkZWNyeXB0Q2lwaGVyLnJlc2V0KCk7XHJcblx0XHRpZihlcGlsb2d1ZSAmJiBlcGlsb2d1ZS5zaWdCeXRlcykgcGxhaW50ZXh0LmNvbmNhdChlcGlsb2d1ZSk7XHJcblx0XHRyZXR1cm4gcGxhaW50ZXh0O1xyXG5cdH07XHJcblxyXG5cdENCQ0NpcGhlci5wcm90b3R5cGUuZ2V0SXYgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0aWYodGhpcy5pdikge1xyXG5cdFx0XHR2YXIgaXYgPSB0aGlzLml2O1xyXG5cdFx0XHR0aGlzLml2ID0gbnVsbDtcclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgaXYpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0LyogU2luY2UgdGhlIGl2IGZvciBhIG5ldyBibG9jayBpcyB0aGUgY2lwaGVydGV4dCBvZiB0aGUgbGFzdCwgdGhpc1xyXG5cdFx0KiBzZXRzIGEgbmV3IGl2ICg9IGFlcyhyYW5kb21CbG9jayBYT1IgbGFzdENpcGhlclRleHQpKSBhcyB3ZWxsIGFzXHJcblx0XHQqIHJldHVybmluZyBpdCAqL1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0Z2VuZXJhdGVSYW5kb20oREVGQVVMVF9CTE9DS0xFTkdUSCwgZnVuY3Rpb24oZXJyLCByYW5kb21CbG9jaykge1xyXG5cdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH0gXHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHJhbmRvbUJsb2NrKSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gQ3J5cHRvO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDcnlwdG8pO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgVHJhbnNwb3J0ID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBhY3Rpb25zID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkFjdGlvbjtcclxuXHR2YXIgY2xvc2VNZXNzYWdlID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5DTE9TRX0pO1xyXG5cdHZhciBkaXNjb25uZWN0TWVzc2FnZSA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuRElTQ09OTkVDVH0pO1xyXG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcblx0LypcclxuXHQgKiBFdmVudEVtaXR0ZXIsIGdlbmVyYXRlcyB0aGUgZm9sbG93aW5nIGV2ZW50czpcclxuXHQgKlxyXG5cdCAqIGV2ZW50IG5hbWUgICAgICAgZGF0YVxyXG5cdCAqIGNsb3NlZCAgICAgICAgICAgZXJyb3JcclxuXHQgKiBmYWlsZWQgICAgICAgICAgIGVycm9yXHJcblx0ICogZGlzcG9zZWRcclxuXHQgKiBjb25uZWN0ZWQgICAgICAgIG51bGwgZXJyb3IsIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHNcclxuXHQgKiBzeW5jICAgICAgICAgICAgIGNvbm5lY3Rpb25TZXJpYWwsIGNvbm5lY3Rpb25JZFxyXG5cdCAqIGV2ZW50ICAgICAgICAgICAgY2hhbm5lbCBtZXNzYWdlIG9iamVjdFxyXG5cdCAqL1xyXG5cclxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cclxuXHRmdW5jdGlvbiBUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xyXG5cdFx0X3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcclxuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcclxuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnJlZ2lzdGVyUHJvcG9zZWRUcmFuc3BvcnQodGhpcyk7XHJcblx0XHR0aGlzLmF1dGggPSBhdXRoO1xyXG5cdFx0dGhpcy5wYXJhbXMgPSBwYXJhbXM7XHJcblx0XHR0aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XHJcblx0XHR0aGlzLmZvcm1hdCA9IHBhcmFtcy5mb3JtYXQ7XHJcblx0XHR0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xyXG5cdFx0dGhpcy5pZGxlVGltZXIgPSBudWxsO1xyXG5cdFx0dGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xyXG5cdH1cclxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFRyYW5zcG9ydCwgX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xyXG5cclxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbigpIHt9O1xyXG5cclxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZih0aGlzLmlzQ29ubmVjdGVkKSB7XHJcblx0XHRcdHRoaXMucmVxdWVzdENsb3NlKCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpbmlzaCgnY2xvc2VkJywgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jbG9zZWQpO1xyXG5cdH07XHJcblxyXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzY29ubmVjdCA9IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0LyogVXNlZCBmb3IgbmV0d29yay90cmFuc3BvcnQgaXNzdWVzIHRoYXQgbmVlZCB0byByZXN1bHQgaW4gdGhlIHRyYW5zcG9ydFxyXG5cdFx0ICogYmVpbmcgZGlzY29ubmVjdGVkLCBidXQgc2hvdWxkIG5vdCBhZmZlY3QgdGhlIGNvbm5lY3Rpb24gKi9cclxuXHRcdGlmKHRoaXMuaXNDb25uZWN0ZWQpIHtcclxuXHRcdFx0dGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVyciB8fCBfdHJhbnNwb3J0X2Nvbm5lY3Rpb25lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRpc2Nvbm5lY3RlZCk7XHJcblx0fTtcclxuXHJcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24oZXJyKSB7XHJcblx0XHQvKiBVc2VkIGZvciBjbGllbnQtc2lkZS1kZXRlY3RlZCBmYXRhbCBjb25uZWN0aW9uIGlzc3VlcyAqL1xyXG5cdFx0aWYodGhpcy5pc0Nvbm5lY3RlZCkge1xyXG5cdFx0XHR0aGlzLnJlcXVlc3REaXNjb25uZWN0KCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmZpbmlzaCgnZmFpbGVkJywgZXJyIHx8IF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uZmFpbGVkKTtcclxuXHR9O1xyXG5cclxuXHRUcmFuc3BvcnQucHJvdG90eXBlLmZpbmlzaCA9IGZ1bmN0aW9uKGV2ZW50LCBlcnIpIHtcclxuXHRcdGlmKHRoaXMuaXNGaW5pc2hlZCkge1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5pc0ZpbmlzaGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMuaXNDb25uZWN0ZWQgPSBmYWxzZTtcclxuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcclxuXHRcdGNsZWFyVGltZW91dCh0aGlzLmlkbGVUaW1lcik7XHJcblx0XHR0aGlzLmlkbGVUaW1lciA9IG51bGw7XHJcblx0XHR0aGlzLmVtaXQoZXZlbnQsIGVycik7XHJcblx0XHR0aGlzLmRpc3Bvc2UoKTtcclxuXHR9O1xyXG5cclxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uUHJvdG9jb2xNZXNzYWdlID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG5cdFx0aWYgKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNob3VsZExvZyhfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8pKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBvbiAnICsgdGhpcy5zaG9ydE5hbWUgKyAnOiAnICsgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ2lmeShtZXNzYWdlKSArICc7IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XHJcblx0XHR9XHJcblx0XHR0aGlzLm9uQWN0aXZpdHkoKTtcclxuXHJcblx0XHRzd2l0Y2gobWVzc2FnZS5hY3Rpb24pIHtcclxuXHRcdGNhc2UgYWN0aW9ucy5IRUFSVEJFQVQ6XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsIHRoaXMuc2hvcnROYW1lICsgJyBoZWFydGJlYXQ7IGNvbm5lY3Rpb25JZCA9ICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZCk7XHJcblx0XHRcdHRoaXMuZW1pdCgnaGVhcnRiZWF0JywgbWVzc2FnZS5pZCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0Y2FzZSBhY3Rpb25zLkNPTk5FQ1RFRDpcclxuXHRcdFx0dGhpcy5vbkNvbm5lY3QobWVzc2FnZSk7XHJcblx0XHRcdHRoaXMuZW1pdCgnY29ubmVjdGVkJywgbWVzc2FnZS5lcnJvciwgbWVzc2FnZS5jb25uZWN0aW9uSWQsIG1lc3NhZ2UuY29ubmVjdGlvbkRldGFpbHMsIG1lc3NhZ2UpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgYWN0aW9ucy5DTE9TRUQ6XHJcblx0XHRcdHRoaXMub25DbG9zZShtZXNzYWdlKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIGFjdGlvbnMuRElTQ09OTkVDVEVEOlxyXG5cdFx0XHR0aGlzLm9uRGlzY29ubmVjdChtZXNzYWdlKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIGFjdGlvbnMuQUNLOlxyXG5cdFx0XHR0aGlzLmVtaXQoJ2FjaycsIG1lc3NhZ2UubXNnU2VyaWFsLCBtZXNzYWdlLmNvdW50KTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIGFjdGlvbnMuTkFDSzpcclxuXHRcdFx0dGhpcy5lbWl0KCduYWNrJywgbWVzc2FnZS5tc2dTZXJpYWwsIG1lc3NhZ2UuY291bnQsIG1lc3NhZ2UuZXJyb3IpO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgYWN0aW9ucy5TWU5DOlxyXG5cdFx0XHRpZihtZXNzYWdlLmNvbm5lY3Rpb25JZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0LyogYSB0cmFuc3BvcnQgU1lOQyAqL1xyXG5cdFx0XHRcdHRoaXMuZW1pdCgnc3luYycsIG1lc3NhZ2UuY29ubmVjdGlvbklkLCBtZXNzYWdlKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHQvKiBvdGhlcndpc2UgaXQncyBhIGNoYW5uZWwgU1lOQywgc28gaGFuZGxlIGl0IGluIHRoZSBjaGFubmVsICovXHJcblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcclxuXHRcdFx0YnJlYWs7XHJcblx0XHRjYXNlIGFjdGlvbnMuQVVUSDpcclxuXHRcdFx0dGhpcy5hdXRoLmF1dGhvcml6ZShmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdBYmx5IHJlcXVlc3RlZCByZS1hdXRoZW50aWNhdGlvbiwgYnV0IHVuYWJsZSB0byBvYnRhaW4gYSBuZXcgdG9rZW46ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRicmVhaztcclxuXHRcdGNhc2UgYWN0aW9ucy5FUlJPUjpcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ3JlY2VpdmVkIGVycm9yIGFjdGlvbjsgY29ubmVjdGlvbklkID0gJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkICsgJzsgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdChtZXNzYWdlLmVycm9yKSArIChtZXNzYWdlLmNoYW5uZWwgPyAoJywgY2hhbm5lbDogJyArICBtZXNzYWdlLmNoYW5uZWwpIDogJycpKTtcclxuXHRcdFx0aWYobWVzc2FnZS5jaGFubmVsID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHR0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cdFx0XHQvKiBvdGhlcndpc2UgaXQncyBhIGNoYW5uZWwtc3BlY2lmaWMgZXJyb3IsIHNvIGhhbmRsZSBpdCBpbiB0aGUgY2hhbm5lbCAqL1xyXG5cdFx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cdFx0ZGVmYXVsdDpcclxuXHRcdFx0LyogYWxsIG90aGVyIGFjdGlvbnMgYXJlIGNoYW5uZWwtc3BlY2lmaWMgKi9cclxuXHRcdFx0dGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25Db25uZWN0ID0gZnVuY3Rpb24obWVzc2FnZSkge1xyXG5cdFx0dGhpcy5pc0Nvbm5lY3RlZCA9IHRydWU7XHJcblx0XHR2YXIgbWF4UHJvbWlzZWRJZGxlID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XHJcblx0XHRpZihtYXhQcm9taXNlZElkbGUpIHtcclxuXHRcdFx0dGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBtYXhQcm9taXNlZElkbGUgKyB0aGlzLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQ7XHJcblx0XHRcdHRoaXMub25BY3Rpdml0eSgpO1xyXG5cdFx0fVxyXG5cdFx0LyogZWxzZSBSZWFsdGltZSBkZWNsaW5lcyB0byBndWFyYW50ZWUgYW55IG1heGltdW0gaWRsZSBpbnRlcnZhbCAtIENEMmggKi9cclxuXHR9O1xyXG5cclxuXHRUcmFuc3BvcnQucHJvdG90eXBlLm9uRGlzY29ubmVjdCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcclxuXHRcdC8qIFVzZWQgZm9yIHdoZW4gdGhlIHNlcnZlciBoYXMgZGlzY29ubmVjdGVkIHRoZSBjbGllbnQgKHVzdWFsbHkgd2l0aCBhXHJcblx0XHQgKiBESVNDT05ORUNURUQgYWN0aW9uKSAqL1xyXG5cdFx0dmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25EaXNjb25uZWN0KCknLCAnZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xyXG5cdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XHJcblx0fTtcclxuXHJcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbkZhdGFsRXJyb3IgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHQvKiBPbiByZWNlaXB0IG9mIGEgZmF0YWwgY29ubmVjdGlvbiBlcnJvciwgd2UgY2FuIGFzc3VtZSB0aGF0IHRoZSBzZXJ2ZXJcclxuXHRcdCAqIHdpbGwgY2xvc2UgdGhlIGNvbm5lY3Rpb24gYW5kIHRoZSB0cmFuc3BvcnQsIGFuZCBkbyBub3QgbmVlZCB0byByZXF1ZXN0XHJcblx0XHQgKiBhIGRpc2Nvbm5lY3Rpb24gLSBSVE4xNWkgKi9cclxuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uRmF0YWxFcnJvcigpJywgJ2VyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcclxuXHRcdHRoaXMuZmluaXNoKCdmYWlsZWQnLCBlcnIpO1xyXG5cdH07XHJcblxyXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25DbG9zZSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcclxuXHRcdHZhciBlcnIgPSBtZXNzYWdlICYmIG1lc3NhZ2UuZXJyb3I7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uQ2xvc2UoKScsICdlcnIgPSAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZXJyKSk7XHJcblx0XHR0aGlzLmZpbmlzaCgnY2xvc2VkJywgZXJyKTtcclxuXHR9O1xyXG5cclxuXHRUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3RDbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5yZXF1ZXN0Q2xvc2UoKScsICcnKTtcclxuXHRcdHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xyXG5cdH07XHJcblxyXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdERpc2Nvbm5lY3QgPSBmdW5jdGlvbigpIHtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScsICcnKTtcclxuXHRcdHRoaXMuc2VuZChkaXNjb25uZWN0TWVzc2FnZSk7XHJcblx0fTtcclxuXHJcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24oaWQpIHtcclxuXHRcdHZhciBtc2cgPSB7YWN0aW9uOiBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uQWN0aW9uLkhFQVJUQkVBVH07XHJcblx0XHRpZihpZCkgbXNnLmlkID0gaWQ7XHJcblx0XHR0aGlzLnNlbmQoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMobXNnKSk7XHJcblx0fTtcclxuXHJcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnVHJhbnNwb3J0LmRpc3Bvc2UoKScsICcnKTtcclxuXHRcdHRoaXMuaXNEaXNwb3NlZCA9IHRydWU7XHJcblx0XHR0aGlzLm9mZigpO1xyXG5cdH07XHJcblxyXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25BY3Rpdml0eSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYoIXRoaXMubWF4SWRsZUludGVydmFsKSB7IHJldHVybjsgfVxyXG5cdFx0dGhpcy5sYXN0QWN0aXZpdHkgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmxhc3RBY3Rpdml0eSA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCk7XHJcblx0XHR0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XHJcblx0fTtcclxuXHJcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5zZXRJZGxlVGltZXIgPSBmdW5jdGlvbih0aW1lb3V0KSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRpZighdGhpcy5pZGxlVGltZXIpIHtcclxuXHRcdFx0dGhpcy5pZGxlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHNlbGYub25JZGxlVGltZXJFeHBpcmUoKTtcclxuXHRcdFx0fSwgdGltZW91dCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0VHJhbnNwb3J0LnByb3RvdHlwZS5vbklkbGVUaW1lckV4cGlyZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5pZGxlVGltZXIgPSBudWxsO1xyXG5cdFx0dmFyIHNpbmNlTGFzdCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eSxcclxuXHRcdFx0dGltZVJlbWFpbmluZyA9IHRoaXMubWF4SWRsZUludGVydmFsIC0gc2luY2VMYXN0O1xyXG5cdFx0aWYodGltZVJlbWFpbmluZyA8PSAwKSB7XHJcblx0XHRcdHZhciBtc2cgPSAnTm8gYWN0aXZpdHkgc2VlbiBmcm9tIHJlYWx0aW1lIGluICcgKyBzaW5jZUxhc3QgKyAnbXM7IGFzc3VtaW5nIGNvbm5lY3Rpb24gaGFzIGRyb3BwZWQnO1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnVHJhbnNwb3J0Lm9uSWRsZVRpbWVyRXhwaXJlKCknLCBtc2cpO1xyXG5cdFx0XHR0aGlzLmRpc2Nvbm5lY3QobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDgwMDAzLCA0MDgpKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFRyYW5zcG9ydC5wcm90b3R5cGUub25BdXRoVXBkYXRlZCA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5cdHJldHVybiBUcmFuc3BvcnQ7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFRyYW5zcG9ydCk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDIxICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG52YXIgQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cclxuXHRmdW5jdGlvbiBDb25uZWN0aW9uU3RhdGVDaGFuZ2UocHJldmlvdXMsIGN1cnJlbnQsIHJldHJ5SW4sIHJlYXNvbikge1xyXG5cdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xyXG5cdFx0dGhpcy5jdXJyZW50ID0gY3VycmVudDtcclxuXHRcdGlmKHJldHJ5SW4pIHRoaXMucmV0cnlJbiA9IHJldHJ5SW47XHJcblx0XHRpZihyZWFzb24pIHRoaXMucmVhc29uID0gcmVhc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIENvbm5lY3Rpb25TdGF0ZUNoYW5nZTtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoQ29ubmVjdGlvblN0YXRlQ2hhbmdlKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjIgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuXHJcbnZhciBNdWx0aWNhc3RlciA9IChmdW5jdGlvbigpIHtcclxuXHJcblx0ZnVuY3Rpb24gTXVsdGljYXN0ZXIobWVtYmVycykge1xyXG5cdFx0bWVtYmVycyA9IG1lbWJlcnMgfHwgW107XHJcblxyXG5cdFx0dmFyIGhhbmRsZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lbWJlcnMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR2YXIgbWVtYmVyID0gbWVtYmVyc1tpXTtcclxuXHRcdFx0XHRpZihtZW1iZXIpIHtcclxuXHRcdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHRcdG1lbWJlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaChlKXtcclxuXHRcdFx0XHRcdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnTXVsdGljYXN0ZXIgbXVsdGlwbGUgY2FsbGJhY2sgaGFuZGxlcicsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbjogJyArIGUgKyAnOyBzdGFjayA9ICcgKyBlLnN0YWNrKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0aGFuZGxlci5wdXNoID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KG1lbWJlcnMsIGFyZ3VtZW50cyk7XHJcblx0XHR9O1xyXG5cdFx0cmV0dXJuIGhhbmRsZXI7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gTXVsdGljYXN0ZXI7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKE11bHRpY2FzdGVyKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjMgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBFcnJvclJlcG9ydGVyID0gKGZ1bmN0aW9uKCkge1xyXG5cdGZ1bmN0aW9uIEVycm9yUmVwb3J0ZXIoKSB7fVxyXG5cclxuXHR2YXIgbGV2ZWxzID0gRXJyb3JSZXBvcnRlci5sZXZlbHMgPSBbXHJcblx0XHQnZmF0YWwnLFxyXG5cdFx0J2Vycm9yJyxcclxuXHRcdCd3YXJuaW5nJyxcclxuXHRcdCdpbmZvJyxcclxuXHRcdCdkZWJ1ZydcclxuXHRdO1xyXG5cclxuXHQvKiAobGV2ZWw6IHR5cGVvZiBFcnJvclJlcG9ydGVyLmxldmVsc1tudW1iZXJdLCBtZXNzYWdlOiBzdHJpbmcsIGZpbmdlcnByaW50Pzogc3RyaW5nLCB0YWdzPzoge1trZXk6IHN0cmluZ106IHN0cmluZ30pOiB2b2lkICovXHJcblx0RXJyb3JSZXBvcnRlci5yZXBvcnQgPSBmdW5jdGlvbihsZXZlbCwgbWVzc2FnZSwgZmluZ2VycHJpbnQsIHRhZ3MpIHtcclxuXHRcdHZhciBldmVudElkID0gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmFuZG9tSGV4U3RyaW5nKDE2KTtcclxuXHJcblx0XHR2YXIgZXZlbnQgPSB7XHJcblx0XHRcdGV2ZW50X2lkOiBldmVudElkLFxyXG5cdFx0XHR0YWdzOiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5taXhpbih7XHJcblx0XHRcdFx0YWJseUFnZW50OiBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFnZW50XHJcblx0XHRcdH0sIHRhZ3MpLFxyXG5cdFx0XHRwbGF0Zm9ybTogJ2phdmFzY3JpcHQnLFxyXG5cdFx0XHRsZXZlbDogbGV2ZWwsXHJcblx0XHRcdHJlbGVhc2U6IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0udmVyc2lvbixcclxuXHRcdFx0ZmluZ2VycHJpbnQ6IGZpbmdlcnByaW50ICYmIFsgZmluZ2VycHJpbnQgXSxcclxuXHRcdFx0bWVzc2FnZTogbWVzc2FnZSxcclxuXHRcdFx0cmVxdWVzdDoge1xyXG5cdFx0XHRcdGhlYWRlcnM6IHtcclxuXHRcdFx0XHRcdCdVc2VyLUFnZW50JzogcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51c2VyQWdlbnRcclxuXHRcdFx0XHR9LFxyXG5cdFx0XHRcdHVybDogcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jdXJyZW50VXJsXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnRXJyb3JSZXBvcnRlcicsICdQT1NUaW5nIHRvIGVycm9yIHJlcG9ydGVyOiAnICsgbWVzc2FnZSk7XHJcblx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucG9zdFVyaShudWxsLCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVycm9yUmVwb3J0aW5nVXJsLCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmVycm9yUmVwb3J0aW5nSGVhZGVycywgSlNPTi5zdHJpbmdpZnkoZXZlbnQpLCB7fSwgZnVuY3Rpb24oZXJyLCByZXMpIHtcclxuXHRcdFx0X2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnRXJyb3JSZXBvcnRlcicsICdQT1NUaW5nIHRvIGVycm9yIHJlcG9ydGVyIHJlc3VsdGVkIGluOiAnICtcclxuXHRcdFx0XHQoZXJyID8gX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikgOiBfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0Qm9keShyZXMpKVxyXG5cdFx0XHQpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIEVycm9yUmVwb3J0ZXI7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEVycm9yUmVwb3J0ZXIpO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxudmFyIG1zZ3BhY2sgPSAoZnVuY3Rpb24oKSB7XHJcblx0XCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG5cdHZhciBleHBvcnRzID0ge307XHJcblxyXG5cdGV4cG9ydHMuaW5zcGVjdCA9IGluc3BlY3Q7XHJcblx0ZnVuY3Rpb24gaW5zcGVjdChidWZmZXIpIHtcclxuXHRcdGlmIChidWZmZXIgPT09IHVuZGVmaW5lZClcclxuXHRcdFx0cmV0dXJuIFwidW5kZWZpbmVkXCI7XHJcblx0XHR2YXIgdmlldztcclxuXHRcdHZhciB0eXBlO1xyXG5cdFx0aWYgKCBidWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG5cdFx0XHR0eXBlID0gXCJBcnJheUJ1ZmZlclwiO1xyXG5cdFx0XHR2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XHJcblx0XHR9IGVsc2UgaWYgKCBidWZmZXIgaW5zdGFuY2VvZiBEYXRhVmlldykge1xyXG5cdFx0XHR0eXBlID0gXCJEYXRhVmlld1wiO1xyXG5cdFx0XHR2aWV3ID0gYnVmZmVyO1xyXG5cdFx0fVxyXG5cdFx0aWYgKCF2aWV3KVxyXG5cdFx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYnVmZmVyKTtcclxuXHRcdHZhciBieXRlcyA9IFtdO1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuYnl0ZUxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdGlmIChpID4gMjApIHtcclxuXHRcdFx0XHRieXRlcy5wdXNoKFwiLi4uXCIpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSkudG9TdHJpbmcoMTYpO1xyXG5cdFx0XHRpZiAoYnl0ZV8ubGVuZ3RoID09PSAxKVxyXG5cdFx0XHRcdGJ5dGVfID0gXCIwXCIgKyBieXRlXztcclxuXHRcdFx0Ynl0ZXMucHVzaChieXRlXyk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gXCI8XCIgKyB0eXBlICsgXCIgXCIgKyBieXRlcy5qb2luKFwiIFwiKSArIFwiPlwiO1xyXG5cdH1cclxuXHJcblx0Ly8gRW5jb2RlIHN0cmluZyBhcyB1dGY4IGludG8gZGF0YXZpZXcgYXQgb2Zmc2V0XHJcblx0ZXhwb3J0cy51dGY4V3JpdGUgPSB1dGY4V3JpdGU7XHJcblx0ZnVuY3Rpb24gdXRmOFdyaXRlKHZpZXcsIG9mZnNldCwgc3RyaW5nKSB7XHJcblx0XHR2YXIgYnl0ZUxlbmd0aCA9IHZpZXcuYnl0ZUxlbmd0aDtcclxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xyXG5cdFx0XHR2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XHJcblxyXG5cdFx0XHQvLyBPbmUgYnl0ZSBvZiBVVEYtOFxyXG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MCkge1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4N2YgfCAweDAwKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gVHdvIGJ5dGVzIG9mIFVURi04XHJcblx0XHRcdGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gNiAmIDB4MWYgfCAweGMwKTtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDAgJiAweDNmIHwgMHg4MCk7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIFRocmVlIGJ5dGVzIG9mIFVURi04LlxyXG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMTIgJiAweDBmIHwgMHhlMCk7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMHgzZiB8IDB4ODApO1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gRm91ciBieXRlcyBvZiBVVEYtOFxyXG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCBjb2RlUG9pbnQgPj4+IDE4ICYgMHgwNyB8IDB4ZjApO1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMTIgJiAweDNmIHwgMHg4MCk7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQrKywgY29kZVBvaW50ID4+PiA2ICYgMHgzZiB8IDB4ODApO1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0KyssIGNvZGVQb2ludCA+Pj4gMCAmIDB4M2YgfCAweDgwKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cclxuXHRleHBvcnRzLnV0ZjhSZWFkID0gdXRmOFJlYWQ7XHJcblx0ZnVuY3Rpb24gdXRmOFJlYWQodmlldywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuXHRcdHZhciBzdHJpbmcgPSBcIlwiO1xyXG5cdFx0Zm9yICh2YXIgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgbGVuZ3RoOyBpIDwgZW5kOyBpKyspIHtcclxuXHRcdFx0dmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKTtcclxuXHRcdFx0Ly8gT25lIGJ5dGUgY2hhcmFjdGVyXHJcblx0XHRcdGlmICgoYnl0ZV8gJiAweDgwKSA9PT0gMHgwMCkge1xyXG5cdFx0XHRcdHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVfKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBUd28gYnl0ZSBjaGFyYWN0ZXJcclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ZTApID09PSAweGMwKSB7XHJcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MGYpIDw8IDYpIHwgKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpKTtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBUaHJlZSBieXRlIGNoYXJhY3RlclxyXG5cdFx0XHRpZiAoKGJ5dGVfICYgMHhmMCkgPT09IDB4ZTApIHtcclxuXHRcdFx0XHRzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSgoKGJ5dGVfICYgMHgwZikgPDwgMTIpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIEZvdXIgYnl0ZSBjaGFyYWN0ZXJcclxuXHRcdFx0aWYgKChieXRlXyAmIDB4ZjgpID09PSAweGYwKSB7XHJcblx0XHRcdFx0c3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MDcpIDw8IDE4KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMTIpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCA2KSB8ICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xyXG5cdFx0XHRcdGNvbnRpbnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYnl0ZSBcIiArIGJ5dGVfLnRvU3RyaW5nKDE2KSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gc3RyaW5nO1xyXG5cdH1cclxuXHJcblxyXG5cdGV4cG9ydHMudXRmOEJ5dGVDb3VudCA9IHV0ZjhCeXRlQ291bnQ7XHJcblx0ZnVuY3Rpb24gdXRmOEJ5dGVDb3VudChzdHJpbmcpIHtcclxuXHRcdHZhciBjb3VudCA9IDA7XHJcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0cmluZy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcclxuXHRcdFx0dmFyIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpO1xyXG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHg4MCkge1xyXG5cdFx0XHRcdGNvdW50ICs9IDE7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XHJcblx0XHRcdFx0Y291bnQgKz0gMjtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG5cdFx0XHRcdGNvdW50ICs9IDM7XHJcblx0XHRcdFx0Y29udGludWU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XHJcblx0XHRcdFx0Y291bnQgKz0gNDtcclxuXHRcdFx0XHRjb250aW51ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJiYWQgY29kZXBvaW50IFwiICsgY29kZVBvaW50KTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBjb3VudDtcclxuXHR9XHJcblxyXG5cclxuXHRleHBvcnRzLmVuY29kZSA9IGZ1bmN0aW9uKHZhbHVlLCBzcGFyc2UpIHtcclxuXHRcdHZhciBzaXplID0gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpO1xyXG5cdFx0aWYoc2l6ZSA9PSAwKVxyXG5cdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xyXG5cdFx0dmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcihzaXplKTtcclxuXHRcdHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XHJcblx0XHRlbmNvZGUodmFsdWUsIHZpZXcsIDAsIHNwYXJzZSk7XHJcblx0XHRyZXR1cm4gYnVmZmVyO1xyXG5cdH07XHJcblxyXG5cdGV4cG9ydHMuZGVjb2RlID0gZGVjb2RlO1xyXG5cclxuXHR2YXIgU0hfTF8zMiA9ICgxIDw8IDE2KSAqICgxIDw8IDE2KSwgU0hfUl8zMiA9IDEgLyBTSF9MXzMyO1xyXG5cdGZ1bmN0aW9uIGdldEludDY0KHZpZXcsIG9mZnNldCkge1xyXG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XHJcblx0XHRyZXR1cm4gdmlldy5nZXRJbnQzMihvZmZzZXQpICogU0hfTF8zMiArIHZpZXcuZ2V0VWludDMyKG9mZnNldCArIDQpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0VWludDY0KHZpZXcsIG9mZnNldCkge1xyXG5cdFx0b2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XHJcblx0XHRyZXR1cm4gdmlldy5nZXRVaW50MzIob2Zmc2V0KSAqIFNIX0xfMzIgKyB2aWV3LmdldFVpbnQzMihvZmZzZXQgKyA0KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldEludDY0KHZpZXcsIG9mZnNldCwgdmFsKSB7XHJcblx0XHRpZiAodmFsIDwgMHg4MDAwMDAwMDAwMDAwMDAwKSB7XHJcblx0XHRcdHZpZXcuc2V0SW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcclxuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIDB4N2ZmZmZmZmYpO1xyXG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweDdmZmZmZmZmKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xyXG5cdFx0aWYgKHZhbCA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcclxuXHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0LCBNYXRoLmZsb29yKHZhbCAqIFNIX1JfMzIpKTtcclxuXHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyA0LCB2YWwgJiAtMSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQsIDB4ZmZmZmZmZmYpO1xyXG5cdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyA0LCAweGZmZmZmZmZmKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG4vLyBodHRwczovL2dpc3QuZ2l0aHViLmNvbS9mcnN5dWtpLzU0MzI1NTkgLSB2NSBzcGVjXHJcbi8vXHJcbi8vIEkndmUgdXNlZCBvbmUgZXh0ZW5zaW9uIHBvaW50IGZyb20gYGZpeGV4dCAxYCB0byBzdG9yZSBgdW5kZWZpbmVkYC4gT24gdGhlIHdpcmUgdGhpc1xyXG4vLyBzaG91bGQgdHJhbnNsYXRlIHRvIGV4YWN0bHkgMHhkNDAwMDBcclxuLy9cclxuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xyXG4vLyB8ICAweGQ0ICB8ICAweDAwICB8ICAweDAwICB8XHJcbi8vICstLS0tLS0tLSstLS0tLS0tLSstLS0tLS0tLStcclxuLy8gICAgXiBmaXhleHQgfCAgICAgICAgXiB2YWx1ZSBwYXJ0IHVudXNlZCAoZml4ZWQgdG8gYmUgMClcclxuLy8gICAgICAgICAgICAgXiBpbmRpY2F0ZXMgdW5kZWZpbmVkIHZhbHVlXHJcbi8vXHJcblxyXG5cdGZ1bmN0aW9uIERlY29kZXIodmlldywgb2Zmc2V0KSB7XHJcblx0XHR0aGlzLm9mZnNldCA9IG9mZnNldCB8fCAwO1xyXG5cdFx0dGhpcy52aWV3ID0gdmlldztcclxuXHR9XHJcblxyXG5cclxuXHREZWNvZGVyLnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbihsZW5ndGgpIHtcclxuXHRcdHZhciB2YWx1ZSA9IHt9O1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIga2V5ID0gdGhpcy5wYXJzZSgpO1xyXG5cdFx0XHR2YWx1ZVtrZXldID0gdGhpcy5wYXJzZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH07XHJcblxyXG5cdERlY29kZXIucHJvdG90eXBlLmJpbiA9IERlY29kZXIucHJvdG90eXBlLmJ1ZiA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0dmFyIHZhbHVlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XHJcblx0XHQobmV3IFVpbnQ4QXJyYXkodmFsdWUpKS5zZXQobmV3IFVpbnQ4QXJyYXkodGhpcy52aWV3LmJ1ZmZlciwgdGhpcy5vZmZzZXQsIGxlbmd0aCksIDApO1xyXG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH07XHJcblxyXG5cdERlY29kZXIucHJvdG90eXBlLnN0ciA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0dmFyIHZhbHVlID0gdXRmOFJlYWQodGhpcy52aWV3LCB0aGlzLm9mZnNldCwgbGVuZ3RoKTtcclxuXHRcdHRoaXMub2Zmc2V0ICs9IGxlbmd0aDtcclxuXHRcdHJldHVybiB2YWx1ZTtcclxuXHR9O1xyXG5cclxuXHREZWNvZGVyLnByb3RvdHlwZS5hcnJheSA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0dmFyIHZhbHVlID0gbmV3IEFycmF5KGxlbmd0aCk7XHJcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdHZhbHVlW2ldID0gdGhpcy5wYXJzZSgpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH07XHJcblxyXG5cdERlY29kZXIucHJvdG90eXBlLmV4dCA9IGZ1bmN0aW9uKGxlbmd0aCkge1xyXG5cdFx0dmFyIHZhbHVlID0ge307XHJcblx0XHQvLyBHZXQgdGhlIHR5cGUgYnl0ZVxyXG5cdFx0dmFsdWVbJ3R5cGUnXSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0KTtcclxuXHRcdHRoaXMub2Zmc2V0Kys7XHJcblx0XHQvLyBHZXQgdGhlIGRhdGEgYXJyYXkgKGxlbmd0aClcclxuXHRcdHZhbHVlWydkYXRhJ10gPSB0aGlzLmJ1ZihsZW5ndGgpO1xyXG5cdFx0dGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xyXG5cdFx0cmV0dXJuIHZhbHVlO1xyXG5cdH07XHJcblxyXG5cdERlY29kZXIucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdHlwZSA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCk7XHJcblx0XHR2YXIgdmFsdWUsIGxlbmd0aDtcclxuXHJcblx0XHQvLyBQb3NpdGl2ZSBGaXhJbnQgLSAweHh4eHh4eFxyXG5cdFx0aWYgKCh0eXBlICYgMHg4MCkgPT09IDB4MDApIHtcclxuXHRcdFx0dGhpcy5vZmZzZXQrKztcclxuXHRcdFx0cmV0dXJuIHR5cGU7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gRml4TWFwIC0gMTAwMHh4eHhcclxuXHRcdGlmICgodHlwZSAmIDB4ZjApID09PSAweDgwKSB7XHJcblx0XHRcdGxlbmd0aCA9IHR5cGUgJiAweDBmO1xyXG5cdFx0XHR0aGlzLm9mZnNldCsrO1xyXG5cdFx0XHRyZXR1cm4gdGhpcy5tYXAobGVuZ3RoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaXhBcnJheSAtIDEwMDF4eHh4XHJcblx0XHRpZiAoKHR5cGUgJiAweGYwKSA9PT0gMHg5MCkge1xyXG5cdFx0XHRsZW5ndGggPSB0eXBlICYgMHgwZjtcclxuXHRcdFx0dGhpcy5vZmZzZXQrKztcclxuXHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBGaXhTdHIgLSAxMDF4eHh4eFxyXG5cdFx0aWYgKCh0eXBlICYgMHhlMCkgPT09IDB4YTApIHtcclxuXHRcdFx0bGVuZ3RoID0gdHlwZSAmIDB4MWY7XHJcblx0XHRcdHRoaXMub2Zmc2V0Kys7XHJcblx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIE5lZ2F0aXZlIEZpeEludCAtIDExMXh4eHh4XHJcblx0XHRpZiAoKHR5cGUgJiAweGUwKSA9PT0gMHhlMCkge1xyXG5cdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRJbnQ4KHRoaXMub2Zmc2V0KTtcclxuXHRcdFx0dGhpcy5vZmZzZXQrKztcclxuXHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHN3aXRjaCAodHlwZSkge1xyXG5cclxuXHRcdFx0Ly8gbmlsXHJcblx0XHRcdGNhc2UgMHhjMDpcclxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xyXG5cdFx0XHRcdHJldHVybiBudWxsO1xyXG5cclxuXHRcdFx0Ly8gMHhjMSBuZXZlciB1c2VkIC0gdXNlIGZvciB1bmRlZmluZWQgKE5PTi1TVEFOREFSRClcclxuXHRcdFx0Y2FzZSAweGMxOlxyXG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XHJcblx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcclxuXHJcblx0XHRcdC8vIGZhbHNlXHJcblx0XHRcdGNhc2UgMHhjMjpcclxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcclxuXHJcblx0XHRcdC8vIHRydWVcclxuXHRcdFx0Y2FzZSAweGMzOlxyXG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XHJcblx0XHRcdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdFx0XHQvLyBiaW4gOFxyXG5cdFx0XHRjYXNlIDB4YzQ6XHJcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XHJcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5iaW4obGVuZ3RoKTtcclxuXHJcblx0XHRcdC8vIGJpbiAxNlxyXG5cdFx0XHRjYXNlIDB4YzU6XHJcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYmluKGxlbmd0aCk7XHJcblxyXG5cdFx0XHQvLyBiaW4gMzJcclxuXHRcdFx0Y2FzZSAweGM2OlxyXG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmJpbihsZW5ndGgpO1xyXG5cclxuXHRcdFx0Ly8gZXh0IDhcclxuXHRcdFx0Y2FzZSAweGM3OlxyXG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50OCh0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDI7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XHJcblxyXG5cdFx0XHQvLyBleHQgMTZcclxuXHRcdFx0Y2FzZSAweGM4OlxyXG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xyXG5cclxuXHRcdFx0Ly8gZXh0IDMyXHJcblx0XHRcdGNhc2UgMHhjOTpcclxuXHRcdFx0XHRsZW5ndGggPSB0aGlzLnZpZXcuZ2V0VWludDMyKHRoaXMub2Zmc2V0ICsgMSk7XHJcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcclxuXHJcblx0XHRcdC8vIGZsb2F0IDMyXHJcblx0XHRcdGNhc2UgMHhjYTpcclxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRGbG9hdDMyKHRoaXMub2Zmc2V0ICsgMSk7XHJcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gNTtcclxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcblxyXG5cdFx0XHQvLyBmbG9hdCA2NFxyXG5cdFx0XHRjYXNlIDB4Y2I6XHJcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0RmxvYXQ2NCh0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdFx0Ly8gdWludDhcclxuXHRcdFx0Y2FzZSAweGNjOlxyXG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XHJcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcclxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcblxyXG5cdFx0XHQvLyB1aW50IDE2XHJcblx0XHRcdGNhc2UgMHhjZDpcclxuXHRcdFx0XHR2YWx1ZSA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xyXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHJcblx0XHRcdC8vIHVpbnQgMzJcclxuXHRcdFx0Y2FzZSAweGNlOlxyXG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdFx0Ly8gdWludCA2NFxyXG5cdFx0XHRjYXNlIDB4Y2Y6XHJcblx0XHRcdFx0dmFsdWUgPSBnZXRVaW50NjQodGhpcy52aWV3LCB0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDk7XHJcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xyXG5cclxuXHRcdFx0Ly8gaW50IDhcclxuXHRcdFx0Y2FzZSAweGQwOlxyXG5cdFx0XHRcdHZhbHVlID0gdGhpcy52aWV3LmdldEludDgodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAyO1xyXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHJcblx0XHRcdC8vIGludCAxNlxyXG5cdFx0XHRjYXNlIDB4ZDE6XHJcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MTYodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xyXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHJcblx0XHRcdC8vIGludCAzMlxyXG5cdFx0XHRjYXNlIDB4ZDI6XHJcblx0XHRcdFx0dmFsdWUgPSB0aGlzLnZpZXcuZ2V0SW50MzIodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xyXG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcclxuXHJcblx0XHRcdC8vIGludCA2NFxyXG5cdFx0XHRjYXNlIDB4ZDM6XHJcblx0XHRcdFx0dmFsdWUgPSBnZXRJbnQ2NCh0aGlzLnZpZXcsIHRoaXMub2Zmc2V0ICsgMSk7XHJcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gOTtcclxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XHJcblxyXG5cdFx0XHQvLyBmaXhleHQgMVxyXG5cdFx0XHRjYXNlIDB4ZDQ6XHJcblx0XHRcdFx0bGVuZ3RoID0gMTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xyXG5cclxuXHRcdFx0Ly8gZml4ZXh0IDJcclxuXHRcdFx0Y2FzZSAweGQ1OlxyXG5cdFx0XHRcdGxlbmd0aCA9IDI7XHJcblx0XHRcdFx0dGhpcy5vZmZzZXQrKztcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5leHQobGVuZ3RoKTtcclxuXHJcblx0XHRcdC8vIGZpeGV4dCA0XHJcblx0XHRcdGNhc2UgMHhkNjpcclxuXHRcdFx0XHRsZW5ndGggPSA0O1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0Kys7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuZXh0KGxlbmd0aCk7XHJcblxyXG5cdFx0XHQvLyBmaXhleHQgOFxyXG5cdFx0XHRjYXNlIDB4ZDc6XHJcblx0XHRcdFx0bGVuZ3RoID0gODtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xyXG5cclxuXHRcdFx0Ly8gZml4ZXh0IDE2XHJcblx0XHRcdGNhc2UgMHhkODpcclxuXHRcdFx0XHRsZW5ndGggPSAxNjtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCsrO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmV4dChsZW5ndGgpO1xyXG5cclxuXHRcdFx0Ly8gc3RyOFxyXG5cdFx0XHRjYXNlIDB4ZDk6XHJcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQ4KHRoaXMub2Zmc2V0ICsgMSk7XHJcblx0XHRcdFx0dGhpcy5vZmZzZXQgKz0gMjtcclxuXHRcdFx0XHRyZXR1cm4gdGhpcy5zdHIobGVuZ3RoKTtcclxuXHJcblx0XHRcdC8vIHN0ciAxNlxyXG5cdFx0XHRjYXNlIDB4ZGE6XHJcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuc3RyKGxlbmd0aCk7XHJcblxyXG5cdFx0XHQvLyBzdHIgMzJcclxuXHRcdFx0Y2FzZSAweGRiOlxyXG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLnN0cihsZW5ndGgpO1xyXG5cclxuXHRcdFx0Ly8gYXJyYXkgMTZcclxuXHRcdFx0Y2FzZSAweGRjOlxyXG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MTYodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSAzO1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLmFycmF5KGxlbmd0aCk7XHJcblxyXG5cdFx0XHQvLyBhcnJheSAzMlxyXG5cdFx0XHRjYXNlIDB4ZGQ6XHJcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQzMih0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDU7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMuYXJyYXkobGVuZ3RoKTtcclxuXHJcblx0XHRcdC8vIG1hcCAxNlxyXG5cdFx0XHRjYXNlIDB4ZGU6XHJcblx0XHRcdFx0bGVuZ3RoID0gdGhpcy52aWV3LmdldFVpbnQxNih0aGlzLm9mZnNldCArIDEpO1xyXG5cdFx0XHRcdHRoaXMub2Zmc2V0ICs9IDM7XHJcblx0XHRcdFx0cmV0dXJuIHRoaXMubWFwKGxlbmd0aCk7XHJcblxyXG5cdFx0XHQvLyBtYXAgMzJcclxuXHRcdFx0Y2FzZSAweGRmOlxyXG5cdFx0XHRcdGxlbmd0aCA9IHRoaXMudmlldy5nZXRVaW50MzIodGhpcy5vZmZzZXQgKyAxKTtcclxuXHRcdFx0XHR0aGlzLm9mZnNldCArPSA1O1xyXG5cdFx0XHRcdHJldHVybiB0aGlzLm1hcChsZW5ndGgpO1xyXG5cdFx0fVxyXG5cdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biB0eXBlIDB4XCIgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gZGVjb2RlKGJ1ZmZlcikge1xyXG5cdFx0dmFyIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcclxuXHRcdHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIodmlldyk7XHJcblx0XHR2YXIgdmFsdWUgPSBkZWNvZGVyLnBhcnNlKCk7XHJcblx0XHRpZiAoZGVjb2Rlci5vZmZzZXQgIT09IGJ1ZmZlci5ieXRlTGVuZ3RoKVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoKGJ1ZmZlci5ieXRlTGVuZ3RoIC0gZGVjb2Rlci5vZmZzZXQpICsgXCIgdHJhaWxpbmcgYnl0ZXNcIik7XHJcblx0XHRyZXR1cm4gdmFsdWU7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKSB7XHJcblx0XHR2YXIga2V5cyA9IFtdOyAvLyBUT0RPOiB1c2UgT2JqZWN0LmtleXMgd2hlbiB3ZSBhcmUgYWJsZSB0byB0cmFuc3BpbGUgdG8gRVMzXHJcblx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcclxuXHRcdFx0aWYgKCF2YWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSBjb250aW51ZTtcclxuXHRcdFx0a2V5cy5wdXNoKGtleSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4ga2V5cy5maWx0ZXIoZnVuY3Rpb24gKGUpIHtcclxuXHRcdFx0dmFyIHZhbCA9IHZhbHVlW2VdLCB0eXBlID0gdHlwZW9mKHZhbCk7XHJcblx0XHRcdHJldHVybiAoIXNwYXJzZSB8fCAodmFsICE9PSB1bmRlZmluZWQgJiYgdmFsICE9PSBudWxsKSkgJiYgKCdmdW5jdGlvbicgIT09IHR5cGUgfHwgISF2YWwudG9KU09OKTtcclxuXHRcdH0pXHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBlbmNvZGUodmFsdWUsIHZpZXcsIG9mZnNldCwgc3BhcnNlKSB7XHJcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcclxuXHJcblx0XHQvLyBTdHJpbmdzIEJ5dGVzXHJcblx0XHQvLyBUaGVyZSBhcmUgZm91ciBzdHJpbmcgdHlwZXM6IGZpeHN0ci9zdHI4L3N0cjE2L3N0cjMyXHJcblx0XHRpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHR2YXIgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XHJcblxyXG5cdFx0XHQvLyBmaXhzdHJcclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MjApIHtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoIHwgMHhhMCk7XHJcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcclxuXHRcdFx0XHRyZXR1cm4gMSArIGxlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Ly8gc3RyOFxyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkOSk7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xyXG5cdFx0XHRcdHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAyLCB2YWx1ZSk7XHJcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIHN0cjE2XHJcblx0XHRcdGlmIChsZW5ndGggPCAweDEwMDAwKSB7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGEpO1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XHJcblx0XHRcdFx0dXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDMsIHZhbHVlKTtcclxuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBzdHIzMlxyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkYik7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgbGVuZ3RoKTtcclxuXHRcdFx0XHR1dGY4V3JpdGUodmlldywgb2Zmc2V0ICsgNSwgdmFsdWUpO1xyXG5cdFx0XHRcdHJldHVybiA1ICsgbGVuZ3RoO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoQXJyYXlCdWZmZXIuaXNWaWV3ICYmIEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcclxuXHRcdFx0Ly8gZXh0cmFjdCB0aGUgYXJyYXlidWZmZXIgYW5kIGZhbGx0aHJvdWdoXHJcblx0XHRcdHZhbHVlID0gdmFsdWUuYnVmZmVyO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIFRoZXJlIGFyZSB0aHJlZSBiaW4gdHlwZXM6IGJpbjgvYmluMTYvYmluMzJcclxuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XHJcblx0XHRcdHZhciBsZW5ndGggPSB2YWx1ZS5ieXRlTGVuZ3RoO1xyXG5cclxuXHRcdFx0Ly8gYmluOFxyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDApIHtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNCk7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQgKyAxLCBsZW5ndGgpO1xyXG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDIpO1xyXG5cdFx0XHRcdHJldHVybiAyICsgbGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiaW4xNlxyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM1KTtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCBsZW5ndGgpO1xyXG5cdFx0XHRcdChuZXcgVWludDhBcnJheSh2aWV3LmJ1ZmZlcikpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDMpO1xyXG5cdFx0XHRcdHJldHVybiAzICsgbGVuZ3RoO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBiaW4gMzJcclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzYpO1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aCk7XHJcblx0XHRcdFx0KG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKSkuc2V0KG5ldyBVaW50OEFycmF5KHZhbHVlKSwgb2Zmc2V0ICsgNSk7XHJcblx0XHRcdFx0cmV0dXJuIDUgKyBsZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZiAodHlwZSA9PT0gXCJudW1iZXJcIikge1xyXG5cclxuXHRcdFx0Ly8gRmxvYXRpbmcgUG9pbnRcclxuXHRcdFx0Ly8gTk9URTogV2UncmUgYWx3YXlzIHVzaW5nIGZsb2F0NjRcclxuXHRcdFx0aWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNiKTtcclxuXHRcdFx0XHR2aWV3LnNldEZsb2F0NjQob2Zmc2V0ICsgMSwgdmFsdWUpO1xyXG5cdFx0XHRcdHJldHVybiA5O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvLyBJbnRlZ2Vyc1xyXG5cdFx0XHRpZiAodmFsdWUgPj0gMCkge1xyXG5cdFx0XHRcdC8vIHBvc2l0aXZlIGZpeG51bVxyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4ODApIHtcclxuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gMTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gdWludCA4XHJcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDApIHtcclxuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNjKTtcclxuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgdmFsdWUpO1xyXG5cdFx0XHRcdFx0cmV0dXJuIDI7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdC8vIHVpbnQgMTZcclxuXHRcdFx0XHRpZiAodmFsdWUgPCAweDEwMDAwKSB7XHJcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZCk7XHJcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gMztcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gdWludCAzMlxyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwKSB7XHJcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZSk7XHJcblx0XHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCB2YWx1ZSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gNTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Ly8gdWludCA2NFxyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApIHtcclxuXHRcdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNmKTtcclxuXHRcdFx0XHRcdHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XHJcblx0XHRcdFx0XHRyZXR1cm4gOTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBiaWcgMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIG5lZ2F0aXZlIGZpeG51bVxyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4MjApIHtcclxuXHRcdFx0XHR2aWV3LnNldEludDgob2Zmc2V0LCB2YWx1ZSk7XHJcblx0XHRcdFx0cmV0dXJuIDE7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaW50IDhcclxuXHRcdFx0aWYgKHZhbHVlID49IC0weDgwKSB7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDApO1xyXG5cdFx0XHRcdHZpZXcuc2V0SW50OChvZmZzZXQgKyAxLCB2YWx1ZSk7XHJcblx0XHRcdFx0cmV0dXJuIDI7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaW50IDE2XHJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwKSB7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDEpO1xyXG5cdFx0XHRcdHZpZXcuc2V0SW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xyXG5cdFx0XHRcdHJldHVybiAzO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8vIGludCAzMlxyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApIHtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMik7XHJcblx0XHRcdFx0dmlldy5zZXRJbnQzMihvZmZzZXQgKyAxLCB2YWx1ZSk7XHJcblx0XHRcdFx0cmV0dXJuIDU7XHJcblx0XHRcdH1cclxuXHRcdFx0Ly8gaW50IDY0XHJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKSB7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDMpO1xyXG5cdFx0XHRcdHNldEludDY0KHZpZXcsIG9mZnNldCArIDEsIHZhbHVlKTtcclxuXHRcdFx0XHRyZXR1cm4gOTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIHNtYWxsIC0weFwiICsgKC12YWx1ZSkudG9TdHJpbmcoMTYpLnN1YnN0cigxKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0Ly8gdW5kZWZpbmVkIC0gdXNlIGQ0IChOT04tU1RBTkRBUkQpXHJcblx0XHRpZiAodHlwZSA9PT0gXCJ1bmRlZmluZWRcIikge1xyXG5cdFx0XHRpZihzcGFyc2UpIHJldHVybiAwO1xyXG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkNCk7XHJcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgMHgwMCk7XHJcblx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMiwgMHgwMCk7XHJcblx0XHRcdHJldHVybiAzO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIG51bGxcclxuXHRcdGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG5cdFx0XHRpZihzcGFyc2UpIHJldHVybiAwO1xyXG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjMCk7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJvb2xlYW5cclxuXHRcdGlmICh0eXBlID09PSBcImJvb2xlYW5cIikge1xyXG5cdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUgPyAweGMzIDogMHhjMik7XHJcblx0XHRcdHJldHVybiAxO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKCdmdW5jdGlvbicgPT09IHR5cGVvZiB2YWx1ZS50b0pTT04pXHJcblx0XHRcdHJldHVybiBlbmNvZGUodmFsdWUudG9KU09OKCksIHZpZXcsIG9mZnNldCwgc3BhcnNlKTtcclxuXHJcblx0XHQvLyBDb250YWluZXIgVHlwZXNcclxuXHRcdGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdHZhciBsZW5ndGgsIHNpemUgPSAwO1xyXG5cdFx0XHR2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkodmFsdWUpO1xyXG5cclxuXHRcdFx0aWYgKGlzQXJyYXkpIHtcclxuXHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dmFyIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcclxuXHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHNpemU7XHJcblx0XHRcdGlmIChsZW5ndGggPCAweDEwKSB7XHJcblx0XHRcdFx0dmlldy5zZXRVaW50OChvZmZzZXQsIGxlbmd0aCB8ICggaXNBcnJheSA/IDB4OTAgOiAweDgwKSk7XHJcblx0XHRcdFx0c2l6ZSA9IDE7XHJcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMCkge1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDgob2Zmc2V0LCBpc0FycmF5ID8gMHhkYyA6IDB4ZGUpO1xyXG5cdFx0XHRcdHZpZXcuc2V0VWludDE2KG9mZnNldCArIDEsIGxlbmd0aCk7XHJcblx0XHRcdFx0c2l6ZSA9IDM7XHJcblx0XHRcdH0gZWxzZSBpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQ4KG9mZnNldCwgaXNBcnJheSA/IDB4ZGQgOiAweGRmKTtcclxuXHRcdFx0XHR2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGgpO1xyXG5cdFx0XHRcdHNpemUgPSA1O1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZiAoaXNBcnJheSkge1xyXG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdHNpemUgKz0gZW5jb2RlKHZhbHVlW2ldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcclxuXHRcdFx0XHRcdHNpemUgKz0gZW5jb2RlKGtleSwgdmlldywgb2Zmc2V0ICsgc2l6ZSk7XHJcblx0XHRcdFx0XHRzaXplICs9IGVuY29kZSh2YWx1ZVtrZXldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0cmV0dXJuIHNpemU7XHJcblx0XHR9XHJcblx0XHRpZih0eXBlID09PSBcImZ1bmN0aW9uXCIpXHJcblx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpIHtcclxuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xyXG5cclxuXHRcdC8vIGZpeHN0ciBvciBzdHI4IG9yIHN0cjE2IG9yIHN0cjMyXHJcblx0XHRpZiAodHlwZSA9PT0gXCJzdHJpbmdcIikge1xyXG5cdFx0XHR2YXIgbGVuZ3RoID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XHJcblx0XHRcdGlmIChsZW5ndGggPCAweDIwKSB7XHJcblx0XHRcdFx0cmV0dXJuIDEgKyBsZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcclxuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcclxuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XHJcblx0XHRcdC8vIGV4dHJhY3QgdGhlIGFycmF5YnVmZmVyIGFuZCBmYWxsdGhyb3VnaFxyXG5cdFx0XHR2YWx1ZSA9IHZhbHVlLmJ1ZmZlcjtcclxuXHRcdH1cclxuXHJcblx0XHQvLyBiaW44IG9yIGJpbjE2IG9yIGJpbjMyXHJcblx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xyXG5cdFx0XHR2YXIgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIDIgKyBsZW5ndGg7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcclxuXHRcdFx0XHRyZXR1cm4gMyArIGxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZiAobGVuZ3RoIDwgMHgxMDAwMDAwMDApIHtcclxuXHRcdFx0XHRyZXR1cm4gNSArIGxlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmICh0eXBlID09PSBcIm51bWJlclwiKSB7XHJcblx0XHRcdC8vIEZsb2F0aW5nIFBvaW50ICgzMiBiaXRzKVxyXG5cdFx0XHQvLyBkb3VibGVcclxuXHRcdFx0aWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcclxuXHRcdFx0XHRyZXR1cm4gOTtcclxuXHJcblx0XHRcdC8vIEludGVnZXJzXHJcblx0XHRcdGlmICh2YWx1ZSA+PSAwKSB7XHJcblx0XHRcdFx0Ly8gcG9zaXRpdmUgZml4aW50XHJcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHg4MClcclxuXHRcdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHRcdC8vIHVpbnQgOFxyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwKVxyXG5cdFx0XHRcdFx0cmV0dXJuIDI7XHJcblx0XHRcdFx0Ly8gdWludCAxNlxyXG5cdFx0XHRcdGlmICh2YWx1ZSA8IDB4MTAwMDApXHJcblx0XHRcdFx0XHRyZXR1cm4gMztcclxuXHRcdFx0XHQvLyB1aW50IDMyXHJcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApXHJcblx0XHRcdFx0XHRyZXR1cm4gNTtcclxuXHRcdFx0XHQvLyB1aW50IDY0XHJcblx0XHRcdFx0aWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMClcclxuXHRcdFx0XHRcdHJldHVybiA5O1xyXG5cdFx0XHRcdC8vIFRvbyBiaWdcclxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJOdW1iZXIgdG9vIGJpZyAweFwiICsgdmFsdWUudG9TdHJpbmcoMTYpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHQvLyBuZWdhdGl2ZSBmaXhpbnRcclxuXHRcdFx0aWYgKHZhbHVlID49IC0weDIwKVxyXG5cdFx0XHRcdHJldHVybiAxO1xyXG5cdFx0XHQvLyBpbnQgOFxyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODApXHJcblx0XHRcdFx0cmV0dXJuIDI7XHJcblx0XHRcdC8vIGludCAxNlxyXG5cdFx0XHRpZiAodmFsdWUgPj0gLTB4ODAwMClcclxuXHRcdFx0XHRyZXR1cm4gMztcclxuXHRcdFx0Ly8gaW50IDMyXHJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMClcclxuXHRcdFx0XHRyZXR1cm4gNTtcclxuXHRcdFx0Ly8gaW50IDY0XHJcblx0XHRcdGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKVxyXG5cdFx0XHRcdHJldHVybiA5O1xyXG5cdFx0XHQvLyBUb28gc21hbGxcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiTnVtYmVyIHRvbyBzbWFsbCAtMHhcIiArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8vIEJvb2xlYW5cclxuXHRcdGlmICh0eXBlID09PSBcImJvb2xlYW5cIikgcmV0dXJuIDE7XHJcblxyXG5cdFx0Ly8gdW5kZWZpbmVkLCBudWxsXHJcblx0XHRpZiAodmFsdWUgPT09IG51bGwpIHJldHVybiBzcGFyc2UgPyAwIDogMTtcclxuXHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm4gc3BhcnNlID8gMCA6IDM7XHJcblxyXG5cdFx0aWYoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcclxuXHRcdFx0cmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcclxuXHJcblx0XHQvLyBDb250YWluZXIgVHlwZXNcclxuXHRcdGlmICh0eXBlID09PSBcIm9iamVjdFwiKSB7XHJcblx0XHRcdHZhciBsZW5ndGgsIHNpemUgPSAwO1xyXG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuXHRcdFx0XHRsZW5ndGggPSB2YWx1ZS5sZW5ndGg7XHJcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xyXG5cdFx0XHRcdFx0c2l6ZSArPSBzaXplb2YodmFsdWVbaV0sIHNwYXJzZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdHZhciBrZXlzID0gZW5jb2RlYWJsZUtleXModmFsdWUsIHNwYXJzZSlcclxuXHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcclxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcclxuXHRcdFx0XHRcdHNpemUgKz0gc2l6ZW9mKGtleSkgKyBzaXplb2YodmFsdWVba2V5XSwgc3BhcnNlKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTApIHtcclxuXHRcdFx0XHRyZXR1cm4gMSArIHNpemU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDApIHtcclxuXHRcdFx0XHRyZXR1cm4gMyArIHNpemU7XHJcblx0XHRcdH1cclxuXHRcdFx0aWYgKGxlbmd0aCA8IDB4MTAwMDAwMDAwKSB7XHJcblx0XHRcdFx0cmV0dXJuIDUgKyBzaXplO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRocm93IG5ldyBFcnJvcihcIkFycmF5IG9yIG9iamVjdCB0b28gbG9uZyAweFwiICsgbGVuZ3RoLnRvU3RyaW5nKDE2KSk7XHJcblx0XHR9XHJcblx0XHRpZih0eXBlID09PSBcImZ1bmN0aW9uXCIpXHJcblx0XHRcdHJldHVybiAwO1xyXG5cclxuXHRcdHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZSBcIiArIHR5cGUpO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIGV4cG9ydHM7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKG1zZ3BhY2spO1xyXG5cclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyNSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovKGZ1bmN0aW9uKGdsb2JhbCkgey8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcHJvdG9jb2xfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMzQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NsaWVudF9jb25uZWN0aW9uc3RhdGVjaGFuZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzhfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjEpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zcG9ydF9jb25uZWN0aW9uZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTMpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX21lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEzX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDkpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfbXVsdGljYXN0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2Vycm9ycmVwb3J0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE1X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE2KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX3RyYW5zcG9ydHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE3X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQxKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF93ZWJzb2NrZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE4X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgQ29ubmVjdGlvbk1hbmFnZXIgPSAoZnVuY3Rpb24oKSB7XHJcblx0dmFyIGhhdmVXZWJTdG9yYWdlID0gISEodHlwZW9mKHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0pICE9PSAndW5kZWZpbmVkJyAmJiBwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldCk7XHJcblx0dmFyIGhhdmVTZXNzaW9uU3RvcmFnZSA9ICEhKHR5cGVvZihwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKSAhPT0gJ3VuZGVmaW5lZCcgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRTZXNzaW9uKTtcclxuXHR2YXIgYWN0aW9ucyA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb247XHJcblx0dmFyIFBlbmRpbmdNZXNzYWdlID0gX3Byb3RvY29sX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUGVuZGluZ01lc3NhZ2U7XHJcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xyXG5cdHZhciB0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcjtcclxuXHR2YXIgb3B0aW1hbFRyYW5zcG9ydCA9IHRyYW5zcG9ydFByZWZlcmVuY2VPcmRlclt0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIubGVuZ3RoIC0gMV07XHJcblx0dmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gJ2FibHktdHJhbnNwb3J0LXByZWZlcmVuY2UnO1xyXG5cclxuXHR2YXIgc2Vzc2lvblJlY292ZXJ5TmFtZSA9ICdhYmx5LWNvbm5lY3Rpb24tcmVjb3ZlcnknO1xyXG5cdGZ1bmN0aW9uIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcclxuXHRcdHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXRTZXNzaW9uKHNlc3Npb25SZWNvdmVyeU5hbWUpO1xyXG5cdH1cclxuXHRmdW5jdGlvbiBzZXRTZXNzaW9uUmVjb3ZlckRhdGEodmFsdWUpIHtcclxuXHRcdHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zZXRTZXNzaW9uKHNlc3Npb25SZWNvdmVyeU5hbWUsIHZhbHVlKTtcclxuXHR9XHJcblx0ZnVuY3Rpb24gY2xlYXJTZXNzaW9uUmVjb3ZlckRhdGEoKSB7XHJcblx0XHRyZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlICYmIHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVtb3ZlU2Vzc2lvbihzZXNzaW9uUmVjb3ZlcnlOYW1lKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIGJldHRlclRyYW5zcG9ydFRoYW4oYSwgYikge1xyXG5cdFx0cmV0dXJuIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZih0cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGEuc2hvcnROYW1lKSA+XHJcblx0XHQgICBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluZGV4T2YodHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLCBiLnNob3J0TmFtZSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBUcmFuc3BvcnRQYXJhbXMob3B0aW9ucywgaG9zdCwgbW9kZSwgY29ubmVjdGlvbktleSkge1xyXG5cdFx0dGhpcy5vcHRpb25zID0gb3B0aW9ucztcclxuXHRcdHRoaXMuaG9zdCA9IGhvc3Q7XHJcblx0XHR0aGlzLm1vZGUgPSBtb2RlO1xyXG5cdFx0dGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcclxuXHRcdHRoaXMuZm9ybWF0ID0gb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJztcclxuXHJcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnRpbWVTZXJpYWwgPSB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRUcmFuc3BvcnRQYXJhbXMucHJvdG90eXBlLmdldENvbm5lY3RQYXJhbXMgPSBmdW5jdGlvbihhdXRoUGFyYW1zKSB7XHJcblx0XHR2YXIgcGFyYW1zID0gYXV0aFBhcmFtcyA/IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY29weShhdXRoUGFyYW1zKSA6IHt9O1xyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XHJcblx0XHRzd2l0Y2godGhpcy5tb2RlKSB7XHJcblx0XHRcdGNhc2UgJ3VwZ3JhZGUnOlxyXG5cdFx0XHRcdHBhcmFtcy51cGdyYWRlID0gdGhpcy5jb25uZWN0aW9uS2V5O1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdyZXN1bWUnOlxyXG5cdFx0XHRcdHBhcmFtcy5yZXN1bWUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XHJcblx0XHRcdFx0aWYodGhpcy50aW1lU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsO1xyXG5cdFx0XHRcdH0gZWxzZSBpZih0aGlzLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRcdFx0cGFyYW1zLmNvbm5lY3Rpb25TZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWw7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdyZWNvdmVyJzpcclxuXHRcdFx0XHR2YXIgbWF0Y2ggPSBvcHRpb25zLnJlY292ZXIuc3BsaXQoJzonKTtcclxuXHRcdFx0XHRpZihtYXRjaCkge1xyXG5cdFx0XHRcdFx0cGFyYW1zLnJlY292ZXIgPSBtYXRjaFswXTtcclxuXHRcdFx0XHRcdHZhciByZWNvdmVyU2VyaWFsID0gbWF0Y2hbMV07XHJcblx0XHRcdFx0XHRpZihpc05hTihyZWNvdmVyU2VyaWFsKSkge1xyXG5cdFx0XHRcdFx0XHRwYXJhbXMudGltZVNlcmlhbCA9IHJlY292ZXJTZXJpYWw7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRwYXJhbXMuY29ubmVjdGlvblNlcmlhbCA9IHJlY292ZXJTZXJpYWw7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0fVxyXG5cdFx0aWYob3B0aW9ucy5jbGllbnRJZCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHBhcmFtcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XHJcblx0XHR9XHJcblx0XHRpZihvcHRpb25zLmVjaG9NZXNzYWdlcyA9PT0gZmFsc2UpIHtcclxuXHRcdFx0cGFyYW1zLmVjaG8gPSAnZmFsc2UnO1xyXG5cdFx0fVxyXG5cdFx0aWYodGhpcy5mb3JtYXQgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRwYXJhbXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XHJcblx0XHR9XHJcblx0XHRpZih0aGlzLnN0cmVhbSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHBhcmFtcy5zdHJlYW0gPSB0aGlzLnN0cmVhbTtcclxuXHRcdH1cclxuXHRcdGlmKHRoaXMuaGVhcnRiZWF0cyAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHBhcmFtcy5oZWFydGJlYXRzID0gdGhpcy5oZWFydGJlYXRzO1xyXG5cdFx0fVxyXG5cdFx0cGFyYW1zLnYgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFwaVZlcnNpb247XHJcblx0XHRwYXJhbXMuYWdlbnQgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFnZW50O1xyXG5cdFx0aWYob3B0aW9ucy50cmFuc3BvcnRQYXJhbXMgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm1peGluKHBhcmFtcywgb3B0aW9ucy50cmFuc3BvcnRQYXJhbXMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhcmFtcztcclxuXHR9O1xyXG5cclxuXHRUcmFuc3BvcnRQYXJhbXMucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgcmVzdWx0ID0gJ1ttb2RlPScgKyB0aGlzLm1vZGU7XHJcblx0XHRpZih0aGlzLmhvc3QpIHsgcmVzdWx0ICs9ICgnLGhvc3Q9JyArIHRoaXMuaG9zdCk7IH1cclxuXHRcdGlmKHRoaXMuY29ubmVjdGlvbktleSkgeyByZXN1bHQgKz0gKCcsY29ubmVjdGlvbktleT0nICsgdGhpcy5jb25uZWN0aW9uS2V5KTsgfVxyXG5cdFx0aWYodGhpcy5jb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHsgcmVzdWx0ICs9ICgnLGNvbm5lY3Rpb25TZXJpYWw9JyArIHRoaXMuY29ubmVjdGlvblNlcmlhbCk7IH1cclxuXHRcdGlmKHRoaXMudGltZVNlcmlhbCkgeyByZXN1bHQgKz0gKCcsdGltZVNlcmlhbD0nICsgdGhpcy50aW1lU2VyaWFsKTsgfVxyXG5cdFx0aWYodGhpcy5mb3JtYXQpIHsgcmVzdWx0ICs9ICgnLGZvcm1hdD0nICsgdGhpcy5mb3JtYXQpOyB9XHJcblx0XHRyZXN1bHQgKz0gJ10nO1xyXG5cclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXHJcblx0ZnVuY3Rpb24gQ29ubmVjdGlvbk1hbmFnZXIocmVhbHRpbWUsIG9wdGlvbnMpIHtcclxuXHRcdF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLnJlYWx0aW1lID0gcmVhbHRpbWU7XHJcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xyXG5cdFx0dmFyIHRpbWVvdXRzID0gb3B0aW9ucy50aW1lb3V0cztcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdC8qIGNvbm5lY3RpbmdUaW1lb3V0OiBsZWF2ZSBwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKH42cykgdG8gdHJ5IHRoZVxyXG5cdFx0ICogcHJlZmVyZW5jZSB0cmFuc3BvcnQsIHRoZW4gcmVhbHRpbWVSZXF1ZXN0VGltZW91dCAofjEwcykgdG8gZXN0YWJsaXNoXHJcblx0XHQgKiB0aGUgYmFzZSB0cmFuc3BvcnQgaW4gY2FzZSB0aGF0IGZhaWxzICovXHJcblx0XHR2YXIgY29ubmVjdGluZ1RpbWVvdXQgPSB0aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xyXG5cdFx0dGhpcy5zdGF0ZXMgPSB7XHJcblx0XHRcdGluaXRpYWxpemVkOiAgIHtzdGF0ZTogJ2luaXRpYWxpemVkJywgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiB0cnVlLCAgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxyXG5cdFx0XHRjb25uZWN0aW5nOiAgICB7c3RhdGU6ICdjb25uZWN0aW5nJywgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCByZXRyeURlbGF5OiBjb25uZWN0aW5nVGltZW91dCwgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJ30sXHJcblx0XHRcdGNvbm5lY3RlZDogICAgIHtzdGF0ZTogJ2Nvbm5lY3RlZCcsICAgICB0ZXJtaW5hbDogZmFsc2UsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogdHJ1ZSwgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCd9LFxyXG5cdFx0XHRzeW5jaHJvbml6aW5nOiB7c3RhdGU6ICdjb25uZWN0ZWQnLCAgICAgdGVybWluYWw6IGZhbHNlLCBxdWV1ZUV2ZW50czogdHJ1ZSwgIHNlbmRFdmVudHM6IGZhbHNlLCBmb3JjZVF1ZXVlRXZlbnRzOiB0cnVlLCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcclxuXHRcdFx0ZGlzY29ubmVjdGVkOiAge3N0YXRlOiAnZGlzY29ubmVjdGVkJywgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IHRydWUsICBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMuZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0LCBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnfSxcclxuXHRcdFx0c3VzcGVuZGVkOiAgICAge3N0YXRlOiAnc3VzcGVuZGVkJywgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMuc3VzcGVuZGVkUmV0cnlUaW1lb3V0LCBmYWlsU3RhdGU6ICdzdXNwZW5kZWQnfSxcclxuXHRcdFx0Y2xvc2luZzogICAgICAge3N0YXRlOiAnY2xvc2luZycsICAgICAgIHRlcm1pbmFsOiBmYWxzZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgcmV0cnlEZWxheTogdGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCwgZmFpbFN0YXRlOiAnY2xvc2VkJ30sXHJcblx0XHRcdGNsb3NlZDogICAgICAgIHtzdGF0ZTogJ2Nsb3NlZCcsICAgICAgICB0ZXJtaW5hbDogdHJ1ZSwgIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2Nsb3NlZCd9LFxyXG5cdFx0XHRmYWlsZWQ6ICAgICAgICB7c3RhdGU6ICdmYWlsZWQnLCAgICAgICAgdGVybWluYWw6IHRydWUsICBxdWV1ZUV2ZW50czogZmFsc2UsIHNlbmRFdmVudHM6IGZhbHNlLCBmYWlsU3RhdGU6ICdmYWlsZWQnfVxyXG5cdFx0fTtcclxuXHRcdHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5pbml0aWFsaXplZDtcclxuXHRcdHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xyXG5cclxuXHRcdHRoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgX21lc3NhZ2VxdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCk7XHJcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5jb25uZWN0aW9uSWQgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25LZXkgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnRpbWVTZXJpYWwgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IHRpbWVvdXRzLmNvbm5lY3Rpb25TdGF0ZVR0bDtcclxuXHRcdHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcclxuXHJcblx0XHR0aGlzLnRyYW5zcG9ydHMgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmludGVyc2VjdCgob3B0aW9ucy50cmFuc3BvcnRzIHx8IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZGVmYXVsdFRyYW5zcG9ydHMpLCBDb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzKTtcclxuXHRcdC8qIGJhc2VUcmFuc3BvcnRzIHNlbGVjdHMgdGhlIGxlZnRtb3N0IHRyYW5zcG9ydCBpbiB0aGUgRGVmYXVsdHMuYmFzZVRyYW5zcG9ydE9yZGVyIGxpc3RcclxuXHRcdCogdGhhdCdzIGJvdGggcmVxdWVzdGVkIGFuZCBzdXBwb3J0ZWQuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB4aHJfcG9sbGluZztcclxuXHRcdCogaWYgeGhyIGlzbid0IHN1cHBvcnRlZCBpdCB3aWxsIGJlIGpzb25wLiBJZiB0aGUgdXNlciBoYXMgZm9yY2VkIGFcclxuXHRcdCogdHJhbnNwb3J0LCBpdCdsbCBqdXN0IGJlIHRoYXQgb25lLiAqL1xyXG5cdFx0dGhpcy5iYXNlVHJhbnNwb3J0ID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcnNlY3QoX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iYXNlVHJhbnNwb3J0T3JkZXIsIHRoaXMudHJhbnNwb3J0cylbMF07XHJcblx0XHR0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcnNlY3QodGhpcy50cmFuc3BvcnRzLCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnVwZ3JhZGVUcmFuc3BvcnRzKTtcclxuXHRcdHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IG51bGw7XHJcblxyXG5cdFx0dGhpcy5odHRwSG9zdHMgPSBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldEhvc3RzKG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5hY3RpdmVQcm90b2NvbCA9IG51bGw7XHJcblx0XHR0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xyXG5cdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xyXG5cdFx0dGhpcy5ob3N0ID0gbnVsbDtcclxuXHRcdHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcclxuXHRcdHRoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcclxuXHRcdHRoaXMubW9zdFJlY2VudE1zZyA9IG51bGw7XHJcblx0XHR0aGlzLmZvcmNlRmFsbGJhY2tIb3N0ID0gZmFsc2U7XHJcblx0XHR0aGlzLmNvbm5lY3RDb3VudGVyID0gMDtcclxuXHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdzdGFydGVkJyk7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdyZXF1ZXN0ZWQgdHJhbnNwb3J0cyA9IFsnICsgKG9wdGlvbnMudHJhbnNwb3J0cyB8fCBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlZmF1bHRUcmFuc3BvcnRzKSArICddJyk7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdhdmFpbGFibGUgdHJhbnNwb3J0cyA9IFsnICsgdGhpcy50cmFuc3BvcnRzICsgJ10nKTtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2h0dHAgaG9zdHMgPSBbJyArIHRoaXMuaHR0cEhvc3RzICsgJ10nKTtcclxuXHJcblx0XHRpZighdGhpcy50cmFuc3BvcnRzLmxlbmd0aCkge1xyXG5cdFx0XHR2YXIgbXNnID0gJ25vIHJlcXVlc3RlZCB0cmFuc3BvcnRzIGF2YWlsYWJsZSc7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdyZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgbXNnKTtcclxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFkZEV2ZW50TGlzdGVuZXI7XHJcblx0XHRpZihhZGRFdmVudExpc3RlbmVyKSB7XHJcblx0XHRcdC8qIGludGVyY2VwdCBjbG9zZSBldmVudCBpbiBicm93c2VyIHRvIHBlcnNpc3QgY29ubmVjdGlvbiBpZCBpZiByZXF1ZXN0ZWQgKi9cclxuXHRcdFx0aWYoaGF2ZVNlc3Npb25TdG9yYWdlICYmIHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHQvKiBVc3VhbGx5IGNhbid0IHVzZSBiaW5kIGFzIG5vdCBzdXBwb3J0ZWQgaW4gSUU4LCBidXQgSUUgZG9lc24ndCBzdXBwb3J0IHNlc3Npb25TdG9yYWdlLCBzby4uLiAqL1xyXG5cdFx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIHRoaXMucGVyc2lzdENvbm5lY3Rpb24uYmluZCh0aGlzKSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xyXG5cdFx0XHRcdGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NQUpPUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnYmVmb3JldW5sb2FkIGV2ZW50IGhhcyB0cmlnZ2VyZWQgdGhlIGNvbm5lY3Rpb24gdG8gY2xvc2UgYXMgY2xvc2VPblVubG9hZCBpcyB0cnVlJyk7XHJcblx0XHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjbG9zaW5nJ30pO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBMaXN0ZW4gZm9yIG9ubGluZSBhbmQgb2ZmbGluZSBldmVudHMgKi9cclxuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignb25saW5lJywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0aWYoc2VsZi5zdGF0ZSA9PSBzZWxmLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgc2VsZi5zdGF0ZSA9PSBzZWxmLnN0YXRlcy5zdXNwZW5kZWQpIHtcclxuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciDigJhvbmxpbmXigJkgZXZlbnQnLCAncmVhdHRlbXB0aW5nIGNvbm5lY3Rpb24nKTtcclxuXHRcdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0YWRkRXZlbnRMaXN0ZW5lcignb2ZmbGluZScsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY29ubmVjdGVkKSB7XHJcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIgY2F1Z2h0IGJyb3dzZXIg4oCYb2ZmbGluZeKAmSBldmVudCcsICdkaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQnKTtcclxuXHRcdFx0XHRcdC8vIE5vdCBzdWZmaWNpZW50IHRvIGp1c3QgZ28gdG8gdGhlICdkaXNjb25uZWN0ZWQnIHN0YXRlLCB3YW50IHRvXHJcblx0XHRcdFx0XHQvLyBmb3JjZSBhbGwgdHJhbnNwb3J0cyB0byByZWF0dGVtcHQgdGhlIGNvbm5lY3Rpb24uIFdpbGwgaW1tZWRpYXRlbHlcclxuXHRcdFx0XHRcdC8vIHJldHJ5LlxyXG5cdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoQ29ubmVjdGlvbk1hbmFnZXIsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcclxuXHJcblx0LyoqKioqKioqKioqKioqKioqKioqKlxyXG5cdCAqIHRyYW5zcG9ydCBtYW5hZ2VtZW50XHJcblx0ICoqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyA9IHt9O1xyXG5cclxuXHRPYmplY3QoX3dlYnNvY2tldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMThfX1svKiBkZWZhdWx0ICovIFwiYVwiXSkoQ29ubmVjdGlvbk1hbmFnZXIpO1xyXG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaChwbGF0Zm9ybV90cmFuc3BvcnRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLCBmdW5jdGlvbiAoaW5pdEZuKSB7XHJcblx0XHRpbml0Rm4oQ29ubmVjdGlvbk1hbmFnZXIpO1xyXG5cdH0pO1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24oaG9zdCwgbW9kZSkge1xyXG5cdFx0dmFyIHBhcmFtcyA9IG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xyXG5cdFx0aWYodGhpcy50aW1lU2VyaWFsKSB7XHJcblx0XHRcdHBhcmFtcy50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsO1xyXG5cdFx0fSBlbHNlIGlmKHRoaXMuY29ubmVjdGlvblNlcmlhbCAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdHBhcmFtcy5jb25uZWN0aW9uU2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhcmFtcztcclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHJcblx0XHRmdW5jdGlvbiBkZWNpZGVNb2RlKG1vZGVDYikge1xyXG5cdFx0XHRpZihzZWxmLmNvbm5lY3Rpb25LZXkpIHtcclxuXHRcdFx0XHRtb2RlQ2IoJ3Jlc3VtZScpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYodHlwZW9mIHNlbGYub3B0aW9ucy5yZWNvdmVyID09PSAnc3RyaW5nJykge1xyXG5cdFx0XHRcdG1vZGVDYigncmVjb3ZlcicpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHJlY292ZXJGbiA9IHNlbGYub3B0aW9ucy5yZWNvdmVyLFxyXG5cdFx0XHRcdGxhc3RTZXNzaW9uRGF0YSA9IGdldFNlc3Npb25SZWNvdmVyRGF0YSgpO1xyXG5cdFx0XHRpZihsYXN0U2Vzc2lvbkRhdGEgJiYgdHlwZW9mKHJlY292ZXJGbikgPT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnQ2FsbGluZyBjbGllbnRPcHRpb25zLXByb3ZpZGVkIHJlY292ZXIgZnVuY3Rpb24gd2l0aCBsYXN0IHNlc3Npb24gZGF0YScpO1xyXG5cdFx0XHRcdHJlY292ZXJGbihsYXN0U2Vzc2lvbkRhdGEsIGZ1bmN0aW9uKHNob3VsZFJlY292ZXIpIHtcclxuXHRcdFx0XHRcdGlmKHNob3VsZFJlY292ZXIpIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XHJcblx0XHRcdFx0XHRcdG1vZGVDYigncmVjb3ZlcicpO1xyXG5cdFx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdFx0bW9kZUNiKCdjbGVhbicpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRtb2RlQ2IoJ2NsZWFuJyk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZGVjaWRlTW9kZShmdW5jdGlvbihtb2RlKSB7XHJcblx0XHRcdHZhciB0cmFuc3BvcnRQYXJhbXMgPSBzZWxmLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhudWxsLCBtb2RlKTtcclxuXHRcdFx0aWYobW9kZSA9PT0gJ3JlY292ZXInKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ1RyYW5zcG9ydCByZWNvdmVyeSBtb2RlID0gcmVjb3ZlcjsgcmVjb3ZlcnlLZXkgPSAnICsgc2VsZi5vcHRpb25zLnJlY292ZXIpO1xyXG5cdFx0XHRcdHZhciBtYXRjaCA9IHNlbGYub3B0aW9ucy5yZWNvdmVyLnNwbGl0KCc6Jyk7XHJcblx0XHRcdFx0aWYobWF0Y2ggJiYgbWF0Y2hbMl0pIHtcclxuXHRcdFx0XHRcdHNlbGYubXNnU2VyaWFsID0gbWF0Y2hbMl07XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdUcmFuc3BvcnQgcGFyYW1zID0gJyArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayh0cmFuc3BvcnRQYXJhbXMpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQXR0ZW1wdCB0byBjb25uZWN0IHVzaW5nIGEgZ2l2ZW4gdHJhbnNwb3J0XHJcblx0ICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xyXG5cdCAqIEBwYXJhbSBjYW5kaWRhdGUsIHRoZSB0cmFuc3BvcnQgdG8gdHJ5XHJcblx0ICogQHBhcmFtIGNhbGxiYWNrXHJcblx0ICovXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRyeUFUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcywgaG9zdCA9IHRyYW5zcG9ydFBhcmFtcy5ob3N0O1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd0cnlpbmcgJyArIGNhbmRpZGF0ZSk7XHJcblx0XHQoQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tjYW5kaWRhdGVdKS50cnlDb25uZWN0KHRoaXMsIHRoaXMucmVhbHRpbWUuYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBmdW5jdGlvbih3cmFwcGVkRXJyLCB0cmFuc3BvcnQpIHtcclxuXHRcdFx0dmFyIHN0YXRlID0gc2VsZi5zdGF0ZTtcclxuXHRcdFx0aWYoc3RhdGUgPT0gc2VsZi5zdGF0ZXMuY2xvc2luZyB8fCBzdGF0ZSA9PSBzZWxmLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gc2VsZi5zdGF0ZXMuZmFpbGVkKSB7XHJcblx0XHRcdFx0aWYodHJhbnNwb3J0KSB7XHJcblx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ2Nvbm5lY3Rpb24gJyArIHN0YXRlLnN0YXRlICsgJyB3aGlsZSB3ZSB3ZXJlIGF0dGVtcHRpbmcgdGhlIHRyYW5zcG9ydDsgY2xvc2luZyAnICsgdHJhbnNwb3J0KTtcclxuXHRcdFx0XHRcdHRyYW5zcG9ydC5jbG9zZSgpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayh0cnVlKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKHdyYXBwZWRFcnIpIHtcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCAnICsgY2FuZGlkYXRlICsgJyAnICsgd3JhcHBlZEVyci5ldmVudCArICcsIGVycjogJyArIHdyYXBwZWRFcnIuZXJyb3IudG9TdHJpbmcoKSk7XHJcblxyXG5cdFx0XHRcdC8qIENvbWV0IHRyYW5zcG9ydCBvbmNvbm5lY3QgdG9rZW4gZXJyb3JzIGNhbiBiZSBkZWFsdCB3aXRoIGhlcmUuXHJcblx0XHRcdFx0KiBXZWJzb2NrZXQgb25lcyBvbmx5IGhhcHBlbiBhZnRlciB0aGUgdHJhbnNwb3J0IGNsYWltcyB0byBiZSB2aWFibGUsXHJcblx0XHRcdFx0KiBzbyBhcmUgZGVhbHQgd2l0aCBhcyBub24tb25jb25uZWN0IHRva2VuIGVycm9ycyAqL1xyXG5cdFx0XHRcdGlmKF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKHdyYXBwZWRFcnIuZXJyb3IpICYmICEoc2VsZi5lcnJvclJlYXNvbiAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycihzZWxmLmVycm9yUmVhc29uKSkpIHtcclxuXHRcdFx0XHRcdHNlbGYuZXJyb3JSZWFzb24gPSB3cmFwcGVkRXJyLmVycm9yO1xyXG5cdFx0XHRcdFx0LyogcmUtZ2V0IGEgdG9rZW4gYW5kIHRyeSBhZ2FpbiAqL1xyXG5cdFx0XHRcdFx0c2VsZi5yZWFsdGltZS5hdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRcdFx0XHRzZWxmLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fSBlbHNlIGlmKHdyYXBwZWRFcnIuZXZlbnQgPT09ICdmYWlsZWQnKSB7XHJcblx0XHRcdFx0XHQvKiBFcnJvciB0aGF0J3MgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cclxuXHRcdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiAnZmFpbGVkJywgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3J9KTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKHRydWUpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZih3cmFwcGVkRXJyLmV2ZW50ID09PSAnZGlzY29ubmVjdGVkJykge1xyXG5cdFx0XHRcdFx0aWYoIV90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNSZXRyaWFibGUod3JhcHBlZEVyci5lcnJvcikpIHtcclxuXHRcdFx0XHRcdFx0LyogRXJyb3IgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyIHRoYXQgZG9lcyBub3QgY2FsbCBmb3IgdHJ5aW5nIGEgZmFsbGJhY2sgaG9zdCwgZWcgYSByYXRlIGxpbWl0ICovXHJcblx0XHRcdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiBzZWxmLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IHdyYXBwZWRFcnIuZXJyb3J9KTtcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2sodHJ1ZSk7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHQvKiBFcnJvciB3aXRoIHRoYXQgdHJhbnNwb3J0IG9ubHk7IGNvbnRpbnVlIHRyeWluZyBvdGhlciBmYWxsYmFjayBob3N0cyAqL1xyXG5cdFx0XHRcdFx0XHRjYWxsYmFjayhmYWxzZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnOyBzZXR0aW5nIHBlbmRpbmcnKTtcclxuXHRcdFx0c2VsZi5zZXRUcmFuc3BvcnRQZW5kaW5nKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKTtcclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBpbmRpY2F0ZWQgdG8gYmUgdmlhYmxlLCBhbmQgdGhlIGNvbm5lY3Rpb25tYW5hZ2VyXHJcblx0ICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cclxuXHQgKiBAcGFyYW0gaG9zdFxyXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRQYXJhbXNcclxuXHQgKi9cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2V0VHJhbnNwb3J0UGVuZGluZyA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XHJcblx0XHR2YXIgbW9kZSA9IHRyYW5zcG9ydFBhcmFtcy5tb2RlO1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldFRyYW5zcG9ydFBlbmRpbmcoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0ICsgJzsgbW9kZSA9ICcgKyBtb2RlKTtcclxuXHJcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xyXG5cdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XHJcblxyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0dHJhbnNwb3J0Lm9uY2UoJ2Nvbm5lY3RlZCcsIGZ1bmN0aW9uKGVycm9yLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pIHtcclxuXHRcdFx0aWYobW9kZSA9PSAndXBncmFkZScgJiYgc2VsZi5hY3RpdmVQcm90b2NvbCkge1xyXG5cdFx0XHRcdC8qICBpZiB3cyBhbmQgeGhycyBhcmUgY29ubmVjdGluZyBpbiBwYXJhbGxlbCwgZGVsYXkgeGhycyBhY3RpdmF0aW9uIHRvIGxldCB3cyBnbyBhaGVhZCAqL1xyXG5cdFx0XHRcdGlmKHRyYW5zcG9ydC5zaG9ydE5hbWUgIT09IG9wdGltYWxUcmFuc3BvcnQgJiYgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJJbihzZWxmLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzKCksIG9wdGltYWxUcmFuc3BvcnQpKSB7XHJcblx0XHRcdFx0XHRzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0XHRzZWxmLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pO1xyXG5cdFx0XHRcdFx0fSwgc2VsZi5vcHRpb25zLnRpbWVvdXRzLnBhcmFsbGVsVXBncmFkZURlbGF5KTtcclxuXHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0c2VsZi5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0c2VsZi5hY3RpdmF0ZVRyYW5zcG9ydChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCBjb25uZWN0aW9uUG9zaXRpb24pO1xyXG5cclxuXHRcdFx0XHQvKiBhbGxvdyBjb25uZWN0SW1wbCB0byBzdGFydCB0aGUgdXBncmFkZSBwcm9jZXNzIGlmIG5lZWRlZCwgYnV0IGFsbG93XHJcblx0XHRcdFx0ICogb3RoZXIgZXZlbnQgaGFuZGxlcnMsIGluY2x1ZGluZyBhY3RpdmF0aW5nIHRoZSB0cmFuc3BvcnQsIHRvIHJ1biBmaXJzdCAqL1xyXG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcyk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKG1vZGUgPT09ICdyZWNvdmVyJyAmJiBzZWxmLm9wdGlvbnMucmVjb3Zlcikge1xyXG5cdFx0XHRcdC8qIEFmdGVyIGEgc3VjY2Vzc2Z1bCByZWNvdmVyeSwgd2UgdW5wZXJzaXN0LCBhcyBhIHJlY292ZXJ5IGtleSBjYW5ub3RcclxuXHRcdFx0XHQqIGJlIHVzZWQgbW9yZSB0aGFuIG9uY2UgKi9cclxuXHRcdFx0XHRzZWxmLm9wdGlvbnMucmVjb3ZlciA9IG51bGw7XHJcblx0XHRcdFx0c2VsZi51bnBlcnNpc3RDb25uZWN0aW9uKCk7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cclxuXHRcdHRyYW5zcG9ydC5vbihbJ2Rpc2Nvbm5lY3RlZCcsICdjbG9zZWQnLCAnZmFpbGVkJ10sIGZ1bmN0aW9uKGVycm9yKSB7XHJcblx0XHRcdHNlbGYuZGVhY3RpdmF0ZVRyYW5zcG9ydCh0cmFuc3BvcnQsIHRoaXMuZXZlbnQsIGVycm9yKTtcclxuXHRcdH0pO1xyXG5cclxuXHRcdHRoaXMuZW1pdCgndHJhbnNwb3J0LnBlbmRpbmcnLCB0cmFuc3BvcnQpO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIGFuIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCxcclxuXHQgKiB0byBzY2hlZHVsZSB0aGUgYWN0aXZhdGlvbiBvZiB0aGF0IHRyYW5zcG9ydC5cclxuXHQgKiBAcGFyYW0gZXJyb3JcclxuXHQgKiBAcGFyYW0gdHJhbnNwb3J0XHJcblx0ICogQHBhcmFtIGNvbm5lY3Rpb25JZFxyXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlsc1xyXG5cdCAqIEBwYXJhbSBjb25uZWN0ZWRNZXNzYWdlXHJcblx0ICovXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbiA9IGZ1bmN0aW9uKGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIHVwZ3JhZGVDb25uZWN0aW9uUG9zaXRpb24pIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcyxcclxuXHRcdFx0Y3VycmVudFRyYW5zcG9ydCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSxcclxuXHRcdFx0YWJhbmRvbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XHJcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZShzZWxmLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdGlmKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XHJcblx0XHRcdC8qIFRoaXMgaXMgbW9zdCBsaWtlbHkgdG8gaGFwcGVuIGZvciB0aGUgZGVsYXllZCB4aHJzLCB3aGVuIHhocnMgYW5kIHdzIGFyZSBzY2hlZHVsZWQgaW4gcGFyYWxsZWwqL1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudCBjb25uZWN0aW9uIHN0YXRlICgnICsgdGhpcy5zdGF0ZS5zdGF0ZSArICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nID8gJywgYnV0IHdpdGggYW4gdXBncmFkZSBhbHJlYWR5IGluIHByb2dyZXNzJyA6ICcnKSArICcpIGlzIG5vdCB2YWxpZCB0byB1cGdyYWRlIGluOyBhYmFuZG9uaW5nIHVwZ3JhZGUgdG8gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xyXG5cdFx0XHRhYmFuZG9uKCk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihjdXJyZW50VHJhbnNwb3J0ICYmICFiZXR0ZXJUcmFuc3BvcnRUaGFuKHRyYW5zcG9ydCwgY3VycmVudFRyYW5zcG9ydCkpIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1Byb3Bvc2VkIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICcgaXMgbm8gYmV0dGVyIHRoYW4gY3VycmVudCBhY3RpdmUgdHJhbnNwb3J0ICcgKyBjdXJyZW50VHJhbnNwb3J0LnNob3J0TmFtZSArICcgLSBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcclxuXHRcdFx0YWJhbmRvbigpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1NjaGVkdWxpbmcgdHJhbnNwb3J0IHVwZ3JhZGU7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xyXG5cclxuXHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25jZU5vcGVuZGluZyhmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0dmFyIG9sZFByb3RvY29sO1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnVW5hYmxlIHRvIGFjdGl2YXRlIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IGVyciA9ICcgKyBlcnIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xyXG5cdFx0XHRcdC8qIFRoaXMgaXMgb25seSBwb3NzaWJsZSBpZiB0aGUgeGhyIHN0cmVhbWluZyB0cmFuc3BvcnQgd2FzIGRpc2Nvbm5lY3RlZCBkdXJpbmcgdGhlIHBhcmFsbGVsVXBncmFkZURlbGF5ICovXHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1Byb3Bvc2VkIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICdpcyBubyBsb25nZXIgY29ubmVjdGVkOyBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcclxuXHRcdFx0XHRhYmFuZG9uKCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHRpZihzZWxmLnN0YXRlID09PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQpIHtcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudGx5IGNvbm5lY3RlZCwgc28gdGVtcG9yYXJpbHkgcGF1c2luZyBldmVudHMgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUnKTtcclxuXHRcdFx0XHRzZWxmLnN0YXRlID0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZztcclxuXHRcdFx0XHRvbGRQcm90b2NvbCA9IHNlbGYuYWN0aXZlUHJvdG9jb2w7XHJcblx0XHRcdH0gZWxzZSBpZihzZWxmLnN0YXRlICE9PSBzZWxmLnN0YXRlcy5jb25uZWN0aW5nKSB7XHJcblx0XHRcdFx0LyogTm90ZTogdXBncmFkaW5nIGZyb20gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgaXMgdmFsaWQgaWYgdGhlIG9sZCBhY3RpdmVcclxuXHRcdFx0XHQqIHRyYW5zcG9ydCB3YXMgZGVhY3RpdmF0ZWQgYWZ0ZXIgdGhlIHVwZ3JhZGUgdHJhbnNwb3J0IGZpcnN0IGNvbm5lY3RlZDtcclxuXHRcdFx0XHQqIHNlZSBsb2dpYyBpbiBkZWFjdGl2YXRlVHJhbnNwb3J0ICovXHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0N1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSAoJyArIHNlbGYuc3RhdGUuc3RhdGUgKyAoc2VsZi5zdGF0ZSA9PT0gc2VsZi5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgKyAnKSBpcyBub3QgdmFsaWQgdG8gdXBncmFkZSBpbjsgYWJhbmRvbmluZyB1cGdyYWRlIHRvICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lKTtcclxuXHRcdFx0XHRhYmFuZG9uKCk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBJZiB0aGUgY29ubmVjdGlvbklkIGhhcyBjaGFuZ2VkLCB0aGUgdXBncmFkZSBoYXNuJ3Qgd29ya2VkLiBCdXQgYXNcclxuXHRcdFx0KiBpdCdzIHN0aWxsIGFuIHVwZ3JhZGUsIHJlYWx0aW1lIHN0aWxsIGV4cGVjdHMgYSBzeW5jIC0gaXQganVzdCBuZWVkcyB0b1xyXG5cdFx0XHQqIGJlIGEgc3luYyB3aXRoIHRoZSBuZXcgY29ubmVjdGlvbiBwb3NpdGlvbi4gKEFuZCBpdFxyXG5cdFx0XHQqIG5lZWRzIHRvIGJlIHNldCBpbiB0aGUgbGlicmFyeSwgd2hpY2ggaXMgZG9uZSBieSBhY3RpdmF0ZVRyYW5zcG9ydCkuICovXHJcblx0XHRcdHZhciBjb25uZWN0aW9uUmVzZXQgPSBjb25uZWN0aW9uSWQgIT09IHNlbGYuY29ubmVjdGlvbklkLFxyXG5cdFx0XHRcdHN5bmNQb3NpdGlvbiA9IGNvbm5lY3Rpb25SZXNldCA/IHVwZ3JhZGVDb25uZWN0aW9uUG9zaXRpb24gOiBzZWxmO1xyXG5cclxuXHRcdFx0aWYoY29ubmVjdGlvblJlc2V0KSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1VwZ3JhZGUgcmVzdWx0ZWQgaW4gbmV3IGNvbm5lY3Rpb25JZDsgcmVzZXR0aW5nIGxpYnJhcnkgY29ubmVjdGlvbiBwb3NpdGlvbiBmcm9tICcgKyAoc2VsZi50aW1lU2VyaWFsIHx8IHNlbGYuY29ubmVjdGlvblNlcmlhbCkgKyAnIHRvICcgKyAoc3luY1Bvc2l0aW9uLnRpbWVTZXJpYWwgfHwgc3luY1Bvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWwpICsgJzsgdXBncmFkZSBlcnJvciB3YXMgJyArIGVycm9yKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1N5bmNpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcclxuXHRcdFx0c2VsZi5zeW5jKHRyYW5zcG9ydCwgc3luY1Bvc2l0aW9uLCBmdW5jdGlvbihzeW5jRXJyLCBjb25uZWN0aW9uSWQsIHBvc3RTeW5jUG9zaXRpb24pIHtcclxuXHRcdFx0XHQvKiBJZiB0aGVyZSdzIGJlZW4gc29tZSBwcm9ibGVtIHdpdGggc3luY2luZyAoYW5kIHRoZSBjb25uZWN0aW9uIGhhc24ndFxyXG5cdFx0XHRcdCAqIGNsb3NlZCBvciBzb21ldGhpbmcgaW4gdGhlIG1lYW50aW1lKSwgd2UgaGF2ZSBhIHByb2JsZW0gLS0gd2UgY2FuJ3RcclxuXHRcdFx0XHQgKiBqdXN0IGZhbGwgYmFjayBvbiB0aGUgb2xkIHRyYW5zcG9ydCwgYXMgd2UgZG9uJ3Qga25vdyB3aGV0aGVyXHJcblx0XHRcdFx0ICogcmVhbHRpbWUgZ290IHRoZSBzeW5jIC0tIGlmIGl0IGRpZCwgdGhlIG9sZCB0cmFuc3BvcnQgaXMgbm8gbG9uZ2VyXHJcblx0XHRcdFx0ICogdmFsaWQuIFRvIGJlIHNhZmUsIHdlIGRpc2Nvbm5lY3QgYm90aCBhbmQgc3RhcnQgYWdhaW4gZnJvbSBzY3JhdGNoLiAqL1xyXG5cdFx0XHRcdGlmKHN5bmNFcnIpIHtcclxuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcclxuXHRcdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1VuZXhwZWN0ZWQgZXJyb3IgYXR0ZW1wdGluZyB0byBzeW5jIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCArICc7IGVyciA9ICcgKyBzeW5jRXJyKTtcclxuXHRcdFx0XHRcdFx0c2VsZi5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR2YXIgZmluaXNoVXBncmFkZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0FjdGl2YXRpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcclxuXHRcdFx0XHRcdHNlbGYuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgcG9zdFN5bmNQb3NpdGlvbik7XHJcblx0XHRcdFx0XHQvKiBSZXN0b3JlIHByZS1zeW5jIHN0YXRlLiBJZiBzdGF0ZSBoYXMgY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWUsXHJcblx0XHRcdFx0XHQgKiBkb24ndCB0b3VjaCBpdCAtLSBzaW5jZSB0aGUgd2Vic29ja2V0IHRyYW5zcG9ydCB3YWl0cyBhIHRpY2sgYmVmb3JlXHJcblx0XHRcdFx0XHQgKiBkaXNwb3NpbmcgaXRzZWxmLCBpdCdzIHBvc3NpYmxlIGZvciBpdCB0byBoYXZlIGhhcHBpbHkgc3luY2VkXHJcblx0XHRcdFx0XHQgKiB3aXRob3V0IGVyciB3aGlsZSwgdW5rbm93biB0byBpdCwgdGhlIGNvbm5lY3Rpb24gaGFzIGNsb3NlZCBpbiB0aGVcclxuXHRcdFx0XHRcdCAqIG1lYW50aW1lIGFuZCB0aGUgd3MgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgZGVhdGggKi9cclxuXHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcclxuXHRcdFx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1ByZS11cGdyYWRlIHByb3RvY29sIGlkbGUsIHNlbmRpbmcgcXVldWVkIG1lc3NhZ2VzIG9uIHVwZ3JhZGVkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XHJcblx0XHRcdFx0XHRcdHNlbGYuc3RhdGUgPSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQ7XHJcblx0XHRcdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJlLXVwZ3JhZGUgcHJvdG9jb2wgaWRsZSwgYnV0IHN0YXRlIGlzIG5vdyAnICsgc2VsZi5zdGF0ZS5zdGF0ZSArICcsIHNvIGxlYXZpbmcgdW5jaGFuZ2VkJyk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihzZWxmLnN0YXRlLnNlbmRFdmVudHMpIHtcclxuXHRcdFx0XHRcdFx0c2VsZi5zZW5kUXVldWVkTWVzc2FnZXMoKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9O1xyXG5cclxuXHRcdFx0XHQvKiBXYWl0IHVudGlsIHN5bmMgaXMgZG9uZSBhbmQgb2xkIHRyYW5zcG9ydCBpcyBpZGxlIGJlZm9yZSBhY3RpdmF0aW5nIG5ldyB0cmFuc3BvcnQuIFRoaXNcclxuXHRcdFx0XHQgKiBndWFyYW50ZWVzIHRoYXQgbWVzc2FnZXMgYXJyaXZlIGF0IHJlYWx0aW1lIGluIHRoZSBzYW1lIG9yZGVyIHRoZXkgYXJlIHNlbnQuXHJcblx0XHRcdFx0ICpcclxuXHRcdFx0XHQgKiBJZiBhIG1lc3NhZ2UgdGltZXMgb3V0IG9uIHRoZSBvbGQgdHJhbnNwb3J0LCBzaW5jZSBpdCdzIHN0aWxsIHRoZSBhY3RpdmUgdHJhbnNwb3J0IHRoZVxyXG5cdFx0XHRcdCAqIG1lc3NhZ2Ugd2lsbCBiZSByZXF1ZXVlZC4gZGVhY3RpdmF0ZVRyYW5zcG9ydCB3aWxsIHNlZSB0aGUgcGVuZGluZyB0cmFuc3BvcnQgYW5kIG5vdGlmeVxyXG5cdFx0XHRcdCAqIHRoZSBgY29ubmVjdGluZ2Agc3RhdGUgd2l0aG91dCBzdGFydGluZyBhIG5ldyBjb25uZWN0aW9uLCBzbyB0aGUgbmV3IHRyYW5zcG9ydCBjYW4gdGFrZVxyXG5cdFx0XHRcdCAqIG92ZXIgb25jZSBkZWFjdGl2YXRlVHJhbnNwb3J0IGNsZWFycyB0aGUgb2xkIHByb3RvY29sJ3MgcXVldWUuXHJcblx0XHRcdFx0ICpcclxuXHRcdFx0XHQgKiBJZiB0aGVyZSBpcyBubyBvbGQgcHJvdG9jb2wsIHRoYXQgbWVhbnQgdGhhdCB3ZSB3ZXJlbid0IGluIHRoZSBjb25uZWN0ZWQgc3RhdGUgYXQgdGhlXHJcblx0XHRcdFx0ICogYmVnaW5uaW5nIG9mIHRoZSBzeW5jIC0gbGlrZWx5IHRoZSBiYXNlIHRyYW5zcG9ydCBkaWVkIGp1c3QgYmVmb3JlIHRoZSBzeW5jLiBTbyBjYW4ganVzdFxyXG5cdFx0XHRcdCAqIGZpbmlzaCB0aGUgdXBncmFkZS4gSWYgd2UncmUgYWN0dWFsbHkgaW4gY2xvc2luZy9mYWlsZWQgcmF0aGVyIHRoYW4gY29ubmVjdGluZywgdGhhdCdzXHJcblx0XHRcdFx0ICogZmluZSwgYWN0aXZhdGV0cmFuc3BvcnQgd2lsbCBkZWFsIHdpdGggdGhhdC4gKi9cclxuXHRcdFx0XHRpZihvbGRQcm90b2NvbCkge1xyXG5cdFx0XHRcdCAvKiBNb3N0IG9mIHRoZSB0aW1lIHRoaXMgd2lsbCBiZSBhbHJlYWR5IHRydWU6IHRoZSBuZXctdHJhbnNwb3J0IHN5bmMgd2lsbCBoYXZlIGdpdmVuXHJcblx0XHRcdFx0ICogZW5vdWdoIHRpbWUgZm9yIGluLWZsaWdodCBtZXNzYWdlcyBvbiB0aGUgb2xkIHRyYW5zcG9ydCB0byBjb21wbGV0ZS4gKi9cclxuXHRcdFx0XHRcdG9sZFByb3RvY29sLm9uY2VJZGxlKGZpbmlzaFVwZ3JhZGUpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRmaW5pc2hVcGdyYWRlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9KTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlciBkZWNpZGVzIHRoYXRcclxuXHQgKiBpdCB3aWxsIG5vdyBiZSB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBhY3RpdmF0ZWRcclxuXHQgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxyXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnQgdGhlIHRyYW5zcG9ydCBpbnN0YW5jZVxyXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uSWQgdGhlIGlkIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cclxuXHQgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxyXG5cdCAqIEBwYXJhbSBjb25uZWN0aW9uUG9zaXRpb24gdGhlIHBvc2l0aW9uIGF0IHRoZSBwb2ludCBhY3RpdmF0aW9uOyBlaXRoZXIge2Nvbm5lY3Rpb25TZXJpYWw6IDxzZXJpYWw+fSBvciB7dGltZVNlcmlhbDogPHNlcmlhbD59XHJcblx0ICovXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2YXRlVHJhbnNwb3J0ID0gZnVuY3Rpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcclxuXHRcdGlmKGVycm9yKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2Vycm9yID0gJyArIGVycm9yKTtcclxuXHRcdH1cclxuXHRcdGlmKGNvbm5lY3Rpb25JZCkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uSWQgPSAgJyArIGNvbm5lY3Rpb25JZCk7XHJcblx0XHR9XHJcblx0XHRpZihjb25uZWN0aW9uRGV0YWlscykge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uRGV0YWlscyA9ICAnICsgSlNPTi5zdHJpbmdpZnkoY29ubmVjdGlvbkRldGFpbHMpKTtcclxuXHRcdH1cclxuXHRcdGlmKGNvbm5lY3Rpb25Qb3NpdGlvbikge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdzZXJpYWwgPSAgJyArIChjb25uZWN0aW9uUG9zaXRpb24udGltZVNlcmlhbCB8fCBjb25uZWN0aW9uUG9zaXRpb24uY29ubmVjdGlvblNlcmlhbCkpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UodHJhbnNwb3J0KTtcclxuXHJcblx0XHQvKiBpZiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgbW92ZWQgdG8gdGhlIGNsb3NpbmcvY2xvc2VkIHN0YXRlIGJlZm9yZSB0aGlzXHJcblx0XHQgKiBjb25uZWN0aW9uIGV2ZW50LCB0aGVuIHdlIHdvbid0IGFjdGl2YXRlIHRoaXMgdHJhbnNwb3J0ICovXHJcblx0XHR2YXIgZXhpc3RpbmdTdGF0ZSA9IHRoaXMuc3RhdGUsXHJcblx0XHRcdGNvbm5lY3RlZFN0YXRlID0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlO1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY3VycmVudCBzdGF0ZSA9ICcgKyBleGlzdGluZ1N0YXRlLnN0YXRlKTtcclxuXHRcdGlmKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2luZy5zdGF0ZSB8fCBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3NlZC5zdGF0ZSB8fCBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmZhaWxlZC5zdGF0ZSkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdEaXNjb25uZWN0aW5nIHRyYW5zcG9ydCBhbmQgYWJhbmRvbmluZycpO1xyXG5cdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogcmVtb3ZlIHRoaXMgdHJhbnNwb3J0IGZyb20gcGVuZGluZyB0cmFuc3BvcnRzICovXHJcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckRlbGV0ZVZhbHVlKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XHJcblxyXG5cdFx0LyogaWYgdGhlIHRyYW5zcG9ydCBpcyBub3QgY29ubmVjdGVkIChlZyBiZWNhdXNlIGl0IGZhaWxlZCBkdXJpbmcgYVxyXG5cdFx0ICogc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uI29uY2VOb1BlbmRpbmcgd2FpdCkgdGhlbiBkb24ndCBhY3RpdmF0ZSBpdCAqL1xyXG5cdFx0aWYoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdEZWNsaW5pbmcgdG8gYWN0aXZhdGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQgKyAnIHNpbmNlIGl0IGFwcGVhcnMgdG8gbm8gbG9uZ2VyIGJlIGNvbm5lY3RlZCcpO1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogdGhlIGdpdmVuIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQ7IHRoaXMgd2lsbCBpbW1lZGlhdGVseVxyXG5cdFx0ICogdGFrZSBvdmVyIGFzIHRoZSBhY3RpdmUgdHJhbnNwb3J0ICovXHJcblx0XHR2YXIgZXhpc3RpbmdBY3RpdmVQcm90b2NvbCA9IHRoaXMuYWN0aXZlUHJvdG9jb2w7XHJcblx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IF9wcm90b2NvbF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKHRyYW5zcG9ydCk7XHJcblx0XHR0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XHJcblxyXG5cdFx0dmFyIGNvbm5lY3Rpb25LZXkgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uS2V5O1xyXG5cdFx0aWYoY29ubmVjdGlvbktleSAmJiB0aGlzLmNvbm5lY3Rpb25LZXkgIT0gY29ubmVjdGlvbktleSkgIHtcclxuXHRcdFx0dGhpcy5zZXRDb25uZWN0aW9uKGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMsIGNvbm5lY3Rpb25Qb3NpdGlvbiwgISFlcnJvcik7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogUmVicm9hZGNhc3QgYW55IG5ldyBjb25uZWN0aW9uRGV0YWlscyBmcm9tIHRoZSBhY3RpdmUgdHJhbnNwb3J0LCB3aGljaFxyXG5cdFx0ICogY2FuIGNvbWUgYXQgYW55IHRpbWUgKGVnIGZvbGxvd2luZyBhIHJlYXV0aCksIGFuZCBlbWl0IGFuIFJUTjI0IFVQREFURVxyXG5cdFx0ICogZXZlbnQuIChMaXN0ZW5lciBhZGRlZCBvbiBuZXh0VGljayBiZWNhdXNlIHdlJ3JlIGluIGEgdHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnKVxyXG5cdFx0ICogY2FsbGJhY2sgYXQgdGhlIG1vbWVudDsgaWYgd2UgYWRkIGl0IG5vdyB3ZSdsbCBiZSBhZGRpbmcgaXQgdG8gdGhlIGVuZFxyXG5cdFx0ICogb2YgdGhlIGxpc3RlbmVycyBhcnJheSBhbmQgaXQnbGwgYmUgY2FsbGVkIGltbWVkaWF0ZWx5KSAqL1xyXG5cdFx0dGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0dHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnLCBmdW5jdGlvbihjb25uZWN0ZWRFcnIsIF9jb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XHJcblx0XHRcdFx0c2VsZi5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xyXG5cdFx0XHRcdHNlbGYuZW1pdCgndXBkYXRlJywgbmV3IF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0oY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBjb25uZWN0ZWRFcnIpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KVxyXG5cclxuXHRcdC8qIElmIHByZXZpb3VzbHkgbm90IGNvbm5lY3RlZCwgbm90aWZ5IHRoZSBzdGF0ZSBjaGFuZ2UgKGluY2x1ZGluZyBhbnlcclxuXHRcdCAqIGVycm9yKS4gKi9cclxuXHRcdGlmKGV4aXN0aW5nU3RhdGUuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkge1xyXG5cdFx0XHRpZihlcnJvcikge1xyXG5cdFx0XHRcdC8qIGlmIHVwZ3JhZGluZyB3aXRob3V0IGVycm9yLCBsZWF2ZSBhbnkgZXhpc3RpbmcgZXJyb3JSZWFzb24gYWxvbmUgKi9cclxuXHRcdFx0XHR0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3I7XHJcblx0XHRcdFx0LyogT25seSBib3RoZXIgZW1pdHRpbmcgYW4gdXBncmFkZSBpZiB0aGVyZSdzIGFuIGVycm9yOyBvdGhlcndpc2UgaXQnc1xyXG5cdFx0XHRcdCAqIGp1c3QgYSB0cmFuc3BvcnQgdXBncmFkZSwgc28gYXV0aCBkZXRhaWxzIHdvbid0IGhhdmUgY2hhbmdlZCAqL1xyXG5cdFx0XHRcdHRoaXMuZW1pdCgndXBkYXRlJywgbmV3IF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0oY29ubmVjdGVkU3RhdGUsIGNvbm5lY3RlZFN0YXRlLCBudWxsLCBlcnJvcikpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLm5vdGlmeVN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RlZCcsIGVycm9yOiBlcnJvcn0pO1xyXG5cdFx0XHR0aGlzLmVycm9yUmVhc29uID0gdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmVycm9yUmVhc29uID0gZXJyb3IgfHwgbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBTZW5kIGFmdGVyIHRoZSBjb25uZWN0aW9uIHN0YXRlIHVwZGF0ZSwgYXMgQ2hhbm5lbHMgaG9va3MgaW50byB0aGlzIHRvXHJcblx0XHQgKiByZXNlbmQgYXR0YWNoZXMgb24gYSBuZXcgdHJhbnNwb3J0IGlmIG5lY2Vzc2FyeSAqL1xyXG5cdFx0dGhpcy5lbWl0KCd0cmFuc3BvcnQuYWN0aXZlJywgdHJhbnNwb3J0KTtcclxuXHJcblx0XHQvKiBHcmFjZWZ1bGx5IHRlcm1pbmF0ZSBleGlzdGluZyBwcm90b2NvbCAqL1xyXG5cdFx0aWYoZXhpc3RpbmdBY3RpdmVQcm90b2NvbCkge1xyXG5cdFx0XHRpZihleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpID4gMCkge1xyXG5cdFx0XHRcdC8qIFdlIGNvdWxkIGp1c3QgcmVxdWV1ZSBwZW5kaW5nIG1lc3NhZ2VzIG9uIHRoZSBuZXcgdHJhbnNwb3J0LCBidXRcclxuXHRcdFx0XHQgKiBhY3R1YWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW46IHRyYW5zcG9ydHMgc2hvdWxkIG9ubHkgdGFrZSBvdmVyXHJcblx0XHRcdFx0ICogZnJvbSBvdGhlciBhY3RpdmUgdHJhbnNwb3J0cyB3aGVuIHVwZ3JhZGluZywgYW5kIHVwZ3JhZGluZyB3YWl0cyBmb3JcclxuXHRcdFx0XHQgKiB0aGUgb2xkIHRyYW5zcG9ydCB0byBiZSBpZGxlLiBTbyBsb2cgYW4gZXJyb3IuICovXHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnUHJldmlvdXMgYWN0aXZlIHByb3RvY29sIChmb3IgdHJhbnNwb3J0ICcgKyBleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnLCBuZXcgb25lIGlzICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJykgZmluaXNoaW5nIHdpdGggJyArIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wubWVzc2FnZVF1ZXVlLmNvdW50KCkgKyAnIG1lc3NhZ2VzIHN0aWxsIHBlbmRpbmcnKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZihleGlzdGluZ0FjdGl2ZVByb3RvY29sLnRyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XHJcblx0XHRcdFx0dmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgd2FzIGFsc28gdGhlIHRyYW5zcG9ydCBmb3IgdGhlIHByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnOyBzdGFjayA9ICcgKyBuZXcgRXJyb3IoKS5zdGFjaztcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XHJcblx0XHRcdFx0X3V0aWxfZXJyb3JyZXBvcnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZXBvcnQoJ2Vycm9yJywgbXNnLCAndHJhbnNwb3J0LXByZXZpb3VzbHktYWN0aXZlJyk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0ZXhpc3RpbmdBY3RpdmVQcm90b2NvbC5maW5pc2goKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8qIFRlcm1pbmF0ZSBhbnkgb3RoZXIgcGVuZGluZyB0cmFuc3BvcnQocyksIGFuZFxyXG5cdFx0ICogYWJvcnQgYW55IG5vdC15ZXQtcGVuZGluZyB0cmFuc3BvcnQgYXR0ZW1wdHMgKi9cclxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24ocGVuZGluZ1RyYW5zcG9ydCkge1xyXG5cdFx0XHRpZihwZW5kaW5nVHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcclxuXHRcdFx0XHR2YXIgbXNnID0gJ0Fzc3VtcHRpb24gdmlvbGF0ZWQ6IGFjdGl2YXRpbmcgYSB0cmFuc3BvcnQgdGhhdCBpcyBzdGlsbCBtYXJrZWQgYXMgYSBwZW5kaW5nIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydC5zaG9ydE5hbWUgKyAnOyBzdGFjayA9ICcgKyBuZXcgRXJyb3IoKS5zdGFjaztcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsIG1zZyk7XHJcblx0XHRcdFx0X3V0aWxfZXJyb3JyZXBvcnRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5yZXBvcnQoJ2Vycm9yJywgbXNnLCAndHJhbnNwb3J0LWFjdGl2YXRpbmctcGVuZGluZycpO1xyXG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUoc2VsZi5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRwZW5kaW5nVHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNhZmVBcnJGb3JFYWNoKHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCBmdW5jdGlvbihwcm9wb3NlZFRyYW5zcG9ydCkge1xyXG5cdFx0XHRpZihwcm9wb3NlZFRyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XHJcblx0XHRcdFx0dmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgaXMgc3RpbGwgbWFya2VkIGFzIGEgcHJvcG9zZWQgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0LnNob3J0TmFtZSArICc7IHN0YWNrID0gJyArIG5ldyBFcnJvcigpLnN0YWNrO1xyXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcclxuXHRcdFx0XHRfdXRpbF9lcnJvcnJlcG9ydGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnJlcG9ydCgnZXJyb3InLCBtc2csICd0cmFuc3BvcnQtYWN0aXZhdGluZy1wcm9wb3NlZCcpO1xyXG5cdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUoc2VsZi5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cHJvcG9zZWRUcmFuc3BvcnQuZGlzcG9zZSgpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBubyBsb25nZXIgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFRoaXMgY2FuIG9jY3VyXHJcblx0ICogaW4gYW55IHRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxyXG5cdCAqIEBwYXJhbSB0cmFuc3BvcnRcclxuXHQgKi9cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVhY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uKHRyYW5zcG9ydCwgc3RhdGUsIGVycm9yKSB7XHJcblx0XHR2YXIgY3VycmVudFByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbCxcclxuXHRcdFx0d2FzQWN0aXZlID0gY3VycmVudFByb3RvY29sICYmIGN1cnJlbnRQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSA9PT0gdHJhbnNwb3J0LFxyXG5cdFx0XHR3YXNQZW5kaW5nID0gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpLFxyXG5cdFx0XHR3YXNQcm9wb3NlZCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRGVsZXRlVmFsdWUodGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIHRyYW5zcG9ydCksXHJcblx0XHRcdG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPSB0aGlzLm5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24oKTtcclxuXHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdzdGF0ZSA9ICcgKyBzdGF0ZSArICh3YXNBY3RpdmUgPyAnOyB3YXMgYWN0aXZlJyA6IHdhc1BlbmRpbmcgPyAnOyB3YXMgcGVuZGluZycgOiB3YXNQcm9wb3NlZCA/ICc7IHdhcyBwcm9wb3NlZCcgOiAnJykgKyAobm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA/ICcnIDogJzsgYW5vdGhlciB0cmFuc3BvcnQgaXMgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uJykpO1xyXG5cdFx0aWYoZXJyb3IgJiYgZXJyb3IubWVzc2FnZSlcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdyZWFzb24gPSAgJyArIGVycm9yLm1lc3NhZ2UpO1xyXG5cclxuXHRcdGlmKHdhc0FjdGl2ZSkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0dldHRpbmcsIGNsZWFyaW5nLCBhbmQgcmVxdWV1aW5nICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICsgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XHJcblx0XHRcdHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcclxuXHRcdFx0LyogQ2xlYXIgYW55IG1lc3NhZ2VzIHdlIHJlcXVldWUgdG8gYWxsb3cgdGhlIHByb3RvY29sIHRvIGJlY29tZSBpZGxlLlxyXG5cdFx0XHQgKiBJbiBjYXNlIG9mIGFuIHVwZ3JhZGUsIHRoaXMgd2lsbCB0cmlnZ2VyIGFuIGltbWVkaWF0ZSBhY3RpdmF0aW9uIG9mXHJcblx0XHRcdCAqIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCwgc28gZGVsYXkgYSB0aWNrIHNvIHRoaXMgdHJhbnNwb3J0IGNhbiBmaW5pc2hcclxuXHRcdFx0ICogZGVhY3RpdmF0aW5nICovXHJcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0Y3VycmVudFByb3RvY29sLmNsZWFyUGVuZGluZ01lc3NhZ2VzKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sID0gdGhpcy5ob3N0ID0gbnVsbDtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMuY2hhbm5lbFJlc3VtZUNoZWNrVGltZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuZW1pdCgndHJhbnNwb3J0LmluYWN0aXZlJywgdHJhbnNwb3J0KTtcclxuXHJcblx0XHQvKiB0aGlzIHRyYW5zcG9ydCBzdGF0ZSBjaGFuZ2UgaXMgYSBzdGF0ZSBjaGFuZ2UgZm9yIHRoZSBjb25uZWN0aW9ubWFuYWdlciBpZlxyXG5cdFx0ICogLSB0aGUgdHJhbnNwb3J0IHdhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCBhbmQgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHNcclxuXHRcdCAqICAgd2hpY2ggYXJlIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBqdXN0IHdhaXRpbmcgZm9yIHRoZVxyXG5cdFx0ICogICBhY3RpdmUgdHJhbnNwb3J0IHRvIGZpbmlzaCB3aGF0IGl0cyBkb2luZzsgb3JcclxuXHRcdCAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZSBlcnJvciB3YXMgZmF0YWwgKHNvXHJcblx0XHQgKiAgIHVuaGVhbGFibGUgYnkgYW5vdGhlciB0cmFuc3BvcnQpOyBvclxyXG5cdFx0ICogLSB0aGVyZSBpcyBubyBhY3RpdmUgdHJhbnNwb3J0LCBhbmQgdGhpcyBpcyB0aGUgbGFzdCByZW1haW5pbmdcclxuXHRcdCAqICAgcGVuZGluZyB0cmFuc3BvcnQgKHNvIHdlIHdlcmUgaW4gdGhlIGNvbm5lY3Rpbmcgc3RhdGUpXHJcblx0XHQgKi9cclxuXHRcdGlmKCh3YXNBY3RpdmUgJiYgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbikgfHxcclxuXHRcdFx0KHdhc0FjdGl2ZSAmJiAoc3RhdGUgPT09ICdmYWlsZWQnKSB8fCAoc3RhdGUgPT09ICdjbG9zZWQnKSkgfHxcclxuXHRcdFx0KGN1cnJlbnRQcm90b2NvbCA9PT0gbnVsbCAmJiB3YXNQZW5kaW5nICYmIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMubGVuZ3RoID09PSAwKSkge1xyXG5cclxuXHRcdFx0LyogSWYgd2UncmUgZGlzY29ubmVjdGVkIHdpdGggYSA1eHggd2UgbmVlZCB0byB0cnkgZmFsbGJhY2sgaG9zdHNcclxuXHRcdFx0ICogKFJUTjE0ZCksIGJ1dCAoYSkgZHVlIHRvIGhvdyB0aGUgdXBncmFkZSBzZXF1ZW5jZSB3b3JrcywgdGhlXHJcblx0XHRcdCAqIGhvc3QvdHJhbnNwb3J0IHNlbGVjdGlvbiBzZXF1ZW5jZSBvbmx5IGNhcmVzIGFib3V0IGdldHRpbmcgdG9cclxuXHRcdFx0ICogYHByZWNvbm5lY3RgIChlZyBlc3RhYmxpc2hpbmcgYSB3ZWJzb2NrZXQpIGdldHRpbmcgYSBgZGlzY29ubmVjdGVkYFxyXG5cdFx0XHQgKiBwcm90b2NvbCBtZXNzYWdlIGFmdGVyd2FyZHMgaXMgdG9vIGxhdGU7IGFuZCAoYikgaG9zdCByZXRyeSBvbmx5XHJcblx0XHRcdCAqIGFwcGxpZXMgdG8gY29ubmVjdEJhc2UgdW5sZXNzIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSB0cmFuc3BvcnQgZG9lc24ndFxyXG5cdFx0XHQgKiB3b3JrLiBXZSBzb2x2ZSB0aGlzIGJ5IHVucGVyc2lzdGluZyB0aGUgdHJhbnNwb3J0IHByZWZlcmVuY2UgYW5kXHJcblx0XHRcdCAqIHNldHRpbmcgYW4gaW5zdGFuY2UgdmFyaWFibGUgdG8gZm9yY2UgZmFsbGJhY2sgaG9zdHMgdG8gYmUgdXNlZCAoaWZcclxuXHRcdFx0ICogYW55KSBoZXJlLiBCaXQgb2YgYSBrbHVkZ2UsIGJ1dCBubyByZWFsIGJldHRlciBhbHRlcm5hdGl2ZXMgd2l0aG91dFxyXG5cdFx0XHQgKiByZXdyaXRpbmcgdGhlIGVudGlyZSB0aGluZyAqL1xyXG5cdFx0XHRpZihzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgZXJyb3IgJiYgZXJyb3Iuc3RhdHVzQ29kZSA+IDUwMCAmJiB0aGlzLmh0dHBIb3N0cy5sZW5ndGggPiAxKSB7XHJcblx0XHRcdFx0dGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XHJcblx0XHRcdFx0dGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IHRydWU7XHJcblx0XHRcdFx0LyogYW5kIHRyeSB0byBjb25uZWN0IGFnYWluIHRvIHRyeSBhIGZhbGxiYWNrIGhvc3Qgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgdXN1YWwgMTVzIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCAqL1xyXG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiBzdGF0ZSwgZXJyb3I6IGVycm9yLCByZXRyeUltbWVkaWF0ZWx5OiB0cnVlfSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHQvKiBUT0RPIHJlbW92ZSBiZWxvdyBsaW5lIG9uY2UgcmVhbHRpbWUgc2VuZHMgdG9rZW4gZXJyb3JzIGFzIERJU0NPTk5FQ1RFRHMgKi9cclxuXHRcdFx0dmFyIG5ld0Nvbm5lY3Rpb25TdGF0ZSA9IChzdGF0ZSA9PT0gJ2ZhaWxlZCcgJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIoZXJyb3IpKSA/ICdkaXNjb25uZWN0ZWQnIDogc3RhdGU7XHJcblx0XHRcdHRoaXMubm90aWZ5U3RhdGUoe3N0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yOiBlcnJvcn0pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYod2FzQWN0aXZlICYmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpICYmICh0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nKSkge1xyXG5cdFx0XHQvKiBJZiB3ZSB3ZXJlIGFjdGl2ZSBidXQgdGhlcmUgaXMgYW5vdGhlciB0cmFuc3BvcnQgc2NoZWR1bGVkIGZvclxyXG5cdFx0XHQqIGFjdGl2YXRpb24sIGdvIGludG8gdG8gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgdW50aWwgdGhhdCB0cmFuc3BvcnRcclxuXHRcdFx0KiBhY3RpdmF0ZXMgYW5kIHNldHMgdXMgYmFjayB0byBjb25uZWN0ZWQuIChtYW51YWxseSBzdGFydGluZyB0aGVcclxuXHRcdFx0KiB0cmFuc2l0aW9uIHRpbWVycyBpbiBjYXNlIHRoYXQgbmV2ZXIgaGFwcGVucykuIChJZiB3ZSB3ZXJlIGluIHRoZVxyXG5cdFx0XHQqIHN5bmNocm9uaXppbmcgc3RhdGUsIHRoZW4gdGhhdCdzIGZpbmUsIHRoZSBvbGQgdHJhbnNwb3J0IGp1c3QgZ290IGl0c1xyXG5cdFx0XHQqIGRpc2Nvbm5lY3RlZCBiZWZvcmUgdGhlIG5ldyBvbmUgZ290IHRoZSBzeW5jIC0tIGlnbm9yZSBpdCBhbmQga2VlcFxyXG5cdFx0XHQqIHdhaXRpbmcgZm9yIHRoZSBzeW5jLiBJZiBpdCBmYWlscyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3luYyB0aW1lciB0aGF0XHJcblx0XHRcdCogd2lsbCBleHBpcmUpLiAqL1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGVhY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ3dhc0FjdGl2ZSBidXQgYW5vdGhlciB0cmFuc3BvcnQgaXMgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIHNvIGdvaW5nIGludG8gdGhlIGNvbm5lY3Rpbmcgc3RhdGUgdW50aWwgaXQgYWN0aXZhdGVzJyk7XHJcblx0XHRcdHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcclxuXHRcdFx0dGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcclxuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJywgZXJyb3I6IGVycm9yfSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyogSGVscGVyIHRoYXQgcmV0dXJucyB0cnVlIGlmIHRoZXJlIGFyZSBubyB0cmFuc3BvcnRzIHdoaWNoIGFyZSBwZW5kaW5nLFxyXG5cdCogaGF2ZSBiZWVuIGNvbm5lY3RlZCwgYW5kIGFyZSBqdXN0IHdhaXRpbmcgZm9yIG9uY2VOb1BlbmRpbmcgdG8gZmlyZSBiZWZvcmVcclxuXHQqIGJlaW5nIGFjdGl2YXRlZCAqL1xyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0VtcHR5KHRoaXMucGVuZGluZ1RyYW5zcG9ydHMpIHx8XHJcblx0XHRcdHRoaXMucGVuZGluZ1RyYW5zcG9ydHMuZXZlcnkoZnVuY3Rpb24odHJhbnNwb3J0KSB7XHJcblx0XHRcdFx0cmV0dXJuICF0cmFuc3BvcnQuaXNDb25uZWN0ZWQ7XHJcblx0XHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdC8qKlxyXG5cdCAqIENhbGxlZCB3aGVuIGFjdGl2YXRpbmcgYSBuZXcgdHJhbnNwb3J0LCB0byBlbnN1cmUgbWVzc2FnZSBkZWxpdmVyeVxyXG5cdCAqIG9uIHRoZSBuZXcgdHJhbnNwb3J0IHN5bmNocm9uaXNlcyB3aXRoIHRoZSBtZXNzYWdlcyBhbHJlYWR5IHJlY2VpdmVkXHJcblx0ICovXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbih0cmFuc3BvcnQsIHJlcXVlc3RlZFN5bmNQb3NpdGlvbiwgY2FsbGJhY2spIHtcclxuXHRcdHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcblx0XHRcdHRyYW5zcG9ydC5vZmYoJ3N5bmMnKTtcclxuXHRcdFx0Y2FsbGJhY2sobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1RpbWVvdXQgd2FpdGluZyBmb3Igc3luYyByZXNwb25zZScsIDUwMDAwLCA1MDApKTtcclxuXHRcdH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcclxuXHJcblx0XHQvKiBzZW5kIHN5bmMgcmVxdWVzdCAqL1xyXG5cdFx0dmFyIHN5bmNNZXNzYWdlID0gX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMoe1xyXG5cdFx0XHRhY3Rpb246IGFjdGlvbnMuU1lOQyxcclxuXHRcdFx0Y29ubmVjdGlvbktleTogdGhpcy5jb25uZWN0aW9uS2V5XHJcblx0XHR9KTtcclxuXHJcblx0XHRpZihyZXF1ZXN0ZWRTeW5jUG9zaXRpb24udGltZVNlcmlhbCkge1xyXG5cdFx0XHRzeW5jTWVzc2FnZS50aW1lU2VyaWFsID0gcmVxdWVzdGVkU3luY1Bvc2l0aW9uLnRpbWVTZXJpYWw7XHJcblx0XHR9IGVsc2UgaWYocmVxdWVzdGVkU3luY1Bvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRzeW5jTWVzc2FnZS5jb25uZWN0aW9uU2VyaWFsID0gcmVxdWVzdGVkU3luY1Bvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWw7XHJcblx0XHR9XHJcblx0XHR0cmFuc3BvcnQuc2VuZChzeW5jTWVzc2FnZSk7XHJcblxyXG5cdFx0dHJhbnNwb3J0Lm9uY2UoJ3N5bmMnLCBmdW5jdGlvbihjb25uZWN0aW9uSWQsIHN5bmNQb3NpdGlvbikge1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGltZW91dCk7XHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIGNvbm5lY3Rpb25JZCwgc3luY1Bvc2l0aW9uKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRDb25uZWN0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgY29ubmVjdGlvblBvc2l0aW9uLCBoYXNDb25uZWN0aW9uRXJyb3IpIHtcclxuXHRcdC8qIGlmIGNvbm5lY3Rpb25LZXkgY2hhbmdlcyBidXQgY29ubmVjdGlvbklkIHN0YXlzIHRoZSBzYW1lLCB0aGVuIGp1c3QgYVxyXG5cdFx0ICogdHJhbnNwb3J0IGNoYW5nZSBvbiB0aGUgc2FtZSBjb25uZWN0aW9uLiBJZiBjb25uZWN0aW9uSWQgY2hhbmdlcywgd2UncmVcclxuXHRcdCAqIG9uIGEgbmV3IGNvbm5lY3Rpb24sIHdpdGggaW1wbGljYXRpb25zIGZvciBtc2dTZXJpYWwgYW5kIGNoYW5uZWwgc3RhdGUsXHJcblx0XHQgKiBhbmQgcmVzZXR0aW5nIHRoZSBjb25uZWN0aW9uU2VyaWFsIHBvc2l0aW9uICovXHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHQvKiBJZiBubyBwcmV2aW91cyBjb25uZWN0aW9uSWQsIGRvbid0IHJlc2V0IHRoZSBtc2dTZXJpYWwgYXMgaXQgbWF5IGhhdmVcclxuXHRcdCAqIGJlZW4gc2V0IGJ5IHJlY292ZXIgZGF0YSAodW5sZXNzIHRoZSByZWNvdmVyIGZhaWxlZCkgKi9cclxuXHRcdHZhciBwcmV2Q29ubklkID0gdGhpcy5jb25uZWN0aW9uaWQsXHJcblx0XHRcdGNvbm5JZENoYW5nZWQgPSBwcmV2Q29ubklkICYmIChwcmV2Q29ubklkICE9PSBjb25uZWN0aW9uSWQpLFxyXG5cdFx0XHRyZWNvdmVyRmFpbHVyZSA9ICFwcmV2Q29ubklkICYmIGhhc0Nvbm5lY3Rpb25FcnJvcjtcclxuXHRcdGlmKGNvbm5JZENoYW5nZWQgfHwgcmVjb3ZlckZhaWx1cmUpICB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKCknLCAnUmVzZXR0aW5nIG1zZ1NlcmlhbCcpO1xyXG5cdFx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XHJcblx0XHR9XHJcblx0XHQvKiBidXQgZG8gbmVlZCB0byByZWF0dGFjaCBjaGFubmVscywgZm9yIGNoYW5uZWxzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGluXHJcblx0XHQgKiB0aGUgYXR0YWNoZWQgc3RhdGUgZXZlbiB0aG91Z2ggdGhlIGNvbm5lY3Rpb24gbW9kZSB3YXMgJ2NsZWFuJyBkdWUgdG8gYVxyXG5cdFx0ICogZnJlc2huZXNzIGNoZWNrIC0gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzM5NCAqL1xyXG5cdFx0aWYodGhpcy5jb25uZWN0aW9uSWQgIT09IGNvbm5lY3Rpb25JZCkgIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdOZXcgY29ubmVjdGlvbklkOyByZWF0dGFjaGluZyBhbnkgYXR0YWNoZWQgY2hhbm5lbHMnKTtcclxuXHRcdFx0LyogV2FpdCB0aWxsIG5leHQgdGljayBiZWZvcmUgcmVhdHRhY2hpbmcgY2hhbm5lbHMsIHNvIHRoYXQgY29ubmVjdGlvblxyXG5cdFx0XHQgKiBzdGF0ZSB3aWxsIGJlIHVwZGF0ZWQgYW5kIHNvIHRoYXQgaXQgd2lsbCBiZSBhcHBsaWVkIGFmdGVyXHJcblx0XHRcdCAqIENoYW5uZWxzI29uVHJhbnNwb3J0VXBkYXRlLCBlbHNlIGNoYW5uZWxzIHdpbGwgbm90IGhhdmUgYW4gQVRUQUNIRURcclxuXHRcdFx0ICogc2VudCB0d2ljZSAob25jZSBmcm9tIHRoaXMgYW5kIG9uY2UgZnJvbSB0aGF0KS4gKi9cclxuXHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzZWxmLnJlYWx0aW1lLmNoYW5uZWxzLnJlYXR0YWNoKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIGlmKHRoaXMub3B0aW9ucy5jaGVja0NoYW5uZWxzT25SZXN1bWUpIHtcclxuXHRcdFx0LyogRm9yIGF0dGFjaGVkIGNoYW5uZWxzLCBzZXQgdGhlIGF0dGFjaGVkIG1zZyBpbmRpY2F0b3IgdmFyaWFibGUgdG8gZmFsc2UsXHJcblx0XHRcdCAqIHdhaXQgMzBzLCBhbmQgY2hlY2sgd2UgZ290IGFuIGF0dGFjaGVkIGZvciBlYWNoIG9uZS5cclxuXHRcdFx0ICogMzBzIHdhcyBjaG9zZW4gdG8gYmUgNXMgbG9uZ2VyIHRoYW4gdGhlIHRyYW5zcG9ydCBpZGxlIHRpbWVvdXQgZXhwaXJlXHJcblx0XHRcdCAqIHRpbWUsIGluIGFuIGF0dGVtcHQgdG8gYXZvaWQgZmFsc2UgcG9zaXRpdmVzIGR1ZSB0byBhIHRyYW5zcG9ydFxyXG5cdFx0XHQgKiBzaWxlbnRseSBmYWlsaW5nIGltbWVkaWF0ZWx5IGFmdGVyIGEgcmVzdW1lICovXHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zZXRDb25uZWN0aW9uKCknLCAnU2FtZSBjb25uZWN0aW9uSWQ7IGNoZWNrQ2hhbm5lbHNPblJlc3VtZSBpcyBlbmFibGVkJyk7XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLmNoYW5uZWxSZXN1bWVDaGVja1RpbWVyKTtcclxuXHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5yZXNldEF0dGFjaGVkTXNnSW5kaWNhdG9ycygpO1xyXG5cdFx0XHR0aGlzLmNoYW5uZWxSZXN1bWVDaGVja1RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzZWxmLnJlYWx0aW1lLmNoYW5uZWxzLmNoZWNrQXR0YWNoZWRNc2dJbmRpY2F0b3JzKGNvbm5lY3Rpb25JZCk7XHJcblx0XHRcdH0sIDMwMDAwKTtcclxuXHRcdH1cclxuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xyXG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XHJcblx0XHR2YXIgZm9yY2VSZXNldE1lc3NhZ2VTZXJpYWwgPSBjb25uSWRDaGFuZ2VkIHx8ICFwcmV2Q29ubklkO1xyXG5cdFx0dGhpcy5zZXRDb25uZWN0aW9uU2VyaWFsKGNvbm5lY3Rpb25Qb3NpdGlvbiwgZm9yY2VSZXNldE1lc3NhZ2VTZXJpYWwpO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5pZCA9IHRoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY2xlYXJDb25uZWN0aW9uU2VyaWFsKCk7XHJcblx0XHR0aGlzLm1zZ1NlcmlhbCA9IDA7XHJcblx0XHR0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcclxuXHR9O1xyXG5cclxuXHQvKiBmb3JjZTogc2V0IHRoZSBjb25uZWN0aW9uU2VyaWFsIGV2ZW4gaWYgaXQncyBsZXNzIHRoYW4gdGhlIGN1cnJlbnRcclxuXHQgKiBjb25uZWN0aW9uU2VyaWFsLiBVc2VkIGZvciBuZXcgY29ubmVjdGlvbnMuXHJcblx0ICogUmV0dXJucyB0cnVlIGlmZiB0aGUgbWVzc2FnZSB3YXMgcmVqZWN0ZWQgYXMgYSBkdXBsaWNhdGUuICovXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldENvbm5lY3Rpb25TZXJpYWwgPSBmdW5jdGlvbihjb25uZWN0aW9uUG9zaXRpb24sIGZvcmNlKSB7XHJcblx0XHR2YXIgdGltZVNlcmlhbCA9IGNvbm5lY3Rpb25Qb3NpdGlvbi50aW1lU2VyaWFsLFxyXG5cdFx0XHRjb25uZWN0aW9uU2VyaWFsID0gY29ubmVjdGlvblBvc2l0aW9uLmNvbm5lY3Rpb25TZXJpYWw7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvblNlcmlhbCgpJywgJ1VwZGF0aW5nIGNvbm5lY3Rpb24gc2VyaWFsOyBzZXJpYWwgPSAnICsgY29ubmVjdGlvblNlcmlhbCArICc7IHRpbWVTZXJpYWwgPSAnICsgdGltZVNlcmlhbCArICc7IGZvcmNlID0gJyArIGZvcmNlICsgJzsgcHJldmlvdXMgPSAnICsgdGhpcy5jb25uZWN0aW9uU2VyaWFsKTtcclxuXHRcdGlmKHRpbWVTZXJpYWwgIT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZih0aW1lU2VyaWFsIDw9IHRoaXMudGltZVNlcmlhbCAmJiAhZm9yY2UpIHtcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0Q29ubmVjdGlvblNlcmlhbCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2Ugd2l0aCB0aW1lU2VyaWFsICcgKyB0aW1lU2VyaWFsICsgJywgYnV0IGN1cnJlbnQgdGltZVNlcmlhbCBpcyAnICsgdGhpcy50aW1lU2VyaWFsICsgJzsgYXNzdW1pbmcgbWVzc2FnZSBpcyBhIGR1cGxpY2F0ZSBhbmQgZGlzY2FyZGluZyBpdCcpO1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi50aW1lU2VyaWFsID0gdGhpcy50aW1lU2VyaWFsID0gdGltZVNlcmlhbDtcclxuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZihjb25uZWN0aW9uU2VyaWFsICE9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYoY29ubmVjdGlvblNlcmlhbCA8PSB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgJiYgIWZvcmNlKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb25TZXJpYWwoKScsICdyZWNlaXZlZCBtZXNzYWdlIHdpdGggY29ubmVjdGlvblNlcmlhbCAnICsgY29ubmVjdGlvblNlcmlhbCArICcsIGJ1dCBjdXJyZW50IGNvbm5lY3Rpb25TZXJpYWwgaXMgJyArIHRoaXMuY29ubmVjdGlvblNlcmlhbCArICc7IGFzc3VtaW5nIG1lc3NhZ2UgaXMgYSBkdXBsaWNhdGUgYW5kIGRpc2NhcmRpbmcgaXQnKTtcclxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uc2VyaWFsID0gdGhpcy5jb25uZWN0aW9uU2VyaWFsID0gY29ubmVjdGlvblNlcmlhbDtcclxuXHRcdFx0dGhpcy5zZXRSZWNvdmVyeUtleSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jbGVhckNvbm5lY3Rpb25TZXJpYWwgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5zZXJpYWwgPSB0aGlzLmNvbm5lY3Rpb25TZXJpYWwgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24udGltZVNlcmlhbCA9IHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuY2xlYXJSZWNvdmVyeUtleSgpO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRSZWNvdmVyeUtleSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLnJlY292ZXJ5S2V5ID0gdGhpcy5jb25uZWN0aW9uS2V5ICsgJzonICsgKHRoaXMudGltZVNlcmlhbCB8fCB0aGlzLmNvbm5lY3Rpb25TZXJpYWwpICsgJzonICsgdGhpcy5tc2dTZXJpYWw7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsZWFyUmVjb3ZlcnlLZXkgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5yZWNvdmVyeUtleSA9IG51bGw7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRpZighdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7IHJldHVybjsgfVxyXG5cclxuXHRcdHZhciBzaW5jZUxhc3QgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XHJcblx0XHRpZihzaW5jZUxhc3QgPiB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCArIHRoaXMubWF4SWRsZUludGVydmFsKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpJywgJ0xhc3Qga25vd24gYWN0aXZpdHkgZnJvbSByZWFsdGltZSB3YXMgJyArIHNpbmNlTGFzdCArICdtcyBhZ287IGRpc2NhcmRpbmcgY29ubmVjdGlvbiBzdGF0ZScpO1xyXG5cdFx0XHR0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xyXG5cdFx0XHR0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xyXG5cdFx0XHR0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gZmFsc2U7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0LyoqXHJcblx0ICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XHJcblx0ICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cclxuXHQgKi9cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdENvbm5lY3Rpb24gPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKGhhdmVTZXNzaW9uU3RvcmFnZSkge1xyXG5cdFx0XHR2YXIgcmVjb3ZlcnlLZXkgPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24ucmVjb3ZlcnlLZXk7XHJcblx0XHRcdGlmKHJlY292ZXJ5S2V5KSB7XHJcblx0XHRcdFx0c2V0U2Vzc2lvblJlY292ZXJEYXRhKHtcclxuXHRcdFx0XHRcdHJlY292ZXJ5S2V5OiByZWNvdmVyeUtleSxcclxuXHRcdFx0XHRcdGRpc2Nvbm5lY3RlZEF0OiBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpLFxyXG5cdFx0XHRcdFx0bG9jYXRpb246IGdsb2JhbC5sb2NhdGlvbixcclxuXHRcdFx0XHRcdGNsaWVudElkOiB0aGlzLnJlYWx0aW1lLmF1dGguY2xpZW50SWRcclxuXHRcdFx0XHR9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBDYWxsZWQgd2hlbiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgd2FudHMgdG8gcGVyc2lzdCB0cmFuc3BvcnRcclxuXHQgKiBzdGF0ZSBmb3IgbGF0ZXIgcmVjb3ZlcnkuIE9ubHkgYXBwbGljYWJsZSBpbiB0aGUgYnJvd3NlciBjb250ZXh0LlxyXG5cdCAqL1xyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS51bnBlcnNpc3RDb25uZWN0aW9uID0gZnVuY3Rpb24oKSB7XHJcblx0XHRjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpO1xyXG5cdH07XHJcblxyXG5cdC8qKioqKioqKioqKioqKioqKioqKipcclxuXHQgKiBzdGF0ZSBtYW5hZ2VtZW50XHJcblx0ICoqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5lcnJvclJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKTtcclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0U3RhdGVFcnJvciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl1bdGhpcy5zdGF0ZS5zdGF0ZV07XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFjdGl2ZVN0YXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cyB8fCB0aGlzLnN0YXRlLnNlbmRFdmVudHM7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmVuYWN0U3RhdGVDaGFuZ2UgPSBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xyXG5cdFx0dmFyIGxvZ0xldmVsID0gc3RhdGVDaGFuZ2UuY3VycmVudCA9PT0gJ2ZhaWxlZCcgPyBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IgOiBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUFKT1I7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24obG9nTGV2ZWwsICdDb25uZWN0aW9uIHN0YXRlJywgc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyAoJzsgcmVhc29uOiAnICsgc3RhdGVDaGFuZ2UucmVhc29uKSA6ICcnKSk7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZW5hY3RTdGF0ZUNoYW5nZScsICdzZXR0aW5nIG5ldyBzdGF0ZTogJyArIHN0YXRlQ2hhbmdlLmN1cnJlbnQgKyAnOyByZWFzb24gPSAnICsgKHN0YXRlQ2hhbmdlLnJlYXNvbiAmJiBzdGF0ZUNoYW5nZS5yZWFzb24ubWVzc2FnZSkpO1xyXG5cdFx0dmFyIG5ld1N0YXRlID0gdGhpcy5zdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlQ2hhbmdlLmN1cnJlbnRdO1xyXG5cdFx0aWYoc3RhdGVDaGFuZ2UucmVhc29uKSB7XHJcblx0XHRcdHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XHJcblx0XHRcdHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IHN0YXRlQ2hhbmdlLnJlYXNvbjtcclxuXHRcdH1cclxuXHRcdGlmKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xyXG5cdFx0XHQvKiBzdXNwZW5kZWQgaXMgbm9udGVybWluYWwsIGJ1dCBvbmNlIGluIHRoZSBzdXNwZW5kZWQgc3RhdGUsIHJlYWx0aW1lXHJcblx0XHRcdCAqIHdpbGwgaGF2ZSBkaXNjYXJkZWQgb3VyIGNvbm5lY3Rpb24gc3RhdGUsIHNvIGZ1dGhlciBjb25uZWN0aW9uXHJcblx0XHRcdCAqIGF0dGVtcHRzIHNob3VsZCBzdGFydCBmcm9tIHNjcmF0Y2ggKi9cclxuXHRcdFx0dGhpcy5jbGVhckNvbm5lY3Rpb24oKTtcclxuXHRcdH1cclxuXHRcdHRoaXMuZW1pdCgnY29ubmVjdGlvbnN0YXRlJywgc3RhdGVDaGFuZ2UpO1xyXG5cdH07XHJcblxyXG5cdC8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcblx0ICogQ29ubmVjdGlvbk1hbmFnZXIgY29ubmVjdGlvbiBsaWZlY3ljbGVcclxuXHQgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0VHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24odHJhbnNpdGlvblN0YXRlKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRUcmFuc2l0aW9uVGltZXIoKScsICd0cmFuc2l0aW9uU3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUpO1xyXG5cclxuXHRcdGlmKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydFRyYW5zaXRpb25UaW1lcigpJywgJ2NsZWFyaW5nIGFscmVhZHktcnVubmluZyB0aW1lcicpO1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdHRoaXMudHJhbnNpdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYoc2VsZi50cmFuc2l0aW9uVGltZXIpIHtcclxuXHRcdFx0XHRzZWxmLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUgKyAnIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlKTtcclxuXHRcdFx0XHRzZWxmLm5vdGlmeVN0YXRlKHtzdGF0ZTogdHJhbnNpdGlvblN0YXRlLmZhaWxTdGF0ZX0pO1xyXG5cdFx0XHR9XHJcblx0XHR9LCB0cmFuc2l0aW9uU3RhdGUucmV0cnlEZWxheSk7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFRyYW5zaXRpb25UaW1lciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpJywgJycpO1xyXG5cdFx0aWYodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRoaXMudHJhbnNpdGlvblRpbWVyKTtcclxuXHRcdFx0dGhpcy50cmFuc2l0aW9uVGltZXIgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0aWYodGhpcy5zdXNwZW5kVGltZXIpXHJcblx0XHRcdHJldHVybjtcclxuXHRcdHRoaXMuc3VzcGVuZFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0aWYoc2VsZi5zdXNwZW5kVGltZXIpIHtcclxuXHRcdFx0XHRzZWxmLnN1c3BlbmRUaW1lciA9IG51bGw7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIHN1c3BlbmQgdGltZXIgZXhwaXJlZCcsICdyZXF1ZXN0aW5nIG5ldyBzdGF0ZTogc3VzcGVuZGVkJyk7XHJcblx0XHRcdFx0c2VsZi5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcclxuXHRcdFx0XHRzZWxmLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gZmFsc2U7XHJcblx0XHRcdFx0c2VsZi5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdzdXNwZW5kZWQnfSk7XHJcblx0XHRcdH1cclxuXHRcdH0sIHRoaXMuY29ubmVjdGlvblN0YXRlVHRsKTtcclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tTdXNwZW5kVGltZXIgPSBmdW5jdGlvbihzdGF0ZSkge1xyXG5cdFx0aWYoc3RhdGUgIT09ICdkaXNjb25uZWN0ZWQnICYmIHN0YXRlICE9PSAnc3VzcGVuZGVkJyAmJiBzdGF0ZSAhPT0gJ2Nvbm5lY3RpbmcnKVxyXG5cdFx0XHR0aGlzLmNhbmNlbFN1c3BlbmRUaW1lcigpO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jYW5jZWxTdXNwZW5kVGltZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlID0gJ2Rpc2Nvbm5lY3RlZCc7XHJcblx0XHR0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnF1ZXVlRXZlbnRzID0gdHJ1ZTtcclxuXHRcdGlmKHRoaXMuc3VzcGVuZFRpbWVyKSB7XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnN1c3BlbmRUaW1lcik7XHJcblx0XHRcdHRoaXMuc3VzcGVuZFRpbWVyID0gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc3RhcnRSZXRyeVRpbWVyID0gZnVuY3Rpb24oaW50ZXJ2YWwpIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdHRoaXMucmV0cnlUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciByZXRyeSB0aW1lciBleHBpcmVkJywgJ3JldHJ5aW5nJyk7XHJcblx0XHRcdHNlbGYucmV0cnlUaW1lciA9IG51bGw7XHJcblx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKHtzdGF0ZTogJ2Nvbm5lY3RpbmcnfSk7XHJcblx0XHR9LCBpbnRlcnZhbCk7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFJldHJ5VGltZXIgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMucmV0cnlUaW1lcikge1xyXG5cdFx0XHRjbGVhclRpbWVvdXQodGhpcy5yZXRyeVRpbWVyKTtcclxuXHRcdFx0dGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUubm90aWZ5U3RhdGUgPSBmdW5jdGlvbihpbmRpY2F0ZWQpIHtcclxuXHRcdHZhciBzdGF0ZSA9IGluZGljYXRlZC5zdGF0ZSxcclxuXHRcdFx0c2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0LyogV2UgcmV0cnkgaW1tZWRpYXRlbHkgaWY6XHJcblx0XHQgKiAtIHNvbWV0aGluZyBkaXNjb25uZWN0cyB1cyB3aGlsZSB3ZSdyZSBjb25uZWN0ZWQsIG9yXHJcblx0XHQgKiAtIGEgdmlhYmxlIChidXQgbm90IHlldCBhY3RpdmUpIHRyYW5zcG9ydCBmYWlscyBkdWUgdG8gYSB0b2tlbiBlcnJvciAoc29cclxuXHRcdCAqICAgdGhpcy5lcnJvclJlYXNvbiB3aWxsIGJlIHNldCwgYW5kIHN0YXJ0Q29ubmVjdCB3aWxsIGRvIGEgZm9yY2VkXHJcblx0XHQgKiAgIGF1dGhvcml6ZSkuIElmIHRoaXMuZXJyb3JSZWFzb24gaXMgYWxyZWFkeSBzZXQgKHRvIGEgdG9rZW4gZXJyb3IpLFxyXG5cdFx0ICogICB0aGVuIHRoZXJlIGhhcyBiZWVuIGF0IGxlYXN0IG9uZSBwcmV2aW91cyBhdHRlbXB0IHRvIGNvbm5lY3QgdGhhdCBhbHNvXHJcblx0XHQgKiAgIGZhaWxlZCBmb3IgYSB0b2tlbiBlcnJvciwgc28gYnkgUlROMTRiIHdlIGdvIHRvIERJU0NPTk5FQ1RFRCBhbmQgd2FpdFxyXG5cdFx0ICogICBiZWZvcmUgdHJ5aW5nIGFnYWluICovXHJcblx0XHR2YXIgcmV0cnlJbW1lZGlhdGVseSA9IChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiZcclxuXHRcdFx0KHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCAgICAgfHxcclxuXHRcdFx0IHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcgfHxcclxuXHRcdFx0IGluZGljYXRlZC5yZXRyeUltbWVkaWF0ZWx5ICAgICAgICAgICAgICAgfHxcclxuXHRcdFx0XHQodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZyAmJlxyXG5cdFx0XHRcdFx0aW5kaWNhdGVkLmVycm9yICYmIF9jbGllbnRfYXV0aF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc1Rva2VuRXJyKGluZGljYXRlZC5lcnJvcikgJiZcclxuXHRcdFx0XHRcdCEodGhpcy5lcnJvclJlYXNvbiAmJiBfY2xpZW50X2F1dGhfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzExX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpKSk7XHJcblxyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnbmV3IHN0YXRlOiAnICsgc3RhdGUgKyAocmV0cnlJbW1lZGlhdGVseSA/ICc7IHdpbGwgcmV0cnkgY29ubmVjdGlvbiBpbW1lZGlhdGVseScgOiAnJykpO1xyXG5cdFx0LyogZG8gbm90aGluZyBpZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBpbmRpY2F0ZWQgc3RhdGUgKi9cclxuXHRcdGlmKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXHJcblx0XHRcdHJldHVybjtcclxuXHJcblx0XHQvKiBraWxsIHRpbWVycyAocG9zc2libHkgZXhjZXB0aW5nIHN1c3BlbmQgdGltZXIgZGVwZW5kaW5nIG9uIHRoZSBub3RpZmllZFxyXG5cdFx0KiBzdGF0ZSksIGFzIHRoZXNlIGFyZSBzdXBlcnNlZGVkIGJ5IHRoaXMgbm90aWZpY2F0aW9uICovXHJcblx0XHR0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xyXG5cdFx0dGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XHJcblx0XHR0aGlzLmNoZWNrU3VzcGVuZFRpbWVyKGluZGljYXRlZC5zdGF0ZSk7XHJcblxyXG5cdFx0LyogZG8gbm90aGluZyBpZiB3ZSdyZSB1bmFibGUgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlICovXHJcblx0XHRpZih0aGlzLnN0YXRlLnRlcm1pbmFsKVxyXG5cdFx0XHRyZXR1cm47XHJcblxyXG5cdFx0LyogcHJvY2VzcyBuZXcgc3RhdGUgKi9cclxuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW2luZGljYXRlZC5zdGF0ZV0sXHJcblx0XHRcdGNoYW5nZSA9IG5ldyBfY2xpZW50X2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCBuZXdTdGF0ZS5yZXRyeURlbGF5LCAoaW5kaWNhdGVkLmVycm9yIHx8IF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl1bbmV3U3RhdGUuc3RhdGVdKSk7XHJcblxyXG5cdFx0aWYocmV0cnlJbW1lZGlhdGVseSkge1xyXG5cdFx0XHR2YXIgYXV0b1JlY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdGlmKHNlbGYuc3RhdGUgPT09IHNlbGYuc3RhdGVzLmRpc2Nvbm5lY3RlZCkge1xyXG5cdFx0XHRcdFx0c2VsZi5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpO1xyXG5cdFx0XHRcdFx0c2VsZi5yZXF1ZXN0U3RhdGUoe3N0YXRlOiAnY29ubmVjdGluZyd9KTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdHZhciBzaW5jZUxhc3QgPSB0aGlzLmxhc3RBdXRvUmVjb25uZWN0QXR0ZW1wdCAmJiAoX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5ub3coKSAtIHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICsgMSk7XHJcblx0XHRcdGlmKHNpbmNlTGFzdCAmJiAoc2luY2VMYXN0IDwgMTAwMCkpIHtcclxuXHRcdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIubm90aWZ5U3RhdGUoKScsICdMYXN0IHJlY29ubmVjdCBhdHRlbXB0IHdhcyBvbmx5ICcgKyBzaW5jZUxhc3QgKyAnbXMgYWdvLCB3YWl0aW5nIGFub3RoZXIgJyArICgxMDAwIC0gc2luY2VMYXN0KSArICdtcyBiZWZvcmUgdHJ5aW5nIGFnYWluJyk7XHJcblx0XHRcdFx0c2V0VGltZW91dChhdXRvUmVjb25uZWN0LCAxMDAwIC0gc2luY2VMYXN0KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGF1dG9SZWNvbm5lY3QpO1xyXG5cdFx0XHR9XHJcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnIHx8IHN0YXRlID09PSAnc3VzcGVuZGVkJykge1xyXG5cdFx0XHR0aGlzLnN0YXJ0UmV0cnlUaW1lcihuZXdTdGF0ZS5yZXRyeURlbGF5KTtcclxuXHRcdH1cclxuXHJcblx0XHQgLyogSWYgZ29pbmcgaW50byBkaXNjb25uZWN0L3N1c3BlbmRlZCAoYW5kIG5vdCByZXRyeWluZyBpbW1lZGlhdGVseSksIG9yIGFcclxuXHRcdFx0KiB0ZXJtaW5hbCBzdGF0ZSwgZW5zdXJlIHRoZXJlIGFyZSBubyBvcnBoYW5lZCB0cmFuc3BvcnRzIGhhbmdpbmcgYXJvdW5kLiAqL1xyXG5cdFx0aWYoKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiAhcmV0cnlJbW1lZGlhdGVseSkgfHxcclxuXHRcdFx0IChzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHx8XHJcblx0XHRcdCBuZXdTdGF0ZS50ZXJtaW5hbCkge1xyXG5cdFx0XHRcdCAvKiBXYWl0IHRpbGwgdGhlIG5leHQgdGljayBzbyB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2UgaXMgZW5hY3RlZCxcclxuXHRcdFx0XHQgKiBzbyBhYm9ydGluZyB0cmFuc3BvcnRzIGRvZXNuJ3QgdHJpZ2dlciByZWR1bmRhbnQgc3RhdGUgY2hhbmdlcyAqL1xyXG5cdFx0XHRcdCBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0IHNlbGYuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKTtcclxuXHRcdFx0XHQgfSk7XHJcblx0XHQgfVxyXG5cclxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0ZWQnICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ0Jyb2tlbiBpbnZhcmlhbnQ6IGF0dGVtcHRlZCB0byBnbyBpbnRvIGNvbm5lY3RlZCBzdGF0ZSwgYnV0IHRoZXJlIGlzIG5vIGFjdGl2ZSBwcm90b2NvbCcpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qIGltcGxlbWVudCB0aGUgY2hhbmdlIGFuZCBub3RpZnkgKi9cclxuXHRcdHRoaXMuZW5hY3RTdGF0ZUNoYW5nZShjaGFuZ2UpO1xyXG5cdFx0aWYodGhpcy5zdGF0ZS5zZW5kRXZlbnRzKSB7XHJcblx0XHRcdHRoaXMuc2VuZFF1ZXVlZE1lc3NhZ2VzKCk7XHJcblx0XHR9IGVsc2UgaWYoIXRoaXMuc3RhdGUucXVldWVFdmVudHMpIHtcclxuXHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKHN0YXRlLCBjaGFuZ2UucmVhc29uKTtcclxuXHRcdFx0dGhpcy5mYWlsUXVldWVkTWVzc2FnZXMoY2hhbmdlLnJlYXNvbik7IC8vIFJUTjdjXHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlcXVlc3RTdGF0ZSA9IGZ1bmN0aW9uKHJlcXVlc3QpIHtcclxuXHRcdHZhciBzdGF0ZSA9IHJlcXVlc3Quc3RhdGUsIHNlbGYgPSB0aGlzO1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSgpJywgJ3JlcXVlc3RlZCBzdGF0ZTogJyArIHN0YXRlICsgJzsgY3VycmVudCBzdGF0ZTogJyArIHRoaXMuc3RhdGUuc3RhdGUpO1xyXG5cdFx0aWYoc3RhdGUgPT0gdGhpcy5zdGF0ZS5zdGF0ZSlcclxuXHRcdFx0cmV0dXJuOyAvKiBzaWxlbnRseSBkbyBub3RoaW5nICovXHJcblxyXG5cdFx0Lyoga2lsbCBydW5uaW5nIHRpbWVycywgYXMgdGhpcyByZXF1ZXN0IHN1cGVyc2VkZXMgdGhlbSAqL1xyXG5cdFx0dGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcclxuXHRcdHRoaXMuY2FuY2VsUmV0cnlUaW1lcigpO1xyXG5cdFx0LyogZm9yIHN1c3BlbmQgdGltZXIgY2hlY2sgcmF0aGVyIHRoYW4gY2FuY2VsIC0tIGVnIHJlcXVlc3RpbmcgYSBjb25uZWN0aW5nXHJcblx0XHQqIHN0YXRlIHNob3VsZCBub3QgcmVzZXQgdGhlIHN1c3BlbmQgdGltZXIgKi9cclxuXHRcdHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoc3RhdGUpO1xyXG5cclxuXHRcdGlmKHN0YXRlID09ICdjb25uZWN0aW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjb25uZWN0ZWQnKSByZXR1cm47XHJcblx0XHRpZihzdGF0ZSA9PSAnY2xvc2luZycgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSAnY2xvc2VkJykgcmV0dXJuO1xyXG5cclxuXHRcdHZhciBuZXdTdGF0ZSA9IHRoaXMuc3RhdGVzW3N0YXRlXSxcclxuXHRcdFx0Y2hhbmdlID0gbmV3IF9jbGllbnRfY29ubmVjdGlvbnN0YXRlY2hhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV84X19bLyogZGVmYXVsdCAqLyBcImFcIl0odGhpcy5zdGF0ZS5zdGF0ZSwgbmV3U3RhdGUuc3RhdGUsIG51bGwsIChyZXF1ZXN0LmVycm9yIHx8IF90cmFuc3BvcnRfY29ubmVjdGlvbmVycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV85X19bLyogZGVmYXVsdCAqLyBcImFcIl1bbmV3U3RhdGUuc3RhdGVdKSk7XHJcblxyXG5cdFx0dGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XHJcblxyXG5cdFx0aWYoc3RhdGUgPT0gJ2Nvbm5lY3RpbmcnKSB7XHJcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7IHNlbGYuc3RhcnRDb25uZWN0KCk7IH0pO1xyXG5cdFx0fVxyXG5cdFx0aWYoc3RhdGUgPT0gJ2Nsb3NpbmcnKSB7XHJcblx0XHRcdHRoaXMuY2xvc2VJbXBsKCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydENvbm5lY3QgPSBmdW5jdGlvbigpIHtcclxuXHRcdGlmKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0Q29ubmVjdCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0LCBidXQgd2FzICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBhdXRoID0gdGhpcy5yZWFsdGltZS5hdXRoLFxyXG5cdFx0XHRzZWxmID0gdGhpcztcclxuXHJcblx0XHQvKiBUaGUgcG9pbnQgb2YgdGhlIGNvbm5lY3RDb3VudGVyIG1lY2hhbmlzbSBpcyB0byBlbnN1cmUgdGhhdCB0aGVcclxuXHRcdCAqIGNvbm5lY3Rpb24gcHJvY2VkdXJlIGNhbiBiZSBjYW5jZWxsZWQuIFdlIHdhbnQgZGlzY29ubmVjdEFsbFRyYW5zcG9ydHNcclxuXHRcdCAqIHRvIGJlIGFibGUgdG8gc3RvcCBhbnkgaW4tcHJvZ3Jlc3MgY29ubmVjdGlvbiwgZXZlbiBiZWZvcmUgaXQgZ2V0cyB0b1xyXG5cdFx0ICogdGhlIHN0YWdlIG9mIGhhdmluZyBhIHBlbmRpbmcgKG9yIGV2ZW4gYSBwcm9wb3NlZCkgdHJhbnNwb3J0IHRoYXQgaXQgY2FuXHJcblx0XHQgKiBkaXNwb3NlKCkgb2YuIFNvIHdlIGNoZWNrIHRoYXQgaXQncyBzdGlsbCBjdXJyZW50IGFmdGVyIGFueSBhc3luYyBzdGFnZSxcclxuXHRcdCAqIHVwIHVudGlsIHRoZSBzdGFnZSB0aGF0IGlzIHN5bmNocm9ub3VzIHdpdGggaW5zdGFudGlhdGluZyBhIHRyYW5zcG9ydCAqL1xyXG5cdFx0dmFyIGNvbm5lY3RDb3VudCA9ICsrdGhpcy5jb25uZWN0Q291bnRlcjtcclxuXHJcblx0XHR2YXIgY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzZWxmLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCk7XHJcblx0XHRcdHNlbGYuZ2V0VHJhbnNwb3J0UGFyYW1zKGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xyXG5cdFx0XHRcdGlmKGNvbm5lY3RDb3VudCAhPT0gc2VsZi5jb25uZWN0Q291bnRlcikge1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRzZWxmLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcclxuXHRcdFx0fSk7XHJcblx0XHR9O1xyXG5cclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKScsICdzdGFydGluZyBjb25uZWN0aW9uJyk7XHJcblx0XHR0aGlzLnN0YXJ0U3VzcGVuZFRpbWVyKCk7XHJcblx0XHR0aGlzLnN0YXJ0VHJhbnNpdGlvblRpbWVyKHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpO1xyXG5cclxuXHRcdGlmKGF1dGgubWV0aG9kID09PSAnYmFzaWMnKSB7XHJcblx0XHRcdGNvbm5lY3QoKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHZhciBhdXRoQ2IgPSBmdW5jdGlvbihlcnIpIHtcclxuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0XHRzZWxmLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdGNvbm5lY3QoKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblx0XHRcdGlmKHRoaXMuZXJyb3JSZWFzb24gJiYgX2NsaWVudF9hdXRoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzVG9rZW5FcnIodGhpcy5lcnJvclJlYXNvbikpIHtcclxuXHRcdFx0XHQvKiBGb3JjZSBhIHJlZmV0Y2ggb2YgYSBuZXcgdG9rZW4gKi9cclxuXHRcdFx0XHRhdXRoLl9mb3JjZU5ld1Rva2VuKG51bGwsIG51bGwsIGF1dGhDYik7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0YXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGF1dGhDYik7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKipcclxuXHQgKiBUaGVyZSBhcmUgdGhyZWUgc3RhZ2VzIGluIGNvbm5lY3Rpbmc6XHJcblx0ICogLSBwcmVmZXJlbmNlOiBpZiB0aGVyZSBpcyBhIGNhY2hlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSwgd2UgdHJ5IHRvIGNvbm5lY3RcclxuXHQgKiAgIG9uIHRoYXQuIElmIHRoYXQgZmFpbHMgb3IgdGltZXMgb3V0IHdlIGFib3J0IHRoZSBhdHRlbXB0LCByZW1vdmUgdGhlXHJcblx0ICogICBwcmVmZXJlbmNlIGFuZCBmYWxsIGJhY2sgdG8gYmFzZS4gSWYgaXQgc3VjY2VlZHMsIHdlIHRyeSB1cGdyYWRpbmcgaXQgaWZcclxuXHQgKiAgIG5lZWRlZCAod2lsbCBvbmx5IGJlIGluIHRoZSBjYXNlIHdoZXJlIHRoZSBwcmVmZXJlbmNlIGlzIHhocnMgYW5kIHRoZVxyXG5cdCAqICAgYnJvd3NlciBzdXBwb3J0cyB3cykuXHJcblx0ICogLSBiYXNlOiB3ZSB0cnkgdG8gY29ubmVjdCB3aXRoIHRoZSBiZXN0IHRyYW5zcG9ydCB0aGF0IHdlIHRoaW5rIHdpbGxcclxuXHQgKiAgIG5ldmVyIGZhaWwgZm9yIHRoaXMgYnJvd3NlciAodXN1YWxseSB0aGlzIGlzIHhocl9wb2xsaW5nOyBmb3IgdmVyeSBvbGRcclxuXHQgKiAgIGJyb3dzZXJzIHdpbGwgYmUganNvbnAsIGZvciBub2RlIHdpbGwgYmUgY29tZXQpLiBJZiBpdCBkb2Vzbid0IHdvcmssIHdlXHJcblx0ICogICB0cnkgZmFsbGJhY2sgaG9zdHMuXHJcblx0ICogLSB1cGdyYWRlOiBnaXZlbiBhIGNvbm5lY3RlZCB0cmFuc3BvcnQsIHdlIHNlZSBpZiB0aGVyZSBhcmUgYW55IGJldHRlclxyXG5cdCAqICAgb25lcywgYW5kIGlmIHNvLCB0cnkgdG8gdXBncmFkZSB0byB0aGVtLlxyXG5cdCAqXHJcblx0ICogY29ubmVjdEltcGwgd29ya3Mgb3V0IHdoYXQgc3RhZ2UgeW91J3JlIGF0ICh3aGljaCBpcyBwdXJlbHkgYSBmdW5jdGlvbiBvZlxyXG5cdCAqIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgYW5kIHdoZXRoZXIgdGhlcmUgYXJlIGFueSBzdG9yZWQgcHJlZmVyZW5jZXMpLFxyXG5cdCAqIGFuZCBkaXNwYXRjaGVzIGFjY29yZGluZ2x5LiBBZnRlciBhIHRyYW5zcG9ydCBoYXMgYmVlbiBzZXQgcGVuZGluZyxcclxuXHQgKiB0cnlBVHJhbnNwb3J0IGNhbGxzIGNvbm5lY3RJbXBsIHRvIHNlZSBpZiB0aGVyZSdzIGFub3RoZXIgc3RhZ2UgdG8gYmUgZG9uZS5cclxuXHQgKiAqL1xyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0SW1wbCA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XHJcblx0XHR2YXIgc3RhdGUgPSB0aGlzLnN0YXRlLnN0YXRlO1xyXG5cclxuXHRcdGlmKHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLnN0YXRlICYmIHN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcclxuXHRcdFx0LyogT25seSBrZWVwIHRyeWluZyBhcyBsb25nIGFzIGluIHRoZSAnY29ubmVjdGluZycgc3RhdGUgKG9yICdjb25uZWN0ZWQnXHJcblx0XHRcdCAqIGZvciB1cGdyYWRpbmcpLiBBbnkgb3BlcmF0aW9uIGNhbiBwdXQgdXMgaW50byAnZGlzY29ubmVjdGVkJyB0byBjYW5jZWxcclxuXHRcdFx0ICogY29ubmVjdGlvbiBhdHRlbXB0cyBhbmQgd2FpdCBiZWZvcmUgcmV0cnlpbmcsIG9yICdmYWlsZWQnIHRvIGZhaWwuICovXHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0IChvciBjb25uZWN0ZWQgdG8gdXBncmFkZSksIGJ1dCB3YXMgJyArIHN0YXRlKTtcclxuXHRcdH0gZWxzZSBpZih0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdEltcGwoKScsICdUcmFuc3BvcnRzICcgKyB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzWzBdLnRvU3RyaW5nKCkgKyAnIGN1cnJlbnRseSBwZW5kaW5nOyB0YWtpbmcgbm8gYWN0aW9uJyk7XHJcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XHJcblx0XHRcdHRoaXMudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XHJcblx0XHR9IGVsc2UgaWYodGhpcy50cmFuc3BvcnRzLmxlbmd0aCA+IDEgJiYgdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCkpIHtcclxuXHRcdFx0dGhpcy5jb25uZWN0UHJlZmVyZW5jZSh0cmFuc3BvcnRQYXJhbXMpO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0dGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcykge1xyXG5cdFx0dmFyIHByZWZlcmVuY2UgPSB0aGlzLmdldFRyYW5zcG9ydFByZWZlcmVuY2UoKSxcclxuXHRcdFx0c2VsZiA9IHRoaXMsXHJcblx0XHRcdHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCA9IGZhbHNlO1xyXG5cclxuXHRcdGlmKCFfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckluKHRoaXMudHJhbnNwb3J0cywgcHJlZmVyZW5jZSkpIHtcclxuXHRcdFx0dGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XHJcblx0XHRcdHRoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcclxuXHRcdH1cclxuXHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdFByZWZlcmVuY2UoKScsICdUcnlpbmcgdG8gY29ubmVjdCB3aXRoIHN0b3JlZCB0cmFuc3BvcnQgcHJlZmVyZW5jZSAnICsgcHJlZmVyZW5jZSk7XHJcblxyXG5cdFx0dmFyIHByZWZlcmVuY2VUaW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuXHRcdFx0cHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkID0gdHJ1ZTtcclxuXHRcdFx0aWYoIShzZWxmLnN0YXRlLnN0YXRlID09PSBzZWxmLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnU2hvcnRjaXJjdWl0IGNvbm5lY3Rpb24gYXR0ZW1wdCB3aXRoICcgKyBwcmVmZXJlbmNlICsgJyBmYWlsZWQ7IGNsZWFyaW5nIHByZWZlcmVuY2UgYW5kIHRyeWluZyBmcm9tIHNjcmF0Y2gnKTtcclxuXHRcdFx0XHQvKiBBYm9ydCBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cy4gKFRoaXMgYWxzbyBkaXNjb25uZWN0cyB0aGUgYWN0aXZlXHJcblx0XHRcdFx0ICogcHJvdG9jb2wsIGJ1dCBub25lIGV4aXN0cyBpZiB3ZSdyZSBub3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSkgKi9cclxuXHRcdFx0XHRzZWxmLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XHJcblx0XHRcdFx0LyogQmUgcXVpdGUgYWdyZXNzaXZlIGFib3V0IGNsZWFyaW5nIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSBpZiBldmVyIGl0IGRvZXNuJ3Qgd29yayAqL1xyXG5cdFx0XHRcdHNlbGYudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHNlbGYuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcclxuXHRcdH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQpO1xyXG5cclxuXHRcdC8qIEZvciBjb25uZWN0UHJlZmVyZW5jZSwganVzdCB1c2UgdGhlIG1haW4gaG9zdC4gSWYgaG9zdCBmYWxsYmFjayBpcyBuZWVkZWQsIGRvIGl0IGluIGNvbm5lY3RCYXNlLlxyXG5cdFx0ICogVGhlIHdzdHJhbnNwb3J0IGl0IHdpbGwgc3Vic3RpdHV0ZSB0aGUgaHR0cGhvc3QgZm9yIGFuIGFwcHJvcHJpYXRlIHdzaG9zdCAqL1xyXG5cdFx0dHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBzZWxmLmh0dHBIb3N0c1swXTtcclxuXHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHByZWZlcmVuY2UsIGZ1bmN0aW9uKGZhdGFsLCB0cmFuc3BvcnQpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHByZWZlcmVuY2VUaW1lb3V0KTtcclxuXHRcdFx0aWYocHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkICYmIHRyYW5zcG9ydCkge1xyXG5cdFx0XHRcdC8qIFZpYWJsZSwgYnV0IHRvbyBsYXRlIC0gY29ubmVjdEltcGwoKSB3aWxsIGFscmVhZHkgYmUgdHJ5aW5nXHJcblx0XHRcdFx0KiBjb25uZWN0QmFzZSwgYW5kIHdlIHdlcmVuJ3QgaW4gdXBncmFkZSBtb2RlLiBKdXN0IHJlbW92ZSB0aGVcclxuXHRcdFx0XHQqIG9uY29ubmVjdGVkIGxpc3RlbmVyIGFuZCBnZXQgcmlkIG9mIGl0ICovXHJcblx0XHRcdFx0dHJhbnNwb3J0Lm9mZigpO1xyXG5cdFx0XHRcdHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XHJcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xyXG5cdFx0XHR9IGVsc2UgaWYoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcclxuXHRcdFx0XHQvKiBQcmVmZXJlbmNlIGZhaWxlZCBpbiBhIHRyYW5zcG9ydC1zcGVjaWZpYyB3YXkuIFRyeSBtb3JlICovXHJcblx0XHRcdFx0c2VsZi51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XHJcblx0XHRcdFx0c2VsZi5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8qIElmIHN1Y2VlZGVkLCBvciBmYWlsZWQgZmF0YWxseSwgbm90aGluZyB0byBkbyAqL1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblxyXG5cdC8qKlxyXG5cdCAqIFRyeSB0byBlc3RhYmxpc2ggYSB0cmFuc3BvcnQgb24gdGhlIGJhc2UgdHJhbnNwb3J0ICh0aGUgYmVzdCB0cmFuc3BvcnRcclxuXHQgKiBzdWNoIHRoYXQgaWYgaXQgZG9lc24ndCB3b3JrLCBub3RoaW5nIHdpbGwgd29yaykgYXMgZGV0ZXJtaW5lZCB0aHJvdWdoXHJcblx0ICogc3RhdGljIGZlYXR1cmUgZGV0ZWN0aW9uLCBjaGVja2luZyBmb3IgbmV0d29yayBjb25uZWN0aXZpdHkgYW5kIHRyeWluZ1xyXG5cdCAqIGZhbGxiYWNrIGhvc3RzIGlmIGFwcGxpY2FibGUuXHJcblx0ICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xyXG5cdCAqL1xyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0QmFzZSA9IGZ1bmN0aW9uKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXMsXHJcblx0XHRcdGdpdmVVcCA9IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdHNlbGYubm90aWZ5U3RhdGUoe3N0YXRlOiBzZWxmLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSwgZXJyb3I6IGVycn0pO1xyXG5cdFx0XHR9LFxyXG5cdFx0XHRjYW5kaWRhdGVIb3N0cyA9IHRoaXMuaHR0cEhvc3RzLnNsaWNlKCksXHJcblx0XHRcdGhvc3RBdHRlbXB0Q2IgPSBmdW5jdGlvbihmYXRhbCwgdHJhbnNwb3J0KSB7XHJcblx0XHRcdFx0aWYoY29ubmVjdENvdW50ICE9PSBzZWxmLmNvbm5lY3RDb3VudGVyKSB7XHJcblx0XHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKCF0cmFuc3BvcnQgJiYgIWZhdGFsKSB7XHJcblx0XHRcdFx0XHR0cnlGYWxsYmFja0hvc3RzKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggYmFzZSB0cmFuc3BvcnQgJyArIHRoaXMuYmFzZVRyYW5zcG9ydCk7XHJcblxyXG5cdFx0LyogZmlyc3QgdHJ5IHRvIGVzdGFibGlzaCBhIGNvbm5lY3Rpb24gd2l0aCB0aGUgcHJpb3JpdHkgaG9zdCB3aXRoIGh0dHAgdHJhbnNwb3J0ICovXHJcblx0XHR2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XHJcblx0XHRpZighaG9zdCkge1xyXG5cdFx0XHRnaXZlVXAobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBjb25uZWN0IChubyBhdmFpbGFibGUgaG9zdCknLCA4MDAwMywgNDA0KSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gaG9zdDtcclxuXHJcblx0XHQvKiB0aGlzIGlzIHdoYXQgd2UnbGwgYmUgZG9pbmcgaWYgdGhlIGF0dGVtcHQgZm9yIHRoZSBtYWluIGhvc3QgZmFpbHMgKi9cclxuXHRcdGZ1bmN0aW9uIHRyeUZhbGxiYWNrSG9zdHMoKSB7XHJcblx0XHRcdC8qIGlmIHRoZXJlIGFyZW4ndCBhbnkgZmFsbGJhY2sgaG9zdHMsIGZhaWwgKi9cclxuXHRcdFx0aWYoIWNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xyXG5cdFx0XHRcdGdpdmVVcChuZXcgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTBfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIGNvbm5lY3QgKGFuZCBubyBtb3JlIGZhbGxiYWNrIGhvc3RzIHRvIHRyeSknLCA4MDAwMywgNDA0KSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdC8qIGJlZm9yZSB0cnlpbmcgYW55IGZhbGxiYWNrIChvciBhbnkgcmVtYWluaW5nIGZhbGxiYWNrKSB3ZSBkZWNpZGUgaWZcclxuXHRcdFx0ICogdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIGFibHkgaG9zdCwgb3IgdGhlcmUgaXMgYSBnZW5lcmFsIGNvbm5lY3Rpdml0eVxyXG5cdFx0XHQgKiBwcm9ibGVtICovXHJcblx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkoZnVuY3Rpb24oZXJyLCBjb25uZWN0aXZpdHkpIHtcclxuXHRcdFx0XHRpZihjb25uZWN0Q291bnQgIT09IHNlbGYuY29ubmVjdENvdW50ZXIpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0Lyogd2Uga25vdyBlcnIgd29uJ3QgaGFwcGVuIGJ1dCBoYW5kbGUgaXQgaGVyZSBhbnl3YXkgKi9cclxuXHRcdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRcdGdpdmVVcChlcnIpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighY29ubmVjdGl2aXR5KSB7XHJcblx0XHRcdFx0XHQvKiB0aGUgaW50ZXJuZXQgaXNuJ3QgcmVhY2hhYmxlLCBzbyBkb24ndCB0cnkgdGhlIGZhbGxiYWNrIGhvc3RzICovXHJcblx0XHRcdFx0XHRnaXZlVXAobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1VuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKScsIDgwMDAzLCA0MDQpKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0LyogdGhlIG5ldHdvcmsgaXMgdGhlcmUsIHNvIHRoZXJlJ3MgYSBwcm9ibGVtIHdpdGggdGhlIG1haW4gaG9zdCwgb3JcclxuXHRcdFx0XHQgKiBpdHMgZG5zLiBUcnkgdGhlIGZhbGxiYWNrIGhvc3RzLiBXZSBjb3VsZCB0cnkgdGhlbSBzaW11bHRhbmVvdXNseSBidXRcclxuXHRcdFx0XHQgKiB0aGF0IHdvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGEgaHVnZSBzcGlrZSBpbiBsb2FkIG9uIHRoZSBsb2FkIGJhbGFuY2VyICovXHJcblx0XHRcdFx0dHJhbnNwb3J0UGFyYW1zLmhvc3QgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyclBvcFJhbmRvbUVsZW1lbnQoY2FuZGlkYXRlSG9zdHMpO1xyXG5cdFx0XHRcdHNlbGYudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIHNlbGYuYmFzZVRyYW5zcG9ydCwgaG9zdEF0dGVtcHRDYik7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgJiYgY2FuZGlkYXRlSG9zdHMubGVuZ3RoKSB7XHJcblx0XHRcdHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcclxuXHRcdFx0dHJ5RmFsbGJhY2tIb3N0cygpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy50cnlBVHJhbnNwb3J0KHRyYW5zcG9ydFBhcmFtcywgdGhpcy5iYXNlVHJhbnNwb3J0LCBob3N0QXR0ZW1wdENiKTtcclxuXHR9O1xyXG5cclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzID0gZnVuY3Rpb24oKSB7XHJcblx0XHQvKiByZXR1cm5zIHRoZSBzdWJzZXQgb2YgdXBncmFkZVRyYW5zcG9ydHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XHJcblx0XHQgKiB0cmFuc3BvcnQgaW4gdXBncmFkZVRyYW5zcG9ydHMgKGlmIGl0J3MgaW4gdGhlcmUgLSBpZiBub3QsIGN1cnJlbnRQb3NpdGlvblxyXG5cdFx0ICogd2lsbCBiZSAtMSwgc28gcmV0dXJuIHVwZ3JhZGVUcmFuc3BvcnRzLnNsaWNlKDApID09IHVwZ3JhZGVUcmFuc3BvcnRzICovXHJcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuc2hvcnROYW1lO1xyXG5cdFx0dmFyIGN1cnJlbnRQb3NpdGlvbiA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZih0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzLCBjdXJyZW50KTtcclxuXHRcdHJldHVybiB0aGlzLnVwZ3JhZGVUcmFuc3BvcnRzLnNsaWNlKGN1cnJlbnRQb3NpdGlvbiArIDEpO1xyXG5cdH07XHJcblxyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBncmFkZUlmTmVlZGVkID0gZnVuY3Rpb24odHJhbnNwb3J0UGFyYW1zKSB7XHJcblx0XHR2YXIgdXBncmFkZVBvc3NpYmlsaXRpZXMgPSB0aGlzLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzKCksXHJcblx0XHRcdHNlbGYgPSB0aGlzO1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnVwZ3JhZGVJZk5lZWRlZCgpJywgJ3VwZ3JhZGUgcG9zc2liaWxpdGllczogJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdCh1cGdyYWRlUG9zc2liaWxpdGllcykpO1xyXG5cclxuXHRcdGlmKCF1cGdyYWRlUG9zc2liaWxpdGllcy5sZW5ndGgpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyRm9yRWFjaCh1cGdyYWRlUG9zc2liaWxpdGllcywgZnVuY3Rpb24odXBncmFkZVRyYW5zcG9ydCkge1xyXG5cdFx0XHQvKiBOb3RlOiB0aGUgdHJhbnNwb3J0IG1heSBtdXRhdGUgdGhlIHBhcmFtcywgc28gZ2l2ZSBlYWNoIHRyYW5zcG9ydCBhIGZyZXNoIG9uZSAqL1xyXG5cdFx0XHR2YXIgdXBncmFkZVRyYW5zcG9ydFBhcmFtcyA9IHNlbGYuY3JlYXRlVHJhbnNwb3J0UGFyYW1zKHRyYW5zcG9ydFBhcmFtcy5ob3N0LCAndXBncmFkZScpO1xyXG5cdFx0XHRzZWxmLnRyeUFUcmFuc3BvcnQodXBncmFkZVRyYW5zcG9ydFBhcmFtcywgdXBncmFkZVRyYW5zcG9ydCwgbm9vcCk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlSW1wbCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ2Nsb3NpbmcgY29ubmVjdGlvbicpO1xyXG5cdFx0dGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcclxuXHRcdHRoaXMuc3RhcnRUcmFuc2l0aW9uVGltZXIodGhpcy5zdGF0ZXMuY2xvc2luZyk7XHJcblxyXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Nsb3NpbmcgcGVuZGluZyB0cmFuc3BvcnQ6ICcgKyB0cmFuc3BvcnQpO1xyXG5cdFx0XHRpZih0cmFuc3BvcnQpIHRyYW5zcG9ydC5jbG9zZSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24odHJhbnNwb3J0KSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcclxuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzcG9zZSgpO1xyXG5cdFx0fSk7XHJcblxyXG5cdFx0aWYodGhpcy5hY3RpdmVQcm90b2NvbCkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuY2xvc2VJbXBsKCknLCAnQ2xvc2luZyBhY3RpdmUgdHJhbnNwb3J0OiAnICsgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSk7XHJcblx0XHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuY2xvc2UoKTtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBJZiB0aGVyZSB3YXMgYW4gYWN0aXZlIHRyYW5zcG9ydCwgdGhpcyB3aWxsIHByb2JhYmx5IGJlXHJcblx0XHQgKiBwcmVlbXB0ZWQgYnkgdGhlIG5vdGlmeVN0YXRlIGNhbGwgaW4gZGVhY3RpdmF0ZVRyYW5zcG9ydCAqL1xyXG5cdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdjbG9zZWQnfSk7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQXV0aFVwZGF0ZWQgPSBmdW5jdGlvbih0b2tlbkRldGFpbHMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRzd2l0Y2godGhpcy5zdGF0ZS5zdGF0ZSkge1xyXG5cdFx0XHRjYXNlICdjb25uZWN0ZWQnOlxyXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLCAnU2VuZGluZyBBVVRIIG1lc3NhZ2Ugb24gYWN0aXZlIHRyYW5zcG9ydCcpO1xyXG5cdFx0XHRcdC8qIElmIHRoZXJlIGFyZSBhbnkgcHJvcG9zZWQvcGVuZGluZyB0cmFuc3BvcnRzIChlZyBhbiB1cGdyYWRlIHRoYXRcclxuXHRcdFx0XHQgKiBpc24ndCB5ZXQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uKSB0aGF0IGhhc24ndCB5ZXQgc3RhcnRlZCBzeW5jaW5nLFxyXG5cdFx0XHRcdCAqIGp1c3QgdG8gZ2V0IHJpZCBvZiB0aGVtICYgcmVzdGFydCB0aGUgdXBncmFkZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRvXHJcblx0XHRcdFx0ICogYXZvaWQgYSByYWNlIGNvbmRpdGlvbi4gKElmIGl0IGhhcyBzdGFydGVkIHN5bmNpbmcsIHRoZSBBVVRIIHdpbGwgYmVcclxuXHRcdFx0XHQgKiBxdWV1ZWQgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUsIHNvIGV2ZXJ5dGhpbmcncyBmaW5lKSAqL1xyXG5cdFx0XHRcdGlmKCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCB8fCB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5sZW5ndGgpICYmXHJcblx0XHRcdFx0XHRzZWxmLnN0YXRlICE9PSBzZWxmLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XHJcblx0XHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKC8qIGV4Y2VwdEFjdGl2ZTogKi90cnVlKTtcclxuXHRcdFx0XHRcdHZhciB0cmFuc3BvcnRQYXJhbXMgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnBhcmFtcztcclxuXHRcdFx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0XHRcdGlmKHNlbGYuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XHJcblx0XHRcdFx0XHRcdFx0c2VsZi51cGdyYWRlSWZOZWVkZWQodHJhbnNwb3J0UGFyYW1zKTtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0fSk7XHJcblx0XHRcdFx0fVxyXG5cclxuXHRcdFx0XHQvKiBEbyBhbnkgdHJhbnNwb3J0LXNwZWNpZmljIG5ldy10b2tlbiBhY3Rpb24gKi9cclxuXHRcdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzKTtcclxuXHJcblx0XHRcdFx0dmFyIGF1dGhNc2cgPSBfdHlwZXNfcHJvdG9jb2xtZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZnJvbVZhbHVlcyh7XHJcblx0XHRcdFx0XHRhY3Rpb246IGFjdGlvbnMuQVVUSCxcclxuXHRcdFx0XHRcdGF1dGg6IHtcclxuXHRcdFx0XHRcdFx0YWNjZXNzVG9rZW46IHRva2VuRGV0YWlscy50b2tlblxyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdHRoaXMuc2VuZChhdXRoTXNnKTtcclxuXHJcblx0XHRcdFx0LyogVGhlIGFuc3dlciB3aWxsIGNvbWUgYmFjayBhcyBlaXRoZXIgYSBjb25uZWN0aW9uZGV0YWlscyBldmVudFxyXG5cdFx0XHRcdCAqIChyZWFsdGltZSBzZW5kcyBhIENPTk5FQ1RFRCB0byBhc2tub3dsZWRnZSB0aGUgcmVhdXRoKSBvciBhXHJcblx0XHRcdFx0ICogc3RhdGVjaGFuZ2UgdG8gZmFpbGVkICovXHJcblx0XHRcdFx0dmFyIHN1Y2Nlc3NMaXN0ZW5lciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdFx0c2VsZi5vZmYoZmFpbHVyZUxpc3RlbmVyKTtcclxuXHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHR2YXIgZmFpbHVyZUxpc3RlbmVyID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcclxuXHRcdFx0XHRcdGlmKHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnKSB7XHJcblx0XHRcdFx0XHRcdHNlbGYub2ZmKHN1Y2Nlc3NMaXN0ZW5lcik7XHJcblx0XHRcdFx0XHRcdHNlbGYub2ZmKGZhaWx1cmVMaXN0ZW5lcik7XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBzZWxmLmdldFN0YXRlRXJyb3IoKSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHR0aGlzLm9uY2UoJ2Nvbm5lY3Rpb25kZXRhaWxzJywgc3VjY2Vzc0xpc3RlbmVyKTtcclxuXHRcdFx0XHR0aGlzLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBmYWlsdXJlTGlzdGVuZXIpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdFx0Y2FzZSAnY29ubmVjdGluZyc6XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsXHJcblx0XHRcdFx0XHQnQWJvcnRpbmcgY3VycmVudCBjb25uZWN0aW9uIGF0dGVtcHRzIGluIG9yZGVyIHRvIHN0YXJ0IGFnYWluIHdpdGggdGhlIG5ldyBhdXRoIGRldGFpbHMnKTtcclxuXHRcdFx0XHR0aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XHJcblx0XHRcdFx0LyogZmFsbHRocm91Z2ggdG8gYWRkIHN0YXRlY2hhbmdlIGxpc3RlbmVyICovXHJcblxyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLFxyXG5cdFx0XHRcdFx0J0Nvbm5lY3Rpb24gc3RhdGUgaXMgJyArIHRoaXMuc3RhdGUuc3RhdGUgKyAnOyB3YWl0aW5nIHVudGlsIGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkJyk7XHJcblx0XHRcdFx0dmFyIGxpc3RlbmVyID0gZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcclxuXHRcdFx0XHRcdHN3aXRjaChzdGF0ZUNoYW5nZS5jdXJyZW50KSB7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2Nvbm5lY3RlZCc6XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5vZmYobGlzdGVuZXIpO1xyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2Nsb3NlZCc6XHJcblx0XHRcdFx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XHJcblx0XHRcdFx0XHRcdFx0c2VsZi5vZmYobGlzdGVuZXIpO1xyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBzZWxmLmdldFN0YXRlRXJyb3IoKSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdFx0LyogaWdub3JlIHRpbGwgd2UgZ2V0IGVpdGhlciBjb25uZWN0ZWQgb3IgZmFpbGVkICovXHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0XHRzZWxmLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBsaXN0ZW5lcik7XHJcblx0XHRcdFx0aWYodGhpcy5zdGF0ZS5zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSB7XHJcblx0XHRcdFx0XHQvKiBjYW4gaGFwcGVuIGlmIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlIGJ1dCBubyB0cmFuc3BvcnQgd2FzIHBlbmRpbmdcclxuXHRcdFx0XHRcdCAqIHlldCwgc28gZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMgZGlkIG5vdCB0cmlnZ2VyIGEgZGlzY29ubmVjdGVkIHN0YXRlICovXHJcblx0XHRcdFx0XHRzZWxmLnN0YXJ0Q29ubmVjdCgpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRzZWxmLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xyXG5cdFx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMgPSBmdW5jdGlvbihleGNlcHRBY3RpdmUpIHtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgYWxsIHRyYW5zcG9ydHMnICsgKGV4Y2VwdEFjdGl2ZSA/ICcgZXhjZXB0IHRoZSBhY3RpdmUgdHJhbnNwb3J0JyA6ICcnKSk7XHJcblxyXG5cdFx0LyogVGhpcyB3aWxsIHByZXZlbnQgYW55IGNvbm5lY3Rpb24gcHJvY2VkdXJlIGluIGFuIGFzeW5jIHBhcnQgb2Ygb25lIG9mIGl0cyBlYXJseSBzdGFnZXMgZnJvbSBjb250aW51aW5nICovXHJcblx0XHR0aGlzLmNvbm5lY3RDb3VudGVyKys7XHJcblxyXG5cdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zYWZlQXJyRm9yRWFjaCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCBmdW5jdGlvbih0cmFuc3BvcnQpIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCknLCAnRGlzY29ubmVjdGluZyBwZW5kaW5nIHRyYW5zcG9ydDogJyArIHRyYW5zcG9ydCk7XHJcblx0XHRcdGlmKHRyYW5zcG9ydCkgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcclxuXHRcdH0pO1xyXG5cdFx0dGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xyXG5cclxuXHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uKHRyYW5zcG9ydCkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcclxuXHRcdFx0aWYodHJhbnNwb3J0KSB0cmFuc3BvcnQuZGlzcG9zZSgpO1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xyXG5cclxuXHRcdGlmKHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgIWV4Y2VwdEFjdGl2ZSkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6ICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpKTtcclxuXHRcdFx0dGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5kaXNjb25uZWN0KCk7XHJcblx0XHR9XHJcblx0XHQvKiBObyBuZWVkIHRvIG5vdGlmeSBzdGF0ZSBkaXNjb25uZWN0ZWQ7IGRpc2Nvbm5lY3RpbmcgdGhlIGFjdGl2ZSB0cmFuc3BvcnRcclxuXHRcdCAqIHdpbGwgaGF2ZSB0aGF0IGVmZmVjdCAqL1xyXG5cdH07XHJcblxyXG5cdC8qKioqKioqKioqKioqKioqKipcclxuXHQgKiBldmVudCBxdWV1ZWluZ1xyXG5cdCAqKioqKioqKioqKioqKioqKiovXHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24obXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xyXG5cdFx0Y2FsbGJhY2sgPSBjYWxsYmFjayB8fCBub29wO1xyXG5cdFx0dmFyIHN0YXRlID0gdGhpcy5zdGF0ZTtcclxuXHJcblx0XHRpZihzdGF0ZS5zZW5kRXZlbnRzKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAnc2VuZGluZyBldmVudCcpO1xyXG5cdFx0XHR0aGlzLnNlbmRJbXBsKG5ldyBQZW5kaW5nTWVzc2FnZShtc2csIGNhbGxiYWNrKSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHZhciBzaG91bGRRdWV1ZSA9IChxdWV1ZUV2ZW50ICYmIHN0YXRlLnF1ZXVlRXZlbnRzKSB8fCBzdGF0ZS5mb3JjZVF1ZXVlRXZlbnRzO1xyXG5cdFx0aWYoIXNob3VsZFF1ZXVlKSB7XHJcblx0XHRcdHZhciBlcnIgPSAncmVqZWN0aW5nIGV2ZW50LCBxdWV1ZUV2ZW50IHdhcyAnICsgcXVldWVFdmVudCArICcsIHN0YXRlIHdhcyAnICsgc3RhdGUuc3RhdGU7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCBlcnIpO1xyXG5cdFx0XHRjYWxsYmFjayh0aGlzLmVycm9yUmVhc29uIHx8IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKGVyciwgOTAwMDAsIDQwMCkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRpZihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zaG91bGRMb2coX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPKSkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgJ3F1ZXVlaW5nIG1zZzsgJyArIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zdHJpbmdpZnkobXNnKSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLnF1ZXVlKG1zZywgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kSW1wbCA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlKSB7XHJcblx0XHR2YXIgbXNnID0gcGVuZGluZ01lc3NhZ2UubWVzc2FnZTtcclxuXHRcdC8qIElmIGhhdmUgYWxyZWFkeSBhdHRlbXB0ZWQgdG8gc2VuZCB0aGlzLCByZXNlbmQgd2l0aCB0aGUgc2FtZSBtc2dTZXJpYWwsXHJcblx0XHQgKiBzbyBBYmx5IGNhbiBkZWR1cCBpZiB0aGUgcHJldmlvdXMgc2VuZCBzdWNjZWVkZWQgKi9cclxuXHRcdGlmKHBlbmRpbmdNZXNzYWdlLmFja1JlcXVpcmVkICYmICFwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkKSB7XHJcblx0XHRcdG1zZy5tc2dTZXJpYWwgPSB0aGlzLm1zZ1NlcmlhbCsrO1xyXG5cdFx0XHR0aGlzLnNldFJlY292ZXJ5S2V5KCk7XHJcblx0XHR9XHJcblx0XHR0cnkge1xyXG5cdFx0XHR0aGlzLmFjdGl2ZVByb3RvY29sLnNlbmQocGVuZGluZ01lc3NhZ2UpO1xyXG5cdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5zZW5kSW1wbCgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGluIHRyYW5zcG9ydC5zZW5kKCk6ICcgKyBlLnN0YWNrKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBidW5kbGVXaXRoKGRlc3QsIHNyYywgbWF4U2l6ZSkge1xyXG5cdFx0dmFyIGFjdGlvbjtcclxuXHRcdGlmKGRlc3QuY2hhbm5lbCAhPT0gc3JjLmNoYW5uZWwpIHtcclxuXHRcdFx0LyogUlRMNmQzICovXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGlmKChhY3Rpb24gPSBkZXN0LmFjdGlvbikgIT09IGFjdGlvbnMuUFJFU0VOQ0UgJiYgYWN0aW9uICE9PSBhY3Rpb25zLk1FU1NBR0UpIHtcclxuXHRcdFx0LyogUlRMNmQgLSBjYW4gb25seSBidW5kbGUgbWVzc2FnZXMgb3IgcHJlc2VuY2UgKi9cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0aWYoYWN0aW9uICE9PSBzcmMuYWN0aW9uKSB7XHJcblx0XHRcdC8qIFJUTDZkNCAqL1xyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XHJcblx0XHR9XHJcblx0XHR2YXIga2luZCA9IChhY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpID8gJ3ByZXNlbmNlJyA6ICdtZXNzYWdlcycsXHJcblx0XHRcdHByb3Bvc2VkID0gZGVzdFtraW5kXS5jb25jYXQoc3JjW2tpbmRdKSxcclxuXHRcdFx0c2l6ZSA9IF90eXBlc19tZXNzYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldE1lc3NhZ2VzU2l6ZShwcm9wb3NlZCk7XHJcblx0XHRpZihzaXplID4gbWF4U2l6ZSkge1xyXG5cdFx0XHQvKiBSVEw2ZDEgKi9cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0aWYoIV91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYWxsU2FtZShwcm9wb3NlZCwgJ2NsaWVudElkJykpIHtcclxuXHRcdFx0LyogUlRMNmQyICovXHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHRcdGlmKCFfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFyckV2ZXJ5KHByb3Bvc2VkLCBmdW5jdGlvbihtc2cpIHtcclxuXHRcdFx0cmV0dXJuICFtc2cuaWQ7XHJcblx0XHR9KSkge1xyXG5cdFx0XHQvKiBSVEw2ZDcgKi9cclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0Lyogd2UncmUgZ29vZCB0byBnbyEgKi9cclxuXHRcdGRlc3Rba2luZF0gPSBwcm9wb3NlZDtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uKG1zZywgY2FsbGJhY2spIHtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5xdWV1ZSgpJywgJ3F1ZXVlaW5nIGV2ZW50Jyk7XHJcblx0XHR2YXIgbGFzdFF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMubGFzdCgpO1xyXG5cdFx0dmFyIG1heFNpemUgPSB0aGlzLm9wdGlvbnMubWF4TWVzc2FnZVNpemU7XHJcblx0XHQvKiBJZiBoYXZlIGFscmVhZHkgYXR0ZW1wdGVkIHRvIHNlbmQgYSBtZXNzYWdlLCBkb24ndCBtZXJnZSBtb3JlIG1lc3NhZ2VzXHJcblx0XHQgKiBpbnRvIGl0LCBhcyBpZiB0aGUgcHJldmlvdXMgc2VuZCBhY3R1YWxseSBzdWNjZWVkZWQgYW5kIHJlYWx0aW1lIGlnbm9yZXNcclxuXHRcdCAqIHRoZSBkdXAsIHRoZXknbGwgYmUgbG9zdCAqL1xyXG5cdFx0aWYobGFzdFF1ZXVlZCAmJiAhbGFzdFF1ZXVlZC5zZW5kQXR0ZW1wdGVkICYmIGJ1bmRsZVdpdGgobGFzdFF1ZXVlZC5tZXNzYWdlLCBtc2csIG1heFNpemUpKSB7XHJcblx0XHRcdGlmKCFsYXN0UXVldWVkLm1lcmdlZCkge1xyXG5cdFx0XHRcdGxhc3RRdWV1ZWQuY2FsbGJhY2sgPSBPYmplY3QoX3V0aWxfbXVsdGljYXN0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE0X19bLyogZGVmYXVsdCAqLyBcImFcIl0pKFtsYXN0UXVldWVkLmNhbGxiYWNrXSk7XHJcblx0XHRcdFx0bGFzdFF1ZXVlZC5tZXJnZWQgPSB0cnVlO1xyXG5cdFx0XHR9XHJcblx0XHRcdGxhc3RRdWV1ZWQuY2FsbGJhY2sucHVzaChjYWxsYmFjayk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IFBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZFF1ZXVlZE1lc3NhZ2VzKCknLCAnc2VuZGluZyAnICsgdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpICsgJyBxdWV1ZWQgbWVzc2FnZXMnKTtcclxuXHRcdHZhciBwZW5kaW5nTWVzc2FnZTtcclxuXHRcdHdoaWxlKHBlbmRpbmdNZXNzYWdlID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5zaGlmdCgpKVxyXG5cdFx0XHR0aGlzLnNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKTtcclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucXVldWVQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbihwZW5kaW5nTWVzc2FnZXMpIHtcclxuXHRcdGlmKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5xdWV1ZVBlbmRpbmdNZXNzYWdlcygpJywgJ3F1ZXVlaW5nICcgKyBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoICsgJyBwZW5kaW5nIG1lc3NhZ2VzJyk7XHJcblx0XHRcdHRoaXMucXVldWVkTWVzc2FnZXMucHJlcGVuZChwZW5kaW5nTWVzc2FnZXMpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5mYWlsUXVldWVkTWVzc2FnZXMgPSBmdW5jdGlvbihlcnIpIHtcclxuXHRcdHZhciBudW1RdWV1ZWQgPSB0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvdW50KCk7XHJcblx0XHRpZihudW1RdWV1ZWQgPiAwKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5mYWlsUXVldWVkTWVzc2FnZXMoKScsICdmYWlsaW5nICcgKyBudW1RdWV1ZWQgKyAnIHF1ZXVlZCBtZXNzYWdlcywgZXJyID0gJyArIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5zcGVjdEVycm9yKGVycikpO1xyXG5cdFx0XHR0aGlzLnF1ZXVlZE1lc3NhZ2VzLmNvbXBsZXRlQWxsTWVzc2FnZXMoZXJyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uKG1lc3NhZ2UsIHRyYW5zcG9ydCkge1xyXG5cdFx0dmFyIG9uQWN0aXZlVHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0cmFuc3BvcnQgPT09IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksXHJcblx0XHRcdG9uVXBncmFkZVRyYW5zcG9ydCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4odGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KSAmJiB0aGlzLnN0YXRlID09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcsXHJcblx0XHRcdG5vdENvbnRyb2xNc2cgPSBtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5NRVNTQUdFIHx8IG1lc3NhZ2UuYWN0aW9uID09PSBhY3Rpb25zLlBSRVNFTkNFO1xyXG5cclxuXHRcdC8qIEFzIHRoZSBsaWIgbm93IGhhcyBhIHBlcmlvZCB3aGVyZSB0aGUgdXBncmFkZSB0cmFuc3BvcnQgaXMgc3luY2VkIGJ1dFxyXG5cdFx0ICogYmVmb3JlIGl0J3MgYmVjb21lIGFjdGl2ZSAod2hpbGUgd2FpdGluZyBmb3IgdGhlIG9sZCBvbmUgdG8gYmVjb21lXHJcblx0XHQgKiBpZGxlKSwgbWVzc2FnZSBjYW4gdmFsaWRseSBhcnJpdmUgb24gaXQgZXZlbiB0aG91Z2ggaXQgaXNuJ3QgYWN0aXZlICovXHJcblx0XHRpZihvbkFjdGl2ZVRyYW5zcG9ydCB8fCBvblVwZ3JhZGVUcmFuc3BvcnQpIHtcclxuXHRcdFx0aWYobm90Q29udHJvbE1zZykge1xyXG5cdFx0XHRcdHZhciBzdXBwcmVzc2VkID0gdGhpcy5zZXRDb25uZWN0aW9uU2VyaWFsKG1lc3NhZ2UpO1xyXG5cdFx0XHRcdGlmKHN1cHByZXNzZWQpIHtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdFx0aWYoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRHVwbGljYXRlKG1lc3NhZ2UsIHRoaXMubW9zdFJlY2VudE1zZykpIHtcclxuXHRcdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgbWVzc2FnZSB3aXRoIGRpZmZlcmVudCBjb25uZWN0aW9uU2VyaWFsLCBidXQgc2FtZSBtZXNzYWdlIGlkIGFzIGEgcHJldmlvdXM7IGRpc2NhcmRpbmc7IGlkID0gJyArIG1lc3NhZ2UuaWQpO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHR0aGlzLm1vc3RSZWNlbnRNc2cgPSBtZXNzYWdlO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIE1lc3NhZ2UgY2FtZSBpbiBvbiBhIGRlZnVuY3QgdHJhbnNwb3J0LiBBbGxvdyBvbmx5IGFja3MsIG5hY2tzLCAmIGVycm9ycyBmb3Igb3V0c3RhbmRpbmdcclxuXHRcdFx0Ly8gbWVzc2FnZXMsICBubyBuZXcgbWVzc2FnZXMgKGFzIHN5bmMgaGFzIGJlZW4gc2VudCBvbiBuZXcgdHJhbnNwb3J0IHNvIG5ldyBtZXNzYWdlcyB3aWxsXHJcblx0XHRcdC8vIGJlIHJlc2VudCB0aGVyZSwgb3IgY29ubmVjdGlvbiBoYXMgYmVlbiBjbG9zZWQgc28gZG9uJ3Qgd2FudCBuZXcgbWVzc2FnZXMpXHJcblx0XHRcdGlmKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW5kZXhPZihbYWN0aW9ucy5BQ0ssIGFjdGlvbnMuTkFDSywgYWN0aW9ucy5FUlJPUl0sIG1lc3NhZ2UuYWN0aW9uKSA+IC0xKSB7XHJcblx0XHRcdFx0dGhpcy5yZWFsdGltZS5jaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgbWVzc2FnZSAnICsgSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkgKyAnb24gZGVmdW5jdCB0cmFuc3BvcnQ7IGRpc2NhcmRpbmcnKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24odHJhbnNwb3J0LCBjYWxsYmFjaykge1xyXG5cdFx0LyogaWYgdHJhbnNwb3J0IGlzIHNwZWNpZmllZCwgdHJ5IHRoYXQgKi9cclxuXHRcdGlmKHRyYW5zcG9ydCkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIucGluZygpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xyXG5cclxuXHRcdFx0dmFyIG9uVGltZW91dCA9IGZ1bmN0aW9uICgpIHtcclxuXHRcdFx0XHR0cmFuc3BvcnQub2ZmKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XHJcblx0XHRcdFx0Y2FsbGJhY2sobmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1RpbWVvdXQgd2FpdGluZyBmb3IgaGVhcnRiZWF0IHJlc3BvbnNlJywgNTAwMDAsIDUwMCkpO1xyXG5cdFx0XHR9O1xyXG5cclxuXHRcdFx0dmFyIHBpbmdTdGFydCA9IF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubm93KCksXHJcblx0XHRcdFx0aWQgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNoZWFwUmFuZFN0cigpO1xyXG5cclxuXHRcdFx0dmFyIG9uSGVhcnRiZWF0ID0gZnVuY3Rpb24gKHJlc3BvbnNlSWQpIHtcclxuXHRcdFx0XHRpZihyZXNwb25zZUlkID09PSBpZCkge1xyXG5cdFx0XHRcdFx0dHJhbnNwb3J0Lm9mZignaGVhcnRiZWF0Jywgb25IZWFydGJlYXQpO1xyXG5cdFx0XHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHRcdFx0XHRcdHZhciByZXNwb25zZVRpbWUgPSBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5vdygpIC0gcGluZ1N0YXJ0O1xyXG5cdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCwgcmVzcG9uc2VUaW1lKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR2YXIgdGltZXIgPSBzZXRUaW1lb3V0KG9uVGltZW91dCwgdGhpcy5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xyXG5cclxuXHRcdFx0dHJhbnNwb3J0Lm9uKCdoZWFydGJlYXQnLCBvbkhlYXJ0YmVhdCk7XHJcblx0XHRcdHRyYW5zcG9ydC5waW5nKGlkKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qIGlmIHdlJ3JlIG5vdCBjb25uZWN0ZWQsIGRvbid0IGF0dGVtcHQgKi9cclxuXHRcdGlmKHRoaXMuc3RhdGUuc3RhdGUgIT09ICdjb25uZWN0ZWQnKSB7XHJcblx0XHRcdGNhbGxiYWNrKG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdVbmFibGUgdG8gcGluZyBzZXJ2aWNlOyBub3QgY29ubmVjdGVkJywgNDAwMDAsIDQwMCkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0Lyogbm8gdHJhbnNwb3J0IHdhcyBzcGVjaWZpZWQsIHNvIHVzZSB0aGUgY3VycmVudCAoY29ubmVjdGVkKSBvbmVcclxuXHRcdCAqIGJ1dCBlbnN1cmUgdGhhdCB3ZSByZXRyeSBpZiB0aGUgdHJhbnNwb3J0IGlzIHN1cGVyc2VkZWQgYmVmb3JlIHdlIGNvbXBsZXRlICovXHJcblx0XHR2YXIgY29tcGxldGVkID0gZmFsc2UsIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRcdHZhciBvblBpbmdDb21wbGV0ZSA9IGZ1bmN0aW9uKGVyciwgcmVzcG9uc2VUaW1lKSB7XHJcblx0XHRcdHNlbGYub2ZmKCd0cmFuc3BvcnQuYWN0aXZlJywgb25UcmFuc3BvcnRBY3RpdmUpO1xyXG5cdFx0XHRpZighY29tcGxldGVkKSB7XHJcblx0XHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHJlc3BvbnNlVGltZSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dmFyIG9uVHJhbnNwb3J0QWN0aXZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdGlmKCFjb21wbGV0ZWQpIHtcclxuXHRcdFx0XHQvKiBlbnN1cmUgdGhhdCBubyBjYWxsYmFjayBoYXBwZW5zIGZvciB0aGUgY3VycmVudGx5IG91dHN0YW5kaW5nIG9wZXJhdGlvbiAqL1xyXG5cdFx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XHJcblx0XHRcdFx0LyogcmVwZWF0IGJ1dCBwaWNraW5nIHVwIHRoZSBuZXcgdHJhbnNwb3J0ICovXHJcblx0XHRcdFx0X3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHNlbGYucGluZyhudWxsLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH1cclxuXHRcdH07XHJcblxyXG5cdFx0dGhpcy5vbigndHJhbnNwb3J0LmFjdGl2ZScsIG9uVHJhbnNwb3J0QWN0aXZlKTtcclxuXHRcdHRoaXMucGluZyh0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLCBvblBpbmdDb21wbGV0ZSk7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oZXJyb3IpIHtcclxuXHRcdHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZmFpbChlcnJvcik7XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnJlZ2lzdGVyUHJvcG9zZWRUcmFuc3BvcnQgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcclxuXHRcdHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzLnB1c2godHJhbnNwb3J0KTtcclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSB8fCAoaGF2ZVdlYlN0b3JhZ2UgJiYgcGxhdGZvcm1fd2Vic3RvcmFnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5nZXQodHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpKTtcclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdFRyYW5zcG9ydFByZWZlcmVuY2UgPSBmdW5jdGlvbih0cmFuc3BvcnQpIHtcclxuXHRcdGlmKF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJySW4oX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS51cGdyYWRlVHJhbnNwb3J0cywgdHJhbnNwb3J0LnNob3J0TmFtZSkpIHtcclxuXHRcdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gdHJhbnNwb3J0LnNob3J0TmFtZTtcclxuXHRcdFx0aWYoaGF2ZVdlYlN0b3JhZ2UpIHtcclxuXHRcdFx0XHRwbGF0Zm9ybV93ZWJzdG9yYWdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnNldCh0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSwgdHJhbnNwb3J0LnNob3J0TmFtZSk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcclxuXHRcdGlmKGhhdmVXZWJTdG9yYWdlKSB7XHJcblx0XHRcdHBsYXRmb3JtX3dlYnN0b3JhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzE2X19bLyogZGVmYXVsdCAqLyBcImFcIl0ucmVtb3ZlKHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdHMsIHNvIGltcGxlbWVudHMgUlNBNGMxLFxyXG5cdCAqIFJTQTRjMiwgYW5kIFJTQTRkLiBJbiBwYXJ0aWN1bGFyIGl0IGlzIG5vdCBpbnZva2VkIGZvclxyXG5cdCAqIHNlcnZlcnNpZGUtdHJpZ2dlcmVkIHJlYXV0aHMgb3IgbWFudWFsIHJlYXV0aHMsIHNvIFJTQTRjMyBkb2VzIG5vdCBhcHBseSAqL1xyXG5cdENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSA9IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0aWYoZXJyLmNvZGUgPT09IDQwMTcxKSB7XHJcblx0XHRcdC8qIE5vIHdheSB0byByZWF1dGggKi9cclxuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogZXJyfSk7XHJcblx0XHR9IGVsc2UgaWYoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xyXG5cdFx0XHR2YXIgbXNnID0gJ0NsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJldHVybmVkIDQwMzsgZmFpbGluZyB0aGUgY29ubmVjdGlvbic7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSgpJywgbXNnKTtcclxuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAxOSwgNDAzLCBlcnIpfSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbXNnID0gJ0NsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJlcXVlc3QgZmFpbGVkJztcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplJywgbXNnKTtcclxuXHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSh7c3RhdGU6IHRoaXMuc3RhdGUuZmFpbFN0YXRlLCBlcnJvcjogbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEwX19bLyogZGVmYXVsdCAqLyBcImFcIl0obXNnLCA4MDAxOSwgNDAxLCBlcnIpfSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Q29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUgPSBmdW5jdGlvbihjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KSB7XHJcblx0XHRpZighY29ubmVjdGlvbkRldGFpbHMpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IGNvbm5lY3Rpb25EZXRhaWxzO1xyXG5cdFx0aWYoY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemUpIHtcclxuXHRcdFx0dGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplID0gY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemU7XHJcblx0XHR9XHJcblx0XHR2YXIgY2xpZW50SWQgPSBjb25uZWN0aW9uRGV0YWlscy5jbGllbnRJZDtcclxuXHRcdGlmKGNsaWVudElkKSB7XHJcblx0XHRcdHZhciBlcnIgPSB0aGlzLnJlYWx0aW1lLmF1dGguX3VuY2hlY2tlZFNldENsaWVudElkKGNsaWVudElkKTtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQ29ubmVjdGlvbkRldGFpbHNVcGRhdGUoKScsIGVyci5tZXNzYWdlKTtcclxuXHRcdFx0XHQvKiBFcnJvcnMgc2V0dGluZyB0aGUgY2xpZW50SWQgYXJlIGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXHJcblx0XHRcdFx0dHJhbnNwb3J0LmZhaWwoZXJyKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHZhciBjb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uRGV0YWlscy5jb25uZWN0aW9uU3RhdGVUdGw7XHJcblx0XHRpZihjb25uZWN0aW9uU3RhdGVUdGwpIHtcclxuXHRcdFx0dGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSBjb25uZWN0aW9uU3RhdGVUdGw7XHJcblx0XHR9XHJcblx0XHR0aGlzLm1heElkbGVJbnRlcnZhbCA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcclxuXHRcdHRoaXMuZW1pdCgnY29ubmVjdGlvbmRldGFpbHMnLCBjb25uZWN0aW9uRGV0YWlscyk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIENvbm5lY3Rpb25NYW5hZ2VyO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChDb25uZWN0aW9uTWFuYWdlcik7XHJcblxyXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi99LmNhbGwodGhpcywgX193ZWJwYWNrX3JlcXVpcmVfXygxNykpKVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5cclxuXHJcblxyXG52YXIgTWVzc2FnZVF1ZXVlID0gKGZ1bmN0aW9uKCkge1xyXG5cdGZ1bmN0aW9uIE1lc3NhZ2VRdWV1ZSgpIHtcclxuXHRcdF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLm1lc3NhZ2VzID0gW107XHJcblx0fVxyXG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoTWVzc2FnZVF1ZXVlLCBfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXSk7XHJcblxyXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY291bnQgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzLmxlbmd0aDtcclxuXHR9O1xyXG5cclxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHR0aGlzLm1lc3NhZ2VzLnB1c2gobWVzc2FnZSk7XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWVzc2FnZXMuc2hpZnQoKTtcclxuXHR9O1xyXG5cclxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmxhc3QgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VzW3RoaXMubWVzc2FnZXMubGVuZ3RoIC0gMV07XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3B5QWxsID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlcy5zbGljZSgpO1xyXG5cdH07XHJcblxyXG5cdE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcclxuXHRcdHRoaXMubWVzc2FnZXMucHVzaC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wcmVwZW5kID0gZnVuY3Rpb24obWVzc2FnZXMpIHtcclxuXHRcdHRoaXMubWVzc2FnZXMudW5zaGlmdC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZU1lc3NhZ2VzID0gZnVuY3Rpb24oc2VyaWFsLCBjb3VudCwgZXJyKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnTWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQpO1xyXG5cdFx0ZXJyID0gZXJyIHx8IG51bGw7XHJcblx0XHR2YXIgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xyXG5cdFx0dmFyIGZpcnN0ID0gbWVzc2FnZXNbMF07XHJcblx0XHRpZihmaXJzdCkge1xyXG5cdFx0XHR2YXIgc3RhcnRTZXJpYWwgPSBmaXJzdC5tZXNzYWdlLm1zZ1NlcmlhbDtcclxuXHRcdFx0dmFyIGVuZFNlcmlhbCA9IHNlcmlhbCArIGNvdW50OyAvKiB0aGUgc2VyaWFsIG9mIHRoZSBmaXJzdCBtZXNzYWdlIHRoYXQgaXMgKm5vdCogdGhlIHN1YmplY3Qgb2YgdGhpcyBjYWxsICovXHJcblx0XHRcdGlmKGVuZFNlcmlhbCA+IHN0YXJ0U2VyaWFsKSB7XHJcblx0XHRcdFx0dmFyIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCwgKGVuZFNlcmlhbCAtIHN0YXJ0U2VyaWFsKSk7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNvbXBsZXRlTWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRcdGNvbXBsZXRlTWVzc2FnZXNbaV0uY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdFx0aWYobWVzc2FnZXMubGVuZ3RoID09IDApXHJcblx0XHRcdFx0dGhpcy5lbWl0KCdpZGxlJyk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0TWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZUFsbE1lc3NhZ2VzID0gZnVuY3Rpb24oZXJyKSB7XHJcblx0XHR0aGlzLmNvbXBsZXRlTWVzc2FnZXMoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTnVtYmVyLk1BWF9WQUxVRSwgZXJyKTtcclxuXHR9O1xyXG5cclxuXHRNZXNzYWdlUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnTWVzc2FnZVF1ZXVlLmNsZWFyKCknLCAnY2xlYXJpbmcgJyArIHRoaXMubWVzc2FnZXMubGVuZ3RoICsgJyBtZXNzYWdlcycpO1xyXG5cdFx0dGhpcy5tZXNzYWdlcyA9IFtdO1xyXG5cdFx0dGhpcy5lbWl0KCdpZGxlJyk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIE1lc3NhZ2VRdWV1ZTtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoTWVzc2FnZVF1ZXVlKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMjcgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHsvKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDYpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fYnVmZmVydXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kb21ldmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzNSk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgWEhSUmVxdWVzdCA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcblx0dmFyIGlkQ291bnRlciA9IDA7XHJcblx0dmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xyXG5cclxuXHR2YXIgUkVRX1NFTkQgPSAwLFxyXG5cdFx0UkVRX1JFQ1YgPSAxLFxyXG5cdFx0UkVRX1JFQ1ZfUE9MTCA9IDIsXHJcblx0XHRSRVFfUkVDVl9TVFJFQU0gPSAzO1xyXG5cclxuXHRmdW5jdGlvbiBjbGVhclBlbmRpbmdSZXF1ZXN0cygpIHtcclxuXHRcdGZvcih2YXIgaWQgaW4gcGVuZGluZ1JlcXVlc3RzKVxyXG5cdFx0XHRwZW5kaW5nUmVxdWVzdHNbaWRdLmRpc3Bvc2UoKTtcclxuXHR9XHJcblxyXG5cdHZhciBpc0lFID0gdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLlhEb21haW5SZXF1ZXN0O1xyXG5cclxuXHRmdW5jdGlvbiBpZVZlcnNpb24oKSB7XHJcblx0XHR2YXIgbWF0Y2ggPSBuYXZpZ2F0b3IudXNlckFnZW50LnRvU3RyaW5nKCkubWF0Y2goL01TSUVcXHMoW1xcZC5dKykvKTtcclxuXHRcdHJldHVybiBtYXRjaCAmJiBOdW1iZXIobWF0Y2hbMV0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbmVlZEpzb25FbnZlbG9wZSgpIHtcclxuXHRcdC8qIElFIDEwIHhociBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MzIwMzM5ICovXHJcblx0XHR2YXIgdmVyc2lvbjtcclxuXHRcdHJldHVybiBpc0lFICYmICh2ZXJzaW9uID0gaWVWZXJzaW9uKCkpICYmIHZlcnNpb24gPT09IDEwO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0SGVhZGVyKHhociwgaGVhZGVyKSB7XHJcblx0XHRyZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xyXG5cdH1cclxuXHJcblx0LyogU2FmYXJpIG15c3RlcmlvdXNseSByZXR1cm5zICdJZGVudGl0eScgZm9yIHRyYW5zZmVyLWVuY29kaW5nIHdoZW4gaW4gZmFjdFxyXG5cdCAqIGl0IGlzICdjaHVua2VkJy4gU28gaW5zdGVhZCwgZGVjaWRlIHRoYXQgaXQgaXMgY2h1bmtlZCB3aGVuXHJcblx0ICogdHJhbnNmZXItZW5jb2RpbmcgaXMgcHJlc2VudCBvciBjb250ZW50LWxlbmd0aCBpcyBhYnNlbnQuICAoJ29yJyBiZWNhdXNlXHJcblx0ICogd2hlbiB1c2luZyBodHRwMiBzdHJlYW1pbmcsIHRoZXJlJ3Mgbm8gdHJhbnNmZXItZW5jb2RpbmcgaGVhZGVyLCBidXQgY2FuXHJcblx0ICogc3RpbGwgZGVkdWNlIHN0cmVhbWluZyBmcm9tIGxhY2sgb2YgY29udGVudC1sZW5ndGgpICovXHJcblx0ZnVuY3Rpb24gaXNFbmNvZGluZ0NodW5rZWQoeGhyKSB7XHJcblx0XHRyZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyXHJcblx0XHRcdCYmICh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJylcclxuXHRcdFx0fHwgIXhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC1sZW5ndGgnKSk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKSB7XHJcblx0XHR2YXIgaGVhZGVyUGFpcnMgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udHJpbSh4aHIuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpLnNwbGl0KCdcXHJcXG4nKSxcclxuXHRcdFx0aGVhZGVycyA9IHt9O1xyXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBoZWFkZXJQYWlycy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgcGFydHMgPSBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uYXJyTWFwKGhlYWRlclBhaXJzW2ldLnNwbGl0KCc6JyksIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50cmltKTtcclxuXHRcdFx0aGVhZGVyc1twYXJ0c1swXS50b0xvd2VyQ2FzZSgpXSA9IHBhcnRzWzFdO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGhlYWRlcnM7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBYSFJSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xyXG5cdFx0X2NvbW1vbl9saWJfdXRpbF9ldmVudGVtaXR0ZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMpO1xyXG5cdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xyXG5cdFx0cGFyYW1zLnJuZCA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVhcFJhbmRTdHIoKTtcclxuXHRcdGlmKG5lZWRKc29uRW52ZWxvcGUoKSAmJiAhcGFyYW1zLmVudmVsb3BlKVxyXG5cdFx0XHRwYXJhbXMuZW52ZWxvcGUgPSAnanNvbic7XHJcblx0XHR0aGlzLnVyaSA9IHVyaSArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XHJcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xyXG5cdFx0dGhpcy5ib2R5ID0gYm9keTtcclxuXHRcdHRoaXMubWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiAoX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzRW1wdHlBcmcoYm9keSkgPyAnR0VUJyA6ICdQT1NUJyk7XHJcblx0XHR0aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XHJcblx0XHR0aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XHJcblx0XHR0aGlzLnRpbWVkT3V0ID0gZmFsc2U7XHJcblx0XHR0aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xyXG5cdFx0cGVuZGluZ1JlcXVlc3RzW3RoaXMuaWQgPSBTdHJpbmcoKytpZENvdW50ZXIpXSA9IHRoaXM7XHJcblx0fVxyXG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhYSFJSZXF1ZXN0LCBfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcclxuXHJcblx0dmFyIGNyZWF0ZVJlcXVlc3QgPSBYSFJSZXF1ZXN0LmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcclxuXHRcdC8qIFhIUiByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXHJcblx0XHQgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxyXG5cdFx0ICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cclxuXHRcdHRpbWVvdXRzID0gdGltZW91dHMgfHwgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRJTUVPVVRTO1xyXG5cdFx0cmV0dXJuIG5ldyBYSFJSZXF1ZXN0KHVyaSwgaGVhZGVycywgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpO1xyXG5cdH07XHJcblxyXG5cdFhIUlJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xyXG5cdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XHJcblx0XHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcclxuXHRcdFx0aWYoIWVyciAmJiBib2R5KSB7XHJcblx0XHRcdFx0dGhpcy5lbWl0KCdkYXRhJywgYm9keSk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xyXG5cdFx0XHR0aGlzLmRpc3Bvc2UoKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRYSFJSZXF1ZXN0LnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dGhpcy5kaXNwb3NlKCk7XHJcblx0fTtcclxuXHJcblx0WEhSUmVxdWVzdC5wcm90b3R5cGUuZXhlYyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHRpbWVvdXQgPSAodGhpcy5yZXF1ZXN0TW9kZSA9PSBSRVFfU0VORCkgPyB0aGlzLnRpbWVvdXRzLmh0dHBSZXF1ZXN0VGltZW91dCA6IHRoaXMudGltZW91dHMucmVjdlRpbWVvdXQsXHJcblx0XHRcdHNlbGYgPSB0aGlzLFxyXG5cdFx0XHR0aW1lciA9IHRoaXMudGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHNlbGYudGltZWRPdXQgPSB0cnVlO1xyXG5cdFx0XHRcdHhoci5hYm9ydCgpO1xyXG5cdFx0XHR9LCB0aW1lb3V0KSxcclxuXHRcdFx0Ym9keSA9IHRoaXMuYm9keSxcclxuXHRcdFx0bWV0aG9kID0gdGhpcy5tZXRob2QsXHJcblx0XHRcdGhlYWRlcnMgPSB0aGlzLmhlYWRlcnMsXHJcblx0XHRcdHhociA9IHRoaXMueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXHJcblx0XHRcdGFjY2VwdCA9IGhlYWRlcnNbJ2FjY2VwdCddLFxyXG5cdFx0XHRyZXNwb25zZVR5cGUgPSAndGV4dCc7XHJcblxyXG5cdFx0aWYoIWFjY2VwdCkge1xyXG5cdFx0XHRoZWFkZXJzWydhY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcclxuXHRcdH0gZWxzZSBpZihhY2NlcHQuaW5kZXhPZignYXBwbGljYXRpb24veC1tc2dwYWNrJykgPT09IDApIHtcclxuXHRcdFx0cmVzcG9uc2VUeXBlID0gJ2FycmF5YnVmZmVyJztcclxuXHRcdH1cclxuXHJcblx0XHRpZihib2R5KSB7XHJcblx0XHRcdHZhciBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8IChoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJyk7XHJcblx0XHRcdGlmKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xICYmIHR5cGVvZihib2R5KSAhPSAnc3RyaW5nJylcclxuXHRcdFx0XHRib2R5ID0gSlNPTi5zdHJpbmdpZnkoYm9keSk7XHJcblx0XHR9XHJcblxyXG5cdFx0eGhyLm9wZW4obWV0aG9kLCB0aGlzLnVyaSwgdHJ1ZSk7XHJcblx0XHR4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xyXG5cclxuXHRcdGlmICgnYXV0aG9yaXphdGlvbicgaW4gaGVhZGVycykge1xyXG5cdFx0XHR4aHIud2l0aENyZWRlbnRpYWxzID0gdHJ1ZTtcclxuXHRcdH1cclxuXHJcblx0XHRmb3IodmFyIGggaW4gaGVhZGVycylcclxuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaCwgaGVhZGVyc1toXSk7XHJcblxyXG5cdFx0dmFyIGVycm9ySGFuZGxlciA9IGZ1bmN0aW9uKGVycm9yRXZlbnQsIG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpIHtcclxuXHRcdFx0dmFyIGVycm9yTWVzc2FnZSA9IG1lc3NhZ2UgKyAnIChldmVudCB0eXBlOiAnICsgZXJyb3JFdmVudC50eXBlICsgJyknICsgKHNlbGYueGhyLnN0YXR1c1RleHQgPyAnLCBjdXJyZW50IHN0YXR1c1RleHQgaXMgJyArIHNlbGYueGhyLnN0YXR1c1RleHQgOiAnJyk7XHJcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnUmVxdWVzdC5vbicgKyBlcnJvckV2ZW50LnR5cGUgKyAnKCknLCBlcnJvck1lc3NhZ2UpO1xyXG5cdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXShlcnJvck1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpKTtcclxuXHRcdH07XHJcblx0XHR4aHIub25lcnJvciA9IGZ1bmN0aW9uKGVycm9yRXZlbnQpIHtcclxuXHRcdFx0ZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdYSFIgZXJyb3Igb2NjdXJyZWQnLCBudWxsLCA0MDApO1xyXG5cdFx0fVxyXG5cdFx0eGhyLm9uYWJvcnQgPSBmdW5jdGlvbihlcnJvckV2ZW50KSB7XHJcblx0XHRcdGlmKHNlbGYudGltZWRPdXQpIHtcclxuXHRcdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgYWJvcnRlZCBkdWUgdG8gcmVxdWVzdCB0aW1lb3V0IGV4cGlyaW5nJywgbnVsbCwgNDA4KTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgY2FuY2VsbGVkJywgbnVsbCwgNDAwKTtcclxuXHRcdFx0fVxyXG5cdFx0fTtcclxuXHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbihlcnJvckV2ZW50KSB7XHJcblx0XHRcdGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnUmVxdWVzdCB0aW1lZCBvdXQnLCBudWxsLCA0MDgpO1xyXG5cdFx0fTtcclxuXHJcblx0XHR2YXIgc3RyZWFtaW5nLFxyXG5cdFx0XHRzdGF0dXNDb2RlLFxyXG5cdFx0XHRyZXNwb25zZUJvZHksXHJcblx0XHRcdGNvbnRlbnRUeXBlLFxyXG5cdFx0XHRzdWNjZXNzUmVzcG9uc2UsXHJcblx0XHRcdHN0cmVhbVBvcyA9IDAsXHJcblx0XHRcdHVucGFja2VkID0gZmFsc2U7XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25SZXNwb25zZSgpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHRcdFx0c3VjY2Vzc1Jlc3BvbnNlID0gKHN0YXR1c0NvZGUgPCA0MDApO1xyXG5cdFx0XHRpZihzdGF0dXNDb2RlID09IDIwNCkge1xyXG5cdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgbnVsbCwgbnVsbCwgbnVsbCwgc3RhdHVzQ29kZSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHN0cmVhbWluZyA9IChzZWxmLnJlcXVlc3RNb2RlID09IFJFUV9SRUNWX1NUUkVBTSAmJiBzdWNjZXNzUmVzcG9uc2UgJiYgaXNFbmNvZGluZ0NodW5rZWQoeGhyKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gb25FbmQoKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dmFyIGNvbnRlbnRUeXBlID0gZ2V0SGVhZGVyKHhociwgJ2NvbnRlbnQtdHlwZScpLFxyXG5cdFx0XHRcdFx0aGVhZGVycyxcclxuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSxcclxuXHRcdFx0XHRcdC8qIEJlIGxpYmVyYWwgaW4gd2hhdCB3ZSBhY2NlcHQ7IGJ1Z2d5IGF1dGggc2VydmVycyBtYXkgcmVzcG9uZFxyXG5cdFx0XHRcdFx0ICogd2l0aG91dCB0aGUgY29ycmVjdCBjb250ZW50dHlwZSwgYnV0IGFzc3VtZSB0aGV5J3JlIHN0aWxsXHJcblx0XHRcdFx0XHQgKiByZXNwb25kaW5nIHdpdGgganNvbiAqL1xyXG5cdFx0XHRcdFx0anNvbiA9IGNvbnRlbnRUeXBlID8gKGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+PSAwKSA6ICh4aHIucmVzcG9uc2VUeXBlID09ICd0ZXh0Jyk7XHJcblxyXG5cdFx0XHRcdGlmKGpzb24pIHtcclxuXHRcdFx0XHRcdC8qIElmIHdlIHJlcXVlc3RlZCBtc2dwYWNrIGJ1dCBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGgganNvbiwgdGhlbiBzaW5jZVxyXG5cdFx0XHRcdFx0ICogd2Ugc2V0IHRoZSByZXNwb25zZVR5cGUgZXhwZWN0aW5nIG1zZ3BhY2ssIHRoZSByZXNwb25zZSB3aWxsIGJlXHJcblx0XHRcdFx0XHQgKiBhbiBBcnJheUJ1ZmZlciBjb250YWluaW5nIGpzb24gKi9cclxuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSA9ICh4aHIucmVzcG9uc2VUeXBlID09PSAnYXJyYXlidWZmZXInKSA/IHBsYXRmb3JtX2J1ZmZlcnV0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0udXRmOERlY29kZSh4aHIucmVzcG9uc2UpIDogU3RyaW5nKHhoci5yZXNwb25zZVRleHQpO1xyXG5cdFx0XHRcdFx0aWYocmVzcG9uc2VCb2R5Lmxlbmd0aCkge1xyXG5cdFx0XHRcdFx0XHRyZXNwb25zZUJvZHkgPSBKU09OLnBhcnNlKHJlc3BvbnNlQm9keSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHR1bnBhY2tlZCA9IHRydWU7XHJcblx0XHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRcdHJlc3BvbnNlQm9keSA9IHhoci5yZXNwb25zZTtcclxuXHRcdFx0XHR9XHJcblxyXG5cdFx0XHRcdGlmKHJlc3BvbnNlQm9keS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0XHQvKiB1bndyYXAgSlNPTiBlbnZlbG9wZSAqL1xyXG5cdFx0XHRcdFx0c3RhdHVzQ29kZSA9IHJlc3BvbnNlQm9keS5zdGF0dXNDb2RlO1xyXG5cdFx0XHRcdFx0c3VjY2Vzc1Jlc3BvbnNlID0gKHN0YXR1c0NvZGUgPCA0MDApO1xyXG5cdFx0XHRcdFx0aGVhZGVycyA9IHJlc3BvbnNlQm9keS5oZWFkZXJzO1xyXG5cdFx0XHRcdFx0cmVzcG9uc2VCb2R5ID0gcmVzcG9uc2VCb2R5LnJlc3BvbnNlO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRoZWFkZXJzID0gZ2V0SGVhZGVyc0FzT2JqZWN0KHhocik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGNhdGNoKGUpIHtcclxuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnTWFsZm9ybWVkIHJlc3BvbnNlIGJvZHkgZnJvbSBzZXJ2ZXI6ICcgKyBlLm1lc3NhZ2UsIG51bGwsIDQwMCkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxyXG5cdFx0XHQgKiBpcyBjb250YWlucyBhbiBlcnJvciBhY3Rpb24gKGhlbmNlIHRoZSBub25zdWNjZXNzIHN0YXR1c2NvZGUpLCB3ZSBjYW5cclxuXHRcdFx0ICogY29uc2lkZXIgdGhlIHJlcXVlc3QgdG8gaGF2ZSBzdWNjZWVkZWQsIGp1c3QgcGFzcyBpdCBvbiB0b1xyXG5cdFx0XHQgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xyXG5cdFx0XHRpZihzdWNjZXNzUmVzcG9uc2UgfHwgX2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmlzQXJyYXkocmVzcG9uc2VCb2R5KSkge1xyXG5cdFx0XHRcdHNlbGYuY29tcGxldGUobnVsbCwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgZXJyID0gcmVzcG9uc2VCb2R5LmVycm9yICYmIF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcclxuXHRcdFx0aWYoIWVycikge1xyXG5cdFx0XHRcdGVyciA9IG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnRXJyb3IgcmVzcG9uc2UgcmVjZWl2ZWQgZnJvbSBzZXJ2ZXI6ICcgKyBzdGF0dXNDb2RlICsgJyBib2R5IHdhczogJyArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KHJlc3BvbnNlQm9keSksIG51bGwsIHN0YXR1c0NvZGUpO1xyXG5cdFx0XHR9XHJcblx0XHRcdHNlbGYuY29tcGxldGUoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTtcclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvblByb2dyZXNzKCkge1xyXG5cdFx0XHRyZXNwb25zZUJvZHkgPSB4aHIucmVzcG9uc2VUZXh0O1xyXG5cdFx0XHR2YXIgYm9keUVuZCA9IHJlc3BvbnNlQm9keS5sZW5ndGggLSAxLCBpZHgsIGNodW5rO1xyXG5cdFx0XHR3aGlsZSgoc3RyZWFtUG9zIDwgYm9keUVuZCkgJiYgKGlkeCA9IHJlc3BvbnNlQm9keS5pbmRleE9mKCdcXG4nLCBzdHJlYW1Qb3MpKSA+IC0xKSB7XHJcblx0XHRcdFx0Y2h1bmsgPSByZXNwb25zZUJvZHkuc2xpY2Uoc3RyZWFtUG9zLCBpZHgpO1xyXG5cdFx0XHRcdHN0cmVhbVBvcyA9IGlkeCArIDE7XHJcblx0XHRcdFx0b25DaHVuayhjaHVuayk7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRmdW5jdGlvbiBvbkNodW5rKGNodW5rKSB7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0Y2h1bmsgPSBKU09OLnBhcnNlKGNodW5rKTtcclxuXHRcdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdFx0c2VsZi5jb21wbGV0ZShuZXcgX2NvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ01hbGZvcm1lZCByZXNwb25zZSBib2R5IGZyb20gc2VydmVyOiAnICsgZS5tZXNzYWdlLCBudWxsLCA0MDApKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0c2VsZi5lbWl0KCdkYXRhJywgY2h1bmspO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIG9uU3RyZWFtRW5kKCkge1xyXG5cdFx0XHRvblByb2dyZXNzKCk7XHJcblx0XHRcdHNlbGYuc3RyZWFtQ29tcGxldGUgPSB0cnVlO1xyXG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c2VsZi5jb21wbGV0ZSgpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH1cclxuXHJcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRcdHZhciByZWFkeVN0YXRlID0geGhyLnJlYWR5U3RhdGU7XHJcblx0XHRcdGlmKHJlYWR5U3RhdGUgPCAzKSByZXR1cm47XHJcblx0XHRcdGlmKHhoci5zdGF0dXMgIT09IDApIHtcclxuXHRcdFx0XHRpZihzdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0XHRcdHN0YXR1c0NvZGUgPSB4aHIuc3RhdHVzO1xyXG5cdFx0XHRcdFx0LyogSUUgcmV0dXJucyAxMjIzIGZvciAyMDQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzE0NTAgKi9cclxuXHRcdFx0XHRcdGlmKHN0YXR1c0NvZGUgPT09IDEyMjMpIHN0YXR1c0NvZGUgPSAyMDQ7XHJcblx0XHRcdFx0XHRvblJlc3BvbnNlKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGlmKHJlYWR5U3RhdGUgPT0gMyAmJiBzdHJlYW1pbmcpIHtcclxuXHRcdFx0XHRcdG9uUHJvZ3Jlc3MoKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYocmVhZHlTdGF0ZSA9PSA0KSB7XHJcblx0XHRcdFx0XHRpZihzdHJlYW1pbmcpXHJcblx0XHRcdFx0XHRcdG9uU3RyZWFtRW5kKCk7XHJcblx0XHRcdFx0XHRlbHNlXHJcblx0XHRcdFx0XHRcdG9uRW5kKCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cdFx0eGhyLnNlbmQoYm9keSk7XHJcblx0fTtcclxuXHJcblx0WEhSUmVxdWVzdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHhociA9IHRoaXMueGhyO1xyXG5cdFx0aWYoeGhyKSB7XHJcblx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSB4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9IG5vb3A7XHJcblx0XHRcdHRoaXMueGhyID0gbnVsbDtcclxuXHRcdFx0dmFyIHRpbWVyID0gdGhpcy50aW1lcjtcclxuXHRcdFx0aWYodGltZXIpIHtcclxuXHRcdFx0XHRjbGVhclRpbWVvdXQodGltZXIpO1xyXG5cdFx0XHRcdHRoaXMudGltZXIgPSBudWxsO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSlcclxuXHRcdFx0XHR4aHIuYWJvcnQoKTtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZF07XHJcblx0fTtcclxuXHJcblx0aWYocGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS54aHJTdXBwb3J0ZWQpIHtcclxuXHRcdGlmKHR5cGVvZiBfdXRpbF9kb21ldmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdID09PSAnb2JqZWN0Jykge1xyXG5cdFx0XHRfdXRpbF9kb21ldmVudF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmFkZFVubG9hZExpc3RlbmVyKGNsZWFyUGVuZGluZ1JlcXVlc3RzKTtcclxuXHRcdH1cclxuXHRcdGlmKHR5cGVvZihwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0pICE9PSAndW5kZWZpbmVkJykge1xyXG5cdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uc3VwcG9ydHNBdXRoSGVhZGVycyA9IHRydWU7XHJcblx0XHRcdHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcclxuXHRcdFx0XHR2YXIgcmVxID0gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgUkVRX1NFTkQsIHJlc3QgJiYgcmVzdC5vcHRpb25zLnRpbWVvdXRzLCBtZXRob2QpO1xyXG5cdFx0XHRcdHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRyZXEuZXhlYygpO1xyXG5cdFx0XHRcdHJldHVybiByZXE7XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHRcdHZhciB1cFVybCA9IF9jb21tb25fbGliX3V0aWxfZGVmYXVsdHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnRlcm5ldFVwVXJsO1xyXG5cdFx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1NlbmRpbmc7ICcgKyB1cFVybCk7XHJcblx0XHRcdFx0cGxhdGZvcm1faHR0cF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFVyaShudWxsLCB1cFVybCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24oZXJyLCByZXNwb25zZVRleHQpIHtcclxuXHRcdFx0XHRcdHZhciByZXN1bHQgPSAoIWVyciAmJiByZXNwb25zZVRleHQucmVwbGFjZSgvXFxuLywgJycpID09ICd5ZXMnKTtcclxuXHRcdFx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhudWxsLCByZXN1bHQpO1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHR9O1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cmV0dXJuIFhIUlJlcXVlc3Q7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFhIUlJlcXVlc3QpO1xyXG5cclxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAyOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHRydWUpIHtcclxuXHRcdC8vIENvbW1vbkpTXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NiksIF9fd2VicGFja19yZXF1aXJlX18oMTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzNiksIF9fd2VicGFja19yZXF1aXJlX18oMjkpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMSksIF9fd2VicGFja19yZXF1aXJlX18oNDcpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ4KSk7XHJcblx0fVxyXG5cdGVsc2Uge31cclxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcclxuXHJcblx0cmV0dXJuIENyeXB0b0pTO1xyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDI5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xyXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcclxuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xyXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIEhNQUMgPSBDX2FsZ28uSE1BQyA9IEJhc2UuZXh0ZW5kKHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIEhNQUMuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWNIYXNoZXIgPSBDcnlwdG9KUy5hbGdvLkhNQUMuY3JlYXRlKENyeXB0b0pTLmFsZ28uU0hBMjU2LCBrZXkpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoaGFzaGVyLCBrZXkpIHtcclxuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBXb3JkQXJyYXksIGVsc2UgYXNzdW1lIFdvcmRBcnJheSBhbHJlYWR5XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcclxuXHQgICAgICAgICAgICAgICAga2V5ID0gVXRmOC5wYXJzZShrZXkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZSA9IGhhc2hlci5ibG9ja1NpemU7XHJcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQWxsb3cgYXJiaXRyYXJ5IGxlbmd0aCBrZXlzXHJcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XHJcblx0ICAgICAgICAgICAgICAgIGtleSA9IGhhc2hlci5maW5hbGl6ZShrZXkpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcclxuXHQgICAgICAgICAgICBrZXkuY2xhbXAoKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ2xvbmUga2V5IGZvciBpbm5lciBhbmQgb3V0ZXIgcGFkc1xyXG5cdCAgICAgICAgICAgIHZhciBvS2V5ID0gdGhpcy5fb0tleSA9IGtleS5jbG9uZSgpO1xyXG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3JkcztcclxuXHQgICAgICAgICAgICB2YXIgaUtleVdvcmRzID0gaUtleS53b3JkcztcclxuXHJcblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoYXNoZXJCbG9ja1NpemU7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBvS2V5V29yZHNbaV0gXj0gMHg1YzVjNWM1YztcclxuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIG9LZXkuc2lnQnl0ZXMgPSBpS2V5LnNpZ0J5dGVzID0gaGFzaGVyQmxvY2tTaXplQnl0ZXM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIucmVzZXQoKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFJlc2V0XHJcblx0ICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XHJcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBVcGRhdGVzIHRoaXMgSE1BQyB3aXRoIGEgbWVzc2FnZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge0hNQUN9IFRoaXMgSE1BQyBpbnN0YW5jZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xyXG5cdCAgICAgICAgICogICAgIGhtYWNIYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl9oYXNoZXIudXBkYXRlKG1lc3NhZ2VVcGRhdGUpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIEhNQUMgY29tcHV0YXRpb24uXHJcblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoKTtcclxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcclxuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUod29yZEFycmF5KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuXHQgICAgICAgICAgICB2YXIgaGFzaGVyID0gdGhpcy5faGFzaGVyO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIEhNQUNcclxuXHQgICAgICAgICAgICB2YXIgaW5uZXJIYXNoID0gaGFzaGVyLmZpbmFsaXplKG1lc3NhZ2VVcGRhdGUpO1xyXG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xyXG5cdCAgICAgICAgICAgIHZhciBobWFjID0gaGFzaGVyLmZpbmFsaXplKHRoaXMuX29LZXkuY2xvbmUoKS5jb25jYXQoaW5uZXJIYXNoKSk7XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHR9KCkpO1xyXG5cclxuXHJcbn0pKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzMCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHRydWUpIHtcclxuXHRcdC8vIENvbW1vbkpTXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM3KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSkpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xyXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xyXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cclxuXHQgICAgICogd3d3Lm9wZW5zc2wub3JnL2RvY3MvY3J5cHRvL0VWUF9CeXRlc1RvS2V5Lmh0bWxcclxuXHQgICAgICovXHJcblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhlIGtleSBzaXplIGluIHdvcmRzIHRvIGdlbmVyYXRlLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2ggYWxnb3JpdGhtIHRvIHVzZS4gRGVmYXVsdDogTUQ1XHJcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcclxuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXHJcblx0ICAgICAgICAgICAgaGFzaGVyOiBNRDUsXHJcblx0ICAgICAgICAgICAgaXRlcmF0aW9uczogMVxyXG5cdCAgICAgICAgfSksXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGUgZGVyaXZhdGlvbi5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDggfSk7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIGtkZiA9IENyeXB0b0pTLmFsZ28uRXZwS0RGLmNyZWF0ZSh7IGtleVNpemU6IDgsIGl0ZXJhdGlvbnM6IDEwMDAgfSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChjZmcpIHtcclxuXHQgICAgICAgICAgICB0aGlzLmNmZyA9IHRoaXMuY2ZnLmV4dGVuZChjZmcpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkZXJpdmVkIGtleS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjb21wdXRlOiBmdW5jdGlvbiAocGFzc3dvcmQsIHNhbHQpIHtcclxuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBJbml0IGhhc2hlclxyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xyXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3JkcztcclxuXHQgICAgICAgICAgICB2YXIga2V5U2l6ZSA9IGNmZy5rZXlTaXplO1xyXG5cdCAgICAgICAgICAgIHZhciBpdGVyYXRpb25zID0gY2ZnLml0ZXJhdGlvbnM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEdlbmVyYXRlIGtleVxyXG5cdCAgICAgICAgICAgIHdoaWxlIChkZXJpdmVkS2V5V29yZHMubGVuZ3RoIDwga2V5U2l6ZSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGhhc2hlci51cGRhdGUoYmxvY2spO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XHJcblx0ICAgICAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xyXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGl0ZXJhdGlvbnM7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBoYXNoZXIuZmluYWxpemUoYmxvY2spO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcclxuXHQgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgZGVyaXZlZEtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gZGVyaXZlZEtleTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSk7XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxyXG5cdCAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgY29tcHV0YXRpb24uXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAc3RhdGljXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAqXHJcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcclxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCB9KTtcclxuXHQgICAgICogICAgIHZhciBrZXkgPSBDcnlwdG9KUy5FdnBLREYocGFzc3dvcmQsIHNhbHQsIHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcclxuXHQgICAgICovXHJcblx0ICAgIEMuRXZwS0RGID0gZnVuY3Rpb24gKHBhc3N3b3JkLCBzYWx0LCBjZmcpIHtcclxuXHQgICAgICAgIHJldHVybiBFdnBLREYuY3JlYXRlKGNmZykuY29tcHV0ZShwYXNzd29yZCwgc2FsdCk7XHJcblx0ICAgIH07XHJcblx0fSgpKTtcclxuXHJcblxyXG5cdHJldHVybiBDcnlwdG9KUy5FdnBLREY7XHJcblxyXG59KSk7XHJcblxyXG4vKioqLyB9KSxcclxuLyogMzEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xyXG5cdGlmICh0cnVlKSB7XHJcblx0XHQvLyBDb21tb25KU1xyXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMCkpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdC8qKlxyXG5cdCAqIENpcGhlciBjb3JlIGNvbXBvbmVudHMuXHJcblx0ICovXHJcblx0Q3J5cHRvSlMubGliLkNpcGhlciB8fCAoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xyXG5cdCAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcclxuXHQgICAgdmFyIENfbGliID0gQy5saWI7XHJcblx0ICAgIHZhciBCYXNlID0gQ19saWIuQmFzZTtcclxuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuXHQgICAgdmFyIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBDX2xpYi5CdWZmZXJlZEJsb2NrQWxnb3JpdGhtO1xyXG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcclxuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xyXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0O1xyXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGtleVNpemUgVGhpcyBjaXBoZXIncyBrZXkgc2l6ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXHJcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcclxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9FTkNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBlbmNyeXB0aW9uIG1vZGUuXHJcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfREVDX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZGVjcnlwdGlvbiBtb2RlLlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIENpcGhlciA9IENfbGliLkNpcGhlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBlbmNyeXB0aW9uIG1vZGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGNyZWF0ZUVuY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIGNpcGhlciBpbiBkZWNyeXB0aW9uIG1vZGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGtleSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGNpcGhlci5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGluaXQ6IGZ1bmN0aW9uICh4Zm9ybU1vZGUsIGtleSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxyXG5cdCAgICAgICAgICAgIHRoaXMuX3hmb3JtTW9kZSA9IHhmb3JtTW9kZTtcclxuXHQgICAgICAgICAgICB0aGlzLl9rZXkgPSBrZXk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFNldCBpbml0aWFsIHZhbHVlc1xyXG5cdCAgICAgICAgICAgIHRoaXMucmVzZXQoKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgY2lwaGVyLnJlc2V0KCk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgLy8gUmVzZXQgZGF0YSBidWZmZXJcclxuXHQgICAgICAgICAgICBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLnJlc2V0LmNhbGwodGhpcyk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFBlcmZvcm0gY29uY3JldGUtY2lwaGVyIGxvZ2ljXHJcblx0ICAgICAgICAgICAgdGhpcy5fZG9SZXNldCgpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgZGF0YSBhZnRlciBwcm9jZXNzaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2VzcygnZGF0YScpO1xyXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwcm9jZXNzOiBmdW5jdGlvbiAoZGF0YVVwZGF0ZSkge1xyXG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxyXG5cdCAgICAgICAgICAgIHRoaXMuX2FwcGVuZChkYXRhVXBkYXRlKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2Nlc3MoKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGVuY3J5cHRpb24gb3IgZGVjcnlwdGlvbiBwcm9jZXNzLlxyXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGRhdGFVcGRhdGUgVGhlIGZpbmFsIGRhdGEgdG8gZW5jcnlwdCBvciBkZWNyeXB0LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgZmluYWwgcHJvY2Vzc2luZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKCk7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xyXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUod29yZEFycmF5KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XHJcblx0ICAgICAgICAgICAgLy8gRmluYWwgZGF0YSB1cGRhdGVcclxuXHQgICAgICAgICAgICBpZiAoZGF0YVVwZGF0ZSkge1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xyXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZERhdGEgPSB0aGlzLl9kb0ZpbmFsaXplKCk7XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcclxuXHJcblx0ICAgICAgICBpdlNpemU6IDEyOC8zMixcclxuXHJcblx0ICAgICAgICBfRU5DX1hGT1JNX01PREU6IDEsXHJcblxyXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gQW4gb2JqZWN0IHdpdGggZW5jcnlwdCBhbmQgZGVjcnlwdCBzaG9ydGN1dCBmdW5jdGlvbnMuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBBRVMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQ3J5cHRvSlMuYWxnby5BRVMpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIGZ1bmN0aW9uIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGtleSA9PSAnc3RyaW5nJykge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gU2VyaWFsaXphYmxlQ2lwaGVyO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgZW5jcnlwdDogZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZGVjcnlwdChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcclxuXHQgICAgICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICAgICAgfTtcclxuXHQgICAgICAgICAgICB9O1xyXG5cdCAgICAgICAgfSgpKVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBjaXBoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDEgKDMyIGJpdHMpXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgU3RyZWFtQ2lwaGVyID0gQ19saWIuU3RyZWFtQ2lwaGVyID0gQ2lwaGVyLmV4dGVuZCh7XHJcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3NcclxuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3MgPSB0aGlzLl9wcm9jZXNzKCEhJ2ZsdXNoJyk7XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2NrcztcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIE1vZGUgbmFtZXNwYWNlLlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgQmxvY2tDaXBoZXJNb2RlID0gQ19saWIuQmxvY2tDaXBoZXJNb2RlID0gQmFzZS5leHRlbmQoe1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZW5jcnlwdGlvbi5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZUVuY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkVuY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGRlY3J5cHRpb24uXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVEZWNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGNyZWF0ZURlY3J5cHRvcjogZnVuY3Rpb24gKGNpcGhlciwgaXYpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5EZWNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYud29yZHMpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xyXG5cdCAgICAgICAgICAgIHRoaXMuX2NpcGhlciA9IGNpcGhlcjtcclxuXHQgICAgICAgICAgICB0aGlzLl9pdiA9IGl2O1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBDaXBoZXIgQmxvY2sgQ2hhaW5pbmcgbW9kZS5cclxuXHQgICAgICovXHJcblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQWJzdHJhY3QgYmFzZSBDQkMgbW9kZS5cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgdmFyIENCQyA9IEJsb2NrQ2lwaGVyTW9kZS5leHRlbmQoKTtcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENCQyBlbmNyeXB0b3IuXHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcclxuXHQgICAgICAgICAgICAvKipcclxuXHQgICAgICAgICAgICAgKiBQcm9jZXNzZXMgdGhlIGRhdGEgYmxvY2sgYXQgb2Zmc2V0LlxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtBcnJheX0gd29yZHMgVGhlIGRhdGEgd29yZHMgdG8gb3BlcmF0ZSBvbi5cclxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0IFRoZSBvZmZzZXQgd2hlcmUgdGhlIGJsb2NrIHN0YXJ0cy5cclxuXHQgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcclxuXHQgICAgICAgICAgICAgKi9cclxuXHQgICAgICAgICAgICBwcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY2lwaGVyID0gdGhpcy5fY2lwaGVyO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gY2lwaGVyLmJsb2NrU2l6ZTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIFhPUiBhbmQgZW5jcnlwdFxyXG5cdCAgICAgICAgICAgICAgICB4b3JCbG9jay5jYWxsKHRoaXMsIHdvcmRzLCBvZmZzZXQsIGJsb2NrU2l6ZSk7XHJcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0pO1xyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ0JDIGRlY3J5cHRvci5cclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgQ0JDLkRlY3J5cHRvciA9IENCQy5leHRlbmQoe1xyXG5cdCAgICAgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXHJcblx0ICAgICAgICAgICAgICpcclxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyBUaGUgZGF0YSB3b3JkcyB0byBvcGVyYXRlIG9uLlxyXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxyXG5cdCAgICAgICAgICAgICAqXHJcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAgICAgKlxyXG5cdCAgICAgICAgICAgICAqICAgICBtb2RlLnByb2Nlc3NCbG9jayhkYXRhLndvcmRzLCBvZmZzZXQpO1xyXG5cdCAgICAgICAgICAgICAqL1xyXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaXBoZXIgPSB0aGlzLl9jaXBoZXI7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gUmVtZW1iZXIgdGhpcyBibG9jayB0byB1c2Ugd2l0aCBuZXh0IGJsb2NrXHJcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBEZWNyeXB0IGFuZCBYT1JcclxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcclxuXHQgICAgICAgICAgICAgICAgeG9yQmxvY2suY2FsbCh0aGlzLCB3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9wcmV2QmxvY2sgPSB0aGlzQmxvY2s7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfSk7XHJcblxyXG5cdCAgICAgICAgZnVuY3Rpb24geG9yQmxvY2sod29yZHMsIG9mZnNldCwgYmxvY2tTaXplKSB7XHJcblx0ICAgICAgICAgICAgdmFyIGJsb2NrO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDaG9vc2UgbWl4aW5nIGJsb2NrXHJcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XHJcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaXY7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuX2l2ID0gdW5kZWZpbmVkO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYmxvY2tTaXplOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgd29yZHNbb2Zmc2V0ICsgaV0gXj0gYmxvY2tbaV07XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cclxuXHQgICAgICAgIHJldHVybiBDQkM7XHJcblx0ICAgIH0oKSk7XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogUGFkZGluZyBuYW1lc3BhY2UuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIFBrY3M3ID0gQ19wYWQuUGtjczcgPSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIFBhZHMgZGF0YSB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG11bHRpcGxlIHRoYXQgdGhlIGRhdGEgc2hvdWxkIGJlIHBhZGRlZCB0by5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgQ3J5cHRvSlMucGFkLlBrY3M3LnBhZCh3b3JkQXJyYXksIDQpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvdW50IHBhZGRpbmcgYnl0ZXNcclxuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGJsb2NrU2l6ZUJ5dGVzIC0gZGF0YS5zaWdCeXRlcyAlIGJsb2NrU2l6ZUJ5dGVzO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZyB3b3JkXHJcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkID0gKG5QYWRkaW5nQnl0ZXMgPDwgMjQpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgMTYpIHwgKG5QYWRkaW5nQnl0ZXMgPDwgOCkgfCBuUGFkZGluZ0J5dGVzO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDcmVhdGUgcGFkZGluZ1xyXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nV29yZHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xyXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nV29yZHMucHVzaChwYWRkaW5nV29yZCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xyXG5cdCAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIFVucGFkcyBkYXRhIHRoYXQgaGFkIGJlZW4gcGFkZGVkIHVzaW5nIHRoZSBhbGdvcml0aG0gZGVmaW5lZCBpbiBQS0NTICM1LzcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICB1bnBhZDogZnVuY3Rpb24gKGRhdGEpIHtcclxuXHQgICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcclxuXHQgICAgICAgICAgICB2YXIgblBhZGRpbmdCeXRlcyA9IGRhdGEud29yZHNbKGRhdGEuc2lnQnl0ZXMgLSAxKSA+Pj4gMl0gJiAweGZmO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xyXG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gblBhZGRpbmdCeXRlcztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgQmxvY2tDaXBoZXIgPSBDX2xpYi5CbG9ja0NpcGhlciA9IENpcGhlci5leHRlbmQoe1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtNb2RlfSBtb2RlIFRoZSBibG9jayBtb2RlIHRvIHVzZS4gRGVmYXVsdDogQ0JDXHJcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjZmc6IENpcGhlci5jZmcuZXh0ZW5kKHtcclxuXHQgICAgICAgICAgICBtb2RlOiBDQkMsXHJcblx0ICAgICAgICAgICAgcGFkZGluZzogUGtjczdcclxuXHQgICAgICAgIH0pLFxyXG5cclxuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgdmFyIG1vZGVDcmVhdG9yO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBSZXNldCBjaXBoZXJcclxuXHQgICAgICAgICAgICBDaXBoZXIucmVzZXQuY2FsbCh0aGlzKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xyXG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcclxuXHQgICAgICAgICAgICB2YXIgbW9kZSA9IGNmZy5tb2RlO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xyXG5cdCAgICAgICAgICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRW5jcnlwdG9yO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XHJcblx0ICAgICAgICAgICAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVEZWNyeXB0b3I7XHJcblx0ICAgICAgICAgICAgICAgIC8vIEtlZXAgYXQgbGVhc3Qgb25lIGJsb2NrIGluIHRoZSBidWZmZXIgZm9yIHVucGFkZGluZ1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlICYmIHRoaXMuX21vZGUuX19jcmVhdG9yID09IG1vZGVDcmVhdG9yKSB7XHJcblx0ICAgICAgICAgICAgICAgIHRoaXMuX21vZGUuaW5pdCh0aGlzLCBpdiAmJiBpdi53b3Jkcyk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xyXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLl9fY3JlYXRvciA9IG1vZGVDcmVhdG9yO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAod29yZHMsIG9mZnNldCkge1xyXG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBmaW5hbFByb2Nlc3NlZEJsb2NrcztcclxuXHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZyA9IHRoaXMuY2ZnLnBhZGRpbmc7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEZpbmFsaXplXHJcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9FTkNfWEZPUk1fTU9ERSkge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBQYWQgZGF0YVxyXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xyXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcclxuXHQgICAgICAgICAgICB9IGVsc2UgLyogaWYgKHRoaXMuX3hmb3JtTW9kZSA9PSB0aGlzLl9ERUNfWEZPUk1fTU9ERSkgKi8ge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBQcm9jZXNzIGZpbmFsIGJsb2Nrc1xyXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIC8vIFVucGFkIGRhdGFcclxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEEgY29sbGVjdGlvbiBvZiBjaXBoZXIgcGFyYW1ldGVycy5cclxuXHQgICAgICpcclxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxyXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkgdG8gdGhpcyBjaXBoZXJ0ZXh0LlxyXG5cdCAgICAgKiBAcHJvcGVydHkge1dvcmRBcnJheX0gaXYgVGhlIElWIHVzZWQgaW4gdGhlIGNpcGhlcmluZyBvcGVyYXRpb24uXHJcblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxyXG5cdCAgICAgKiBAcHJvcGVydHkge0NpcGhlcn0gYWxnb3JpdGhtIFRoZSBjaXBoZXIgYWxnb3JpdGhtLlxyXG5cdCAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cclxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxyXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBibG9jayBzaXplIG9mIHRoZSBjaXBoZXIuXHJcblx0ICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0fSBmb3JtYXR0ZXIgVGhlIGRlZmF1bHQgZm9ybWF0dGluZyBzdHJhdGVneSB0byBjb252ZXJ0IHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgQ2lwaGVyUGFyYW1zID0gQ19saWIuQ2lwaGVyUGFyYW1zID0gQmFzZS5leHRlbmQoe1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNpcGhlclBhcmFtcyBBbiBvYmplY3Qgd2l0aCBhbnkgb2YgdGhlIHBvc3NpYmxlIGNpcGhlciBwYXJhbWV0ZXJzLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XHJcblx0ICAgICAgICAgKiAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHRXb3JkQXJyYXksXHJcblx0ICAgICAgICAgKiAgICAgICAgIGtleToga2V5V29yZEFycmF5LFxyXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXHJcblx0ICAgICAgICAgKiAgICAgICAgIHNhbHQ6IHNhbHRXb3JkQXJyYXksXHJcblx0ICAgICAgICAgKiAgICAgICAgIGFsZ29yaXRobTogQ3J5cHRvSlMuYWxnby5BRVMsXHJcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxyXG5cdCAgICAgICAgICogICAgICAgICBwYWRkaW5nOiBDcnlwdG9KUy5wYWQuUEtDUzcsXHJcblx0ICAgICAgICAgKiAgICAgICAgIGJsb2NrU2l6ZTogNCxcclxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxyXG5cdCAgICAgICAgICogICAgIH0pO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5taXhJbihjaXBoZXJQYXJhbXMpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR9IGZvcm1hdHRlciAoT3B0aW9uYWwpIFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIHVzZS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEB0aHJvd3MgRXJyb3IgSWYgbmVpdGhlciB0aGUgZm9ybWF0dGVyIG5vciB0aGUgZGVmYXVsdCBmb3JtYXR0ZXIgaXMgc2V0LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcclxuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKCk7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZyhDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHRvU3RyaW5nOiBmdW5jdGlvbiAoZm9ybWF0dGVyKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuIChmb3JtYXR0ZXIgfHwgdGhpcy5mb3JtYXR0ZXIpLnN0cmluZ2lmeSh0aGlzKTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSk7XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogRm9ybWF0IG5hbWVzcGFjZS5cclxuXHQgICAgICovXHJcblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIE9wZW5TU0xGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5PcGVuU1NMID0ge1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIG9wZW5TU0xTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTC5zdHJpbmdpZnkoY2lwaGVyUGFyYW1zKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XHJcblx0ICAgICAgICAgICAgdmFyIHdvcmRBcnJheTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dDtcclxuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBGb3JtYXRcclxuXHQgICAgICAgICAgICBpZiAoc2FsdCkge1xyXG5cdCAgICAgICAgICAgICAgICB3b3JkQXJyYXkgPSBXb3JkQXJyYXkuY3JlYXRlKFsweDUzNjE2Yzc0LCAweDY1NjQ1ZjVmXSkuY29uY2F0KHNhbHQpLmNvbmNhdChjaXBoZXJ0ZXh0KTtcclxuXHQgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGFuIE9wZW5TU0wtY29tcGF0aWJsZSBzdHJpbmcgdG8gYSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnBhcnNlKG9wZW5TU0xTdHJpbmcpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKG9wZW5TU0xTdHIpIHtcclxuXHQgICAgICAgICAgICB2YXIgc2FsdDtcclxuXHJcblx0ICAgICAgICAgICAgLy8gUGFyc2UgYmFzZTY0XHJcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBCYXNlNjQucGFyc2Uob3BlblNTTFN0cik7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHRXb3JkcyA9IGNpcGhlcnRleHQud29yZHM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFRlc3QgZm9yIHNhbHRcclxuXHQgICAgICAgICAgICBpZiAoY2lwaGVydGV4dFdvcmRzWzBdID09IDB4NTM2MTZjNzQgJiYgY2lwaGVydGV4dFdvcmRzWzFdID09IDB4NjU2NDVmNWYpIHtcclxuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XHJcblx0ICAgICAgICAgICAgICAgIHNhbHQgPSBXb3JkQXJyYXkuY3JlYXRlKGNpcGhlcnRleHRXb3Jkcy5zbGljZSgyLCA0KSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcclxuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dFdvcmRzLnNwbGljZSgwLCA0KTtcclxuXHQgICAgICAgICAgICAgICAgY2lwaGVydGV4dC5zaWdCeXRlcyAtPSAxNjtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCwgc2FsdDogc2FsdCB9KTtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBBIGNpcGhlciB3cmFwcGVyIHRoYXQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7Rm9ybWF0dGVyfSBmb3JtYXQgVGhlIGZvcm1hdHRpbmcgc3RyYXRlZ3kgdG8gY29udmVydCBjaXBoZXIgcGFyYW0gb2JqZWN0cyB0byBhbmQgZnJvbSBhIHN0cmluZy4gRGVmYXVsdDogT3BlblNTTFxyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcclxuXHQgICAgICAgICAgICBmb3JtYXQ6IE9wZW5TU0xGb3JtYXR0ZXJcclxuXHQgICAgICAgIH0pLFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogRW5jcnlwdHMgYSBtZXNzYWdlLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYgfSk7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcclxuXHQgICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XHJcblx0ICAgICAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBlbmNyeXB0b3IuZmluYWxpemUobWVzc2FnZSk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcblx0ICAgICAgICAgICAgdmFyIGNpcGhlckNmZyA9IGVuY3J5cHRvci5jZmc7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXHJcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoe1xyXG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LFxyXG5cdCAgICAgICAgICAgICAgICBrZXk6IGtleSxcclxuXHQgICAgICAgICAgICAgICAgaXY6IGNpcGhlckNmZy5pdixcclxuXHQgICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBjaXBoZXIsXHJcblx0ICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxyXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nOiBjaXBoZXJDZmcucGFkZGluZyxcclxuXHQgICAgICAgICAgICAgICAgYmxvY2tTaXplOiBjaXBoZXIuYmxvY2tTaXplLFxyXG5cdCAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcclxuXHQgICAgICAgICAgICB9KTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBEZWNyeXB0cyBzZXJpYWxpemVkIGNpcGhlcnRleHQuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGNpcGhlcnRleHRQYXJhbXMsIGtleSwgeyBpdjogaXYsIGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xyXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxyXG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBjaXBoZXIuY3JlYXRlRGVjcnlwdG9yKGtleSwgY2ZnKS5maW5hbGl6ZShjaXBoZXJ0ZXh0LmNpcGhlcnRleHQpO1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gcGxhaW50ZXh0O1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dCB0byBDaXBoZXJQYXJhbXMsXHJcblx0ICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN8c3RyaW5nfSBjaXBoZXJ0ZXh0IFRoZSBjaXBoZXJ0ZXh0LlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIHVuc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuX3BhcnNlKGNpcGhlcnRleHRTdHJpbmdPclBhcmFtcywgZm9ybWF0KTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgX3BhcnNlOiBmdW5jdGlvbiAoY2lwaGVydGV4dCwgZm9ybWF0KSB7XHJcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBjaXBoZXJ0ZXh0ID09ICdzdHJpbmcnKSB7XHJcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XHJcblx0ICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XHJcblx0ICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9KTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBLZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiBuYW1lc3BhY2UuXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgQ19rZGYgPSBDLmtkZiA9IHt9O1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIE9wZW5TU0wga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkIHRvIGRlcml2ZSBmcm9tLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtudW1iZXJ9IGtleVNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIGtleSB0byBnZW5lcmF0ZS5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IChPcHRpb25hbCkgQSA2NC1iaXQgc2FsdCB0byB1c2UuIElmIG9taXR0ZWQsIGEgc2FsdCB3aWxsIGJlIGdlbmVyYXRlZCByYW5kb21seS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBDcnlwdG9KUy5rZGYuT3BlblNTTC5leGVjdXRlKCdQYXNzd29yZCcsIDI1Ni8zMiwgMTI4LzMyLCAnc2FsdHNhbHQnKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcclxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSByYW5kb20gc2FsdFxyXG5cdCAgICAgICAgICAgIGlmICghc2FsdCkge1xyXG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXHJcblx0ICAgICAgICAgICAgdmFyIGtleSA9IEV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiBrZXlTaXplICsgaXZTaXplIH0pLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXHJcblx0ICAgICAgICAgICAgdmFyIGl2ID0gV29yZEFycmF5LmNyZWF0ZShrZXkud29yZHMuc2xpY2Uoa2V5U2l6ZSksIGl2U2l6ZSAqIDQpO1xyXG5cdCAgICAgICAgICAgIGtleS5zaWdCeXRlcyA9IGtleVNpemUgKiA0O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcGFyYW1zXHJcblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBrZXk6IGtleSwgaXY6IGl2LCBzYWx0OiBzYWx0IH0pO1xyXG5cdCAgICAgICAgfVxyXG5cdCAgICB9O1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEEgc2VyaWFsaXphYmxlIGNpcGhlciB3cmFwcGVyIHRoYXQgZGVyaXZlcyB0aGUga2V5IGZyb20gYSBwYXNzd29yZCxcclxuXHQgICAgICogYW5kIHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuXHQgICAgICovXHJcblx0ICAgIHZhciBQYXNzd29yZEJhc2VkQ2lwaGVyID0gQ19saWIuUGFzc3dvcmRCYXNlZENpcGhlciA9IFNlcmlhbGl6YWJsZUNpcGhlci5leHRlbmQoe1xyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtLREZ9IGtkZiBUaGUga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gdG8gdXNlIHRvIGdlbmVyYXRlIGEga2V5IGFuZCBJViBmcm9tIGEgcGFzc3dvcmQuIERlZmF1bHQ6IE9wZW5TU0xcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgY2ZnOiBTZXJpYWxpemFibGVDaXBoZXIuY2ZnLmV4dGVuZCh7XHJcblx0ICAgICAgICAgICAga2RmOiBPcGVuU1NMS2RmXHJcblx0ICAgICAgICB9KSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwgJ3Bhc3N3b3JkJyk7XHJcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIGVuY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIG1lc3NhZ2UsIHBhc3N3b3JkLCBjZmcpIHtcclxuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcclxuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXHJcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQWRkIElWIHRvIGNvbmZpZ1xyXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEVuY3J5cHRcclxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gTWl4IGluIGRlcml2ZWQgcGFyYW1zXHJcblx0ICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cclxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHBsYWludGV4dC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIHBsYWludGV4dCA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmRlY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIGZvcm1hdHRlZENpcGhlcnRleHQsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcclxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlBhc3N3b3JkQmFzZWRDaXBoZXIuZGVjcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgY2lwaGVydGV4dFBhcmFtcywgJ3Bhc3N3b3JkJywgeyBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBkZWNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBwYXNzd29yZCwgY2ZnKSB7XHJcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXHJcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIENpcGhlclBhcmFtc1xyXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gRGVyaXZlIGtleSBhbmQgb3RoZXIgcGFyYW1zXHJcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXHJcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcclxuXHJcblx0ICAgICAgICAgICAgLy8gRGVjcnlwdFxyXG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiBwbGFpbnRleHQ7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cdH0oKSk7XHJcblxyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuSGV4O1xyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDMzICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmODtcclxuXHJcbn0pKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9tZXNzYWdlcXVldWVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMjYpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKTtcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBQcm90b2NvbCA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgYWN0aW9ucyA9IF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5BY3Rpb247XHJcblxyXG5cdGZ1bmN0aW9uIFByb3RvY29sKHRyYW5zcG9ydCkge1xyXG5cdFx0X3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2FsbCh0aGlzKTtcclxuXHRcdHRoaXMudHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xyXG5cdFx0dGhpcy5tZXNzYWdlUXVldWUgPSBuZXcgX21lc3NhZ2VxdWV1ZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCk7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHR0cmFuc3BvcnQub24oJ2FjaycsIGZ1bmN0aW9uKHNlcmlhbCwgY291bnQpIHsgc2VsZi5vbkFjayhzZXJpYWwsIGNvdW50KTsgfSk7XHJcblx0XHR0cmFuc3BvcnQub24oJ25hY2snLCBmdW5jdGlvbihzZXJpYWwsIGNvdW50LCBlcnIpIHsgc2VsZi5vbk5hY2soc2VyaWFsLCBjb3VudCwgZXJyKTsgfSk7XHJcblx0fVxyXG5cdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uaW5oZXJpdHMoUHJvdG9jb2wsIF91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcclxuXHJcblx0UHJvdG9jb2wucHJvdG90eXBlLm9uQWNrID0gZnVuY3Rpb24oc2VyaWFsLCBjb3VudCkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1Byb3RvY29sLm9uQWNrKCknLCAnc2VyaWFsID0gJyArIHNlcmlhbCArICc7IGNvdW50ID0gJyArIGNvdW50KTtcclxuXHRcdHRoaXMubWVzc2FnZVF1ZXVlLmNvbXBsZXRlTWVzc2FnZXMoc2VyaWFsLCBjb3VudCk7XHJcblx0fTtcclxuXHJcblx0UHJvdG9jb2wucHJvdG90eXBlLm9uTmFjayA9IGZ1bmN0aW9uKHNlcmlhbCwgY291bnQsIGVycikge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1Byb3RvY29sLm9uTmFjaygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCArICc7IGVyciA9ICcgKyBfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluc3BlY3RFcnJvcihlcnIpKTtcclxuXHRcdGlmKCFlcnIpIHtcclxuXHRcdFx0ZXJyID0gbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnVW5hYmxlIHRvIHNlbmQgbWVzc2FnZTsgY2hhbm5lbCBub3QgcmVzcG9uZGluZycsIDUwMDAxLCA1MDApO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5tZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcyhzZXJpYWwsIGNvdW50LCBlcnIpO1xyXG5cdH07XHJcblxyXG5cdFByb3RvY29sLnByb3RvdHlwZS5vbmNlSWRsZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XHJcblx0XHR2YXIgbWVzc2FnZVF1ZXVlID0gdGhpcy5tZXNzYWdlUXVldWU7XHJcblx0XHRpZihtZXNzYWdlUXVldWUuY291bnQoKSA9PT0gMCkge1xyXG5cdFx0XHRsaXN0ZW5lcigpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRtZXNzYWdlUXVldWUub25jZSgnaWRsZScsIGxpc3RlbmVyKTtcclxuXHR9O1xyXG5cclxuXHRQcm90b2NvbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKHBlbmRpbmdNZXNzYWdlKSB7XHJcblx0XHRpZihwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCkge1xyXG5cdFx0XHR0aGlzLm1lc3NhZ2VRdWV1ZS5wdXNoKHBlbmRpbmdNZXNzYWdlKTtcclxuXHRcdH1cclxuXHRcdGlmIChfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zaG91bGRMb2coX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPKSkge1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JQ1JPLCAnUHJvdG9jb2wuc2VuZCgpJywgJ3NlbmRpbmcgbXNnOyAnICsgX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnN0cmluZ2lmeShwZW5kaW5nTWVzc2FnZS5tZXNzYWdlKSk7XHJcblx0XHR9XHJcblx0XHRwZW5kaW5nTWVzc2FnZS5zZW5kQXR0ZW1wdGVkID0gdHJ1ZTtcclxuXHRcdHRoaXMudHJhbnNwb3J0LnNlbmQocGVuZGluZ01lc3NhZ2UubWVzc2FnZSk7XHJcblx0fTtcclxuXHJcblx0UHJvdG9jb2wucHJvdG90eXBlLmdldFRyYW5zcG9ydCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMudHJhbnNwb3J0O1xyXG5cdH07XHJcblxyXG5cdFByb3RvY29sLnByb3RvdHlwZS5nZXRQZW5kaW5nTWVzc2FnZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB0aGlzLm1lc3NhZ2VRdWV1ZS5jb3B5QWxsKCk7XHJcblx0fTtcclxuXHJcblx0UHJvdG9jb2wucHJvdG90eXBlLmNsZWFyUGVuZGluZ01lc3NhZ2VzID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5tZXNzYWdlUXVldWUuY2xlYXIoKTtcclxuXHR9O1xyXG5cclxuXHRQcm90b2NvbC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnQ7XHJcblx0XHR0aGlzLm9uY2VJZGxlKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHR0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gUGVuZGluZ01lc3NhZ2UobWVzc2FnZSwgY2FsbGJhY2spIHtcclxuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XHJcblx0XHR0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XHJcblx0XHR0aGlzLm1lcmdlZCA9IGZhbHNlO1xyXG5cdFx0dmFyIGFjdGlvbiA9IG1lc3NhZ2UuYWN0aW9uO1xyXG5cdFx0dGhpcy5zZW5kQXR0ZW1wdGVkID0gZmFsc2U7XHJcblx0XHR0aGlzLmFja1JlcXVpcmVkID0gKGFjdGlvbiA9PSBhY3Rpb25zLk1FU1NBR0UgfHwgYWN0aW9uID09IGFjdGlvbnMuUFJFU0VOQ0UpO1xyXG5cdH1cclxuXHRQcm90b2NvbC5QZW5kaW5nTWVzc2FnZSA9IFBlbmRpbmdNZXNzYWdlO1xyXG5cclxuXHRyZXR1cm4gUHJvdG9jb2w7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKFByb3RvY29sKTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogMzUgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgRG9tRXZlbnQgPSAoZnVuY3Rpb24oKSB7XHJcblx0ZnVuY3Rpb24gRG9tRXZlbnQoKSB7fVxyXG5cclxuXHREb21FdmVudC5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyKSB7XHJcblx0XHRpZih0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG5cdFx0XHR0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRhcmdldC5hdHRhY2hFdmVudCgnb24nK2V2ZW50LCBmdW5jdGlvbigpIHsgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpOyB9KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHREb21FdmVudC5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgZXZlbnQsIGxpc3RlbmVyKSB7XHJcblx0XHRpZih0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcikge1xyXG5cdFx0XHR0YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHRhcmdldC5kZXRhY2hFdmVudCgnb24nK2V2ZW50LCBmdW5jdGlvbigpIHsgbGlzdGVuZXIuYXBwbHkodGFyZ2V0LCBhcmd1bWVudHMpOyB9KTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHREb21FdmVudC5hZGRNZXNzYWdlTGlzdGVuZXIgPSBmdW5jdGlvbih0YXJnZXQsIGxpc3RlbmVyKSB7XHJcblx0XHREb21FdmVudC5hZGRMaXN0ZW5lcih0YXJnZXQsICdtZXNzYWdlJywgbGlzdGVuZXIpO1xyXG5cdH07XHJcblxyXG5cdERvbUV2ZW50LnJlbW92ZU1lc3NhZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uKHRhcmdldCwgbGlzdGVuZXIpIHtcclxuXHRcdERvbUV2ZW50LnJlbW92ZUxpc3RlbmVyKHRhcmdldCwgJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XHJcblx0fTtcclxuXHJcblx0RG9tRXZlbnQuYWRkVW5sb2FkTGlzdGVuZXIgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xyXG5cdFx0RG9tRXZlbnQuYWRkTGlzdGVuZXIoZ2xvYmFsLCAndW5sb2FkJywgbGlzdGVuZXIpO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBEb21FdmVudDtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoRG9tRXZlbnQpO1xyXG5cclxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzNiAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHRydWUpIHtcclxuXHRcdC8vIENvbW1vbkpTXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcclxuXHR9XHJcblx0ZWxzZSB7fVxyXG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xyXG5cclxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcclxuXHQgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XHJcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xyXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xyXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cclxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcclxuXHQgICAgdmFyIEggPSBbXTtcclxuXHQgICAgdmFyIEsgPSBbXTtcclxuXHJcblx0ICAgIC8vIENvbXB1dGUgY29uc3RhbnRzXHJcblx0ICAgIChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcclxuXHQgICAgICAgICAgICB2YXIgc3FydE4gPSBNYXRoLnNxcnQobik7XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgZmFjdG9yID0gMjsgZmFjdG9yIDw9IHNxcnROOyBmYWN0b3IrKykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICBmdW5jdGlvbiBnZXRGcmFjdGlvbmFsQml0cyhuKSB7XHJcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICB2YXIgbiA9IDI7XHJcblx0ICAgICAgICB2YXIgblByaW1lID0gMDtcclxuXHQgICAgICAgIHdoaWxlIChuUHJpbWUgPCA2NCkge1xyXG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChuUHJpbWUgPCA4KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBIW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMikpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblx0ICAgICAgICAgICAgICAgIEtbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAzKSk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIG4rKztcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSgpKTtcclxuXHJcblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxyXG5cdCAgICB2YXIgVyA9IFtdO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNIQS0yNTYgaGFzaCBhbGdvcml0aG0uXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgU0hBMjU2ID0gQ19hbGdvLlNIQTI1NiA9IEhhc2hlci5leHRlbmQoe1xyXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcclxuXHJcblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcclxuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XHJcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xyXG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcclxuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XHJcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xyXG5cdCAgICAgICAgICAgIHZhciBmID0gSFs1XTtcclxuXHQgICAgICAgICAgICB2YXIgZyA9IEhbNl07XHJcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWEweCA9IFdbaSAtIDE1XTtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTAgID0gKChnYW1tYTB4IDw8IDI1KSB8IChnYW1tYTB4ID4+PiA3KSkgIF5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChnYW1tYTB4ID4+PiAzKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMSAgPSAoKGdhbW1hMXggPDwgMTUpIHwgKGdhbW1hMXggPj4+IDE3KSkgXlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKGdhbW1hMXggPDwgMTMpIHwgKGdhbW1hMXggPj4+IDE5KSkgXlxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gZ2FtbWEwICsgV1tpIC0gN10gKyBnYW1tYTEgKyBXW2kgLSAxNl07XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciBjaCAgPSAoZSAmIGYpIF4gKH5lICYgZyk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgc2lnbWEwID0gKChhIDw8IDMwKSB8IChhID4+PiAyKSkgXiAoKGEgPDwgMTkpIHwgKGEgPj4+IDEzKSkgXiAoKGEgPDwgMTApIHwgKGEgPj4+IDIyKSk7XHJcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IGggKyBzaWdtYTEgKyBjaCArIEtbaV0gKyBXW2ldO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XHJcblxyXG5cdCAgICAgICAgICAgICAgICBoID0gZztcclxuXHQgICAgICAgICAgICAgICAgZyA9IGY7XHJcblx0ICAgICAgICAgICAgICAgIGYgPSBlO1xyXG5cdCAgICAgICAgICAgICAgICBlID0gKGQgKyB0MSkgfCAwO1xyXG5cdCAgICAgICAgICAgICAgICBkID0gYztcclxuXHQgICAgICAgICAgICAgICAgYyA9IGI7XHJcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xyXG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXHJcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xyXG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcclxuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XHJcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xyXG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcclxuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XHJcblx0ICAgICAgICAgICAgSFs2XSA9IChIWzZdICsgZykgfCAwO1xyXG5cdCAgICAgICAgICAgIEhbN10gPSAoSFs3XSArIGgpIHwgMDtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XHJcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xyXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xyXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xyXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcclxuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXHJcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHN0YXRpY1xyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcclxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuU0hBMjU2KHdvcmRBcnJheSk7XHJcblx0ICAgICAqL1xyXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cclxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBzdGF0aWNcclxuXHQgICAgICpcclxuXHQgICAgICogQGV4YW1wbGVcclxuXHQgICAgICpcclxuXHQgICAgICogICAgIHZhciBobWFjID0gQ3J5cHRvSlMuSG1hY1NIQTI1NihtZXNzYWdlLCBrZXkpO1xyXG5cdCAgICAgKi9cclxuXHQgICAgQy5IbWFjU0hBMjU2ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTI1Nik7XHJcblx0fShNYXRoKSk7XHJcblxyXG5cclxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMjU2O1xyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcclxuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcclxuXHJcblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxyXG5cdCAgICB2YXIgVyA9IFtdO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNIQS0xIGhhc2ggYWxnb3JpdGhtLlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xyXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcclxuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcclxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NixcclxuXHQgICAgICAgICAgICAgICAgMHhjM2QyZTFmMFxyXG5cdCAgICAgICAgICAgIF0pO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG5cdCAgICAgICAgICAgIHZhciBIID0gdGhpcy5faGFzaC53b3JkcztcclxuXHJcblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWJsZXNcclxuXHQgICAgICAgICAgICB2YXIgYSA9IEhbMF07XHJcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xyXG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcclxuXHQgICAgICAgICAgICB2YXIgZCA9IEhbM107XHJcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb21wdXRhdGlvblxyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICBpZiAoaSA8IDE2KSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gTVtvZmZzZXQgKyBpXSB8IDA7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgbiA9IFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl07XHJcblx0ICAgICAgICAgICAgICAgICAgICBXW2ldID0gKG4gPDwgMSkgfCAobiA+Pj4gMzEpO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICB2YXIgdCA9ICgoYSA8PCA1KSB8IChhID4+PiAyNykpICsgZSArIFdbaV07XHJcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAofmIgJiBkKSkgKyAweDVhODI3OTk5O1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA0MCkge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDYwKSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKGIgJiBkKSB8IChjICYgZCkpIC0gMHg3MGU0NDMyNDtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKGIgXiBjIF4gZCkgLSAweDM1OWQzZTJhO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICBlID0gZDtcclxuXHQgICAgICAgICAgICAgICAgZCA9IGM7XHJcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XHJcblx0ICAgICAgICAgICAgICAgIGIgPSBhO1xyXG5cdCAgICAgICAgICAgICAgICBhID0gdDtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXHJcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xyXG5cdCAgICAgICAgICAgIEhbMV0gPSAoSFsxXSArIGIpIHwgMDtcclxuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XHJcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xyXG5cdCAgICAgICAgICAgIEhbNF0gPSAoSFs0XSArIGUpIHwgMDtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XHJcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XHJcblxyXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XHJcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xyXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xyXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xyXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcclxuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzID0gZGF0YVdvcmRzLmxlbmd0aCAqIDQ7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXHJcblx0ICAgICAgICAgICAgdGhpcy5fcHJvY2VzcygpO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxyXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYXNoO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBoYXNoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cclxuXHQgICAgICpcclxuXHQgICAgICogQHN0YXRpY1xyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEExKCdtZXNzYWdlJyk7XHJcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcclxuXHQgICAgICovXHJcblx0ICAgIEMuU0hBMSA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTEpO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXHJcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAc3RhdGljXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAqXHJcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNTSEExKG1lc3NhZ2UsIGtleSk7XHJcblx0ICAgICAqL1xyXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xyXG5cdH0oKSk7XHJcblxyXG5cclxuXHRyZXR1cm4gQ3J5cHRvSlMuU0hBMTtcclxuXHJcbn0pKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiAzOCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHRydWUpIHtcclxuXHRcdC8vIENvbW1vbkpTXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyOSkpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdHJldHVybiBDcnlwdG9KUy5IbWFjU0hBMjU2O1xyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDM5ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcblwidXNlIHN0cmljdFwiO1xyXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7LyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTUpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIHBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBKU09OUFRyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XHJcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xyXG5cdC8qIENhbid0IGp1c3QgdXNlIHdpbmRvdy5BYmx5LCBhcyB0aGF0IHdvbid0IGV4aXN0IGlmIHVzaW5nIHRoZSBjb21tb25qcyB2ZXJzaW9uLiAqL1xyXG5cdHZhciBfID0gZ2xvYmFsLl9hYmx5anNfanNvbnAgPSB7fTtcclxuXHJcblx0LyogZXhwcmVzcyBzdHJpcHMgb3V0IHBhcmFudGhlc2VzIGZyb20gdGhlIGNhbGxiYWNrIVxyXG5cdCAqIEtsdWRnZSB0byBzdGlsbCBhbG93IGl0cyByZXNwb25zZXMgdG8gd29yaywgd2hpbGUgbm90IGtlZXBpbmcgdGhlXHJcblx0ICogZnVuY3Rpb24gZm9ybSBmb3Igbm9ybWFsIHVzZSBhbmQgbm90IGNsdXR0ZXJpbmcgd2luZG93LkFibHlcclxuXHQgKiBodHRwczovL2dpdGh1Yi5jb20vZXhwcmVzc2pzL2V4cHJlc3MvYmxvYi81YjRkNGI0YWIxMzI0NzQzNTM0ZmJjZDQ3MDlmNGU3NWJiNGI0ZTlkL2xpYi9yZXNwb25zZS5qcyNMMzA1XHJcblx0ICovXHJcblx0Xy5fID0gZnVuY3Rpb24oaWQpIHsgcmV0dXJuIF9bJ18nICsgaWRdIHx8IG5vb3A7IH07XHJcblx0dmFyIGlkQ291bnRlciA9IDE7XHJcblx0dmFyIGhlYWQgPSBudWxsO1xyXG5cdHZhciBzaG9ydE5hbWUgPSAnanNvbnAnO1xyXG5cclxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cclxuXHRmdW5jdGlvbiBKU09OUFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XHJcblx0XHRwYXJhbXMuc3RyZWFtID0gZmFsc2U7XHJcblx0XHRfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xyXG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XHJcblx0fVxyXG5cdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbmhlcml0cyhKU09OUFRyYW5zcG9ydCwgX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xyXG5cclxuXHRKU09OUFRyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQgJiYgcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5hbGxvd0NvbWV0O1xyXG5cdH07XHJcblx0aWYoSlNPTlBUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xyXG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gSlNPTlBUcmFuc3BvcnQ7XHJcblx0fVxyXG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQpIHtcclxuXHRcdGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xyXG5cdH1cclxuXHJcblx0LyogY29ubmVjdGl2aXR5IGNoZWNrOyBzaW5jZSB0aGlzIGhhcyBhIGhhcmQtY29kZWQgY2FsbGJhY2sgaWQsXHJcblx0ICogd2UganVzdCBtYWtlIHN1cmUgdGhhdCB3ZSBoYW5kbGUgY29uY3VycmVudCByZXF1ZXN0cyAoYnV0IHRoZVxyXG5cdCAqIGNvbm5lY3Rpb25tYW5hZ2VyIHNob3VsZCBlbnN1cmUgdGhpcyBkb2Vzbid0IGhhcHBlbiBhbnl3YXkgKi9cclxuXHR2YXIgY2hlY2tzSW5Qcm9ncmVzcyA9IG51bGw7XHJcblx0Z2xvYmFsLkpTT05QVHJhbnNwb3J0ID0gSlNPTlBUcmFuc3BvcnRcclxuXHJcblx0SlNPTlBUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IEpTT05QVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xyXG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XHJcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xyXG5cdFx0dHJhbnNwb3J0Lm9uKCdwcmVjb25uZWN0JywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnSlNPTlBUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XHJcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xyXG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xyXG5cdFx0fSk7XHJcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xyXG5cdH07XHJcblxyXG5cdEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICdKU09OUFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcclxuXHR9O1xyXG5cclxuXHR2YXIgY3JlYXRlUmVxdWVzdCA9IEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24odXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XHJcblx0XHQvKiBKU09OUCByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXHJcblx0XHQgKiB0cmFuc3BvcnQsIG9yIHdpdGggdGltZW91dHMgcGFzc2VkIGluIChmb3Igd2hlbiB1c2VkIGJ5IGEgcmVzdCBjbGllbnQpLFxyXG5cdFx0ICogb3IgY29tcGxldGVseSBzdGFuZGFsb25lLiAgVXNlIHRoZSBhcHByb3ByaWF0ZSB0aW1lb3V0cyBpbiBlYWNoIGNhc2UgKi9cclxuXHRcdHRpbWVvdXRzID0gKHRoaXMgJiYgdGhpcy50aW1lb3V0cykgfHwgdGltZW91dHMgfHwgX2NvbW1vbl9saWJfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlRJTUVPVVRTO1xyXG5cdFx0cmV0dXJuIG5ldyBSZXF1ZXN0KHVuZGVmaW5lZCwgdXJpLCBoZWFkZXJzLCBfY29tbW9uX2xpYl91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0uY29weShwYXJhbXMpLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gUmVxdWVzdChpZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XHJcblx0XHRfY29tbW9uX2xpYl91dGlsX2V2ZW50ZW1pdHRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcyk7XHJcblx0XHRpZihpZCA9PT0gdW5kZWZpbmVkKSBpZCA9IGlkQ291bnRlcisrO1xyXG5cdFx0dGhpcy5pZCA9IGlkO1xyXG5cdFx0dGhpcy51cmkgPSB1cmk7XHJcblx0XHR0aGlzLnBhcmFtcyA9IHBhcmFtcyB8fCB7fTtcclxuXHRcdHRoaXMucGFyYW1zLnJuZCA9IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5jaGVhcFJhbmRTdHIoKTtcclxuXHRcdGlmKGhlYWRlcnMpIHtcclxuXHRcdFx0LyogSlNPTlAgZG9lc24ndCBhbGxvdyBoZWFkZXJzLiBDaGVycnktcGljayBhIGNvdXBsZSB0byB0dXJuIGludG8gcXMgcGFyYW1zICovXHJcblx0XHRcdGlmKGhlYWRlcnNbJ1gtQWJseS1WZXJzaW9uJ10pIHRoaXMucGFyYW1zLnYgPSBoZWFkZXJzWydYLUFibHktVmVyc2lvbiddO1xyXG5cdFx0XHRpZihoZWFkZXJzWydBYmx5LUFnZW50J10pIHRoaXMucGFyYW1zLmFnZW50ID0gaGVhZGVyc1snQWJseS1BZ2VudCddO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5ib2R5ID0gYm9keTtcclxuXHRcdHRoaXMubWV0aG9kID0gbWV0aG9kO1xyXG5cdFx0dGhpcy5yZXF1ZXN0TW9kZSA9IHJlcXVlc3RNb2RlO1xyXG5cdFx0dGhpcy50aW1lb3V0cyA9IHRpbWVvdXRzO1xyXG5cdFx0dGhpcy5yZXF1ZXN0Q29tcGxldGUgPSBmYWxzZTtcclxuXHR9XHJcblx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFJlcXVlc3QsIF9jb21tb25fbGliX3V0aWxfZXZlbnRlbWl0dGVyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0pO1xyXG5cclxuXHRSZXF1ZXN0LnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgaWQgPSB0aGlzLmlkLFxyXG5cdFx0XHRib2R5ID0gdGhpcy5ib2R5LFxyXG5cdFx0XHRtZXRob2QgPSB0aGlzLm1ldGhvZCxcclxuXHRcdFx0dXJpID0gdGhpcy51cmksXHJcblx0XHRcdHBhcmFtcyA9IHRoaXMucGFyYW1zLFxyXG5cdFx0XHRzZWxmID0gdGhpcztcclxuXHJcblx0XHRwYXJhbXMuY2FsbGJhY2sgPSAnX2FibHlqc19qc29ucC5fKCcgKyBpZCArICcpJztcclxuXHJcblx0XHRwYXJhbXMuZW52ZWxvcGUgPSAnanNvbnAnO1xyXG5cdFx0aWYoYm9keSkge1xyXG5cdFx0XHRwYXJhbXMuYm9keSA9IGJvZHk7XHJcblx0XHR9XHJcblx0XHRpZihtZXRob2QgJiYgbWV0aG9kICE9PSAnZ2V0Jykge1xyXG5cdFx0XHRwYXJhbXMubWV0aG9kID0gbWV0aG9kO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xyXG5cdFx0dmFyIHNyYyA9IHVyaSArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XHJcblx0XHRzY3JpcHQuc3JjID0gc3JjO1xyXG5cdFx0aWYoc2NyaXB0LnNyYy5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSAhPT0gc3JjLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdKSB7XHJcblx0XHRcdC8qIFRoZSBzcmMgaGFzIGJlZW4gdHJ1bmNhdGVkLiBDYW4ndCBhYm9ydCwgYnV0IGNhbiBhdCBsZWFzdCBlbWl0IGFuXHJcblx0XHRcdCAqIGVycm9yIHNvIHRoZSB1c2VyIGtub3dzIHdoYXQncyBnb25lIHdyb25nLiAoQ2FuJ3QgY29tcGFyZSBzdHJpbmdzXHJcblx0XHRcdCAqIGRpcmVjdGx5IGFzIHNyYyBtYXkgaGF2ZSBhIHBvcnQsIHNjcmlwdC5zcmMgd29uJ3QpICovXHJcblx0XHRcdF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX0VSUk9SLCAnSlNPTlAgUmVxdWVzdC5leGVjKCknLCAnV2FybmluZzogdGhlIGJyb3dzZXIgYXBwZWFycyB0byBoYXZlIHRydW5jYXRlZCB0aGUgc2NyaXB0IFVSSS4gVGhpcyB3aWxsIGxpa2VseSByZXN1bHQgaW4gdGhlIHJlcXVlc3QgZmFpbGluZyBkdWUgdG8gYW4gdW5wYXJzZWFibGUgYm9keSBwYXJhbScpO1xyXG5cdFx0fVxyXG5cdFx0c2NyaXB0LmFzeW5jID0gdHJ1ZTtcclxuXHRcdHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XHJcblx0XHRzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XHJcblx0XHRzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRzZWxmLmNvbXBsZXRlKG5ldyBfY29tbW9uX2xpYl90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXSgnSlNPTlAgc2NyaXB0IGVycm9yIChldmVudDogJyArIF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0KGVycikgKyAnKScsIG51bGwsIDQwMCkpO1xyXG5cdFx0fTtcclxuXHJcblx0XHRfWydfJyArIGlkXSA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcclxuXHRcdFx0aWYobWVzc2FnZS5zdGF0dXNDb2RlKSB7XHJcblx0XHRcdFx0LyogSGFuZGxlIGFzIGVudmVsb3BlZCBqc29ucCwgYXMgYWxsIGpzb25wIHRyYW5zcG9ydCB1c2VzIHNob3VsZCBiZSAqL1xyXG5cdFx0XHRcdHZhciByZXNwb25zZSA9IG1lc3NhZ2UucmVzcG9uc2U7XHJcblx0XHRcdFx0aWYobWVzc2FnZS5zdGF0dXNDb2RlID09IDIwNCkge1xyXG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xyXG5cdFx0XHRcdH0gZWxzZSBpZighcmVzcG9uc2UpIHtcclxuXHRcdFx0XHRcdHNlbGYuY29tcGxldGUobmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdJbnZhbGlkIHNlcnZlciByZXNwb25zZTogbm8gZW52ZWxvcGUgZGV0ZWN0ZWQnLCBudWxsLCA1MDApKTtcclxuXHRcdFx0XHR9IGVsc2UgaWYobWVzc2FnZS5zdGF0dXNDb2RlIDwgNDAwIHx8IF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pc0FycmF5KHJlc3BvbnNlKSkge1xyXG5cdFx0XHRcdFx0LyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxyXG5cdFx0XHRcdFx0ICogaXQgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXHJcblx0XHRcdFx0XHQgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXHJcblx0XHRcdFx0XHQgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xyXG5cdFx0XHRcdFx0c2VsZi5jb21wbGV0ZShudWxsLCByZXNwb25zZSwgbWVzc2FnZS5oZWFkZXJzLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHR2YXIgZXJyID0gcmVzcG9uc2UuZXJyb3IgfHwgbmV3IF9jb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcicsIG51bGwsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XHJcblx0XHRcdFx0XHRzZWxmLmNvbXBsZXRlKGVycik7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdC8qIEhhbmRsZSBhcyBub24tZW52ZWxvcGVkIC0tIGFzIHdpbGwgYmUgZWcgZnJvbSBhIGN1c3RvbWVyJ3MgYXV0aFVybCBzZXJ2ZXIgKi9cclxuXHRcdFx0XHRzZWxmLmNvbXBsZXRlKG51bGwsIG1lc3NhZ2UpO1xyXG5cdFx0XHR9XHJcblx0XHR9O1xyXG5cclxuXHRcdHZhciB0aW1lb3V0ID0gKHRoaXMucmVxdWVzdE1vZGUgPT0gX2NvbW1vbl9saWJfdHJhbnNwb3J0X2NvbWV0dHJhbnNwb3J0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0uUkVRX1NFTkQpID8gdGhpcy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiB0aGlzLnRpbWVvdXRzLnJlY3ZUaW1lb3V0O1xyXG5cdFx0dGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHNlbGYuYWJvcnQoKTsgfSwgdGltZW91dCk7XHJcblx0XHRoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XHJcblx0fTtcclxuXHJcblx0UmVxdWVzdC5wcm90b3R5cGUuY29tcGxldGUgPSBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHN0YXR1c0NvZGUpIHtcclxuXHRcdGhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xyXG5cdFx0aWYoIXRoaXMucmVxdWVzdENvbXBsZXRlKSB7XHJcblx0XHRcdHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcclxuXHRcdFx0dmFyIGNvbnRlbnRUeXBlO1xyXG5cdFx0XHRpZihib2R5KSB7XHJcblx0XHRcdFx0Y29udGVudFR5cGUgPSAodHlwZW9mKGJvZHkpID09ICdzdHJpbmcnKSA/ICd0ZXh0L3BsYWluJyA6ICdhcHBsaWNhdGlvbi9qc29uJztcclxuXHRcdFx0XHRoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGNvbnRlbnRUeXBlO1xyXG5cdFx0XHRcdHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR0aGlzLmVtaXQoJ2NvbXBsZXRlJywgZXJyLCBib2R5LCBoZWFkZXJzLCAvKiB1bnBhY2tlZDogKi8gdHJ1ZSwgc3RhdHVzQ29kZSk7XHJcblx0XHRcdHRoaXMuZGlzcG9zZSgpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLmRpc3Bvc2UoKTtcclxuXHR9O1xyXG5cclxuXHRSZXF1ZXN0LnByb3RvdHlwZS5kaXNwb3NlID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgdGltZXIgPSB0aGlzLnRpbWVyO1xyXG5cdFx0aWYodGltZXIpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHRpbWVyKTtcclxuXHRcdFx0dGhpcy50aW1lciA9IG51bGw7XHJcblx0XHR9XHJcblx0XHR2YXIgc2NyaXB0ID0gdGhpcy5zY3JpcHQ7XHJcblx0XHRpZihzY3JpcHQucGFyZW50Tm9kZSkgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcclxuXHRcdGRlbGV0ZSBfW3RoaXMuaWRdO1xyXG5cdFx0dGhpcy5lbWl0KCdkaXNwb3NlZCcpO1xyXG5cdH07XHJcblxyXG5cdGlmKHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBTdXBwb3J0ZWQgJiYgIXBsYXRmb3JtX2h0dHBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SZXF1ZXN0KSB7XHJcblx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uUmVxdWVzdCA9IGZ1bmN0aW9uKG1ldGhvZCwgcmVzdCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIGNhbGxiYWNrKSB7XHJcblx0XHRcdHZhciByZXEgPSBjcmVhdGVSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBfY29tbW9uX2xpYl90cmFuc3BvcnRfY29tZXR0cmFuc3BvcnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5SRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMsIG1ldGhvZCk7XHJcblx0XHRcdHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcclxuXHRcdFx0X2NvbW1vbl9saWJfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRcdHJlcS5leGVjKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0XHRyZXR1cm4gcmVxO1xyXG5cdFx0fTtcclxuXHJcblx0XHRwbGF0Zm9ybV9odHRwX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0XHR2YXIgdXBVcmwgPSBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uanNvbnBJbnRlcm5ldFVwVXJsO1xyXG5cclxuXHRcdFx0aWYoY2hlY2tzSW5Qcm9ncmVzcykge1xyXG5cdFx0XHRcdGNoZWNrc0luUHJvZ3Jlc3MucHVzaChjYWxsYmFjayk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNoZWNrc0luUHJvZ3Jlc3MgPSBbY2FsbGJhY2tdO1xyXG5cdFx0XHRfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIHVwVXJsKTtcclxuXHJcblx0XHRcdHZhciByZXEgPSBuZXcgUmVxdWVzdCgnaXNUaGVJbnRlcm5ldFVwJywgdXBVcmwsIG51bGwsIG51bGwsIG51bGwsIF9jb21tb25fbGliX3RyYW5zcG9ydF9jb21ldHRyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLlJFUV9TRU5ELCBfY29tbW9uX2xpYl91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0uVElNRU9VVFMpO1xyXG5cdFx0XHRyZXEub25jZSgnY29tcGxldGUnLCBmdW5jdGlvbihlcnIsIHJlc3BvbnNlKSB7XHJcblx0XHRcdFx0dmFyIHJlc3VsdCA9ICFlcnIgJiYgcmVzcG9uc2U7XHJcblx0XHRcdFx0X2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlDUk8sICcoSlNPTlApSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XHJcblx0XHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGNoZWNrc0luUHJvZ3Jlc3MubGVuZ3RoOyBpKyspIGNoZWNrc0luUHJvZ3Jlc3NbaV0obnVsbCwgcmVzdWx0KTtcclxuXHRcdFx0XHRjaGVja3NJblByb2dyZXNzID0gbnVsbDtcclxuXHRcdFx0fSk7XHJcblx0XHRcdF9jb21tb25fbGliX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5uZXh0VGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRyZXEuZXhlYygpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gSlNPTlBUcmFuc3BvcnQ7XHJcbn07XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJhXCJdID0gKEpTT05QVHJhbnNwb3J0KTtcclxuXHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSkpXHJcblxyXG4vKioqLyB9KSxcclxuLyogNDAgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcclxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XHJcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBmdW5jdGlvbihjb25uZWN0aW9uTWFuYWdlcikge1xyXG5cdHZhciBXZWJTb2NrZXQgPSBwbGF0Zm9ybV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLldlYlNvY2tldDtcclxuXHR2YXIgc2hvcnROYW1lID0gJ3dlYl9zb2NrZXQnO1xyXG5cclxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cclxuXHRmdW5jdGlvbiBXZWJTb2NrZXRUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xyXG5cdFx0dGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XHJcblx0XHQvKiBJZiBpcyBhIGJyb3dzZXIsIGNhbid0IGRldGVjdCBwaW5ncywgc28gcmVxdWVzdCBwcm90b2NvbCBoZWFydGJlYXRzICovXHJcblx0XHRwYXJhbXMuaGVhcnRiZWF0cyA9IHBsYXRmb3JtX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bLyogZGVmYXVsdCAqLyBcImFcIl0udXNlUHJvdG9jb2xIZWFydGJlYXRzO1xyXG5cdFx0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XHJcblx0XHR0aGlzLndzSG9zdCA9IF91dGlsX2RlZmF1bHRzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bLyogZGVmYXVsdCAqLyBcImFcIl0uZ2V0SG9zdChwYXJhbXMub3B0aW9ucywgcGFyYW1zLmhvc3QsIHRydWUpO1xyXG5cdH1cclxuXHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmluaGVyaXRzKFdlYlNvY2tldFRyYW5zcG9ydCwgX3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdKTtcclxuXHJcblx0V2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4gISFXZWJTb2NrZXQ7XHJcblx0fTtcclxuXHJcblx0aWYoV2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpXHJcblx0XHRjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBXZWJTb2NrZXRUcmFuc3BvcnQ7XHJcblxyXG5cdFdlYlNvY2tldFRyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgV2ViU29ja2V0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xyXG5cdFx0dmFyIGVycm9yQ2IgPSBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soe2V2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyfSk7IH07XHJcblx0XHR0cmFuc3BvcnQub24oWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xyXG5cdFx0dHJhbnNwb3J0Lm9uKCd3c29wZW4nLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC50cnlDb25uZWN0KCknLCAndmlhYmxlIHRyYW5zcG9ydCAnICsgdHJhbnNwb3J0KTtcclxuXHRcdFx0dHJhbnNwb3J0Lm9mZihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XHJcblx0XHR9KTtcclxuXHRcdHRyYW5zcG9ydC5jb25uZWN0KCk7XHJcblx0fTtcclxuXHJcblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVXZWJTb2NrZXQgPSBmdW5jdGlvbih1cmksIGNvbm5lY3RQYXJhbXMpIHtcclxuXHRcdHRoaXMudXJpID0gdXJpICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS50b1F1ZXJ5U3RyaW5nKGNvbm5lY3RQYXJhbXMpXHJcblx0XHRyZXR1cm4gbmV3IFdlYlNvY2tldCh0aGlzLnVyaSk7XHJcblx0fTtcclxuXHJcblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICdXZWJTb2NrZXRUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy51cmk7XHJcblx0fTtcclxuXHJcblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xyXG5cdFx0X3RyYW5zcG9ydF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXMsIHBhcmFtcyA9IHRoaXMucGFyYW1zLCBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XHJcblx0XHR2YXIgd3NTY2hlbWUgPSBvcHRpb25zLnRscyA/ICd3c3M6Ly8nIDogJ3dzOi8vJztcclxuXHRcdHZhciB3c1VyaSA9IHdzU2NoZW1lICsgdGhpcy53c0hvc3QgKyAnOicgKyBfdXRpbF9kZWZhdWx0c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmdldFBvcnQob3B0aW9ucykgKyAnLyc7XHJcblx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyB3c1VyaSk7XHJcblx0XHR0aGlzLmF1dGguZ2V0QXV0aFBhcmFtcyhmdW5jdGlvbihlcnIsIGF1dGhQYXJhbXMpIHtcclxuXHRcdFx0aWYoc2VsZi5pc0Rpc3Bvc2VkKSB7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBwYXJhbVN0ciA9ICcnOyBmb3IodmFyIHBhcmFtIGluIGF1dGhQYXJhbXMpIHBhcmFtU3RyICs9ICcgJyArIHBhcmFtICsgJzogJyArIGF1dGhQYXJhbXNbcGFyYW1dICsgJzsnO1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdhdXRoUGFyYW1zOicgKyBwYXJhbVN0ciArICcgZXJyOiAnICsgZXJyKTtcclxuXHRcdFx0aWYoZXJyKSB7XHJcblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGVycik7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdHZhciBjb25uZWN0UGFyYW1zID0gcGFyYW1zLmdldENvbm5lY3RQYXJhbXMoYXV0aFBhcmFtcyk7XHJcblx0XHRcdHRyeSB7XHJcblx0XHRcdFx0dmFyIHdzQ29ubmVjdGlvbiA9IHNlbGYud3NDb25uZWN0aW9uID0gc2VsZi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpO1xyXG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5iaW5hcnlUeXBlID0gcGxhdGZvcm1fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5iaW5hcnlUeXBlO1xyXG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbm9wZW4gPSBmdW5jdGlvbigpIHsgc2VsZi5vbldzT3BlbigpOyB9O1xyXG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbmNsb3NlID0gZnVuY3Rpb24oZXYpIHsgc2VsZi5vbldzQ2xvc2UoZXYpOyB9O1xyXG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldikgeyBzZWxmLm9uV3NEYXRhKGV2LmRhdGEpOyB9O1xyXG5cdFx0XHRcdHdzQ29ubmVjdGlvbi5vbmVycm9yID0gZnVuY3Rpb24oZXYpIHsgc2VsZi5vbldzRXJyb3IoZXYpOyB9O1xyXG5cdFx0XHRcdGlmKHdzQ29ubmVjdGlvbi5vbikge1xyXG5cdFx0XHRcdFx0Lyogbm9kZTsgYnJvd3NlcnMgY3VycmVudGx5IGRvbid0IGhhdmUgYSBnZW5lcmFsIGV2ZW50ZW1pdHRlciBhbmQgY2FuJ3QgZGV0ZWN0XHJcblx0XHRcdFx0XHQgKiBwaW5ncy4gQWxzbywgbm8gbmVlZCB0byByZXBseSB3aXRoIGEgcG9uZyBleHBsaWNpdGx5LCB3cyBsaWIgaGFuZGxlcyB0aGF0ICovXHJcblx0XHRcdFx0XHR3c0Nvbm5lY3Rpb24ub24oJ3BpbmcnLCBmdW5jdGlvbigpIHsgc2VsZi5vbkFjdGl2aXR5KCk7IH0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gY3JlYXRpbmcgd2Vic29ja2V0OiBlcnIgPSAnICsgKGUuc3RhY2sgfHwgZS5tZXNzYWdlKSk7XHJcblx0XHRcdFx0c2VsZi5kaXNjb25uZWN0KGUpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHR2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XHJcblx0XHRpZighd3NDb25uZWN0aW9uKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgJ05vIHNvY2tldCBjb25uZWN0aW9uJyk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHRyeSB7XHJcblx0XHRcdHdzQ29ubmVjdGlvbi5zZW5kKF90eXBlc19wcm90b2NvbG1lc3NhZ2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5zZXJpYWxpemUobWVzc2FnZSwgdGhpcy5wYXJhbXMuZm9ybWF0KSk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdHZhciBtc2cgPSAnRXhjZXB0aW9uIGZyb20gd3MgY29ubmVjdGlvbiB3aGVuIHRyeWluZyB0byBzZW5kOiAnICsgX3V0aWxfdXRpbHNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5pbnNwZWN0RXJyb3IoZSk7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgbXNnKTtcclxuXHRcdFx0LyogRG9uJ3QgdHJ5IHRvIHJlcXVlc3QgYSBkaXNjb25uZWN0LCB0aGF0J2xsIGp1c3QgaW52b2x2ZSBzZW5kaW5nIGRhdGFcclxuXHRcdFx0ICogZG93biB0aGUgd2Vic29ja2V0IGFnYWluLiBKdXN0IGZpbmlzaCB0aGUgdHJhbnNwb3J0LiAqL1xyXG5cdFx0XHR0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDUwMDAwLCA1MDApKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NEYXRhID0gZnVuY3Rpb24oZGF0YSkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ2RhdGEgcmVjZWl2ZWQ7IGxlbmd0aCA9ICcgKyBkYXRhLmxlbmd0aCArICc7IHR5cGUgPSAnICsgdHlwZW9mKGRhdGEpKTtcclxuXHRcdHRyeSB7XHJcblx0XHRcdHRoaXMub25Qcm90b2NvbE1lc3NhZ2UoX3R5cGVzX3Byb3RvY29sbWVzc2FnZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmRlc2VyaWFsaXplKGRhdGEsIHRoaXMuZm9ybWF0KSk7XHJcblx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc0RhdGEoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBoYW5kaW5nIGNoYW5uZWwgbWVzc2FnZTogJyArIGUuc3RhY2spO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc09wZW4gPSBmdW5jdGlvbigpIHtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKScsICdvcGVuZWQgV2ViU29ja2V0Jyk7XHJcblx0XHR0aGlzLmVtaXQoJ3dzb3BlbicpO1xyXG5cdH07XHJcblxyXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0Nsb3NlID0gZnVuY3Rpb24oZXYpIHtcclxuXHRcdHZhciB3YXNDbGVhbiwgY29kZSwgcmVhc29uO1xyXG5cdFx0aWYodHlwZW9mKGV2KSA9PSAnb2JqZWN0Jykge1xyXG5cdFx0XHQvKiBXM0Mgc3BlYy1jb21wYXRpYmxlICovXHJcblx0XHRcdHdhc0NsZWFuID0gZXYud2FzQ2xlYW47XHJcblx0XHRcdGNvZGUgPSBldi5jb2RlO1xyXG5cdFx0fSBlbHNlIC8qaWYodHlwZW9mKGV2KSA9PSAnbnVtYmVyJykqLyB7XHJcblx0XHRcdC8qIHdzIGluIG5vZGUgKi9cclxuXHRcdFx0Y29kZSA9IGV2O1xyXG5cdFx0XHR3YXNDbGVhbiA9IChjb2RlID09IDEwMDApO1xyXG5cdFx0fVxyXG5cdFx0ZGVsZXRlIHRoaXMud3NDb25uZWN0aW9uO1xyXG5cdFx0aWYod2FzQ2xlYW4pIHtcclxuXHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKScsICdDbGVhbmx5IGNsb3NlZCBXZWJTb2NrZXQnKTtcclxuXHRcdFx0dmFyIGVyciA9IG5ldyBfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X19bLyogZGVmYXVsdCAqLyBcImFcIl0oJ1dlYnNvY2tldCBjbG9zZWQnLCA4MDAwMywgNDAwKTtcclxuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR2YXIgbXNnID0gJ1VuY2xlYW4gZGlzY29ubmVjdGlvbiBvZiBXZWJTb2NrZXQgOyBjb2RlID0gJyArIGNvZGUsXHJcblx0XHRcdFx0ZXJyID0gbmV3IF90eXBlc19lcnJvcmluZm9fX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfX1svKiBkZWZhdWx0ICovIFwiYVwiXShtc2csIDgwMDAzLCA0MDApO1xyXG5cdFx0XHRfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5sb2dBY3Rpb24oX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0uTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NDbG9zZSgpJywgbXNnKTtcclxuXHRcdFx0dGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XHJcblx0XHR9XHJcblx0XHR0aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XHJcblx0fTtcclxuXHJcblx0V2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzRXJyb3IgPSBmdW5jdGlvbihlcnIpIHtcclxuXHRcdF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLmxvZ0FjdGlvbihfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX1svKiBkZWZhdWx0ICovIFwiYVwiXS5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpJywgJ0Vycm9yIGZyb20gV2ViU29ja2V0OiAnICsgZXJyLm1lc3NhZ2UpO1xyXG5cdFx0LyogV2FpdCBhIHRpY2sgYmVmb3JlIGFib3J0aW5nOiBpZiB0aGUgd2Vic29ja2V0IHdhcyBjb25uZWN0ZWQsIHRoaXMgZXZlbnRcclxuXHRcdCAqIHdpbGwgYmUgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgYW4gb25jbG9zZSBldmVudCB3aXRoIGEgY2xvc2UgY29kZS4gQWxsb3dcclxuXHRcdCAqIHRoYXQgdG8gY2xvc2UgaXQgKHNvIHdlIHNlZSB0aGUgY2xvc2UgY29kZSkgcmF0aGVyIHRoYW4gYW50aWNpcGF0aW5nIGl0ICovXHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRfdXRpbF91dGlsc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XHJcblx0XHR0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xyXG5cdFx0dmFyIHdzQ29ubmVjdGlvbiA9IHRoaXMud3NDb25uZWN0aW9uO1xyXG5cdFx0aWYod3NDb25uZWN0aW9uKSB7XHJcblx0XHRcdC8qIElnbm9yZSBhbnkgbWVzc2FnZXMgdGhhdCBjb21lIHRocm91Z2ggYWZ0ZXIgZGlzcG9zZSgpIGlzIGNhbGxlZCBidXQgYmVmb3JlXHJcblx0XHRcdCAqIHdlYnNvY2tldCBpcyBhY3R1YWxseSBjbG9zZWQuIChtb3N0bHkgd291bGQgYmUgaGFybWxlc3MsIGJ1dCBpZiBpdCdzIGFcclxuXHRcdFx0ICogQ09OTkVDVEVELCBpdCdsbCByZS10aWNrIGlzQ29ubmVjdGVkIGFuZCBjYXVzZSBhbGwgc29ydHMgb2YgaGF2b2MpICovXHJcblx0XHRcdHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHt9O1xyXG5cdFx0XHRkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XHJcblx0XHRcdC8qIGRlZmVyIHVudGlsIHRoZSBuZXh0IGV2ZW50IGxvb3AgY3ljbGUgYmVmb3JlIGNsb3NpbmcgdGhlIHNvY2tldCxcclxuXHRcdFx0ICogZ2l2aW5nIHNvbWUgaW1wbGVtZW50YXRpb25zIHRoZSBvcHBvcnR1bml0eSB0byBzZW5kIGFueSBvdXRzdGFuZGluZyBjbG9zZSBtZXNzYWdlICovXHJcblx0XHRcdF91dGlsX3V0aWxzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bLyogZGVmYXVsdCAqLyBcImFcIl0ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0X3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bLyogZGVmYXVsdCAqLyBcImFcIl0ubG9nQWN0aW9uKF91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fWy8qIGRlZmF1bHQgKi8gXCJhXCJdLkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnY2xvc2luZyB3ZWJzb2NrZXQnKTtcclxuXHRcdFx0XHR3c0Nvbm5lY3Rpb24uY2xvc2UoKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFdlYlNvY2tldFRyYW5zcG9ydDtcclxufTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gX193ZWJwYWNrX2V4cG9ydHNfX1tcImFcIl0gPSAoV2ViU29ja2V0VHJhbnNwb3J0KTtcclxuXHJcblxyXG4vKioqLyB9KSxcclxuLyogNDEgKi9cclxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xyXG5cclxuXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L2pzb25wdHJhbnNwb3J0LmpzXHJcbnZhciBqc29ucHRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMzkpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC91dGlscy5qc1xyXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9sb2dnZXIuanNcclxudmFyIGxvZ2dlciA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9mcmFnbWVudHMvcGxhdGZvcm0tYnJvd3Nlci5qc1xyXG52YXIgcGxhdGZvcm1fYnJvd3NlciA9IF9fd2VicGFja19yZXF1aXJlX18oMyk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi90cmFuc3BvcnQvY29tZXR0cmFuc3BvcnQuanNcclxudmFyIGNvbWV0dHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L3hocnJlcXVlc3QuanNcclxudmFyIHhocnJlcXVlc3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KTtcclxuXHJcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L3hocnBvbGxpbmd0cmFuc3BvcnQuanNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIHhocnBvbGxpbmd0cmFuc3BvcnRfWEhSUG9sbGluZ1RyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XHJcblx0dmFyIHNob3J0TmFtZSA9ICd4aHJfcG9sbGluZyc7XHJcblxyXG5cdGZ1bmN0aW9uIFhIUlBvbGxpbmdUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykge1xyXG5cdFx0cGFyYW1zLnN0cmVhbSA9IGZhbHNlO1xyXG5cdFx0Y29tZXR0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcclxuXHRcdHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xyXG5cdH1cclxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhYSFJQb2xsaW5nVHJhbnNwb3J0LCBjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXSk7XHJcblxyXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbG93Q29tZXQ7XHJcblx0fTtcclxuXHJcblx0WEhSUG9sbGluZ1RyYW5zcG9ydC50cnlDb25uZWN0ID0gZnVuY3Rpb24oY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdHZhciB0cmFuc3BvcnQgPSBuZXcgWEhSUG9sbGluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcclxuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xyXG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcclxuXHRcdHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdYSFJQb2xsaW5nVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xyXG5cdFx0XHR0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcclxuXHRcdH0pO1xyXG5cdFx0dHJhbnNwb3J0LmNvbm5lY3QoKTtcclxuXHR9O1xyXG5cclxuXHRYSFJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuICdYSFJQb2xsaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xyXG5cdH07XHJcblxyXG5cdFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbih1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUpIHtcclxuXHRcdHJldHVybiB4aHJyZXF1ZXN0W1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aGlzLnRpbWVvdXRzKTtcclxuXHR9O1xyXG5cclxuXHRpZih0eXBlb2YoY29ubmVjdGlvbk1hbmFnZXIpICE9PSAndW5kZWZpbmVkJyAmJiBYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcclxuXHRcdGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFhIUlBvbGxpbmdUcmFuc3BvcnQ7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gWEhSUG9sbGluZ1RyYW5zcG9ydDtcclxufTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHhocnBvbGxpbmd0cmFuc3BvcnQgPSAoeGhycG9sbGluZ3RyYW5zcG9ydF9YSFJQb2xsaW5nVHJhbnNwb3J0KTtcclxuXHJcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdHJhbnNwb3J0L3hocnN0cmVhbWluZ3RyYW5zcG9ydC5qc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgeGhyc3RyZWFtaW5ndHJhbnNwb3J0X1hIUlN0cmVhbWluZ1RyYW5zcG9ydCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XHJcblx0dmFyIHNob3J0TmFtZSA9ICd4aHJfc3RyZWFtaW5nJztcclxuXHJcblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXHJcblx0ZnVuY3Rpb24gWEhSU3RyZWFtaW5nVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcclxuXHRcdGNvbWV0dHJhbnNwb3J0W1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XHJcblx0XHR0aGlzLnNob3J0TmFtZSA9IHNob3J0TmFtZTtcclxuXHR9XHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoWEhSU3RyZWFtaW5nVHJhbnNwb3J0LCBjb21ldHRyYW5zcG9ydFtcImFcIiAvKiBkZWZhdWx0ICovXSk7XHJcblxyXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ueGhyU3VwcG9ydGVkICYmIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc3RyZWFtaW5nU3VwcG9ydGVkICYmIHBsYXRmb3JtX2Jyb3dzZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsb3dDb21ldDtcclxuXHR9O1xyXG5cclxuXHRYSFJTdHJlYW1pbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uKGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgdHJhbnNwb3J0ID0gbmV3IFhIUlN0cmVhbWluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKTtcclxuXHRcdHZhciBlcnJvckNiID0gZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKHtldmVudDogdGhpcy5ldmVudCwgZXJyb3I6IGVycn0pOyB9O1xyXG5cdFx0dHJhbnNwb3J0Lm9uKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcclxuXHRcdHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uKCkge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdYSFJTdHJlYW1pbmdUcmFuc3BvcnQudHJ5Q29ubmVjdCgpJywgJ3ZpYWJsZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCk7XHJcblx0XHRcdHRyYW5zcG9ydC5vZmYoWydmYWlsZWQnLCAnZGlzY29ubmVjdGVkJ10sIGVycm9yQ2IpO1xyXG5cdFx0XHRjYWxsYmFjayhudWxsLCB0cmFuc3BvcnQpO1xyXG5cdFx0fSk7XHJcblx0XHR0cmFuc3BvcnQuY29ubmVjdCgpO1xyXG5cdH07XHJcblxyXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiAnWEhSU3RyZWFtaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xyXG5cdH07XHJcblxyXG5cdFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlUmVxdWVzdCA9IGZ1bmN0aW9uKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSkge1xyXG5cdFx0cmV0dXJuIHhocnJlcXVlc3RbXCJhXCIgLyogZGVmYXVsdCAqL10uY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRoaXMudGltZW91dHMpO1xyXG5cdH07XHJcblxyXG5cdGlmKHR5cGVvZihjb25uZWN0aW9uTWFuYWdlcikgIT09ICd1bmRlZmluZWQnICYmIFhIUlN0cmVhbWluZ1RyYW5zcG9ydC5pc0F2YWlsYWJsZSgpKSB7XHJcblx0XHRjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gWEhSU3RyZWFtaW5nVHJhbnNwb3J0O1xyXG59O1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgeGhyc3RyZWFtaW5ndHJhbnNwb3J0ID0gKHhocnN0cmVhbWluZ3RyYW5zcG9ydF9YSFJTdHJlYW1pbmdUcmFuc3BvcnQpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9icm93c2VyL2xpYi90cmFuc3BvcnQvaW5kZXguanNcclxuXHJcblxyXG5cclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGxpYl90cmFuc3BvcnQgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiYVwiXSA9IChbXHJcbiAganNvbnB0cmFuc3BvcnRbXCJhXCIgLyogZGVmYXVsdCAqL10sXHJcbiAgeGhycG9sbGluZ3RyYW5zcG9ydCxcclxuICB4aHJzdHJlYW1pbmd0cmFuc3BvcnRcclxuXSk7XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQyICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHt2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmKSB8fFxyXG4gICAgICAgICAgICB3aW5kb3c7XHJcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcclxuXHJcbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXHJcblxyXG5leHBvcnRzLnNldFRpbWVvdXQgPSBmdW5jdGlvbigpIHtcclxuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcclxufTtcclxuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xyXG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XHJcbn07XHJcbmV4cG9ydHMuY2xlYXJUaW1lb3V0ID1cclxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xyXG4gIGlmICh0aW1lb3V0KSB7XHJcbiAgICB0aW1lb3V0LmNsb3NlKCk7XHJcbiAgfVxyXG59O1xyXG5cclxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xyXG4gIHRoaXMuX2lkID0gaWQ7XHJcbiAgdGhpcy5fY2xlYXJGbiA9IGNsZWFyRm47XHJcbn1cclxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xyXG5UaW1lb3V0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xyXG59O1xyXG5cclxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXHJcbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcclxuICBjbGVhclRpbWVvdXQoaXRlbS5faWRsZVRpbWVvdXRJZCk7XHJcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2VjcztcclxufTtcclxuXHJcbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XHJcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xyXG4gIGl0ZW0uX2lkbGVUaW1lb3V0ID0gLTE7XHJcbn07XHJcblxyXG5leHBvcnRzLl91bnJlZkFjdGl2ZSA9IGV4cG9ydHMuYWN0aXZlID0gZnVuY3Rpb24oaXRlbSkge1xyXG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcclxuXHJcbiAgdmFyIG1zZWNzID0gaXRlbS5faWRsZVRpbWVvdXQ7XHJcbiAgaWYgKG1zZWNzID49IDApIHtcclxuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcclxuICAgICAgaWYgKGl0ZW0uX29uVGltZW91dClcclxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcclxuICAgIH0sIG1zZWNzKTtcclxuICB9XHJcbn07XHJcblxyXG4vLyBzZXRpbW1lZGlhdGUgYXR0YWNoZXMgaXRzZWxmIHRvIHRoZSBnbG9iYWwgb2JqZWN0XHJcbl9fd2VicGFja19yZXF1aXJlX18oNDMpO1xyXG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcclxuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcclxuLy8gYHNldGltbWVkaWF0ZWAgbGlicmFyeS5cclxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XHJcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLnNldEltbWVkaWF0ZSk7XHJcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuY2xlYXJJbW1lZGlhdGUpO1xyXG5cclxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTcpKSlcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0MyAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsLCBwcm9jZXNzKSB7KGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xyXG4gICAgXCJ1c2Ugc3RyaWN0XCI7XHJcblxyXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cclxuICAgIHZhciB0YXNrc0J5SGFuZGxlID0ge307XHJcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XHJcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xyXG4gICAgdmFyIHJlZ2lzdGVySW1tZWRpYXRlO1xyXG5cclxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xyXG4gICAgICAvLyBDYWxsYmFjayBjYW4gZWl0aGVyIGJlIGEgZnVuY3Rpb24gb3IgYSBzdHJpbmdcclxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XHJcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xyXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XHJcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XHJcbiAgICAgIH1cclxuICAgICAgLy8gU3RvcmUgYW5kIHJlZ2lzdGVyIHRoZSB0YXNrXHJcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcclxuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XHJcbiAgICAgIHJlZ2lzdGVySW1tZWRpYXRlKG5leHRIYW5kbGUpO1xyXG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xyXG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSB0YXNrLmNhbGxiYWNrO1xyXG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xyXG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcclxuICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBydW5JZlByZXNlbnQoaGFuZGxlKSB7XHJcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxyXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXHJcbiAgICAgICAgaWYgKGN1cnJlbnRseVJ1bm5pbmdBVGFzaykge1xyXG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxyXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxyXG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcclxuICAgICAgICAgICAgaWYgKHRhc2spIHtcclxuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJ1bih0YXNrKTtcclxuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcclxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpIHtcclxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xyXG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY2FuVXNlUG9zdE1lc3NhZ2UoKSB7XHJcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxyXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxyXG4gICAgICAgIGlmIChnbG9iYWwucG9zdE1lc3NhZ2UgJiYgIWdsb2JhbC5pbXBvcnRTY3JpcHRzKSB7XHJcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XHJcbiAgICAgICAgICAgIGdsb2JhbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKFwiXCIsIFwiKlwiKTtcclxuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcclxuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uKCkge1xyXG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxyXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxyXG4gICAgICAgIC8vICogaHR0cDovL3d3dy53aGF0d2cub3JnL3NwZWNzL3dlYi1hcHBzL2N1cnJlbnQtd29yay9tdWx0aXBhZ2UvY29tbXMuaHRtbCNjcm9zc0RvY3VtZW50TWVzc2FnZXNcclxuXHJcbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcclxuICAgICAgICB2YXIgb25HbG9iYWxNZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXHJcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxyXG4gICAgICAgICAgICAgICAgZXZlbnQuZGF0YS5pbmRleE9mKG1lc3NhZ2VQcmVmaXgpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xyXG4gICAgICAgICAgICBnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgb25HbG9iYWxNZXNzYWdlLCBmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xyXG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UobWVzc2FnZVByZWZpeCArIGhhbmRsZSwgXCIqXCIpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcclxuICAgICAgICBjaGFubmVsLnBvcnQxLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XHJcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xyXG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xyXG4gICAgICAgICAgICBjaGFubmVsLnBvcnQyLnBvc3RNZXNzYWdlKGhhbmRsZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xyXG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcclxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcclxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cclxuICAgICAgICAgICAgdmFyIHNjcmlwdCA9IGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xyXG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XHJcbiAgICAgICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcclxuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XHJcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcclxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cclxuICAgIHZhciBhdHRhY2hUbyA9IE9iamVjdC5nZXRQcm90b3R5cGVPZiAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZ2xvYmFsKTtcclxuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xyXG5cclxuICAgIC8vIERvbid0IGdldCBmb29sZWQgYnkgZS5nLiBicm93c2VyaWZ5IGVudmlyb25tZW50cy5cclxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcclxuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XHJcbiAgICAgICAgaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcclxuICAgICAgICAvLyBGb3Igbm9uLUlFMTAgbW9kZXJuIGJyb3dzZXJzXHJcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGdsb2JhbC5NZXNzYWdlQ2hhbm5lbCkge1xyXG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXHJcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcclxuXHJcbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XHJcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XHJcbiAgICAgICAgaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbigpO1xyXG5cclxuICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gRm9yIG9sZGVyIGJyb3dzZXJzXHJcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xyXG4gICAgfVxyXG5cclxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcclxuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XHJcbn0odHlwZW9mIHNlbGYgPT09IFwidW5kZWZpbmVkXCIgPyB0eXBlb2YgZ2xvYmFsID09PSBcInVuZGVmaW5lZFwiID8gdGhpcyA6IGdsb2JhbCA6IHNlbGYpKTtcclxuXHJcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0NCkpKVxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ0ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcbi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XHJcblxyXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcclxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXHJcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcclxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cclxuXHJcbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xyXG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xyXG5cclxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xyXG59XHJcbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcclxufVxyXG4oZnVuY3Rpb24gKCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XHJcbiAgICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZSkge1xyXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcclxuICAgICAgICB9XHJcbiAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcclxuICAgIH1cclxufSAoKSlcclxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcclxuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XHJcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXHJcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcclxuICAgIH1cclxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXHJcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcclxuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcclxuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xyXG4gICAgfVxyXG4gICAgdHJ5IHtcclxuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXHJcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcclxuICAgIH0gY2F0Y2goZSl7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcclxuICAgICAgICB9IGNhdGNoKGUpe1xyXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxyXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuXHJcbn1cclxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xyXG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XHJcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXHJcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xyXG4gICAgfVxyXG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxyXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XHJcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xyXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcclxuICAgIH1cclxuICAgIHRyeSB7XHJcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xyXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcclxuICAgIH0gY2F0Y2ggKGUpe1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XHJcbiAgICAgICAgfSBjYXRjaCAoZSl7XHJcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxyXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XHJcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcblxyXG5cclxufVxyXG52YXIgcXVldWUgPSBbXTtcclxudmFyIGRyYWluaW5nID0gZmFsc2U7XHJcbnZhciBjdXJyZW50UXVldWU7XHJcbnZhciBxdWV1ZUluZGV4ID0gLTE7XHJcblxyXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XHJcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xyXG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcclxuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XHJcbiAgICB9XHJcbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XHJcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xyXG4gICAgaWYgKGRyYWluaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XHJcbiAgICBkcmFpbmluZyA9IHRydWU7XHJcblxyXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIHdoaWxlKGxlbikge1xyXG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xyXG4gICAgICAgIHF1ZXVlID0gW107XHJcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xyXG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcclxuICAgIH1cclxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XHJcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xyXG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xyXG59XHJcblxyXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xyXG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcclxuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XHJcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcclxuICAgIH1cclxufTtcclxuXHJcbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcclxuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XHJcbiAgICB0aGlzLmZ1biA9IGZ1bjtcclxuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcclxufVxyXG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcclxufTtcclxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcclxucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcclxucHJvY2Vzcy5lbnYgPSB7fTtcclxucHJvY2Vzcy5hcmd2ID0gW107XHJcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xyXG5wcm9jZXNzLnZlcnNpb25zID0ge307XHJcblxyXG5mdW5jdGlvbiBub29wKCkge31cclxuXHJcbnByb2Nlc3Mub24gPSBub29wO1xyXG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5vbmNlID0gbm9vcDtcclxucHJvY2Vzcy5vZmYgPSBub29wO1xyXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcclxucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xyXG5wcm9jZXNzLmVtaXQgPSBub29wO1xyXG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XHJcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XHJcblxyXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XHJcblxyXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xyXG59O1xyXG5cclxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcclxucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcclxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XHJcbn07XHJcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ1ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcclxuXHJcblxyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ2ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMikpO1xyXG5cdH1cclxuXHRlbHNlIHt9XHJcbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XHJcblxyXG5cdChmdW5jdGlvbiAoKSB7XHJcblx0ICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xyXG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcclxuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcclxuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogVVRGLTE2IEJFIGVuY29kaW5nIHN0cmF0ZWd5LlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIFV0ZjE2QkUgPSBDX2VuYy5VdGYxNiA9IENfZW5jLlV0ZjE2QkUgPSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBCRSBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgdXRmMTZTdHJpbmcgPSBDcnlwdG9KUy5lbmMuVXRmMTYuc3RyaW5naWZ5KHdvcmRBcnJheSk7XHJcblx0ICAgICAgICAgKi9cclxuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xyXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3JkcztcclxuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcclxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkgKz0gMikge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgY29kZVBvaW50ID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmO1xyXG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgVVRGLTE2IEJFIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuVXRmMTYucGFyc2UodXRmMTZTdHJpbmcpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcclxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gdXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblxyXG5cdCAgICAvKipcclxuXHQgICAgICogVVRGLTE2IExFIGVuY29kaW5nIHN0cmF0ZWd5LlxyXG5cdCAgICAgKi9cclxuXHQgICAgQ19lbmMuVXRmMTZMRSA9IHtcclxuXHQgICAgICAgIC8qKlxyXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgVVRGLTE2IExFIHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XHJcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XHJcblx0ICAgICAgICAgICAgdmFyIHV0ZjE2Q2hhcnMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcclxuXHQgICAgICAgICAgICAgICAgdmFyIGNvZGVQb2ludCA9IHN3YXBFbmRpYW4oKHdvcmRzW2kgPj4+IDJdID4+PiAoMTYgLSAoaSAlIDQpICogOCkpICYgMHhmZmZmKTtcclxuXHQgICAgICAgICAgICAgICAgdXRmMTZDaGFycy5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KSk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gdXRmMTZDaGFycy5qb2luKCcnKTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSB1dGYxNlN0ciBUaGUgVVRGLTE2IExFIHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBzdGF0aWNcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAZXhhbXBsZVxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLlV0ZjE2TEUucGFyc2UodXRmMTZTdHIpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcclxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcclxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcclxuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gMV0gfD0gc3dhcEVuZGlhbih1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNikpO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgcmV0dXJuIFdvcmRBcnJheS5jcmVhdGUod29yZHMsIHV0ZjE2U3RyTGVuZ3RoICogMik7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblxyXG5cdCAgICBmdW5jdGlvbiBzd2FwRW5kaWFuKHdvcmQpIHtcclxuXHQgICAgICAgIHJldHVybiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcclxuXHQgICAgfVxyXG5cdH0oKSk7XHJcblxyXG5cclxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0ZjE2O1xyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ3ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMzEpKTtcclxuXHR9XHJcblx0ZWxzZSB7fVxyXG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xyXG5cclxuXHQoZnVuY3Rpb24gKHVuZGVmaW5lZCkge1xyXG5cdCAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcclxuXHQgICAgdmFyIENfbGliID0gQy5saWI7XHJcblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXM7XHJcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xyXG5cdCAgICB2YXIgSGV4ID0gQ19lbmMuSGV4O1xyXG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdDtcclxuXHJcblx0ICAgIHZhciBIZXhGb3JtYXR0ZXIgPSBDX2Zvcm1hdC5IZXggPSB7XHJcblx0ICAgICAgICAvKipcclxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoZSBjaXBoZXJ0ZXh0IG9mIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QgdG8gYSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBzdHJpbmcuXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQHN0YXRpY1xyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogICAgIHZhciBoZXhTdHJpbmcgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xyXG5cdCAgICAgICAgICovXHJcblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uIChjaXBoZXJQYXJhbXMpIHtcclxuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVyUGFyYW1zLmNpcGhlcnRleHQudG9TdHJpbmcoSGV4KTtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgLyoqXHJcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxyXG5cdCAgICAgICAgICpcclxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dCBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IFRoZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiBAc3RhdGljXHJcblx0ICAgICAgICAgKlxyXG5cdCAgICAgICAgICogQGV4YW1wbGVcclxuXHQgICAgICAgICAqXHJcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlclBhcmFtcyA9IENyeXB0b0pTLmZvcm1hdC5IZXgucGFyc2UoaGV4U3RyaW5nKTtcclxuXHQgICAgICAgICAqL1xyXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChpbnB1dCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gSGV4LnBhcnNlKGlucHV0KTtcclxuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGNpcGhlcnRleHQ6IGNpcGhlcnRleHQgfSk7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH07XHJcblx0fSgpKTtcclxuXHJcblxyXG5cdHJldHVybiBDcnlwdG9KUy5mb3JtYXQuSGV4O1xyXG5cclxufSkpO1xyXG5cclxuLyoqKi8gfSksXHJcbi8qIDQ4ICovXHJcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcclxuXHJcbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcclxuXHRpZiAodHJ1ZSkge1xyXG5cdFx0Ly8gQ29tbW9uSlNcclxuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXygxMiksIF9fd2VicGFja19yZXF1aXJlX18oMTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ5KSwgX193ZWJwYWNrX3JlcXVpcmVfXygzMCksIF9fd2VicGFja19yZXF1aXJlX18oMzEpKTtcclxuXHR9XHJcblx0ZWxzZSB7fVxyXG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xyXG5cclxuXHQoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcclxuXHQgICAgdmFyIENfbGliID0gQy5saWI7XHJcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xyXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cclxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xyXG5cdCAgICB2YXIgU0JPWCA9IFtdO1xyXG5cdCAgICB2YXIgSU5WX1NCT1ggPSBbXTtcclxuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xyXG5cdCAgICB2YXIgU1VCX01JWF8xID0gW107XHJcblx0ICAgIHZhciBTVUJfTUlYXzIgPSBbXTtcclxuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xyXG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMCA9IFtdO1xyXG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMSA9IFtdO1xyXG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xyXG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMyA9IFtdO1xyXG5cclxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXHJcblx0ICAgIChmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAvLyBDb21wdXRlIGRvdWJsZSB0YWJsZVxyXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcclxuXHQgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyBpKyspIHtcclxuXHQgICAgICAgICAgICBpZiAoaSA8IDEyOCkge1xyXG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIGRbaV0gPSAoaSA8PCAxKSBeIDB4MTFiO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcclxuXHQgICAgICAgIHZhciB4ID0gMDtcclxuXHQgICAgICAgIHZhciB4aSA9IDA7XHJcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzYm94XHJcblx0ICAgICAgICAgICAgdmFyIHN4ID0geGkgXiAoeGkgPDwgMSkgXiAoeGkgPDwgMikgXiAoeGkgPDwgMykgXiAoeGkgPDwgNCk7XHJcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xyXG5cdCAgICAgICAgICAgIFNCT1hbeF0gPSBzeDtcclxuXHQgICAgICAgICAgICBJTlZfU0JPWFtzeF0gPSB4O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG11bHRpcGxpY2F0aW9uXHJcblx0ICAgICAgICAgICAgdmFyIHgyID0gZFt4XTtcclxuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcclxuXHQgICAgICAgICAgICB2YXIgeDggPSBkW3g0XTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xyXG5cdCAgICAgICAgICAgIHZhciB0ID0gKGRbc3hdICogMHgxMDEpIF4gKHN4ICogMHgxMDEwMTAwKTtcclxuXHQgICAgICAgICAgICBTVUJfTUlYXzBbeF0gPSAodCA8PCAyNCkgfCAodCA+Pj4gOCk7XHJcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcclxuXHQgICAgICAgICAgICBTVUJfTUlYXzJbeF0gPSAodCA8PCA4KSAgfCAodCA+Pj4gMjQpO1xyXG5cdCAgICAgICAgICAgIFNVQl9NSVhfM1t4XSA9IHQ7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IHN1YiBieXRlcywgaW52IG1peCBjb2x1bW5zIHRhYmxlc1xyXG5cdCAgICAgICAgICAgIHZhciB0ID0gKHg4ICogMHgxMDEwMTAxKSBeICh4NCAqIDB4MTAwMDEpIF4gKHgyICogMHgxMDEpIF4gKHggKiAweDEwMTAxMDApO1xyXG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xyXG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzFbc3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcclxuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8yW3N4XSA9ICh0IDw8IDgpICB8ICh0ID4+PiAyNCk7XHJcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG5leHQgY291bnRlclxyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xyXG5cdCAgICAgICAgICAgICAgICB4ID0geGkgPSAxO1xyXG5cdCAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XHJcblx0ICAgICAgICAgICAgICAgIHhpIF49IGRbZFt4aV1dO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH1cclxuXHQgICAgfSgpKTtcclxuXHJcblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXHJcblx0ICAgIHZhciBSQ09OID0gWzB4MDAsIDB4MDEsIDB4MDIsIDB4MDQsIDB4MDgsIDB4MTAsIDB4MjAsIDB4NDAsIDB4ODAsIDB4MWIsIDB4MzZdO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIEFFUyBibG9jayBjaXBoZXIgYWxnb3JpdGhtLlxyXG5cdCAgICAgKi9cclxuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xyXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICB2YXIgdDtcclxuXHJcblx0ICAgICAgICAgICAgLy8gU2tpcCByZXNldCBvZiBuUm91bmRzIGhhcyBiZWVuIHNldCBiZWZvcmUgYW5kIGtleSBkaWQgbm90IGNoYW5nZVxyXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9uUm91bmRzICYmIHRoaXMuX2tleVByaW9yUmVzZXQgPT09IHRoaXMuX2tleSkge1xyXG5cdCAgICAgICAgICAgICAgICByZXR1cm47XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICB2YXIga2V5ID0gdGhpcy5fa2V5UHJpb3JSZXNldCA9IHRoaXMuX2tleTtcclxuXHQgICAgICAgICAgICB2YXIga2V5V29yZHMgPSBrZXkud29yZHM7XHJcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiByb3VuZHNcclxuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBudW1iZXIgb2Yga2V5IHNjaGVkdWxlIHJvd3NcclxuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUga2V5IHNjaGVkdWxlXHJcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcclxuXHQgICAgICAgICAgICBmb3IgKHZhciBrc1JvdyA9IDA7IGtzUm93IDwga3NSb3dzOyBrc1JvdysrKSB7XHJcblx0ICAgICAgICAgICAgICAgIGlmIChrc1JvdyA8IGtleVNpemUpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcclxuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDFdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgICAgIGlmICghKGtzUm93ICUga2V5U2l6ZSkpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBSb3Qgd29yZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWl4IFJjb25cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcclxuXHQgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5U2l6ZSA+IDYgJiYga3NSb3cgJSBrZXlTaXplID09IDQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBTdWIgd29yZFxyXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XHJcblx0ICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XHJcblx0ICAgICAgICAgICAgICAgIH1cclxuXHQgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgaW52IGtleSBzY2hlZHVsZVxyXG5cdCAgICAgICAgICAgIHZhciBpbnZLZXlTY2hlZHVsZSA9IHRoaXMuX2ludktleVNjaGVkdWxlID0gW107XHJcblx0ICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xyXG5cdCAgICAgICAgICAgICAgICB2YXIga3NSb3cgPSBrc1Jvd3MgLSBpbnZLc1JvdztcclxuXHJcblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIHZhciB0ID0ga2V5U2NoZWR1bGVba3NSb3ddO1xyXG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xyXG5cdCAgICAgICAgICAgICAgICB9XHJcblxyXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcclxuXHQgICAgICAgICAgICAgICAgICAgIGludktleVNjaGVkdWxlW2ludktzUm93XSA9IHQ7XHJcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cclxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbU0JPWFsodCA+Pj4gOCkgJiAweGZmXV0gXiBJTlZfU1VCX01JWF8zW1NCT1hbdCAmIDB4ZmZdXTtcclxuXHQgICAgICAgICAgICAgICAgfVxyXG5cdCAgICAgICAgICAgIH1cclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XHJcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5fa2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCk7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIGRlY3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCkge1xyXG5cdCAgICAgICAgICAgIC8vIFN3YXAgMm5kIGFuZCA0dGggcm93c1xyXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcclxuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcclxuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcclxuXHJcblx0ICAgICAgICAgICAgdGhpcy5fZG9DcnlwdEJsb2NrKE0sIG9mZnNldCwgdGhpcy5faW52S2V5U2NoZWR1bGUsIElOVl9TVUJfTUlYXzAsIElOVl9TVUJfTUlYXzEsIElOVl9TVUJfTUlYXzIsIElOVl9TVUJfTUlYXzMsIElOVl9TQk9YKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xyXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcclxuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gTVtvZmZzZXQgKyAzXTtcclxuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xyXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XHJcblx0ICAgICAgICAgICAgdmFyIG5Sb3VuZHMgPSB0aGlzLl9uUm91bmRzO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBHZXQgaW5wdXQsIGFkZCByb3VuZCBrZXlcclxuXHQgICAgICAgICAgICB2YXIgczAgPSBNW29mZnNldF0gICAgIF4ga2V5U2NoZWR1bGVbMF07XHJcblx0ICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xyXG5cdCAgICAgICAgICAgIHZhciBzMiA9IE1bb2Zmc2V0ICsgMl0gXiBrZXlTY2hlZHVsZVsyXTtcclxuXHQgICAgICAgICAgICB2YXIgczMgPSBNW29mZnNldCArIDNdIF4ga2V5U2NoZWR1bGVbM107XHJcblxyXG5cdCAgICAgICAgICAgIC8vIEtleSBzY2hlZHVsZSByb3cgY291bnRlclxyXG5cdCAgICAgICAgICAgIHZhciBrc1JvdyA9IDQ7XHJcblxyXG5cdCAgICAgICAgICAgIC8vIFJvdW5kc1xyXG5cdCAgICAgICAgICAgIGZvciAodmFyIHJvdW5kID0gMTsgcm91bmQgPCBuUm91bmRzOyByb3VuZCsrKSB7XHJcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcclxuXHQgICAgICAgICAgICAgICAgdmFyIHQwID0gU1VCX01JWF8wW3MwID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMxID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczIgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczMgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG5cdCAgICAgICAgICAgICAgICB2YXIgdDEgPSBTVUJfTUlYXzBbczEgPj4+IDI0XSBeIFNVQl9NSVhfMVsoczIgPj4+IDE2KSAmIDB4ZmZdIF4gU1VCX01JWF8yWyhzMyA+Pj4gOCkgJiAweGZmXSBeIFNVQl9NSVhfM1tzMCAmIDB4ZmZdIF4ga2V5U2NoZWR1bGVba3NSb3crK107XHJcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIHQzID0gU1VCX01JWF8wW3MzID4+PiAyNF0gXiBTVUJfTUlYXzFbKHMwID4+PiAxNikgJiAweGZmXSBeIFNVQl9NSVhfMlsoczEgPj4+IDgpICYgMHhmZl0gXiBTVUJfTUlYXzNbczIgJiAweGZmXSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xyXG5cclxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXHJcblx0ICAgICAgICAgICAgICAgIHMwID0gdDA7XHJcblx0ICAgICAgICAgICAgICAgIHMxID0gdDE7XHJcblx0ICAgICAgICAgICAgICAgIHMyID0gdDI7XHJcblx0ICAgICAgICAgICAgICAgIHMzID0gdDM7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAvLyBTaGlmdCByb3dzLCBzdWIgYnl0ZXMsIGFkZCByb3VuZCBrZXlcclxuXHQgICAgICAgICAgICB2YXIgdDAgPSAoKFNCT1hbczAgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczEgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMiA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczMgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuXHQgICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuXHQgICAgICAgICAgICB2YXIgdDIgPSAoKFNCT1hbczIgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczMgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMCA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczEgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuXHQgICAgICAgICAgICB2YXIgdDMgPSAoKFNCT1hbczMgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczAgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMSA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczIgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gU2V0IG91dHB1dFxyXG5cdCAgICAgICAgICAgIE1bb2Zmc2V0XSAgICAgPSB0MDtcclxuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XHJcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAyXSA9IHQyO1xyXG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0MztcclxuXHQgICAgICAgIH0sXHJcblxyXG5cdCAgICAgICAga2V5U2l6ZTogMjU2LzMyXHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQGV4YW1wbGVcclxuXHQgICAgICpcclxuXHQgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0ID0gQ3J5cHRvSlMuQUVTLmVuY3J5cHQobWVzc2FnZSwga2V5LCBjZmcpO1xyXG5cdCAgICAgKiAgICAgdmFyIHBsYWludGV4dCAgPSBDcnlwdG9KUy5BRVMuZGVjcnlwdChjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XHJcblx0ICAgICAqL1xyXG5cdCAgICBDLkFFUyA9IEJsb2NrQ2lwaGVyLl9jcmVhdGVIZWxwZXIoQUVTKTtcclxuXHR9KCkpO1xyXG5cclxuXHJcblx0cmV0dXJuIENyeXB0b0pTLkFFUztcclxuXHJcbn0pKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA0OSAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XHJcblx0aWYgKHRydWUpIHtcclxuXHRcdC8vIENvbW1vbkpTXHJcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oMTIpKTtcclxuXHR9XHJcblx0ZWxzZSB7fVxyXG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xyXG5cclxuXHQoZnVuY3Rpb24gKE1hdGgpIHtcclxuXHQgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XHJcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xyXG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xyXG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xyXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xyXG5cclxuXHQgICAgLy8gQ29uc3RhbnRzIHRhYmxlXHJcblx0ICAgIHZhciBUID0gW107XHJcblxyXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xyXG5cdCAgICAoZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XHJcblx0ICAgICAgICAgICAgVFtpXSA9IChNYXRoLmFicyhNYXRoLnNpbihpICsgMSkpICogMHgxMDAwMDAwMDApIHwgMDtcclxuXHQgICAgICAgIH1cclxuXHQgICAgfSgpKTtcclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXHJcblx0ICAgICAqL1xyXG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENSA9IEhhc2hlci5leHRlbmQoe1xyXG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcclxuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KFtcclxuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcclxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxyXG5cdCAgICAgICAgICAgIF0pO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcclxuXHQgICAgICAgICAgICAvLyBTd2FwIGVuZGlhblxyXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dHNcclxuXHQgICAgICAgICAgICAgICAgdmFyIG9mZnNldF9pID0gb2Zmc2V0ICsgaTtcclxuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIE1bb2Zmc2V0X2ldID0gKFxyXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuXHQgICAgICAgICAgICAgICAgICAgICgoKE1fb2Zmc2V0X2kgPDwgMjQpIHwgKE1fb2Zmc2V0X2kgPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxyXG5cdCAgICAgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgIH1cclxuXHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMCAgPSBNW29mZnNldCArIDBdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XHJcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzIgID0gTVtvZmZzZXQgKyAyXTtcclxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMyAgPSBNW29mZnNldCArIDNdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XHJcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzUgID0gTVtvZmZzZXQgKyA1XTtcclxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfNiAgPSBNW29mZnNldCArIDZdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XHJcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzggID0gTVtvZmZzZXQgKyA4XTtcclxuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfOSAgPSBNW29mZnNldCArIDldO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMSA9IE1bb2Zmc2V0ICsgMTFdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMiA9IE1bb2Zmc2V0ICsgMTJdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNCA9IE1bb2Zmc2V0ICsgMTRdO1xyXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xNSA9IE1bb2Zmc2V0ICsgMTVdO1xyXG5cclxuXHQgICAgICAgICAgICAvLyBXb3JraW5nIHZhcmlhbGJlc1xyXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcclxuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XHJcblx0ICAgICAgICAgICAgdmFyIGMgPSBIWzJdO1xyXG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQ29tcHV0YXRpb25cclxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfMCwgIDcsICBUWzBdKTtcclxuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcclxuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMiwgIDE3LCBUWzJdKTtcclxuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfMywgIDIyLCBUWzNdKTtcclxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcclxuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfNSwgIDEyLCBUWzVdKTtcclxuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE3LCBUWzZdKTtcclxuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcclxuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfOCwgIDcsICBUWzhdKTtcclxuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfOSwgIDEyLCBUWzldKTtcclxuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XHJcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzExLCAyMiwgVFsxMV0pO1xyXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8xMiwgNywgIFRbMTJdKTtcclxuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XHJcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNywgVFsxNF0pO1xyXG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xNSwgMjIsIFRbMTVdKTtcclxuXHJcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA1LCAgVFsxNl0pO1xyXG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF82LCAgOSwgIFRbMTddKTtcclxuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XHJcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzAsICAyMCwgVFsxOV0pO1xyXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF81LCAgNSwgIFRbMjBdKTtcclxuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XHJcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNCwgVFsyMl0pO1xyXG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF80LCAgMjAsIFRbMjNdKTtcclxuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XHJcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE0LCA5LCAgVFsyNV0pO1xyXG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTQsIFRbMjZdKTtcclxuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XHJcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA1LCAgVFsyOF0pO1xyXG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8yLCAgOSwgIFRbMjldKTtcclxuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XHJcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEyLCAyMCwgVFszMV0pO1xyXG5cclxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XHJcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzgsICAxMSwgVFszM10pO1xyXG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xMSwgMTYsIFRbMzRdKTtcclxuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XHJcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEsICA0LCAgVFszNl0pO1xyXG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF80LCAgMTEsIFRbMzddKTtcclxuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XHJcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEwLCAyMywgVFszOV0pO1xyXG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNCwgIFRbNDBdKTtcclxuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XHJcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNiwgVFs0Ml0pO1xyXG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF82LCAgMjMsIFRbNDNdKTtcclxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XHJcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzEyLCAxMSwgVFs0NV0pO1xyXG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTYsIFRbNDZdKTtcclxuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XHJcblxyXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNiwgIFRbNDhdKTtcclxuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XHJcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE0LCAxNSwgVFs1MF0pO1xyXG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF81LCAgMjEsIFRbNTFdKTtcclxuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XHJcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzMsICAxMCwgVFs1M10pO1xyXG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xMCwgMTUsIFRbNTRdKTtcclxuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XHJcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA2LCAgVFs1Nl0pO1xyXG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8xNSwgMTAsIFRbNTddKTtcclxuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XHJcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzEzLCAyMSwgVFs1OV0pO1xyXG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF80LCAgNiwgIFRbNjBdKTtcclxuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XHJcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNSwgVFs2Ml0pO1xyXG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF85LCAgMjEsIFRbNjNdKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcclxuXHQgICAgICAgICAgICBIWzBdID0gKEhbMF0gKyBhKSB8IDA7XHJcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xyXG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcclxuXHQgICAgICAgICAgICBIWzNdID0gKEhbM10gKyBkKSB8IDA7XHJcblx0ICAgICAgICB9LFxyXG5cclxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xyXG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xyXG5cclxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xyXG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcclxuXHJcblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcclxuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcclxuXHJcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxIID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xyXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsTCA9IG5CaXRzVG90YWw7XHJcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXHJcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxIIDw8IDgpICB8IChuQml0c1RvdGFsSCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuXHQgICAgICAgICAgICAgICAgKCgobkJpdHNUb3RhbEggPDwgMjQpIHwgKG5CaXRzVG90YWxIID4+PiA4KSkgICYgMHhmZjAwZmYwMClcclxuXHQgICAgICAgICAgICApO1xyXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gKFxyXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsTCA8PCA4KSAgfCAobkJpdHNUb3RhbEwgPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XHJcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXHJcblx0ICAgICAgICAgICAgKTtcclxuXHJcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xyXG5cclxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xyXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcclxuXHJcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXHJcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xyXG5cdCAgICAgICAgICAgIHZhciBIID0gaGFzaC53b3JkcztcclxuXHJcblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cclxuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG5cdCAgICAgICAgICAgICAgICAvLyBTaG9ydGN1dFxyXG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcclxuXHJcblx0ICAgICAgICAgICAgICAgIEhbaV0gPSAoKChIX2kgPDwgOCkgIHwgKEhfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcclxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XHJcblx0ICAgICAgICAgICAgfVxyXG5cclxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxyXG5cdCAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG5cdCAgICAgICAgfSxcclxuXHJcblx0ICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xyXG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xyXG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xyXG5cclxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XHJcblx0ICAgICAgICB9XHJcblx0ICAgIH0pO1xyXG5cclxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG5cdCAgICAgICAgdmFyIG4gPSBhICsgKChiICYgYykgfCAofmIgJiBkKSkgKyB4ICsgdDtcclxuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIGZ1bmN0aW9uIEdHKGEsIGIsIGMsIGQsIHgsIHMsIHQpIHtcclxuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XHJcblx0ICAgICAgICByZXR1cm4gKChuIDw8IHMpIHwgKG4gPj4+ICgzMiAtIHMpKSkgKyBiO1xyXG5cdCAgICB9XHJcblxyXG5cdCAgICBmdW5jdGlvbiBISChhLCBiLCBjLCBkLCB4LCBzLCB0KSB7XHJcblx0ICAgICAgICB2YXIgbiA9IGEgKyAoYiBeIGMgXiBkKSArIHggKyB0O1xyXG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcclxuXHQgICAgfVxyXG5cclxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xyXG5cdCAgICAgICAgdmFyIG4gPSBhICsgKGMgXiAoYiB8IH5kKSkgKyB4ICsgdDtcclxuXHQgICAgICAgIHJldHVybiAoKG4gPDwgcykgfCAobiA+Pj4gKDMyIC0gcykpKSArIGI7XHJcblx0ICAgIH1cclxuXHJcblx0ICAgIC8qKlxyXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGhhc2guXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBzdGF0aWNcclxuXHQgICAgICpcclxuXHQgICAgICogQGV4YW1wbGVcclxuXHQgICAgICpcclxuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KCdtZXNzYWdlJyk7XHJcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSh3b3JkQXJyYXkpO1xyXG5cdCAgICAgKi9cclxuXHQgICAgQy5NRDUgPSBIYXNoZXIuX2NyZWF0ZUhlbHBlcihNRDUpO1xyXG5cclxuXHQgICAgLyoqXHJcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9uIHRvIHRoZSBITUFDJ3Mgb2JqZWN0IGludGVyZmFjZS5cclxuXHQgICAgICpcclxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXHJcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxyXG5cdCAgICAgKlxyXG5cdCAgICAgKiBAc3RhdGljXHJcblx0ICAgICAqXHJcblx0ICAgICAqIEBleGFtcGxlXHJcblx0ICAgICAqXHJcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcclxuXHQgICAgICovXHJcblx0ICAgIEMuSG1hY01ENSA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihNRDUpO1xyXG5cdH0oTWF0aCkpO1xyXG5cclxuXHJcblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcclxuXHJcbn0pKTtcclxuXHJcbi8qKiovIH0pLFxyXG4vKiA1MCAqL1xyXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XHJcblxyXG5cInVzZSBzdHJpY3RcIjtcclxuLy8gRVNNIENPTVBBVCBGTEFHXHJcbl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2ZyYWdtZW50cy9wbGF0Zm9ybS1icm93c2VyLmpzXHJcbnZhciBwbGF0Zm9ybV9icm93c2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvdXRpbHMuanNcclxudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvbG9nZ2VyLmpzXHJcbnZhciBsb2dnZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdXRpbC9kZWZhdWx0cy5qcyArIDEgbW9kdWxlc1xyXG52YXIgZGVmYXVsdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2F1dGguanMgKyAxIG1vZHVsZXNcclxudmFyIGF1dGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KTtcclxuXHJcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi90eXBlcy9kZXZpY2VkZXRhaWxzLmpzXHJcblxyXG5cclxudmFyIGRldmljZWRldGFpbHNfRGV2aWNlRGV0YWlscyA9IChmdW5jdGlvbigpIHtcclxuXHJcblx0ZnVuY3Rpb24gRGV2aWNlRGV0YWlscygpIHtcclxuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmRldmljZVNlY3JldCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMucGxhdGZvcm0gPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmZvcm1GYWN0b3IgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5tZXRhZGF0YSA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbiA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMucHVzaCA9IHtcclxuXHRcdFx0cmVjaXBpZW50OiB1bmRlZmluZWQsXHJcblx0XHRcdHN0YXRlOiB1bmRlZmluZWQsXHJcblx0XHRcdGVycm9yOiB1bmRlZmluZWRcclxuXHRcdH07XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxyXG5cdCAqIEByZXR1cm4geyp9XHJcblx0ICovXHJcblx0RGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24oKSB7XHJcblx0XHRyZXR1cm4ge1xyXG5cdFx0XHRpZDogdGhpcy5pZCxcclxuXHRcdFx0ZGV2aWNlU2VjcmV0OiB0aGlzLmRldmljZVNlY3JldCxcclxuXHRcdFx0cGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXHJcblx0XHRcdGZvcm1GYWN0b3I6IHRoaXMuZm9ybUZhY3RvcixcclxuXHRcdFx0Y2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXHJcblx0XHRcdG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxyXG5cdFx0XHRkZXZpY2VJZGVudGl0eVRva2VuOiB0aGlzLmRldmljZUlkZW50aXR5VG9rZW4sXHJcblx0XHRcdHB1c2g6IHtcclxuXHRcdFx0XHRyZWNpcGllbnQ6IHRoaXMucHVzaC5yZWNpcGllbnQsXHJcblx0XHRcdFx0c3RhdGU6IHRoaXMucHVzaC5zdGF0ZSxcclxuXHRcdFx0XHRlcnJvcjogdGhpcy5wdXNoLmVycm9yXHJcblx0XHRcdH1cclxuXHRcdH07XHJcblx0fTtcclxuXHJcblx0RGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciByZXN1bHQgPSAnW0RldmljZURldGFpbHMnO1xyXG5cdFx0aWYodGhpcy5pZClcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xyXG5cdFx0aWYodGhpcy5wbGF0Zm9ybSlcclxuXHRcdFx0cmVzdWx0ICs9ICc7IHBsYXRmb3JtPScgKyB0aGlzLnBsYXRmb3JtO1xyXG5cdFx0aWYodGhpcy5mb3JtRmFjdG9yKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgZm9ybUZhY3Rvcj0nICsgdGhpcy5mb3JtRmFjdG9yO1xyXG5cdFx0aWYodGhpcy5jbGllbnRJZClcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xyXG5cdFx0aWYodGhpcy5tZXRhZGF0YSlcclxuXHRcdFx0cmVzdWx0ICs9ICc7IG1ldGFkYXRhPScgKyB0aGlzLm1ldGFkYXRhO1xyXG5cdFx0aWYodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgZGV2aWNlSWRlbnRpdHlUb2tlbj0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5kZXZpY2VJZGVudGl0eVRva2VuKTtcclxuXHRcdGlmKHRoaXMucHVzaC5yZWNpcGllbnQpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLnJlY2lwaWVudD0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5wdXNoLnJlY2lwaWVudCk7XHJcblx0XHRpZih0aGlzLnB1c2guc3RhdGUpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLnN0YXRlPScgKyB0aGlzLnB1c2guc3RhdGU7XHJcblx0XHRpZih0aGlzLnB1c2guZXJyb3IpXHJcblx0XHRcdHJlc3VsdCArPSAnOyBwdXNoLmVycm9yPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2guZXJyb3IpO1xyXG5cdFx0aWYodGhpcy5wdXNoLm1ldGFkYXRhKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgcHVzaC5tZXRhZGF0YT0nICsgdGhpcy5wdXNoLm1ldGFkYXRhO1xyXG5cdFx0cmVzdWx0ICs9ICddJztcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0RGV2aWNlRGV0YWlscy50b1JlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keTtcclxuXHJcblx0RGV2aWNlRGV0YWlscy5mcm9tUmVzcG9uc2VCb2R5ID0gZnVuY3Rpb24oYm9keSwgZm9ybWF0KSB7XHJcblx0XHRpZihmb3JtYXQpIHtcclxuXHRcdFx0Ym9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pc0FycmF5KGJvZHkpKSB7XHJcblx0XHRcdHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheShib2R5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMoYm9keSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0RGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcblx0XHR2YWx1ZXMuZXJyb3IgPSB2YWx1ZXMuZXJyb3IgJiYgRXJyb3JJbmZvLmZyb21WYWx1ZXModmFsdWVzLmVycm9yKTsgXHJcblx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4obmV3IERldmljZURldGFpbHMoKSwgdmFsdWVzKTtcclxuXHR9O1xyXG5cclxuXHREZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheSA9IGZ1bmN0aW9uKHZhbHVlcykge1xyXG5cdFx0dmFyIGNvdW50ID0gdmFsdWVzLmxlbmd0aCwgcmVzdWx0ID0gbmV3IEFycmF5KGNvdW50KTtcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSByZXN1bHRbaV0gPSBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIERldmljZURldGFpbHM7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBkZXZpY2VkZXRhaWxzID0gKGRldmljZWRldGFpbHNfRGV2aWNlRGV0YWlscyk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vYnJvd3Nlci9saWIvdXRpbC9odHRwLmpzXHJcbnZhciBodHRwID0gX193ZWJwYWNrX3JlcXVpcmVfXyg2KTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9icm93c2VyL2xpYi91dGlsL2J1ZmZlcnV0aWxzLmpzXHJcbnZhciBidWZmZXJ1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3Jlc291cmNlLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgcmVzb3VyY2VfUmVzb3VyY2UgPSAoZnVuY3Rpb24oKSB7XHJcblx0dmFyIG1zZ3BhY2sgPSBwbGF0Zm9ybV9icm93c2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1zZ3BhY2s7XHJcblxyXG5cdGZ1bmN0aW9uIFJlc291cmNlKCkge31cclxuXHJcblx0ZnVuY3Rpb24gd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgZXJyQ2FsbGJhY2ssIG9wQ2FsbGJhY2spIHtcclxuXHRcdGlmIChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzQXV0aEhlYWRlcnMpIHtcclxuXHRcdFx0cmVzdC5hdXRoLmdldEF1dGhIZWFkZXJzKGZ1bmN0aW9uKGVyciwgYXV0aEhlYWRlcnMpIHtcclxuXHRcdFx0XHRpZihlcnIpXHJcblx0XHRcdFx0XHRlcnJDYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdGVsc2VcclxuXHRcdFx0XHRcdG9wQ2FsbGJhY2sodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oYXV0aEhlYWRlcnMsIGhlYWRlcnMpLCBwYXJhbXMpO1xyXG5cdFx0XHR9KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJlc3QuYXV0aC5nZXRBdXRoUGFyYW1zKGZ1bmN0aW9uKGVyciwgYXV0aFBhcmFtcykge1xyXG5cdFx0XHRcdGlmKGVycilcclxuXHRcdFx0XHRcdGVyckNhbGxiYWNrKGVycik7XHJcblx0XHRcdFx0ZWxzZVxyXG5cdFx0XHRcdFx0b3BDYWxsYmFjayhoZWFkZXJzLCB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihhdXRoUGFyYW1zLCBwYXJhbXMpKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiB1bmVudmVsb3BlKGNhbGxiYWNrLCBmb3JtYXQpIHtcclxuXHRcdHJldHVybiBmdW5jdGlvbihlcnIsIGJvZHksIG91dGVySGVhZGVycywgdW5wYWNrZWQsIG91dGVyU3RhdHVzQ29kZSkge1xyXG5cdFx0XHRpZihlcnIgJiYgIWJvZHkpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0aWYoIXVucGFja2VkKSB7XHJcblx0XHRcdFx0dHJ5IHtcclxuXHRcdFx0XHRcdGJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XHJcblx0XHRcdFx0fSBjYXRjaChlKSB7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhlKTtcclxuXHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmKGJvZHkuc3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdFx0LyogRW52ZWxvcGUgYWxyZWFkeSB1bndyYXBwZWQgYnkgdGhlIHRyYW5zcG9ydCAqL1xyXG5cdFx0XHRcdGNhbGxiYWNrKGVyciwgYm9keSwgb3V0ZXJIZWFkZXJzLCB0cnVlLCBvdXRlclN0YXR1c0NvZGUpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIHdyYXBwZWRTdGF0dXNDb2RlID0gYm9keS5zdGF0dXNDb2RlLFxyXG5cdFx0XHRcdHJlc3BvbnNlID0gYm9keS5yZXNwb25zZSxcclxuXHRcdFx0XHR3cmFwcGVkSGVhZGVycyA9IGJvZHkuaGVhZGVycztcclxuXHJcblx0XHRcdGlmKHdyYXBwZWRTdGF0dXNDb2RlIDwgMjAwIHx8IHdyYXBwZWRTdGF0dXNDb2RlID49IDMwMCkge1xyXG5cdFx0XHRcdC8qIGhhbmRsZSB3cmFwcGVkIGVycm9ycyAqL1xyXG5cdFx0XHRcdHZhciB3cmFwcGVkRXJyID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yKSB8fCBlcnI7XHJcblx0XHRcdFx0aWYoIXdyYXBwZWRFcnIpIHtcclxuXHRcdFx0XHRcdHdyYXBwZWRFcnIgPSBuZXcgRXJyb3IoXCJFcnJvciBpbiB1bmVudmVsb3BpbmcgXCIgKyBib2R5KTtcclxuXHRcdFx0XHRcdHdyYXBwZWRFcnIuc3RhdHVzQ29kZSA9IHdyYXBwZWRTdGF0dXNDb2RlO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayh3cmFwcGVkRXJyLCByZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMsIHRydWUsIHdyYXBwZWRTdGF0dXNDb2RlKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNhbGxiYWNrKGVyciwgcmVzcG9uc2UsIHdyYXBwZWRIZWFkZXJzLCB0cnVlLCB3cmFwcGVkU3RhdHVzQ29kZSk7XHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyYW1TdHJpbmcocGFyYW1zKSB7XHJcblx0XHR2YXIgcGFyYW1QYWlycyA9IFtdO1xyXG5cdFx0aWYgKHBhcmFtcykge1xyXG5cdFx0XHRmb3IgKHZhciBuZWVkbGUgaW4gcGFyYW1zKSB7XHJcblx0XHRcdFx0cGFyYW1QYWlycy5wdXNoKG5lZWRsZSArICc9JyArIHBhcmFtc1tuZWVkbGVdKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHBhcmFtUGFpcnMuam9pbignJicpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSB7XHJcblx0XHRyZXR1cm4gcGF0aCArIChwYXJhbXMgPyAnPycgOiAnJykgKyBwYXJhbVN0cmluZyhwYXJhbXMpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIHBhcmFtcykge1xyXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcclxuXHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnUmVjZWl2ZWQgRXJyb3I7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgRXJyb3I6ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsXHJcblx0XHRcdFx0XHQnUmVjZWl2ZWQ7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgSGVhZGVyczogJyArIHBhcmFtU3RyaW5nKGhlYWRlcnMpICsgJzsgU3RhdHVzQ29kZTogJyArIHN0YXR1c0NvZGUgKyAnOyBCb2R5OiAnICsgKGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQnVmZmVyKGJvZHkpID8gYm9keS50b1N0cmluZygpIDogYm9keSkpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGlmIChjYWxsYmFjaykgeyBjYWxsYmFjayhlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKTsgfVxyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRob3V0Qm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRSZXNvdXJjZVttZXRob2RdID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRSZXNvdXJjZVsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIG51bGwsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xyXG5cdFx0fTtcclxuXHR9KTtcclxuXHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRoQm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRSZXNvdXJjZVttZXRob2RdID0gZnVuY3Rpb24ocmVzdCwgcGF0aCwgYm9keSwgb3JpZ2hlYWRlcnMsIG9yaWdwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xyXG5cdFx0XHRSZXNvdXJjZVsnZG8nXShtZXRob2QsIHJlc3QsIHBhdGgsIGJvZHksIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spO1xyXG5cdFx0fTtcclxuXHR9KTtcclxuXHJcblx0UmVzb3VyY2VbJ2RvJ10gPSBmdW5jdGlvbihtZXRob2QsIHJlc3QsIHBhdGgsIGJvZHksIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBlbnZlbG9wZSwgY2FsbGJhY2spIHtcclxuXHRcdGlmIChsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2hvdWxkTG9nKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8pKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIG9yaWdwYXJhbXMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKGVudmVsb3BlKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gKGNhbGxiYWNrICYmIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGVudmVsb3BlKSk7XHJcblx0XHRcdChvcmlncGFyYW1zID0gKG9yaWdwYXJhbXMgfHwge30pKVsnZW52ZWxvcGUnXSA9IGVudmVsb3BlO1xyXG5cdFx0fVxyXG5cclxuXHRcdGZ1bmN0aW9uIGRvUmVxdWVzdChoZWFkZXJzLCBwYXJhbXMpIHtcclxuXHRcdFx0aWYgKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zaG91bGRMb2cobG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTykpIHtcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmc7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpKTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0dmFyIGFyZ3MgPSBbcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBmdW5jdGlvbihlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcclxuXHRcdFx0XHRpZihlcnIgJiYgYXV0aFtcImFcIiAvKiBkZWZhdWx0ICovXS5pc1Rva2VuRXJyKGVycikpIHtcclxuXHRcdFx0XHRcdC8qIHRva2VuIGhhcyBleHBpcmVkLCBzbyBnZXQgYSBuZXcgb25lICovXHJcblx0XHRcdFx0XHRyZXN0LmF1dGguYXV0aG9yaXplKG51bGwsIG51bGwsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0XHQvKiByZXRyeSAuLi4gKi9cclxuXHRcdFx0XHRcdFx0d2l0aEF1dGhEZXRhaWxzKHJlc3QsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBjYWxsYmFjaywgZG9SZXF1ZXN0KTtcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayhlcnIsIHJlcywgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xyXG5cdFx0XHR9XTtcclxuXHRcdFx0aWYgKCFib2R5KSB7XHJcblx0XHRcdFx0YXJncy5zcGxpY2UoMywgMSk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGlmIChsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2hvdWxkTG9nKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8pKSB7XHJcblx0XHRcdFx0dmFyIGRlY29kZWRCb2R5ID0gYm9keTtcclxuXHRcdFx0XHRpZiAoKGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8ICcnKS5pbmRleE9mKCdtc2dwYWNrJykgPiAwKSB7XHJcblx0XHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0XHRkZWNvZGVkQm9keSA9IG1zZ3BhY2suZGVjb2RlKGJvZHkpO1xyXG5cdFx0XHRcdFx0fSBjYXRjaCAoZGVjb2RlRXJyKSB7XHJcblx0XHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZyBNc2dQYWNrIERlY29kaW5nIEVycm9yOiAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdEVycm9yKGRlY29kZUVycikpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1NlbmRpbmc7ICcgKyB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICsgJzsgQm9keTogJyArIGRlY29kZWRCb2R5KTtcclxuXHRcdFx0fVxyXG5cdFx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dW21ldGhvZF0uYXBwbHkodGhpcywgYXJncyk7XHJcblx0XHR9XHJcblxyXG5cdFx0d2l0aEF1dGhEZXRhaWxzKHJlc3QsIG9yaWdoZWFkZXJzLCBvcmlncGFyYW1zLCBjYWxsYmFjaywgZG9SZXF1ZXN0KTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gUmVzb3VyY2U7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcmVzb3VyY2UgPSAocmVzb3VyY2VfUmVzb3VyY2UpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9wYWdpbmF0ZWRyZXNvdXJjZS5qc1xyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV9QYWdpbmF0ZWRSZXNvdXJjZSA9IChmdW5jdGlvbigpIHtcclxuXHJcblx0ZnVuY3Rpb24gZ2V0UmVsUGFyYW1zKGxpbmtVcmwpIHtcclxuXHRcdHZhciB1cmxNYXRjaCA9IGxpbmtVcmwubWF0Y2goL15cXC5cXC8oXFx3KylcXD8oLiopJC8pO1xyXG5cdFx0cmV0dXJuIHVybE1hdGNoICYmIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnBhcnNlUXVlcnlTdHJpbmcodXJsTWF0Y2hbMl0pO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gcGFyc2VSZWxMaW5rcyhsaW5rSGVhZGVyKSB7XHJcblx0XHRpZih0eXBlb2YobGlua0hlYWRlcikgPT0gJ3N0cmluZycpXHJcblx0XHRcdGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KCcsJyk7XHJcblxyXG5cdFx0dmFyIHJlbFBhcmFtcyA9IHt9O1xyXG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IGxpbmtIZWFkZXIubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIGxpbmtNYXRjaCA9IGxpbmtIZWFkZXJbaV0ubWF0Y2goL15cXHMqPCguKyk+O1xccypyZWw9XCIoXFx3KylcIiQvKTtcclxuXHRcdFx0aWYobGlua01hdGNoKSB7XHJcblx0XHRcdFx0dmFyIHBhcmFtcyA9IGdldFJlbFBhcmFtcyhsaW5rTWF0Y2hbMV0pO1xyXG5cdFx0XHRcdGlmKHBhcmFtcylcclxuXHRcdFx0XHRcdHJlbFBhcmFtc1tsaW5rTWF0Y2hbMl1dID0gcGFyYW1zO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVsUGFyYW1zO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUGFnaW5hdGVkUmVzb3VyY2UocmVzdCwgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGJvZHlIYW5kbGVyLCB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcclxuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XHJcblx0XHR0aGlzLnBhdGggPSBwYXRoO1xyXG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcclxuXHRcdHRoaXMuZW52ZWxvcGUgPSBlbnZlbG9wZTtcclxuXHRcdHRoaXMuYm9keUhhbmRsZXIgPSBib2R5SGFuZGxlcjtcclxuXHRcdHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlID0gdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlIHx8IGZhbHNlO1xyXG5cdH1cclxuXHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRob3V0Qm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRjbGllbnRfcmVzb3VyY2VbbWV0aG9kXShzZWxmLnJlc3QsIHNlbGYucGF0aCwgc2VsZi5oZWFkZXJzLCBwYXJhbXMsIHNlbGYuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcclxuXHRcdFx0XHRzZWxmLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xyXG5cdFx0XHR9KTtcclxuXHRcdH07XHJcblx0fSlcclxuXHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJyRm9yRWFjaChodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRoQm9keSwgZnVuY3Rpb24obWV0aG9kKSB7XHJcblx0XHRQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcclxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRjbGllbnRfcmVzb3VyY2VbbWV0aG9kXShzZWxmLnJlc3QsIHNlbGYucGF0aCwgYm9keSwgc2VsZi5oZWFkZXJzLCBwYXJhbXMsIHNlbGYuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgcmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcclxuXHRcdFx0XHRpZihjYWxsYmFjaykge1xyXG5cdFx0XHRcdFx0c2VsZi5oYW5kbGVQYWdlKGVyciwgcmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fTtcclxuXHR9KTtcclxuXHJcblx0ZnVuY3Rpb24gcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHVzZUhQUikge1xyXG5cdFx0LyogSWYgdXNpbmcgaHR0cFBhZ2luYXRlZFJlc3BvbnNlLCBlcnJvcnMgZnJvbSBBYmx5IGFyZSByZXR1cm5lZCBhcyBwYXJ0IG9mXHJcblx0XHQgKiB0aGUgSFBSLCBvbmx5IGRvIGNhbGxiYWNrKGVycikgZm9yIG5ldHdvcmsgZXJyb3JzIGV0Yy4gd2hpY2ggZG9uJ3RcclxuXHRcdCAqIHJldHVybiBhIGJvZHkgYW5kL29yIGhhdmUgbm8gYWJseS1vcmlnaW5hdGVkIGVycm9yIGNvZGUgKG5vbi1udW1lcmljXHJcblx0XHQgKiBlcnJvciBjb2RlcyBvcmlnaW5hdGUgZnJvbSBub2RlKSAqL1xyXG5cdFx0cmV0dXJuICEodXNlSFBSICYmIChib2R5IHx8IHR5cGVvZiBlcnIuY29kZSA9PT0gJ251bWJlcicpKTtcclxuXHR9XHJcblxyXG5cdFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5oYW5kbGVQYWdlID0gZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spIHtcclxuXHRcdGlmKGVyciAmJiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpKSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1BhZ2luYXRlZFJlc291cmNlLmhhbmRsZVBhZ2UoKScsICdVbmV4cGVjdGVkIGVycm9yIGdldHRpbmcgcmVzb3VyY2U6IGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XHJcblx0XHRcdGNhbGxiYWNrKGVycik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdHZhciBpdGVtcywgbGlua0hlYWRlciwgcmVsUGFyYW1zO1xyXG5cdFx0dHJ5IHtcclxuXHRcdFx0aXRlbXMgPSB0aGlzLmJvZHlIYW5kbGVyKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKTtcclxuXHRcdH0gY2F0Y2goZSkge1xyXG5cdFx0XHQvKiBJZiB3ZSBnb3QgYW4gZXJyb3IsIHRoZSBmYWlsdXJlIHRvIHBhcnNlIHRoZSBib2R5IGlzIGFsbW9zdCBjZXJ0YWlubHlcclxuXHRcdFx0ICogZHVlIHRvIHRoYXQsIHNvIGNiIHdpdGggdGhhdCBpbiBwcmVmZXJlbmNlIHRvIHRoZSBwYXJzZSBlcnJvciAqL1xyXG5cdFx0XHRjYWxsYmFjayhlcnIgfHwgZSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihoZWFkZXJzICYmIChsaW5rSGVhZGVyID0gKGhlYWRlcnNbJ0xpbmsnXSB8fCBoZWFkZXJzWydsaW5rJ10pKSkge1xyXG5cdFx0XHRyZWxQYXJhbXMgPSBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSB7XHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIG5ldyBIdHRwUGFnaW5hdGVkUmVzcG9uc2UodGhpcywgaXRlbXMsIGhlYWRlcnMsIHN0YXR1c0NvZGUsIHJlbFBhcmFtcywgZXJyKSk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRjYWxsYmFjayhudWxsLCBuZXcgUGFnaW5hdGVkUmVzdWx0KHRoaXMsIGl0ZW1zLCByZWxQYXJhbXMpKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBQYWdpbmF0ZWRSZXN1bHQocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHtcclxuXHRcdHRoaXMucmVzb3VyY2UgPSByZXNvdXJjZTtcclxuXHRcdHRoaXMuaXRlbXMgPSBpdGVtcztcclxuXHJcblx0XHRpZihyZWxQYXJhbXMpIHtcclxuXHRcdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0XHRpZignZmlyc3QnIGluIHJlbFBhcmFtcykge1xyXG5cdFx0XHRcdHRoaXMuZmlyc3QgPSBmdW5jdGlvbihjYikge1xyXG5cdFx0XHRcdFx0aWYoIWNiICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkoc2VsZiwgJ2ZpcnN0JywgW10pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2VsZi5nZXQocmVsUGFyYW1zLmZpcnN0LCBjYik7XHJcblx0XHRcdFx0fTtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZignY3VycmVudCcgaW4gcmVsUGFyYW1zKSB7XHJcblx0XHRcdFx0dGhpcy5jdXJyZW50ID0gZnVuY3Rpb24oY2IpIHtcclxuXHRcdFx0XHRcdGlmKCFjYiAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHNlbGYsICdjdXJyZW50JywgW10pO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0c2VsZi5nZXQocmVsUGFyYW1zLmN1cnJlbnQsIGNiKTtcclxuXHRcdFx0XHR9O1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMubmV4dCA9IGZ1bmN0aW9uKGNiKSB7XHJcblx0XHRcdFx0aWYoIWNiICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHNlbGYsICduZXh0JywgW10pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZignbmV4dCcgaW4gcmVsUGFyYW1zKSB7XHJcblx0XHRcdFx0XHRzZWxmLmdldChyZWxQYXJhbXMubmV4dCwgY2IpO1xyXG5cdFx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0XHRjYihudWxsLCBudWxsKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH07XHJcblxyXG5cdFx0XHR0aGlzLmhhc05leHQgPSBmdW5jdGlvbigpIHsgcmV0dXJuICgnbmV4dCcgaW4gcmVsUGFyYW1zKSB9O1xyXG5cdFx0XHR0aGlzLmlzTGFzdCA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gIXRoaXMuaGFzTmV4dCgpOyB9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHQvKiBXZSBhc3N1bWUgdGhhdCBvbmx5IHRoZSBpbml0aWFsIHJlcXVlc3QgY2FuIGJlIGEgUE9TVCwgYW5kIHRoYXQgYWNjZXNzaW5nXHJcblx0ICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXHJcblx0UGFnaW5hdGVkUmVzdWx0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgcmVzID0gdGhpcy5yZXNvdXJjZTtcclxuXHRcdGNsaWVudF9yZXNvdXJjZS5nZXQocmVzLnJlc3QsIHJlcy5wYXRoLCByZXMuaGVhZGVycywgcGFyYW1zLCByZXMuZW52ZWxvcGUsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcclxuXHRcdFx0cmVzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gSHR0cFBhZ2luYXRlZFJlc3BvbnNlKHJlc291cmNlLCBpdGVtcywgaGVhZGVycywgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpIHtcclxuXHRcdFBhZ2luYXRlZFJlc3VsdC5jYWxsKHRoaXMsIHJlc291cmNlLCBpdGVtcywgcmVsUGFyYW1zKTtcclxuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XHJcblx0XHR0aGlzLnN1Y2Nlc3MgPSBzdGF0dXNDb2RlIDwgMzAwICYmIHN0YXR1c0NvZGUgPj0gMjAwO1xyXG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcclxuXHRcdHRoaXMuZXJyb3JDb2RlID0gZXJyICYmIGVyci5jb2RlO1xyXG5cdFx0dGhpcy5lcnJvck1lc3NhZ2UgPSBlcnIgJiYgZXJyLm1lc3NhZ2U7XHJcblx0fVxyXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKEh0dHBQYWdpbmF0ZWRSZXNwb25zZSwgUGFnaW5hdGVkUmVzdWx0KTtcclxuXHJcblx0cmV0dXJuIFBhZ2luYXRlZFJlc291cmNlO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgcGFnaW5hdGVkcmVzb3VyY2UgPSAocGFnaW5hdGVkcmVzb3VyY2VfUGFnaW5hdGVkUmVzb3VyY2UpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvZXJyb3JpbmZvLmpzXHJcbnZhciBlcnJvcmluZm8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL3B1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmpzXHJcblxyXG5cclxudmFyIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uX1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRmdW5jdGlvbiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbigpIHtcclxuXHRcdHRoaXMuY2hhbm5lbCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuZGV2aWNlSWQgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmNsaWVudElkID0gdW5kZWZpbmVkO1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogT3ZlcmxvYWQgdG9KU09OKCkgdG8gaW50ZXJjZXB0IEpTT04uc3RyaW5naWZ5KClcclxuXHQgKiBAcmV0dXJuIHsqfVxyXG5cdCAqL1xyXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbigpIHtcclxuXHRcdHJldHVybiB7XHJcblx0XHRcdGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcclxuXHRcdFx0ZGV2aWNlSWQ6IHRoaXMuZGV2aWNlSWQsXHJcblx0XHRcdGNsaWVudElkOiB0aGlzLmNsaWVudElkXHJcblx0XHR9O1xyXG5cdH07XHJcblxyXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHJlc3VsdCA9ICdbUHVzaENoYW5uZWxTdWJzY3JpcHRpb24nO1xyXG5cdFx0aWYodGhpcy5jaGFubmVsKVxyXG5cdFx0XHRyZXN1bHQgKz0gJzsgY2hhbm5lbD0nICsgdGhpcy5jaGFubmVsO1xyXG5cdFx0aWYodGhpcy5kZXZpY2VJZClcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGRldmljZUlkPScgKyB0aGlzLmRldmljZUlkO1xyXG5cdFx0aWYodGhpcy5jbGllbnRJZClcclxuXHRcdFx0cmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xyXG5cdFx0cmVzdWx0ICs9ICddJztcclxuXHRcdHJldHVybiByZXN1bHQ7XHJcblx0fTtcclxuXHJcblx0UHVzaENoYW5uZWxTdWJzY3JpcHRpb24udG9SZXF1ZXN0Qm9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZUJvZHk7XHJcblxyXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbihib2R5LCBmb3JtYXQpIHtcclxuXHRcdGlmKGZvcm1hdCkge1xyXG5cdFx0XHRib2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlQm9keShib2R5LCBmb3JtYXQpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkoYm9keSkpIHtcclxuXHRcdFx0cmV0dXJuIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXNBcnJheShib2R5KTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzKGJvZHkpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcclxuXHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihuZXcgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24oKSwgdmFsdWVzKTtcclxuXHR9O1xyXG5cclxuXHRQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbih2YWx1ZXMpIHtcclxuXHRcdHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykgcmVzdWx0W2ldID0gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb247XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbiA9IChwdXNoY2hhbm5lbHN1YnNjcmlwdGlvbl9QdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbik7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3B1c2guanNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgcHVzaF9QdXNoID0gKGZ1bmN0aW9uKCkge1xyXG5cdHZhciBub29wID0gZnVuY3Rpb24oKSB7fTtcclxuXHJcblx0ZnVuY3Rpb24gUHVzaChyZXN0KSB7XHJcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xyXG5cdFx0dGhpcy5hZG1pbiA9IG5ldyBBZG1pbihyZXN0KTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIEFkbWluKHJlc3QpIHtcclxuXHRcdHRoaXMucmVzdCA9IHJlc3Q7XHJcblx0XHR0aGlzLmRldmljZVJlZ2lzdHJhdGlvbnMgPSBuZXcgRGV2aWNlUmVnaXN0cmF0aW9ucyhyZXN0KTtcclxuXHRcdHRoaXMuY2hhbm5lbFN1YnNjcmlwdGlvbnMgPSBuZXcgQ2hhbm5lbFN1YnNjcmlwdGlvbnMocmVzdCk7XHJcblx0fVxyXG5cclxuXHRBZG1pbi5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKHJlY2lwaWVudCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcclxuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0O1xyXG5cdFx0dmFyIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcclxuXHRcdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbih7cmVjaXBpZW50OiByZWNpcGllbnR9LCBwYXlsb2FkKSxcclxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpLFxyXG5cdFx0XHRwYXJhbXMgPSB7fTtcclxuXHJcblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcclxuXHJcblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XHJcblxyXG5cdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5LCBmb3JtYXQpO1xyXG5cdFx0Y2xpZW50X3Jlc291cmNlLnBvc3QocmVzdCwgJy9wdXNoL3B1Ymxpc2gnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyKSB7IGNhbGxiYWNrKGVycik7IH0pO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIERldmljZVJlZ2lzdHJhdGlvbnMocmVzdCkge1xyXG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcclxuXHR9XHJcblxyXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnNhdmUgPSBmdW5jdGlvbihkZXZpY2UsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdDtcclxuXHRcdHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXHJcblx0XHRcdHJlcXVlc3RCb2R5ID0gZGV2aWNlZGV0YWlscy5mcm9tVmFsdWVzKGRldmljZSksXHJcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KSxcclxuXHRcdFx0cGFyYW1zID0ge307XHJcblxyXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc2F2ZScsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xyXG5cclxuXHRcdHJlcXVlc3RCb2R5ID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQm9keShyZXF1ZXN0Qm9keSwgZm9ybWF0KTtcclxuXHRcdGNsaWVudF9yZXNvdXJjZS5wdXQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2UuaWQpLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBmYWxzZSwgZnVuY3Rpb24oZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xyXG5cdFx0XHRjYWxsYmFjayhlcnIsICFlcnIgJiYgZGV2aWNlZGV0YWlscy5mcm9tUmVzcG9uc2VCb2R5KGJvZHksICF1bnBhY2tlZCAmJiBmb3JtYXQpKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGRldmljZUlkT3JEZXRhaWxzLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXHJcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcclxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCksXHJcblx0XHRcdGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XHJcblxyXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodHlwZW9mIGRldmljZUlkICE9PSAnc3RyaW5nJyB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XHJcblx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0ZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjZ2V0IG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlscycsIDQwMDAwLCA0MDApKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG5cdFx0Y2xpZW50X3Jlc291cmNlLmdldChyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSwgaGVhZGVycywge30sIGZhbHNlLCBmdW5jdGlvbihlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XHJcblx0XHRcdGNhbGxiYWNrKGVyciwgIWVyciAmJiBkZXZpY2VkZXRhaWxzLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCkpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxyXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXHJcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxyXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcclxuXHJcblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsaXN0JywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcclxuXHJcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XHJcblx0XHRcdHJldHVybiBkZXZpY2VkZXRhaWxzLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCk7XHJcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uKGRldmljZUlkT3JEZXRhaWxzLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3QsXHJcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcclxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCksXHJcblx0XHRcdHBhcmFtcyA9IHt9LFxyXG5cdFx0XHRkZXZpY2VJZCA9IGRldmljZUlkT3JEZXRhaWxzLmlkIHx8IGRldmljZUlkT3JEZXRhaWxzO1xyXG5cclxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlbW92ZScsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycgfHwgIWRldmljZUlkLmxlbmd0aCkge1xyXG5cdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdGaXJzdCBhcmd1bWVudCB0byBEZXZpY2VSZWdpc3RyYXRpb25zI3JlbW92ZSBtdXN0IGJlIGEgZGV2aWNlSWQgc3RyaW5nIG9yIERldmljZURldGFpbHMnLCA0MDAwMCwgNDAwKSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcclxuXHJcblx0XHRjbGllbnRfcmVzb3VyY2VbJ2RlbGV0ZSddKHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zLycgKyBlbmNvZGVVUklDb21wb25lbnQoZGV2aWNlSWQpLCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XHJcblx0fTtcclxuXHJcblx0RGV2aWNlUmVnaXN0cmF0aW9ucy5wcm90b3R5cGUucmVtb3ZlV2hlcmUgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcclxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxyXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcclxuXHJcblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdyZW1vdmVXaGVyZScsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG5cdFx0aWYocmVzdC5vcHRpb25zLnB1c2hGdWxsV2FpdClcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4ocGFyYW1zLCB7ZnVsbFdhaXQ6ICd0cnVlJ30pO1xyXG5cclxuXHRcdGNsaWVudF9yZXNvdXJjZVsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMnLCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gQ2hhbm5lbFN1YnNjcmlwdGlvbnMocmVzdCkge1xyXG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcclxuXHR9XHJcblxyXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24oc3Vic2NyaXB0aW9uLCBjYWxsYmFjaykge1xyXG5cdFx0dmFyIHJlc3QgPSB0aGlzLnJlc3Q7XHJcblx0XHR2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxyXG5cdFx0XHRyZXF1ZXN0Qm9keSA9IHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmZyb21WYWx1ZXMoc3Vic2NyaXB0aW9uKSxcclxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRQb3N0SGVhZGVycyhmb3JtYXQpLFxyXG5cdFx0XHRwYXJhbXMgPSB7fTtcclxuXHJcblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzYXZlJywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcclxuXHJcblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XHJcblxyXG5cdFx0cmVxdWVzdEJvZHkgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5lbmNvZGVCb2R5KHJlcXVlc3RCb2R5LCBmb3JtYXQpO1xyXG5cdFx0Y2xpZW50X3Jlc291cmNlLnBvc3QocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHBhcmFtcywgZmFsc2UsIGZ1bmN0aW9uKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcclxuXHRcdFx0Y2FsbGJhY2soZXJyLCAhZXJyICYmIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCkpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcclxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxyXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcclxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCk7XHJcblxyXG5cdFx0aWYodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGlmKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnbGlzdCcsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcclxuXHRcdFx0cmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkoYm9keSwgIXVucGFja2VkICYmIGZvcm1hdCk7XHJcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxyXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXHJcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xyXG5cclxuXHRcdGlmKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYocmVzdC5vcHRpb25zLmhlYWRlcnMpXHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcclxuXHJcblx0XHRpZihyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihwYXJhbXMsIHtmdWxsV2FpdDogJ3RydWUnfSk7XHJcblxyXG5cdFx0Y2xpZW50X3Jlc291cmNlWydkZWxldGUnXShyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBmdW5jdGlvbihlcnIpIHsgY2FsbGJhY2soZXJyKTsgfSk7XHJcblx0fTtcclxuXHJcblx0LyogQ2hhbm5lbFN1YnNjcmlwdGlvbnMgaGF2ZSBubyB1bmlxdWUgaWQ7IHJlbW92aW5nIG9uZSBpcyBlcXVpdmFsZW50IHRvIHJlbW92ZVdoZXJlIGJ5IGl0cyBwcm9wZXJ0aWVzICovXHJcblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZSA9IENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5yZW1vdmVXaGVyZTtcclxuXHJcblx0Q2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmxpc3RDaGFubmVscyA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxyXG5cdFx0XHRmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyAnbXNncGFjaycgOiAnanNvbicsXHJcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LFxyXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoZm9ybWF0KTtcclxuXHJcblx0XHRpZih0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdsaXN0Q2hhbm5lbHMnLCBhcmd1bWVudHMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcclxuXHRcdH1cclxuXHJcblx0XHRpZihyZXN0Lm9wdGlvbnMuaGVhZGVycylcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKHBhcmFtcywge2Z1bGxXYWl0OiAndHJ1ZSd9KTtcclxuXHJcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsICcvcHVzaC9jaGFubmVscycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xyXG5cdFx0XHR2YXIgZiA9ICF1bnBhY2tlZCAmJiBmb3JtYXQ7XHJcblxyXG5cdFx0XHRpZihmKSB7XHJcblx0XHRcdFx0Ym9keSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHRib2R5W2ldID0gU3RyaW5nKGJvZHlbaV0pO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBib2R5O1xyXG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gUHVzaDtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHB1c2ggPSAocHVzaF9QdXNoKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvZXZlbnRlbWl0dGVyLmpzXHJcbnZhciBldmVudGVtaXR0ZXIgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDcpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvcHJlc2VuY2VtZXNzYWdlLmpzXHJcbnZhciBwcmVzZW5jZW1lc3NhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcclxuXHJcbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vY29tbW9uL2xpYi9jbGllbnQvcHJlc2VuY2UuanNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciBwcmVzZW5jZV9QcmVzZW5jZSA9IChmdW5jdGlvbigpIHtcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHRmdW5jdGlvbiBQcmVzZW5jZShjaGFubmVsKSB7XHJcblx0XHR0aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xyXG5cdFx0dGhpcy5iYXNlUGF0aCA9IGNoYW5uZWwuYmFzZVBhdGggKyAnL3ByZXNlbmNlJztcclxuXHR9XHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUHJlc2VuY2UsIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XHJcblxyXG5cdFByZXNlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdQcmVzZW5jZS5nZXQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcclxuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xyXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XHJcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHZhciByZXN0ID0gdGhpcy5jaGFubmVsLnJlc3QsXHJcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcclxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXHJcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpO1xyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XHJcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsIHRoaXMuYmFzZVBhdGgsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xyXG5cdFx0XHRyZXR1cm4gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21SZXNwb25zZUJvZHkoYm9keSwgb3B0aW9ucywgIXVucGFja2VkICYmIGZvcm1hdCk7XHJcblx0XHR9KSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdFByZXNlbmNlLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUHJlc2VuY2UuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUpO1xyXG5cdFx0dGhpcy5faGlzdG9yeShwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHR9O1xyXG5cclxuXHRQcmVzZW5jZS5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cclxuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xyXG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnX2hpc3RvcnknLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHZhciByZXN0ID0gdGhpcy5jaGFubmVsLnJlc3QsXHJcblx0XHRcdGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/ICdtc2dwYWNrJyA6ICdqc29uJyxcclxuXHRcdFx0ZW52ZWxvcGUgPSBodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQsXHJcblx0XHRcdGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycyhmb3JtYXQpLFxyXG5cdFx0XHRjaGFubmVsID0gdGhpcy5jaGFubmVsO1xyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWwuY2hhbm5lbE9wdGlvbnM7XHJcblx0XHQobmV3IHBhZ2luYXRlZHJlc291cmNlKHJlc3QsIHRoaXMuYmFzZVBhdGggKyAnL2hpc3RvcnknLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24oYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcclxuXHRcdFx0cmV0dXJuIHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xyXG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHR9O1xyXG5cclxuXHRyZXR1cm4gUHJlc2VuY2U7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcHJlc2VuY2UgPSAocHJlc2VuY2VfUHJlc2VuY2UpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvY3J5cHRvLmpzXHJcbnZhciB1dGlsX2NyeXB0byA9IF9fd2VicGFja19yZXF1aXJlX18oMTkpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvbWVzc2FnZS5qc1xyXG52YXIgdHlwZXNfbWVzc2FnZSA9IF9fd2VicGFja19yZXF1aXJlX18oOSk7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2NoYW5uZWwuanNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgY2hhbm5lbF9DaGFubmVsID0gKGZ1bmN0aW9uKCkge1xyXG5cdGZ1bmN0aW9uIG5vb3AoKSB7fVxyXG5cdHZhciBNU0dfSURfRU5UUk9QWV9CWVRFUyA9IDk7XHJcblxyXG5cdC8qIHB1YmxpYyBjb25zdHJ1Y3RvciAqL1xyXG5cdGZ1bmN0aW9uIENoYW5uZWwocmVzdCwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ0NoYW5uZWwoKScsICdzdGFydGVkOyBuYW1lID0gJyArIG5hbWUpO1xyXG5cdFx0ZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNhbGwodGhpcyk7XHJcblx0XHR0aGlzLnJlc3QgPSByZXN0O1xyXG5cdFx0dGhpcy5uYW1lID0gbmFtZTtcclxuXHRcdHRoaXMuYmFzZVBhdGggPSAnL2NoYW5uZWxzLycgKyBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XHJcblx0XHR0aGlzLnByZXNlbmNlID0gbmV3IGNsaWVudF9wcmVzZW5jZSh0aGlzKTtcclxuXHRcdHRoaXMuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XHJcblx0fVxyXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKENoYW5uZWwsIGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSk7XHJcblxyXG5cdENoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbihvcHRpb25zKSB7XHJcblx0XHR0aGlzLmNoYW5uZWxPcHRpb25zID0gb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XHJcblx0XHRpZihvcHRpb25zLmNpcGhlcikge1xyXG5cdFx0XHRpZighdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL10pIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkJyk7XHJcblx0XHRcdHZhciBjaXBoZXIgPSB1dGlsX2NyeXB0b1tcImFcIiAvKiBkZWZhdWx0ICovXS5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIpO1xyXG5cdFx0XHRvcHRpb25zLmNpcGhlciA9IGNpcGhlci5jaXBoZXJQYXJhbXM7XHJcblx0XHRcdG9wdGlvbnMuY2hhbm5lbENpcGhlciA9IGNpcGhlci5jaXBoZXI7XHJcblx0XHR9IGVsc2UgaWYoJ2NpcGhlcicgaW4gb3B0aW9ucykge1xyXG5cdFx0XHQvKiBEb24ndCBkZWFjdGl2YXRlIGFuIGV4aXN0aW5nIGNpcGhlciB1bmxlc3Mgb3B0aW9uc1xyXG5cdFx0XHQgKiBoYXMgYSAnY2lwaGVyJyBrZXkgdGhhdCdzIGZhbHNleSAqL1xyXG5cdFx0XHRvcHRpb25zLmNpcGhlciA9IG51bGw7XHJcblx0XHRcdG9wdGlvbnMuY2hhbm5lbENpcGhlciA9IG51bGw7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0Q2hhbm5lbC5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ0NoYW5uZWwuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcclxuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xyXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XHJcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0Q2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbihwYXJhbXMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgcmVzdCA9IHRoaXMucmVzdCxcclxuXHRcdFx0Zm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxyXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCxcclxuXHRcdFx0aGVhZGVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCksXHJcblx0XHRcdGNoYW5uZWwgPSB0aGlzO1xyXG5cclxuXHRcdGlmKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XHJcblxyXG5cdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xyXG5cdFx0KG5ldyBwYWdpbmF0ZWRyZXNvdXJjZShyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xyXG5cdFx0XHRyZXR1cm4gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsICF1bnBhY2tlZCAmJiBmb3JtYXQpO1xyXG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBhbGxFbXB0eUlkcyhtZXNzYWdlcykge1xyXG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckV2ZXJ5KG1lc3NhZ2VzLCBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHRcdHJldHVybiAhbWVzc2FnZS5pZDtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHJcblx0Q2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcclxuXHRcdFx0Zmlyc3QgPSBhcmd1bWVudHNbMF0sXHJcblx0XHRcdHNlY29uZCA9IGFyZ3VtZW50c1sxXSxcclxuXHRcdFx0Y2FsbGJhY2sgPSBhcmd1bWVudHNbYXJnQ291bnQgLSAxXSxcclxuXHRcdFx0bWVzc2FnZXMsXHJcblx0XHRcdHBhcmFtcyxcclxuXHRcdFx0c2VsZiA9IHRoaXM7XHJcblxyXG5cdFx0aWYodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRpZih0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xyXG5cdFx0XHR9XHJcblx0XHRcdGNhbGxiYWNrID0gbm9vcDtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0eXBlb2YgZmlyc3QgPT09ICdzdHJpbmcnIHx8IGZpcnN0ID09PSBudWxsKSB7XHJcblx0XHRcdC8qIChuYW1lLCBkYXRhLCAuLi4pICovXHJcblx0XHRcdG1lc3NhZ2VzID0gW3R5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7bmFtZTogZmlyc3QsIGRhdGE6IHNlY29uZH0pXTtcclxuXHRcdFx0cGFyYW1zID0gYXJndW1lbnRzWzJdO1xyXG5cdFx0fSBlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzT2JqZWN0KGZpcnN0KSkge1xyXG5cdFx0XHRtZXNzYWdlcyA9IFt0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoZmlyc3QpXTtcclxuXHRcdFx0cGFyYW1zID0gYXJndW1lbnRzWzFdO1xyXG5cdFx0fSBlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkoZmlyc3QpKSB7XHJcblx0XHRcdG1lc3NhZ2VzID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzQXJyYXkoZmlyc3QpO1xyXG5cdFx0XHRwYXJhbXMgPSBhcmd1bWVudHNbMV07XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdUaGUgc2luZ2xlLWFyZ3VtZW50IGZvcm0gb2YgcHVibGlzaCgpIGV4cGVjdHMgYSBtZXNzYWdlIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHMnLCA0MDAxMywgNDAwKTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JyB8fCAhcGFyYW1zKSB7XHJcblx0XHRcdC8qIE5vIHBhcmFtcyBzdXBwbGllZCAoc28gYWZ0ZXItbWVzc2FnZSBhcmd1bWVudCBpcyBqdXN0IHRoZSBjYWxsYmFjayBvciB1bmRlZmluZWQpICovXHJcblx0XHRcdHBhcmFtcyA9IHt9O1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciByZXN0ID0gdGhpcy5yZXN0LFxyXG5cdFx0XHRvcHRpb25zID0gcmVzdC5vcHRpb25zLFxyXG5cdFx0XHRmb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxyXG5cdFx0XHRpZGVtcG90ZW50UmVzdFB1Ymxpc2hpbmcgPSByZXN0Lm9wdGlvbnMuaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nLFxyXG5cdFx0XHRoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdFBvc3RIZWFkZXJzKGZvcm1hdCk7XHJcblxyXG5cdFx0aWYob3B0aW9ucy5oZWFkZXJzKVxyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xyXG5cclxuXHRcdGlmKGlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyAmJiBhbGxFbXB0eUlkcyhtZXNzYWdlcykpIHtcclxuXHRcdFx0dmFyIG1zZ0lkQmFzZSA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJhbmRvbVN0cmluZyhNU0dfSURfRU5UUk9QWV9CWVRFUyk7XHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckZvckVhY2gobWVzc2FnZXMsIGZ1bmN0aW9uKG1lc3NhZ2UsIGluZGV4KSB7XHJcblx0XHRcdFx0bWVzc2FnZS5pZCA9IG1zZ0lkQmFzZSArICc6JyArIGluZGV4LnRvU3RyaW5nKCk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cclxuXHRcdHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0LyogUlNMMWkgKi9cclxuXHRcdFx0dmFyIHNpemUgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyksXHJcblx0XHRcdFx0bWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xyXG5cdFx0XHRpZihzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgJyArIHNpemUgKyAnIGJ5dGVzOyBsaW1pdCBpcyAnICsgbWF4TWVzc2FnZVNpemUgKyAnIGJ5dGVzKScsIDQwMDA5LCA0MDApKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdHNlbGYuX3B1Ymxpc2godHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5zZXJpYWxpemUobWVzc2FnZXMsIGZvcm1hdCksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0Q2hhbm5lbC5wcm90b3R5cGUuX3B1Ymxpc2ggPSBmdW5jdGlvbihyZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaykge1xyXG5cdFx0Y2xpZW50X3Jlc291cmNlLnBvc3QodGhpcy5yZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGZhbHNlLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIENoYW5uZWw7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfY2hhbm5lbCA9IChjaGFubmVsX0NoYW5uZWwpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL3R5cGVzL3N0YXRzLmpzXHJcblxyXG5cclxudmFyIHN0YXRzX1N0YXRzID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRmdW5jdGlvbiBNZXNzYWdlQ291bnQodmFsdWVzKSB7XHJcblx0XHR0aGlzLmNvdW50ID0gKHZhbHVlcyAmJiB2YWx1ZXMuY291bnQpIHx8IDA7XHJcblx0XHR0aGlzLmRhdGEgPSAodmFsdWVzICYmIHZhbHVlcy5kYXRhKSB8fCAwO1xyXG5cdFx0dGhpcy51bmNvbXByZXNzZWREYXRhID0gKHZhbHVlcyAmJiB2YWx1ZXMudW5jb21wcmVzc2VkRGF0YSkgfHwgMDtcclxuXHRcdHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xyXG5cdFx0dGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMpIHtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdE1lc3NhZ2VDb3VudC5jYWxsKHRoaXMsIHZhbHVlcyk7XHJcblx0XHR0aGlzLmNhdGVnb3J5ID0gdW5kZWZpbmVkO1xyXG5cdFx0aWYgKHZhbHVlcyAmJiB2YWx1ZXMuY2F0ZWdvcnkpIHtcclxuXHRcdFx0dGhpcy5jYXRlZ29yeSA9IHsgfTtcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZm9ySW5Pd25Ob25OdWxsUHJvcHModmFsdWVzLmNhdGVnb3J5LCBmdW5jdGlvbihwcm9wKSB7XHJcblx0XHRcdFx0c2VsZi5jYXRlZ29yeVtwcm9wXSA9IG5ldyBNZXNzYWdlQ291bnQodmFsdWVzLmNhdGVnb3J5W3Byb3BdKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBSZXNvdXJjZUNvdW50KHZhbHVlcykge1xyXG5cdFx0dGhpcy5wZWFrID0gKHZhbHVlcyAmJiB2YWx1ZXMucGVhaykgfHwgMDtcclxuXHRcdHRoaXMubWluID0gKHZhbHVlcyAmJiB2YWx1ZXMubWluKSB8fCAwO1xyXG5cdFx0dGhpcy5tZWFuID0gKHZhbHVlcyAmJiB2YWx1ZXMubWVhbikgfHwgMDtcclxuXHRcdHRoaXMub3BlbmVkID0gKHZhbHVlcyAmJiB2YWx1ZXMub3BlbmVkKSB8fCAwO1xyXG5cdFx0dGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFJlcXVlc3RDb3VudCh2YWx1ZXMpIHtcclxuXHRcdHRoaXMuc3VjY2VlZGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc3VjY2VlZGVkKSB8fCAwO1xyXG5cdFx0dGhpcy5mYWlsZWQgPSAodmFsdWVzICYmIHZhbHVlcy5mYWlsZWQpIHx8IDA7XHJcblx0XHR0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gQ29ubmVjdGlvblR5cGVzKHZhbHVlcykge1xyXG5cdFx0dGhpcy5wbGFpbiA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMucGxhaW4pO1xyXG5cdFx0dGhpcy50bHMgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRscyk7XHJcblx0XHR0aGlzLmFsbCA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIE1lc3NhZ2VUeXBlcyh2YWx1ZXMpIHtcclxuXHRcdHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMubWVzc2FnZXMpO1xyXG5cdFx0dGhpcy5wcmVzZW5jZSA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5wcmVzZW5jZSk7XHJcblx0XHR0aGlzLmFsbCA9IG5ldyBNZXNzYWdlQ2F0ZWdvcnkodmFsdWVzICYmIHZhbHVlcy5hbGwpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gTWVzc2FnZVRyYWZmaWModmFsdWVzKSB7XHJcblx0XHR0aGlzLnJlYWx0aW1lID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnJlYWx0aW1lKTtcclxuXHRcdHRoaXMucmVzdCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5yZXN0KTtcclxuXHRcdHRoaXMud2ViaG9vayA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy53ZWJob29rKTtcclxuXHRcdHRoaXMuc2hhcmVkUXVldWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuc2hhcmVkUXVldWUpO1xyXG5cdFx0dGhpcy5leHRlcm5hbFF1ZXVlID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmV4dGVybmFsUXVldWUpO1xyXG5cdFx0dGhpcy5odHRwRXZlbnQgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuaHR0cEV2ZW50KTtcclxuXHRcdHRoaXMucHVzaCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5wdXNoKTtcclxuXHRcdHRoaXMuYWxsID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMpIHtcclxuXHRcdHRoaXMuYWxsICAgICAgICAgICA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xyXG5cdFx0dGhpcy5pbmJvdW5kICAgICAgID0gbmV3IE1lc3NhZ2VUcmFmZmljKHZhbHVlcyAmJiB2YWx1ZXMuaW5ib3VuZCk7XHJcblx0XHR0aGlzLm91dGJvdW5kICAgICAgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5vdXRib3VuZCk7XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBYY2hnTWVzc2FnZXModmFsdWVzKSB7XHJcblx0XHR0aGlzLmFsbCAgICAgICAgICAgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcclxuXHRcdHRoaXMucHJvZHVjZXJQYWlkICA9IG5ldyBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMgJiYgdmFsdWVzLnByb2R1Y2VyUGFpZCk7XHJcblx0XHR0aGlzLmNvbnN1bWVyUGFpZCAgPSBuZXcgTWVzc2FnZURpcmVjdGlvbnModmFsdWVzICYmIHZhbHVlcy5jb25zdW1lclBhaWQpO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUHVzaFN0YXRzKHZhbHVlcykge1xyXG5cdFx0dGhpcy5tZXNzYWdlcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1lc3NhZ2VzKSB8fCAwO1xyXG5cdFx0dmFyIG5vdGlmaWNhdGlvbnMgPSB2YWx1ZXMgJiYgdmFsdWVzLm5vdGlmaWNhdGlvbnM7XHJcblx0XHR0aGlzLm5vdGlmaWNhdGlvbnMgPSB7XHJcblx0XHRcdGludmFsaWQ6IG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5pbnZhbGlkIHx8IDAsXHJcblx0XHRcdGF0dGVtcHRlZDogbm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmF0dGVtcHRlZCB8fCAwLFxyXG5cdFx0XHRzdWNjZXNzZnVsOiBub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuc3VjY2Vzc2Z1bCB8fCAwLFxyXG5cdFx0XHRmYWlsZWQ6IG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5mYWlsZWQgfHwgMFxyXG5cdFx0fTtcclxuXHRcdHRoaXMuZGlyZWN0UHVibGlzaGVzID0gKHZhbHVlcyAmJiB2YWx1ZXMuZGlyZWN0UHVibGlzaGVzKSB8fCAwO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gUHJvY2Vzc2VkQ291bnQodmFsdWVzKSB7XHJcblx0XHR0aGlzLnN1Y2NlZWRlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnN1Y2NlZWRlZCkgfHwgMDtcclxuXHRcdHRoaXMuc2tpcHBlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnNraXBwZWQpIHx8IDA7XHJcblx0XHR0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcykge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0dGhpcy5kZWx0YSA9IHVuZGVmaW5lZDtcclxuXHRcdGlmICh2YWx1ZXMgJiYgdmFsdWVzLmRlbHRhKSB7XHJcblx0XHRcdHRoaXMuZGVsdGEgPSB7IH07XHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZvckluT3duTm9uTnVsbFByb3BzKHZhbHVlcy5kZWx0YSwgZnVuY3Rpb24ocHJvcCkge1xyXG5cdFx0XHRcdHNlbGYuZGVsdGFbcHJvcF0gPSBuZXcgUHJvY2Vzc2VkQ291bnQodmFsdWVzLmRlbHRhW3Byb3BdKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRmdW5jdGlvbiBTdGF0cyh2YWx1ZXMpIHtcclxuXHRcdE1lc3NhZ2VEaXJlY3Rpb25zLmNhbGwodGhpcywgdmFsdWVzKTtcclxuXHRcdHRoaXMucGVyc2lzdGVkICAgICA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5wZXJzaXN0ZWQpO1xyXG5cdFx0dGhpcy5jb25uZWN0aW9ucyAgID0gbmV3IENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmNvbm5lY3Rpb25zKTtcclxuXHRcdHRoaXMuY2hhbm5lbHMgICAgICA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMuY2hhbm5lbHMpO1xyXG5cdFx0dGhpcy5hcGlSZXF1ZXN0cyAgID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFwaVJlcXVlc3RzKTtcclxuXHRcdHRoaXMudG9rZW5SZXF1ZXN0cyA9IG5ldyBSZXF1ZXN0Q291bnQodmFsdWVzICYmIHZhbHVlcy50b2tlblJlcXVlc3RzKTtcclxuXHRcdHRoaXMueGNoZ1Byb2R1Y2VyICA9IG5ldyBYY2hnTWVzc2FnZXModmFsdWVzICYmIHZhbHVlcy54Y2hnUHJvZHVjZXIpO1xyXG5cdFx0dGhpcy54Y2hnQ29uc3VtZXIgID0gbmV3IFhjaGdNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnhjaGdDb25zdW1lcik7XHJcblx0XHR0aGlzLnB1c2ggICAgICAgICAgPSBuZXcgUHVzaFN0YXRzKHZhbHVlcyAmJiB2YWx1ZXMucHVzaFN0YXRzKTtcclxuXHRcdHRoaXMucHJvY2Vzc2VkICAgICA9IG5ldyBQcm9jZXNzZWRNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnByb2Nlc3NlZCk7XHJcblx0XHR0aGlzLmluUHJvZ3Jlc3MgICAgPSAodmFsdWVzICYmIHZhbHVlcy5pblByb2dyZXNzKSB8fCB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnVuaXQgICAgICAgICAgPSAodmFsdWVzICYmIHZhbHVlcy51bml0KSB8fCB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmludGVydmFsSWQgICAgPSAodmFsdWVzICYmIHZhbHVlcy5pbnRlcnZhbElkKSB8fCB1bmRlZmluZWQ7XHJcblx0fVxyXG5cclxuXHRTdGF0cy5mcm9tVmFsdWVzID0gZnVuY3Rpb24odmFsdWVzKSB7XHJcblx0XHRyZXR1cm4gbmV3IFN0YXRzKHZhbHVlcyk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFN0YXRzO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgc3RhdHMgPSAoc3RhdHNfU3RhdHMpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZXN0LmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcbnZhciByZXN0X1Jlc3QgPSAoZnVuY3Rpb24oKSB7XHJcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xyXG5cdHZhciBtc2dwYWNrID0gcGxhdGZvcm1fYnJvd3NlcltcImFcIiAvKiBkZWZhdWx0ICovXS5tc2dwYWNrO1xyXG5cclxuXHRmdW5jdGlvbiBSZXN0KG9wdGlvbnMpIHtcclxuXHRcdGlmKCEodGhpcyBpbnN0YW5jZW9mIFJlc3QpKXtcclxuXHRcdFx0cmV0dXJuIG5ldyBSZXN0KG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdC8qIG5vcm1hbGlzZSBvcHRpb25zICovXHJcblx0XHRpZighb3B0aW9ucykge1xyXG5cdFx0XHR2YXIgbXNnID0gJ25vIG9wdGlvbnMgcHJvdmlkZWQnO1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZXN0KCknLCBtc2cpO1xyXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IobXNnKTtcclxuXHRcdH1cclxuXHRcdG9wdGlvbnMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXS5vYmplY3RpZnlPcHRpb25zKG9wdGlvbnMpO1xyXG5cclxuXHRcdGlmKG9wdGlvbnMubG9nKSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5zZXRMb2cob3B0aW9ucy5sb2cubGV2ZWwsIG9wdGlvbnMubG9nLmhhbmRsZXIpO1xyXG5cdFx0fVxyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVzdCgpJywgJ2luaXRpYWxpemVkIHdpdGggY2xpZW50T3B0aW9ucyAnICsgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5zcGVjdChvcHRpb25zKSk7XHJcblxyXG5cdFx0dGhpcy5vcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zKTtcclxuXHJcblx0XHQvKiBwcm9jZXNzIG9wdGlvbnMgKi9cclxuXHRcdGlmKG9wdGlvbnMua2V5KSB7XHJcblx0XHRcdHZhciBrZXlNYXRjaCA9IG9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcclxuXHRcdFx0aWYoIWtleU1hdGNoKSB7XHJcblx0XHRcdFx0dmFyIG1zZyA9ICdpbnZhbGlkIGtleSBwYXJhbWV0ZXInO1xyXG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1Jlc3QoKScsIG1zZyk7XHJcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKG1zZyk7XHJcblx0XHRcdH1cclxuXHRcdFx0b3B0aW9ucy5rZXlOYW1lID0ga2V5TWF0Y2hbMV07XHJcblx0XHRcdG9wdGlvbnMua2V5U2VjcmV0ID0ga2V5TWF0Y2hbMl07XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoJ2NsaWVudElkJyBpbiBvcHRpb25zKSB7XHJcblx0XHRcdGlmKCEodHlwZW9mKG9wdGlvbnMuY2xpZW50SWQpID09PSAnc3RyaW5nJyB8fCBvcHRpb25zLmNsaWVudElkID09PSBudWxsKSlcclxuXHRcdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XHJcblx0XHRcdGVsc2UgaWYob3B0aW9ucy5jbGllbnRJZCA9PT0gJyonKVxyXG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NhbuKAmXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIHVzZSB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pJywgNDAwMTIsIDQwMCk7XHJcblx0XHR9XHJcblxyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVzdCgpJywgJ3N0YXJ0ZWQ7IHZlcnNpb24gPSAnICsgZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubGlic3RyaW5nKTtcclxuXHJcblx0XHR0aGlzLmJhc2VVcmkgPSB0aGlzLmF1dGhvcml0eSA9IGZ1bmN0aW9uKGhvc3QpIHsgcmV0dXJuIGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldEh0dHBTY2hlbWUob3B0aW9ucykgKyBob3N0ICsgJzonICsgZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZ2V0UG9ydChvcHRpb25zLCBmYWxzZSk7IH07XHJcblx0XHR0aGlzLl9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xyXG5cclxuXHRcdHRoaXMuc2VydmVyVGltZU9mZnNldCA9IG51bGw7XHJcblx0XHR0aGlzLmF1dGggPSBuZXcgYXV0aFtcImFcIiAvKiBkZWZhdWx0ICovXSh0aGlzLCBvcHRpb25zKTtcclxuXHRcdHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcyk7XHJcblx0XHR0aGlzLnB1c2ggPSBuZXcgcHVzaCh0aGlzKTtcclxuXHR9XHJcblxyXG5cdFJlc3QucHJvdG90eXBlLnN0YXRzID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xyXG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXHJcblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcclxuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc3RhdHMnLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdHZhciBoZWFkZXJzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVmYXVsdEdldEhlYWRlcnMoKSxcclxuXHRcdFx0Zm9ybWF0ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gJ21zZ3BhY2snIDogJ2pzb24nLFxyXG5cdFx0XHRlbnZlbG9wZSA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL10uc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdDtcclxuXHJcblx0XHRpZih0aGlzLm9wdGlvbnMuaGVhZGVycylcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xyXG5cclxuXHRcdChuZXcgcGFnaW5hdGVkcmVzb3VyY2UodGhpcywgJy9zdGF0cycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbihib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xyXG5cdFx0XHR2YXIgc3RhdHNWYWx1ZXMgPSAodW5wYWNrZWQgPyBib2R5IDogSlNPTi5wYXJzZShib2R5KSk7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBzdGF0c1ZhbHVlcy5sZW5ndGg7IGkrKykgc3RhdHNWYWx1ZXNbaV0gPSBzdGF0cy5mcm9tVmFsdWVzKHN0YXRzVmFsdWVzW2ldKTtcclxuXHRcdFx0cmV0dXJuIHN0YXRzVmFsdWVzO1xyXG5cdFx0fSkpLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHR9O1xyXG5cclxuXHRSZXN0LnByb3RvdHlwZS50aW1lID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xyXG5cdFx0LyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXHJcblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmKHR5cGVvZihwYXJhbXMpID09ICdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRjYWxsYmFjayA9IHBhcmFtcztcclxuXHRcdFx0XHRwYXJhbXMgPSBudWxsO1xyXG5cdFx0XHR9IGVsc2Uge1xyXG5cdFx0XHRcdGlmKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAndGltZScsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdFx0dmFyIGhlYWRlcnMgPSB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0R2V0SGVhZGVycygpO1xyXG5cdFx0aWYodGhpcy5vcHRpb25zLmhlYWRlcnMpXHJcblx0XHRcdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdHZhciB0aW1lVXJpID0gZnVuY3Rpb24oaG9zdCkgeyByZXR1cm4gc2VsZi5hdXRob3JpdHkoaG9zdCkgKyAnL3RpbWUnIH07XHJcblx0XHRodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldCh0aGlzLCB0aW1lVXJpLCBoZWFkZXJzLCBwYXJhbXMsIGZ1bmN0aW9uKGVyciwgcmVzLCBoZWFkZXJzLCB1bnBhY2tlZCkge1xyXG5cdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRpZighdW5wYWNrZWQpIHJlcyA9IEpTT04ucGFyc2UocmVzKTtcclxuXHRcdFx0dmFyIHRpbWUgPSByZXNbMF07XHJcblx0XHRcdGlmKCF0aW1lKSB7XHJcblx0XHRcdFx0ZXJyID0gbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciAodW5leHBlY3RlZCByZXN1bHQgdHlwZSBmcm9tIEdFVCAvdGltZSknKTtcclxuXHRcdFx0XHRlcnIuc3RhdHVzQ29kZSA9IDUwMDtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHQvKiBjYWxjdWxhdGUgdGltZSBvZmZzZXQgb25seSBvbmNlIGZvciB0aGlzIGRldmljZSBieSBhZGRpbmcgdG8gdGhlIHByb3RvdHlwZSAqL1xyXG5cdFx0XHRzZWxmLnNlcnZlclRpbWVPZmZzZXQgPSAodGltZSAtIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm5vdygpKTtcclxuXHRcdFx0Y2FsbGJhY2sobnVsbCwgdGltZSk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRSZXN0LnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24obWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMsIGNhbGxiYWNrKSB7XHJcblx0XHR2YXIgdXNlQmluYXJ5ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sLFxyXG5cdFx0XHRlbmNvZGVyID0gdXNlQmluYXJ5ID8gbXNncGFjay5lbmNvZGU6IEpTT04uc3RyaW5naWZ5LFxyXG5cdFx0XHRkZWNvZGVyID0gdXNlQmluYXJ5ID8gbXNncGFjay5kZWNvZGUgOiBKU09OLnBhcnNlLFxyXG5cdFx0XHRmb3JtYXQgPSB1c2VCaW5hcnkgPyAnbXNncGFjaycgOiAnanNvbicsXHJcblx0XHRcdGVudmVsb3BlID0gaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0O1xyXG5cdFx0cGFyYW1zID0gcGFyYW1zIHx8IHt9O1xyXG5cdFx0bWV0aG9kID0gbWV0aG9kLnRvTG93ZXJDYXNlKCk7XHJcblx0XHR2YXIgaGVhZGVycyA9IG1ldGhvZCA9PSAnZ2V0JyA/IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlZmF1bHRHZXRIZWFkZXJzKGZvcm1hdCkgOiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5kZWZhdWx0UG9zdEhlYWRlcnMoZm9ybWF0KTtcclxuXHJcblx0XHRpZihjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XHJcblx0XHRcdGlmKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3JlcXVlc3QnLCBbbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnNdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYodHlwZW9mIGJvZHkgIT09ICdzdHJpbmcnKSB7XHJcblx0XHRcdGJvZHkgPSBlbmNvZGVyKGJvZHkpO1xyXG5cdFx0fVxyXG5cdFx0aWYodGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xyXG5cdFx0fVxyXG5cdFx0aWYoY3VzdG9tSGVhZGVycykge1xyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5taXhpbihoZWFkZXJzLCBjdXN0b21IZWFkZXJzKTtcclxuXHRcdH1cclxuXHRcdHZhciBwYWdpbmF0ZWRSZXNvdXJjZSA9IG5ldyBwYWdpbmF0ZWRyZXNvdXJjZSh0aGlzLCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24ocmVzYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcclxuXHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuc3VyZUFycmF5KHVucGFja2VkID8gcmVzYm9keSA6IGRlY29kZXIocmVzYm9keSkpO1xyXG5cdFx0fSwgLyogdXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlOiAqLyB0cnVlKTtcclxuXHJcblx0XHRpZighdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYXJySW4oaHR0cFtcImFcIiAvKiBkZWZhdWx0ICovXS5tZXRob2RzLCBtZXRob2QpKSB7XHJcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1Vuc3VwcG9ydGVkIG1ldGhvZCAnICsgbWV0aG9kLCA0MDUwMCwgNDA1KTtcclxuXHRcdH1cclxuXHJcblx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihodHRwW1wiYVwiIC8qIGRlZmF1bHQgKi9dLm1ldGhvZHNXaXRoQm9keSwgbWV0aG9kKSkge1xyXG5cdFx0XHRwYWdpbmF0ZWRSZXNvdXJjZVttZXRob2RdKHBhcmFtcywgYm9keSwgY2FsbGJhY2spO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cGFnaW5hdGVkUmVzb3VyY2VbbWV0aG9kXShwYXJhbXMsIGNhbGxiYWNrKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRSZXN0LnByb3RvdHlwZS5zZXRMb2cgPSBmdW5jdGlvbihsb2dPcHRpb25zKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uc2V0TG9nKGxvZ09wdGlvbnMubGV2ZWwsIGxvZ09wdGlvbnMuaGFuZGxlcik7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gQ2hhbm5lbHMocmVzdCkge1xyXG5cdFx0dGhpcy5yZXN0ID0gcmVzdDtcclxuXHRcdHRoaXMuYWxsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHR9XHJcblxyXG5cdENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lLCBjaGFubmVsT3B0aW9ucykge1xyXG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcclxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XHJcblx0XHRpZighY2hhbm5lbCkge1xyXG5cdFx0XHR0aGlzLmFsbFtuYW1lXSA9IGNoYW5uZWwgPSBuZXcgY2xpZW50X2NoYW5uZWwodGhpcy5yZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XHJcblx0XHR9IGVsc2UgaWYoY2hhbm5lbE9wdGlvbnMpIHtcclxuXHRcdFx0Y2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gY2hhbm5lbDtcclxuXHR9O1xyXG5cclxuXHQvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cclxuXHQgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xyXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24obmFtZSkge1xyXG5cdFx0ZGVsZXRlIHRoaXMuYWxsW1N0cmluZyhuYW1lKV07XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFJlc3Q7XHJcbn0pKCk7XHJcblxyXG5yZXN0X1Jlc3QuUHJvbWlzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRvcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcclxuXHRvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcclxuXHRyZXR1cm4gbmV3IHJlc3RfUmVzdChvcHRpb25zKTtcclxufTtcclxuXHJcbnJlc3RfUmVzdC5DYWxsYmFja3MgPSByZXN0X1Jlc3Q7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcmVzdCA9IChyZXN0X1Jlc3QpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHJhbnNwb3J0L2Nvbm5lY3Rpb25tYW5hZ2VyLmpzXHJcbnZhciBjb25uZWN0aW9ubWFuYWdlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb25zdGF0ZWNoYW5nZS5qc1xyXG52YXIgY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMSk7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2Nvbm5lY3Rpb24uanNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIGNvbm5lY3Rpb25fQ29ubmVjdGlvbiA9IChmdW5jdGlvbigpIHtcclxuXHRmdW5jdGlvbiBub29wKCkge31cclxuXHJcblx0LyogcHVibGljIGNvbnN0cnVjdG9yICovXHJcblx0ZnVuY3Rpb24gQ29ubmVjdGlvbihhYmx5LCBvcHRpb25zKSB7XHJcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcclxuXHRcdHRoaXMuYWJseSA9IGFibHk7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyID0gbmV3IGNvbm5lY3Rpb25tYW5hZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKGFibHksIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5zdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGU7XHJcblx0XHR0aGlzLmtleSA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMuaWQgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLnNlcmlhbCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMudGltZVNlcmlhbCA9IHVuZGVmaW5lZDtcclxuXHRcdHRoaXMucmVjb3ZlcnlLZXkgPSB1bmRlZmluZWQ7XHJcblx0XHR0aGlzLmVycm9yUmVhc29uID0gbnVsbDtcclxuXHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCdjb25uZWN0aW9uc3RhdGUnLCBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xyXG5cdFx0XHR2YXIgc3RhdGUgPSBzZWxmLnN0YXRlID0gc3RhdGVDaGFuZ2UuY3VycmVudDtcclxuXHRcdFx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ubmV4dFRpY2soZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0c2VsZi5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XHJcblx0XHRcdH0pO1xyXG5cdFx0fSk7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd1cGRhdGUnLCBmdW5jdGlvbihzdGF0ZUNoYW5nZSkge1xyXG5cdFx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5uZXh0VGljayhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzZWxmLmVtaXQoJ3VwZGF0ZScsIHN0YXRlQ2hhbmdlKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9KTtcclxuXHR9XHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoQ29ubmVjdGlvbiwgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxuXHJcblx0Q29ubmVjdGlvbi5wcm90b3R5cGUud2hlblN0YXRlID0gZnVuY3Rpb24oc3RhdGUsIGxpc3RlbmVyKSB7XHJcblx0XHRyZXR1cm4gZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb3RvdHlwZS53aGVuU3RhdGUuY2FsbCh0aGlzLCBzdGF0ZSwgdGhpcy5zdGF0ZSwgbGlzdGVuZXIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10odW5kZWZpbmVkLCBzdGF0ZSkpO1xyXG5cdH1cclxuXHJcblx0Q29ubmVjdGlvbi5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5jb25uZWN0KCknLCAnJyk7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjb25uZWN0aW5nJ30pO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb24ucHJvdG90eXBlLnBpbmcgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5waW5nKCknLCAnJyk7XHJcblx0XHRpZighY2FsbGJhY2spIHtcclxuXHRcdFx0aWYodGhpcy5hYmx5Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwaW5nJywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnBpbmcobnVsbCwgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdENvbm5lY3Rpb24ucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdDb25uZWN0aW9uLmNsb3NlKCknLCAnY29ubmVjdGlvbktleSA9ICcgKyB0aGlzLmtleSk7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7c3RhdGU6ICdjbG9zaW5nJ30pO1xyXG5cdH07XHJcblxyXG5cdHJldHVybiBDb25uZWN0aW9uO1xyXG59KSgpO1xyXG5cclxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyB2YXIgY29ubmVjdGlvbiA9IChjb25uZWN0aW9uX0Nvbm5lY3Rpb24pO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHlwZXMvcHJvdG9jb2xtZXNzYWdlLmpzXHJcbnZhciBwcm90b2NvbG1lc3NhZ2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDgpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2NvbW1vbi9saWIvdHJhbnNwb3J0L2Nvbm5lY3Rpb25lcnJvci5qc1xyXG52YXIgY29ubmVjdGlvbmVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMyk7XHJcblxyXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vY29tbW9uL2xpYi91dGlsL211bHRpY2FzdGVyLmpzXHJcbnZhciB1dGlsX211bHRpY2FzdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyMik7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L2NoYW5uZWxzdGF0ZWNoYW5nZS5qc1xyXG52YXIgQ2hhbm5lbFN0YXRlQ2hhbmdlID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cclxuXHRmdW5jdGlvbiBDaGFubmVsU3RhdGVDaGFuZ2UocHJldmlvdXMsIGN1cnJlbnQsIHJlc3VtZWQsIHJlYXNvbikge1xyXG5cdFx0dGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xyXG5cdFx0dGhpcy5jdXJyZW50ID0gY3VycmVudDtcclxuXHRcdGlmKGN1cnJlbnQgPT09ICdhdHRhY2hlZCcpIHRoaXMucmVzdW1lZCA9IHJlc3VtZWQ7XHJcblx0XHRpZihyZWFzb24pIHRoaXMucmVhc29uID0gcmVhc29uO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIENoYW5uZWxTdGF0ZUNoYW5nZTtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIGNoYW5uZWxzdGF0ZWNoYW5nZSA9IChDaGFubmVsU3RhdGVDaGFuZ2UpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZXByZXNlbmNlLmpzXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIHJlYWx0aW1lcHJlc2VuY2VfUmVhbHRpbWVQcmVzZW5jZSA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgbm9vcCA9IGZ1bmN0aW9uKCkge307XHJcblxyXG5cdGZ1bmN0aW9uIG1lbWJlcktleShpdGVtKSB7XHJcblx0XHRyZXR1cm4gaXRlbS5jbGllbnRJZCArICc6JyArIGl0ZW0uY29ubmVjdGlvbklkO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gZ2V0Q2xpZW50SWQocmVhbHRpbWVQcmVzZW5jZSkge1xyXG5cdFx0cmV0dXJuIHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZS5hdXRoLmNsaWVudElkO1xyXG5cdH1cclxuXHJcblx0ZnVuY3Rpb24gaXNBbm9ueW1vdXNPcldpbGRjYXJkKHJlYWx0aW1lUHJlc2VuY2UpIHtcclxuXHRcdHZhciByZWFsdGltZSA9IHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZTtcclxuXHRcdC8qIElmIG5vdCBjdXJyZW50bHkgY29ubmVjdGVkLCB3ZSBjYW4ndCBhc3N1bWUgdGhhdCB3ZSdyZSBhbiBhbm9ueW1vdXNcclxuXHRcdCAqIGNsaWVudCwgYXMgcmVhbHRpbWUgbWF5IGluZm9ybSB1cyBvZiBvdXIgY2xpZW50SWQgaW4gdGhlIENPTk5FQ1RFRFxyXG5cdFx0ICogbWVzc2FnZS4gU28gYXNzdW1lIHdlJ3JlIG5vdCBhbm9ueW1vdXMgYW5kIGxlYXZlIGl0IHRvIHJlYWx0aW1lIHRvXHJcblx0XHQgKiByZXR1cm4gYW4gZXJyb3IgaWYgd2UgYXJlICovXHJcblx0XHR2YXIgY2xpZW50SWQgPSByZWFsdGltZS5hdXRoLmNsaWVudElkO1xyXG5cdFx0cmV0dXJuICghY2xpZW50SWQgfHwgKGNsaWVudElkID09PSAnKicpKSAmJiByZWFsdGltZS5jb25uZWN0aW9uLnN0YXRlID09PSAnY29ubmVjdGVkJztcclxuXHR9XHJcblxyXG5cdC8qIENhbGxiYWNrIGlzIGNhbGxlZCBvbmx5IGluIHRoZSBldmVudCBvZiBhbiBlcnJvciAqL1xyXG5cdGZ1bmN0aW9uIHdhaXRBdHRhY2hlZChjaGFubmVsLCBjYWxsYmFjaywgYWN0aW9uKSB7XHJcblx0XHRzd2l0Y2goY2hhbm5lbC5zdGF0ZSkge1xyXG5cdFx0XHRjYXNlICdhdHRhY2hlZCc6XHJcblx0XHRcdGNhc2UgJ3N1c3BlbmRlZCc6XHJcblx0XHRcdFx0YWN0aW9uKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcclxuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxyXG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxyXG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxyXG5cdFx0XHRcdGNoYW5uZWwuYXR0YWNoKGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdFx0aWYoZXJyKSBjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdFx0ZWxzZSBhY3Rpb24oKTtcclxuXHRcdFx0XHR9KTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhyZWFsdGltZWNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoY2hhbm5lbC5zdGF0ZSkpKTtcclxuXHRcdH1cclxuXHR9XHJcblxyXG5cdGZ1bmN0aW9uIFJlYWx0aW1lUHJlc2VuY2UoY2hhbm5lbCwgb3B0aW9ucykge1xyXG5cdFx0Y2xpZW50X3ByZXNlbmNlLmNhbGwodGhpcywgY2hhbm5lbCk7XHJcblx0XHR0aGlzLnN5bmNDb21wbGV0ZSA9IGZhbHNlO1xyXG5cdFx0dGhpcy5tZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMpO1xyXG5cdFx0dGhpcy5fbXlNZW1iZXJzID0gbmV3IFByZXNlbmNlTWFwKHRoaXMpO1xyXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xyXG5cdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UgPSBbXTtcclxuXHR9XHJcblx0dXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaW5oZXJpdHMoUmVhbHRpbWVQcmVzZW5jZSwgY2xpZW50X3ByZXNlbmNlKTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbihkYXRhLCBjYWxsYmFjaykge1xyXG5cdFx0aWYoaXNBbm9ueW1vdXNPcldpbGRjYXJkKHRoaXMpKSB7XHJcblx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIGVudGVyIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCAnZW50ZXInLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24oZGF0YSwgY2FsbGJhY2spIHtcclxuXHRcdGlmKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xyXG5cdFx0XHR0aHJvdyBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdjbGllbnRJZCBtdXN0IGJlIHNwZWNpZmllZCB0byB1cGRhdGUgcHJlc2VuY2UgZGF0YScsIDQwMDEyLCA0MDApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCAndXBkYXRlJywgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmVudGVyQ2xpZW50ID0gZnVuY3Rpb24oY2xpZW50SWQsIGRhdGEsIGNhbGxiYWNrKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChjbGllbnRJZCwgZGF0YSwgJ2VudGVyJywgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnVwZGF0ZUNsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQoY2xpZW50SWQsIGRhdGEsICd1cGRhdGUnLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2VudGVyT3JVcGRhdGVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgYWN0aW9uLCBjYWxsYmFjaykge1xyXG5cdFx0aWYgKCFjYWxsYmFjaykge1xyXG5cdFx0XHRpZiAodHlwZW9mKGRhdGEpPT09J2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGNhbGxiYWNrID0gZGF0YTtcclxuXHRcdFx0XHRkYXRhID0gbnVsbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnX2VudGVyT3JVcGRhdGVDbGllbnQnLCBbY2xpZW50SWQsIGRhdGEsIGFjdGlvbl0pO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcclxuXHRcdGlmKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcclxuXHRcdFx0Y2FsbGJhY2soY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuJyArIGFjdGlvbiArICdDbGllbnQoKScsXHJcblx0XHQgICdjaGFubmVsID0gJyArIGNoYW5uZWwubmFtZSArICcsIGNsaWVudCA9ICcgKyAoY2xpZW50SWQgfHwgJyhpbXBsaWNpdCkgJyArIGdldENsaWVudElkKHRoaXMpKSk7XHJcblxyXG5cdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xyXG5cdFx0XHRhY3Rpb24gOiBhY3Rpb24sXHJcblx0XHRcdGRhdGEgICA6IGRhdGFcclxuXHRcdH0pO1xyXG5cdFx0aWYgKGNsaWVudElkKSB7XHJcblx0XHRcdHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0cHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmVuY29kZShwcmVzZW5jZSwgY2hhbm5lbC5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdGlmIChlcnIpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzd2l0Y2goY2hhbm5lbC5zdGF0ZSkge1xyXG5cdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcclxuXHRcdFx0XHRcdGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XHJcblx0XHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxyXG5cdFx0XHRcdFx0Y2hhbm5lbC5hdHRhY2goKTtcclxuXHRcdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxyXG5cdFx0XHRcdFx0c2VsZi5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XHJcblx0XHRcdFx0XHRcdHByZXNlbmNlIDogcHJlc2VuY2UsXHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrIDogY2FsbGJhY2tcclxuXHRcdFx0XHRcdH0pO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHRcdGVyciA9IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byAnICsgYWN0aW9uICsgJyBwcmVzZW5jZSBjaGFubmVsIHdoaWxlIGluICcgKyBjaGFubmVsLnN0YXRlICsgJyBzdGF0ZScsIDkwMDAxKTtcclxuXHRcdFx0XHRcdGVyci5jb2RlID0gOTAwMDE7XHJcblx0XHRcdFx0XHRjYWxsYmFjayhlcnIpO1xyXG5cdFx0XHR9XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5sZWF2ZSA9IGZ1bmN0aW9uKGRhdGEsIGNhbGxiYWNrKSB7XHJcblx0XHRpZihpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcclxuXHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnY2xpZW50SWQgbXVzdCBoYXZlIGJlZW4gc3BlY2lmaWVkIHRvIGVudGVyIG9yIGxlYXZlIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHRoaXMubGVhdmVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUubGVhdmVDbGllbnQgPSBmdW5jdGlvbihjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcclxuXHRcdGlmICghY2FsbGJhY2spIHtcclxuXHRcdFx0aWYgKHR5cGVvZihkYXRhKT09PSdmdW5jdGlvbicpIHtcclxuXHRcdFx0XHRjYWxsYmFjayA9IGRhdGE7XHJcblx0XHRcdFx0ZGF0YSA9IG51bGw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2xlYXZlQ2xpZW50JywgW2NsaWVudElkLCBkYXRhXSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xyXG5cdFx0aWYoIWNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuYWN0aXZlU3RhdGUoKSkge1xyXG5cdFx0XHRjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5sZWF2ZUNsaWVudCgpJywgJ2xlYXZpbmc7IGNoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBjbGllbnQgPSAnICsgY2xpZW50SWQpO1xyXG5cdFx0dmFyIHByZXNlbmNlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe1xyXG5cdFx0XHRhY3Rpb24gOiAnbGVhdmUnLFxyXG5cdFx0XHRkYXRhICAgOiBkYXRhXHJcblx0XHR9KTtcclxuXHRcdGlmIChjbGllbnRJZCkgeyBwcmVzZW5jZS5jbGllbnRJZCA9IGNsaWVudElkOyB9XHJcblxyXG5cdFx0c3dpdGNoKGNoYW5uZWwuc3RhdGUpIHtcclxuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxyXG5cdFx0XHRcdGNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlLCBjYWxsYmFjayk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XHJcblx0XHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XHJcblx0XHRcdFx0XHRwcmVzZW5jZSA6IHByZXNlbmNlLFxyXG5cdFx0XHRcdFx0Y2FsbGJhY2sgOiBjYWxsYmFja1xyXG5cdFx0XHRcdH0pO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdpbml0aWFsaXplZCc6XHJcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XHJcblx0XHRcdFx0Lyogd2UncmUgbm90IGF0dGFjaGVkOyB0aGVyZWZvcmUgd2UgbGV0IGFueSBlbnRlcmVkIHN0YXR1c1xyXG5cdFx0XHRcdCAqIHRpbWVvdXQgYnkgaXRzZWxmIGluc3RlYWQgb2YgYXR0YWNoaW5nIGp1c3QgaW4gb3JkZXIgdG8gbGVhdmUgKi9cclxuXHRcdFx0XHR2YXIgZXJyID0gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIGxlYXZlIHByZXNlbmNlIGNoYW5uZWwgKGluY29tcGF0aWJsZSBzdGF0ZSknLCA5MDAwMSk7XHJcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHQvKiB0aGVyZSBpcyBubyBjb25uZWN0aW9uOyB0aGVyZWZvcmUgd2UgbGV0XHJcblx0XHRcdFx0ICogYW55IGVudGVyZWQgc3RhdHVzIHRpbWVvdXQgYnkgaXRzZWxmICovXHJcblx0XHRcdFx0Y2FsbGJhY2soY29ubmVjdGlvbmVycm9yW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZhaWxlZCk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24oLyogcGFyYW1zLCBjYWxsYmFjayAqLykge1xyXG5cdFx0dmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xyXG5cdFx0aWYoYXJncy5sZW5ndGggPT0gMSAmJiB0eXBlb2YoYXJnc1swXSkgPT0gJ2Z1bmN0aW9uJylcclxuXHRcdFx0YXJncy51bnNoaWZ0KG51bGwpO1xyXG5cclxuXHRcdHZhciBwYXJhbXMgPSBhcmdzWzBdLFxyXG5cdFx0XHRjYWxsYmFjayA9IGFyZ3NbMV0sXHJcblx0XHRcdHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoJ3dhaXRGb3JTeW5jJyBpbiBwYXJhbXMgPyBwYXJhbXMud2FpdEZvclN5bmMgOiB0cnVlKTtcclxuXHJcblx0XHRpZighY2FsbGJhY2spIHtcclxuXHRcdFx0aWYodGhpcy5jaGFubmVsLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdnZXQnLCBhcmdzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0ZnVuY3Rpb24gcmV0dXJuTWVtYmVycyhtZW1iZXJzKSB7XHJcblx0XHRcdGNhbGxiYWNrKG51bGwsIHBhcmFtcyA/IG1lbWJlcnMubGlzdChwYXJhbXMpIDogbWVtYmVycy52YWx1ZXMoKSk7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogU3BlY2lhbC1jYXNlIHRoZSBzdXNwZW5kZWQgc3RhdGU6IGNhbiBzdGlsbCBnZXQgKHN0YWxlKSBwcmVzZW5jZSBzZXQgaWYgd2FpdEZvclN5bmMgaXMgZmFsc2UgKi9cclxuXHRcdGlmKHRoaXMuY2hhbm5lbC5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcpIHtcclxuXHRcdFx0aWYod2FpdEZvclN5bmMpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XHJcblx0XHRcdFx0XHRzdGF0dXNDb2RlOiA0MDAsXHJcblx0XHRcdFx0XHRjb2RlOiA5MTAwNSxcclxuXHRcdFx0XHRcdG1lc3NhZ2U6ICdQcmVzZW5jZSBzdGF0ZSBpcyBvdXQgb2Ygc3luYyBkdWUgdG8gY2hhbm5lbCBiZWluZyBpbiB0aGUgU1VTUEVOREVEIHN0YXRlJ1xyXG5cdFx0XHRcdH0pKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRyZXR1cm5NZW1iZXJzKHRoaXMubWVtYmVycyk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHZhciBzZWxmID0gdGhpcztcclxuXHRcdHdhaXRBdHRhY2hlZCh0aGlzLmNoYW5uZWwsIGNhbGxiYWNrLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0dmFyIG1lbWJlcnMgPSBzZWxmLm1lbWJlcnM7XHJcblx0XHRcdGlmKHdhaXRGb3JTeW5jKSB7XHJcblx0XHRcdFx0bWVtYmVycy53YWl0U3luYyhmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRcdHJldHVybk1lbWJlcnMobWVtYmVycyk7XHJcblx0XHRcdFx0fSk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0cmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcclxuXHRcdFx0fVxyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uKHBhcmFtcywgY2FsbGJhY2spIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuaGlzdG9yeSgpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5uYW1lKTtcclxuXHRcdC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xyXG5cdFx0aWYoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRpZih0eXBlb2YocGFyYW1zKSA9PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XHJcblx0XHRcdFx0cGFyYW1zID0gbnVsbDtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdGNhbGxiYWNrID0gbm9vcDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcclxuXHRcdFx0aWYodGhpcy5jaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XHJcblx0XHRcdFx0ZGVsZXRlIHBhcmFtcy51bnRpbEF0dGFjaDtcclxuXHRcdFx0XHRwYXJhbXMuZnJvbV9zZXJpYWwgPSB0aGlzLmNoYW5uZWwucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcIm9wdGlvbiB1bnRpbEF0dGFjaCByZXF1aXJlcyB0aGUgY2hhbm5lbCB0byBiZSBhdHRhY2hlZCwgd2FzOiBcIiArIHRoaXMuY2hhbm5lbC5zdGF0ZSwgNDAwMDAsIDQwMCkpO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xpZW50X3ByZXNlbmNlLnByb3RvdHlwZS5faGlzdG9yeS5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnNldFByZXNlbmNlID0gZnVuY3Rpb24ocHJlc2VuY2VTZXQsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2Uuc2V0UHJlc2VuY2UoKScsICdyZWNlaXZlZCBwcmVzZW5jZSBmb3IgJyArIHByZXNlbmNlU2V0Lmxlbmd0aCArICcgcGFydGljaXBhbnRzOyBzeW5jQ2hhbm5lbFNlcmlhbCA9ICcgKyBzeW5jQ2hhbm5lbFNlcmlhbCk7XHJcblx0XHR2YXIgc3luY0N1cnNvciwgbWF0Y2gsIG1lbWJlcnMgPSB0aGlzLm1lbWJlcnMsIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycyxcclxuXHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMgPSBbXSwgY29ubklkID0gdGhpcy5jaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3Rpb25JZDtcclxuXHJcblx0XHRpZihpc1N5bmMpIHtcclxuXHRcdFx0dGhpcy5tZW1iZXJzLnN0YXJ0U3luYygpO1xyXG5cdFx0XHRpZihzeW5jQ2hhbm5lbFNlcmlhbCAmJiAobWF0Y2ggPSBzeW5jQ2hhbm5lbFNlcmlhbC5tYXRjaCgvXltcXHdcXC1dKzooLiopJC8pKSkge1xyXG5cdFx0XHRcdHN5bmNDdXJzb3IgPSBtYXRjaFsxXTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwcmVzZW5jZVNldC5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhwcmVzZW5jZVNldFtpXSk7XHJcblx0XHRcdHN3aXRjaChwcmVzZW5jZS5hY3Rpb24pIHtcclxuXHRcdFx0XHRjYXNlICdsZWF2ZSc6XHJcblx0XHRcdFx0XHRpZihtZW1iZXJzLnJlbW92ZShwcmVzZW5jZSkpIHtcclxuXHRcdFx0XHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCAmJiAhcHJlc2VuY2UuaXNTeW50aGVzaXplZCgpKSB7XHJcblx0XHRcdFx0XHRcdG15TWVtYmVycy5yZW1vdmUocHJlc2VuY2UpO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnZW50ZXInOlxyXG5cdFx0XHRcdGNhc2UgJ3ByZXNlbnQnOlxyXG5cdFx0XHRcdGNhc2UgJ3VwZGF0ZSc6XHJcblx0XHRcdFx0XHRpZihtZW1iZXJzLnB1dChwcmVzZW5jZSkpIHtcclxuXHRcdFx0XHRcdFx0YnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0XHRpZihwcmVzZW5jZS5jb25uZWN0aW9uSWQgPT09IGNvbm5JZCkge1xyXG5cdFx0XHRcdFx0XHRteU1lbWJlcnMucHV0KHByZXNlbmNlKTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0XHQvKiBpZiB0aGlzIGlzIHRoZSBsYXN0IChvciBvbmx5KSBtZXNzYWdlIGluIGEgc2VxdWVuY2Ugb2Ygc3luYyB1cGRhdGVzLCBlbmQgdGhlIHN5bmMgKi9cclxuXHRcdGlmKGlzU3luYyAmJiAhc3luY0N1cnNvcikge1xyXG5cdFx0XHRtZW1iZXJzLmVuZFN5bmMoKTtcclxuXHRcdFx0LyogUlRQNWMyOiByZS1lbnRlciBvdXIgb3duIG1lbWJlcnMgaWYgdGhleSBoYXZlbid0IHNob3duIHVwIGluIHRoZSBzeW5jICovXHJcblx0XHRcdHRoaXMuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKTtcclxuXHRcdFx0dGhpcy5jaGFubmVsLnNldEluUHJvZ3Jlc3MocmVhbHRpbWVjaGFubmVsLnByb2dyZXNzT3BzLnN5bmMsIGZhbHNlKTtcclxuXHRcdFx0dGhpcy5jaGFubmVsLnN5bmNDaGFubmVsU2VyaWFsID0gbnVsbDtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBicm9hZGNhc3QgdG8gbGlzdGVuZXJzICovXHJcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgYnJvYWRjYXN0TWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0dmFyIHByZXNlbmNlID0gYnJvYWRjYXN0TWVzc2FnZXNbaV07XHJcblx0XHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5lbWl0KHByZXNlbmNlLmFjdGlvbiwgcHJlc2VuY2UpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLm9uQXR0YWNoZWQgPSBmdW5jdGlvbihoYXNQcmVzZW5jZSkge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGhhc1ByZXNlbmNlID0gJyArIGhhc1ByZXNlbmNlKTtcclxuXHJcblx0XHRpZihoYXNQcmVzZW5jZSkge1xyXG5cdFx0XHR0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XHJcblx0XHRcdHRoaXMubWVtYmVycy5jbGVhcigpO1xyXG5cdFx0XHR0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XHJcblx0XHR9XHJcblxyXG5cdFx0LyogTkIgdGhpcyBtdXN0IGJlIGFmdGVyIHRoZSBfZW5zdXJlTXlNZW1iZXJzUHJlc2VudCBjYWxsLCB3aGljaCBtYXkgYWRkIGl0ZW1zIHRvIHBlbmRpbmdQcmVzZW5jZSAqL1xyXG5cdFx0dmFyIHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLFxyXG5cdFx0XHRwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcclxuXHJcblx0XHRpZihwZW5kaW5nUHJlc0NvdW50KSB7XHJcblx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XHJcblx0XHRcdHZhciBwcmVzZW5jZUFycmF5ID0gW107XHJcblx0XHRcdHZhciBtdWx0aWNhc3RlciA9IE9iamVjdCh1dGlsX211bHRpY2FzdGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKSgpO1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQnLCAnc2VuZGluZyAnICsgcGVuZGluZ1ByZXNDb3VudCArICcgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzJyk7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBwZW5kaW5nUHJlc0NvdW50OyBpKyspIHtcclxuXHRcdFx0XHR2YXIgZXZlbnQgPSBwZW5kaW5nUHJlc2VuY2VbaV07XHJcblx0XHRcdFx0cHJlc2VuY2VBcnJheS5wdXNoKGV2ZW50LnByZXNlbmNlKTtcclxuXHRcdFx0XHRtdWx0aWNhc3Rlci5wdXNoKGV2ZW50LmNhbGxiYWNrKTtcclxuXHRcdFx0fVxyXG5cdFx0XHR0aGlzLmNoYW5uZWwuc2VuZFByZXNlbmNlKHByZXNlbmNlQXJyYXksIG11bHRpY2FzdGVyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5hY3RPbkNoYW5uZWxTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XHJcblx0XHRzd2l0Y2goc3RhdGUpIHtcclxuXHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxyXG5cdFx0XHRcdHRoaXMub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcclxuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcclxuXHRcdFx0XHR0aGlzLl9jbGVhck15TWVtYmVycygpO1xyXG5cdFx0XHRcdHRoaXMubWVtYmVycy5jbGVhcigpO1xyXG5cdFx0XHRcdC8qIGZhbGxzIHRocm91Z2ggKi9cclxuXHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcclxuXHRcdFx0XHR0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5mYWlsUGVuZGluZ1ByZXNlbmNlID0gZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRpZih0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGgpIHtcclxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmZhaWxQZW5kaW5nUHJlc2VuY2UnLCAnY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGVyciA9ICcgKyB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbnNwZWN0RXJyb3IoZXJyKSk7XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLnBlbmRpbmdQcmVzZW5jZS5sZW5ndGg7IGkrKylcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHR9IGNhdGNoKGUpIHt9XHJcblx0XHRcdHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2NsZWFyTXlNZW1iZXJzID0gZnVuY3Rpb24oKSB7XHJcblx0XHR0aGlzLl9teU1lbWJlcnMuY2xlYXIoKTtcclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzLCBtZW1iZXJzID0gdGhpcy5tZW1iZXJzLCBteU1lbWJlcnMgPSB0aGlzLl9teU1lbWJlcnMsXHJcblx0XHRcdHJlZW50ZXJDYiA9IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdGlmKGVycikge1xyXG5cdFx0XHRcdFx0dmFyIG1zZyA9ICdQcmVzZW5jZSBhdXRvLXJlLWVudGVyIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpO1xyXG5cdFx0XHRcdFx0dmFyIHdyYXBwZWRFcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKG1zZywgOTEwMDQsIDQwMCk7XHJcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCBtc2cpO1xyXG5cdFx0XHRcdFx0dmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2Uoc2VsZi5jaGFubmVsLnN0YXRlLCBzZWxmLmNoYW5uZWwuc3RhdGUsIHRydWUsIHdyYXBwZWRFcnIpO1xyXG5cdFx0XHRcdFx0c2VsZi5jaGFubmVsLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9O1xyXG5cclxuXHRcdGZvcih2YXIgbWVtYmVyS2V5IGluIG15TWVtYmVycy5tYXApIHtcclxuXHRcdFx0aWYoIShtZW1iZXJLZXkgaW4gbWVtYmVycy5tYXApKSB7XHJcblx0XHRcdFx0dmFyIGVudHJ5ID0gbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xyXG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lUHJlc2VuY2UuX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQoKScsICdBdXRvLXJlZW50ZXJpbmcgY2xpZW50SWQgXCInICsgZW50cnkuY2xpZW50SWQgKyAnXCIgaW50byB0aGUgcHJlc2VuY2Ugc2V0Jyk7XHJcblx0XHRcdFx0dGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudChlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgJ2VudGVyJywgcmVlbnRlckNiKTtcclxuXHRcdFx0XHRkZWxldGUgbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX3N5bnRoZXNpemVMZWF2ZXMgPSBmdW5jdGlvbihpdGVtcykge1xyXG5cdFx0dmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XHJcblx0XHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJGb3JFYWNoKGl0ZW1zLCBmdW5jdGlvbihpdGVtKSB7XHJcblx0XHRcdHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHtcclxuXHRcdFx0XHRhY3Rpb246ICdsZWF2ZScsXHJcblx0XHRcdFx0Y29ubmVjdGlvbklkOiBpdGVtLmNvbm5lY3Rpb25JZCxcclxuXHRcdFx0XHRjbGllbnRJZDogaXRlbS5jbGllbnRJZCxcclxuXHRcdFx0XHRkYXRhOiBpdGVtLmRhdGEsXHJcblx0XHRcdFx0ZW5jb2Rpbmc6IGl0ZW0uZW5jb2RpbmcsXHJcblx0XHRcdFx0dGltZXN0YW1wOiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5ub3coKVxyXG5cdFx0XHR9KTtcclxuXHRcdFx0c3Vic2NyaXB0aW9ucy5lbWl0KCdsZWF2ZScsIHByZXNlbmNlKTtcclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdC8qIERlcHJlY2F0ZWQgKi9cclxuXHRSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlcHJlY2F0ZWQoJ3ByZXNlbmNlLm9uJywgJ3ByZXNlbmNlLnN1YnNjcmliZScpO1xyXG5cdFx0dGhpcy5zdWJzY3JpYmUuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuXHR9O1xyXG5cclxuXHQvKiBEZXByZWNhdGVkICovXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24oKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVwcmVjYXRlZCgncHJlc2VuY2Uub2ZmJywgJ3ByZXNlbmNlLnVuc3Vic2NyaWJlJyk7XHJcblx0XHR0aGlzLnVuc3Vic2NyaWJlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24oLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi8pIHtcclxuXHRcdHZhciBhcmdzID0gcmVhbHRpbWVjaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MoYXJndW1lbnRzKTtcclxuXHRcdHZhciBldmVudCA9IGFyZ3NbMF07XHJcblx0XHR2YXIgbGlzdGVuZXIgPSBhcmdzWzFdO1xyXG5cdFx0dmFyIGNhbGxiYWNrID0gYXJnc1syXTtcclxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5jaGFubmVsO1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cclxuXHRcdGlmKCFjYWxsYmFjaykge1xyXG5cdFx0XHRpZih0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcclxuXHRcdFx0Y2FsbGJhY2soZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMocmVhbHRpbWVjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCdmYWlsZWQnKSkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XHJcblx0XHRjaGFubmVsLmF0dGFjaChjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLykge1xyXG5cdFx0dmFyIGFyZ3MgPSByZWFsdGltZWNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xyXG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcclxuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XHJcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMub2ZmKGV2ZW50LCBsaXN0ZW5lcik7XHJcblx0fTtcclxuXHJcblx0ZnVuY3Rpb24gUHJlc2VuY2VNYXAocHJlc2VuY2UpIHtcclxuXHRcdGV2ZW50ZW1pdHRlcltcImFcIiAvKiBkZWZhdWx0ICovXS5jYWxsKHRoaXMpO1xyXG5cdFx0dGhpcy5wcmVzZW5jZSA9IHByZXNlbmNlO1xyXG5cdFx0dGhpcy5tYXAgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xyXG5cdFx0dGhpcy5zeW5jSW5Qcm9ncmVzcyA9IGZhbHNlO1xyXG5cdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xyXG5cdH1cclxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhQcmVzZW5jZU1hcCwgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxuXHJcblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uKGtleSkge1xyXG5cdFx0cmV0dXJuIHRoaXMubWFwW2tleV07XHJcblx0fTtcclxuXHJcblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmdldENsaWVudCA9IGZ1bmN0aW9uKGNsaWVudElkKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xyXG5cdFx0Zm9yKHZhciBrZXkgaW4gbWFwKSB7XHJcblx0XHRcdHZhciBpdGVtID0gbWFwW2tleV07XHJcblx0XHRcdGlmKGl0ZW0uY2xpZW50SWQgPT0gY2xpZW50SWQgJiYgaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24ocGFyYW1zKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsXHJcblx0XHRcdGNsaWVudElkID0gcGFyYW1zICYmIHBhcmFtcy5jbGllbnRJZCxcclxuXHRcdFx0Y29ubmVjdGlvbklkID0gcGFyYW1zICYmIHBhcmFtcy5jb25uZWN0aW9uSWQsXHJcblx0XHRcdHJlc3VsdCA9IFtdO1xyXG5cclxuXHRcdGZvcih2YXIga2V5IGluIG1hcCkge1xyXG5cdFx0XHR2YXIgaXRlbSA9IG1hcFtrZXldO1xyXG5cdFx0XHRpZihpdGVtLmFjdGlvbiA9PT0gJ2Fic2VudCcpIGNvbnRpbnVlO1xyXG5cdFx0XHRpZihjbGllbnRJZCAmJiBjbGllbnRJZCAhPSBpdGVtLmNsaWVudElkKSBjb250aW51ZTtcclxuXHRcdFx0aWYoY29ubmVjdGlvbklkICYmIGNvbm5lY3Rpb25JZCAhPSBpdGVtLmNvbm5lY3Rpb25JZCkgY29udGludWU7XHJcblx0XHRcdHJlc3VsdC5wdXNoKGl0ZW0pO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIHJlc3VsdDtcclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiBuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmcpIHtcclxuXHRcdC8qIFJUUDJiMTogaWYgZWl0aGVyIGlzIHN5bnRoZXNpc2VkLCBjb21wYXJlIGJ5IHRpbWVzdGFtcCAqL1xyXG5cdFx0aWYoaXRlbS5pc1N5bnRoZXNpemVkKCkgfHwgZXhpc3RpbmcuaXNTeW50aGVzaXplZCgpKSB7XHJcblx0XHRcdHJldHVybiBpdGVtLnRpbWVzdGFtcCA+IGV4aXN0aW5nLnRpbWVzdGFtcDtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBSVFAyYjIgKi9cclxuXHRcdHZhciBpdGVtT3JkZXJpbmdzID0gaXRlbS5wYXJzZUlkKCksXHJcblx0XHRcdGV4aXN0aW5nT3JkZXJpbmdzID0gZXhpc3RpbmcucGFyc2VJZCgpO1xyXG5cdFx0aWYoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xyXG5cdFx0XHRyZXR1cm4gaXRlbU9yZGVyaW5ncy5pbmRleCA+IGV4aXN0aW5nT3JkZXJpbmdzLmluZGV4O1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0cmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uKGl0ZW0pIHtcclxuXHRcdGlmKGl0ZW0uYWN0aW9uID09PSAnZW50ZXInIHx8IGl0ZW0uYWN0aW9uID09PSAndXBkYXRlJykge1xyXG5cdFx0XHRpdGVtID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoaXRlbSk7XHJcblx0XHRcdGl0ZW0uYWN0aW9uID0gJ3ByZXNlbnQnO1xyXG5cdFx0fVxyXG5cdFx0dmFyIG1hcCA9IHRoaXMubWFwLCBrZXkgPSBtZW1iZXJLZXkoaXRlbSk7XHJcblx0XHQvKiB3ZSd2ZSBzZWVuIHRoaXMgbWVtYmVyLCBzbyBkbyBub3QgcmVtb3ZlIGl0IGF0IHRoZSBlbmQgb2Ygc3luYyAqL1xyXG5cdFx0aWYodGhpcy5yZXNpZHVhbE1lbWJlcnMpXHJcblx0XHRcdGRlbGV0ZSB0aGlzLnJlc2lkdWFsTWVtYmVyc1trZXldO1xyXG5cclxuXHRcdC8qIGNvbXBhcmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbmV3IGl0ZW0gd2l0aCBhbnkgZXhpc3RpbmcgbWVtYmVyIChvciBBQlNFTlQgd2l0bmVzcykgKi9cclxuXHRcdHZhciBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcclxuXHRcdGlmKGV4aXN0aW5nSXRlbSAmJiAhbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nSXRlbSkpIHtcclxuXHRcdFx0cmV0dXJuIGZhbHNlO1xyXG5cdFx0fVxyXG5cdFx0bWFwW2tleV0gPSBpdGVtO1xyXG5cdFx0cmV0dXJuIHRydWU7XHJcblxyXG5cdH07XHJcblxyXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS52YWx1ZXMgPSBmdW5jdGlvbigpIHtcclxuXHRcdHZhciBtYXAgPSB0aGlzLm1hcCwgcmVzdWx0ID0gW107XHJcblx0XHRmb3IodmFyIGtleSBpbiBtYXApIHtcclxuXHRcdFx0dmFyIGl0ZW0gPSBtYXBba2V5XTtcclxuXHRcdFx0aWYoaXRlbS5hY3Rpb24gIT0gJ2Fic2VudCcpXHJcblx0XHRcdFx0cmVzdWx0LnB1c2goaXRlbSk7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gcmVzdWx0O1xyXG5cdH07XHJcblxyXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbihpdGVtKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIGtleSA9IG1lbWJlcktleShpdGVtKTtcclxuXHRcdHZhciBleGlzdGluZ0l0ZW0gPSBtYXBba2V5XTtcclxuXHJcblx0XHRpZihleGlzdGluZ0l0ZW0gJiYgIW5ld2VyVGhhbihpdGVtLCBleGlzdGluZ0l0ZW0pKSB7XHJcblx0XHRcdHJldHVybiBmYWxzZTtcclxuXHRcdH1cclxuXHJcblx0XHQvKiBSVFAyZiAqL1xyXG5cdFx0aWYodGhpcy5zeW5jSW5Qcm9ncmVzcykge1xyXG5cdFx0XHRpdGVtID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoaXRlbSk7XHJcblx0XHRcdGl0ZW0uYWN0aW9uID0gJ2Fic2VudCc7XHJcblx0XHRcdG1hcFtrZXldID0gaXRlbTtcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdGRlbGV0ZSBtYXBba2V5XTtcclxuXHRcdH1cclxuXHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9O1xyXG5cclxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUuc3RhcnRTeW5jID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLnN0YXJ0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XHJcblx0XHQvKiB3ZSBtaWdodCBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2hpbGUgYSBzeW5jIGlzIGluIHByb2dyZXNzICovXHJcblx0XHRpZighdGhpcy5zeW5jSW5Qcm9ncmVzcykge1xyXG5cdFx0XHR0aGlzLnJlc2lkdWFsTWVtYmVycyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmNvcHkobWFwKTtcclxuXHRcdFx0dGhpcy5zZXRJblByb2dyZXNzKHRydWUpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5lbmRTeW5jID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgbWFwID0gdGhpcy5tYXAsIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLmVuZFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xyXG5cdFx0aWYoc3luY0luUHJvZ3Jlc3MpIHtcclxuXHRcdFx0Lyogd2UgY2FuIG5vdyBzdHJpcCBvdXQgdGhlIEFCU0VOVCBtZW1iZXJzLCBhcyB3ZSBoYXZlXHJcblx0XHRcdCAqIHJlY2VpdmVkIGFsbCBvZiB0aGUgb3V0LW9mLW9yZGVyIHN5bmMgbWVzc2FnZXMgKi9cclxuXHRcdFx0Zm9yKHZhciBtZW1iZXJLZXkgaW4gbWFwKSB7XHJcblx0XHRcdFx0dmFyIGVudHJ5ID0gbWFwW21lbWJlcktleV07XHJcblx0XHRcdFx0aWYoZW50cnkuYWN0aW9uID09PSAnYWJzZW50Jykge1xyXG5cdFx0XHRcdFx0ZGVsZXRlIG1hcFttZW1iZXJLZXldO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fVxyXG5cdFx0XHQvKiBhbnkgbWVtYmVycyB0aGF0IHdlcmUgcHJlc2VudCBhdCB0aGUgc3RhcnQgb2YgdGhlIHN5bmMsXHJcblx0XHRcdCAqIGFuZCBoYXZlIG5vdCBiZWVuIHNlZW4gaW4gc3luYywgY2FuIGJlIHJlbW92ZWQsIGFuZCBsZWF2ZSBldmVudHMgZW1pdHRlZCAqL1xyXG5cdFx0XHR0aGlzLnByZXNlbmNlLl9zeW50aGVzaXplTGVhdmVzKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnZhbHVlc0FycmF5KHRoaXMucmVzaWR1YWxNZW1iZXJzKSk7XHJcblx0XHRcdGZvcih2YXIgbWVtYmVyS2V5IGluIHRoaXMucmVzaWR1YWxNZW1iZXJzKSB7XHJcblx0XHRcdFx0ZGVsZXRlIG1hcFttZW1iZXJLZXldO1xyXG5cdFx0XHR9XHJcblx0XHRcdHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcclxuXHJcblx0XHRcdC8qIGZpbmlzaCwgbm90aWZ5aW5nIGFueSB3YWl0ZXJzICovXHJcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhmYWxzZSk7XHJcblx0XHR9XHJcblx0XHR0aGlzLmVtaXQoJ3N5bmMnKTtcclxuXHR9O1xyXG5cclxuXHRQcmVzZW5jZU1hcC5wcm90b3R5cGUud2FpdFN5bmMgPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0dmFyIHN5bmNJblByb2dyZXNzID0gdGhpcy5zeW5jSW5Qcm9ncmVzcztcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLndhaXRTeW5jKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLnByZXNlbmNlLmNoYW5uZWwubmFtZSArICc7IHN5bmNJblByb2dyZXNzID0gJyArIHN5bmNJblByb2dyZXNzKTtcclxuXHRcdGlmKCFzeW5jSW5Qcm9ncmVzcykge1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR0aGlzLm9uY2UoJ3N5bmMnLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UHJlc2VuY2VNYXAucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdHRoaXMubWFwID0ge307XHJcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xyXG5cdFx0dGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xyXG5cdH07XHJcblxyXG5cdFByZXNlbmNlTWFwLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24oaW5Qcm9ncmVzcykge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUHJlc2VuY2VNYXAuc2V0SW5Qcm9ncmVzcygpJywgJ2luUHJvZ3Jlc3MgPSAnICsgaW5Qcm9ncmVzcyk7XHJcblx0XHR0aGlzLnN5bmNJblByb2dyZXNzID0gaW5Qcm9ncmVzcztcclxuXHRcdHRoaXMucHJlc2VuY2Uuc3luY0NvbXBsZXRlID0gIWluUHJvZ3Jlc3M7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFJlYWx0aW1lUHJlc2VuY2U7XHJcbn0pKCk7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciByZWFsdGltZXByZXNlbmNlID0gKHJlYWx0aW1lcHJlc2VuY2VfUmVhbHRpbWVQcmVzZW5jZSk7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvY2xpZW50L3JlYWx0aW1lY2hhbm5lbC5qc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG52YXIgcmVhbHRpbWVjaGFubmVsX1JlYWx0aW1lQ2hhbm5lbCA9IChmdW5jdGlvbigpIHtcclxuXHR2YXIgYWN0aW9ucyA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5BY3Rpb247XHJcblx0dmFyIG5vb3AgPSBmdW5jdGlvbigpIHt9O1xyXG5cdHZhciBzdGF0ZWNoYW5nZU9wID0gJ3N0YXRlY2hhbmdlJztcclxuXHR2YXIgc3luY09wID0gJ3N5bmMnO1xyXG5cclxuXHQvKiBwdWJsaWMgY29uc3RydWN0b3IgKi9cclxuXHRmdW5jdGlvbiBSZWFsdGltZUNoYW5uZWwocmVhbHRpbWUsIG5hbWUsIG9wdGlvbnMpIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbCgpJywgJ3N0YXJ0ZWQ7IG5hbWUgPSAnICsgbmFtZSk7XHJcblx0XHRjbGllbnRfY2hhbm5lbC5jYWxsKHRoaXMsIHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKTtcclxuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcclxuXHRcdHRoaXMucHJlc2VuY2UgPSBuZXcgcmVhbHRpbWVwcmVzZW5jZSh0aGlzLCByZWFsdGltZS5vcHRpb25zKTtcclxuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSByZWFsdGltZS5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyO1xyXG5cdFx0dGhpcy5zdGF0ZSA9ICdpbml0aWFsaXplZCc7XHJcblx0XHR0aGlzLnN1YnNjcmlwdGlvbnMgPSBuZXcgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XHJcblx0XHR0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gdW5kZWZpbmVkO1xyXG5cdFx0dGhpcy5wcm9wZXJ0aWVzID0ge1xyXG5cdFx0XHRhdHRhY2hTZXJpYWw6IHVuZGVmaW5lZFxyXG5cdFx0fTtcclxuXHRcdHRoaXMuc2V0T3B0aW9ucyhvcHRpb25zKTtcclxuXHRcdHRoaXMuZXJyb3JSZWFzb24gPSBudWxsO1xyXG5cdFx0dGhpcy5fcmVxdWVzdGVkRmxhZ3MgPSBudWxsO1xyXG5cdFx0dGhpcy5fbW9kZSA9IG51bGw7XHJcblx0XHQvKiBUZW1wb3Jhcnk7IG9ubHkgdXNlZCBmb3IgdGhlIGNoZWNrQ2hhbm5lbHNPblJlc3VtZSBvcHRpb24gKi9cclxuXHRcdHRoaXMuX2F0dGFjaGVkTXNnSW5kaWNhdG9yID0gZmFsc2U7XHJcblx0XHR0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcclxuXHRcdHRoaXMuX2RlY29kaW5nQ29udGV4dCA9IHtcclxuXHRcdFx0Y2hhbm5lbE9wdGlvbnM6IHRoaXMuY2hhbm5lbE9wdGlvbnMsXHJcblx0XHRcdHBsdWdpbnM6IHJlYWx0aW1lLm9wdGlvbnMucGx1Z2lucyB8fCB7IH0sXHJcblx0XHRcdGJhc2VFbmNvZGVkUHJldmlvdXNQYXlsb2FkOiB1bmRlZmluZWRcclxuXHRcdH07XHJcblx0XHR0aGlzLl9sYXN0UGF5bG9hZCA9IHtcclxuXHRcdFx0bWVzc2FnZUlkOiBudWxsLFxyXG5cdFx0XHRwcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsOiBudWxsLFxyXG5cdFx0XHRkZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzOiBudWxsXHJcblx0XHR9O1xyXG5cdFx0LyogT25seSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBwdWJsaWMgZXZlbnQgZW1pdHRlciBpcyB0aGF0IHRoaXMgZW1pdHMgYW5cclxuXHRcdCAqIHVwZGF0ZSBldmVudCBmb3IgYWxsIEFUVEFDSEVEcywgd2hldGhlciByZXN1bWVkIG9yIG5vdCAqL1xyXG5cdFx0dGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMgPSBuZXcgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCk7XHJcblx0fVxyXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFJlYWx0aW1lQ2hhbm5lbCwgY2xpZW50X2NoYW5uZWwpO1xyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IgPSBmdW5jdGlvbihzdGF0ZSkge1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0c3RhdHVzQ29kZTogNDAwLFxyXG5cdFx0XHRjb2RlOiA5MDAwMSxcclxuXHRcdFx0bWVzc2FnZTogJ0NoYW5uZWwgb3BlcmF0aW9uIGZhaWxlZCBhcyBjaGFubmVsIHN0YXRlIGlzICcgKyBzdGF0ZVxyXG5cdFx0fTtcclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwucHJvZ3Jlc3NPcHMgPSB7XHJcblx0XHRzdGF0ZWNoYW5nZTogc3RhdGVjaGFuZ2VPcCxcclxuXHRcdHN5bmM6IHN5bmNPcFxyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzID0gZnVuY3Rpb24oYXJncykge1xyXG5cdFx0LyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi9cclxuXHRcdGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzKTtcclxuXHRcdGlmKHR5cGVvZiBhcmdzWzBdID09PSAnZnVuY3Rpb24nKSB7XHJcblx0XHRcdGFyZ3MudW5zaGlmdChudWxsKTtcclxuXHRcdH1cclxuXHRcdGlmKGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0YXJncy5wb3AoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiBhcmdzO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMsIGNhbGxiYWNrKSB7XHJcblx0XHRpZighY2FsbGJhY2spIHtcclxuXHRcdFx0aWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnc2V0T3B0aW9ucycsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKXtcclxuXHRcdFx0XHRpZihlcnIpIHtcclxuXHRcdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5zZXRPcHRpb25zKCknLCAnU2V0IG9wdGlvbnMgZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHRcdHZhciBlcnIgPSB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xyXG5cdFx0aWYoZXJyKSB7XHJcblx0XHRcdGNhbGxiYWNrKGVycik7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGNsaWVudF9jaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zLmNhbGwodGhpcywgb3B0aW9ucyk7XHJcblx0XHRpZiAodGhpcy5fZGVjb2RpbmdDb250ZXh0KVxyXG5cdFx0XHR0aGlzLl9kZWNvZGluZ0NvbnRleHQuY2hhbm5lbE9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xyXG5cdFx0aWYodGhpcy5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMob3B0aW9ucykpIHtcclxuXHRcdFx0LyogVGhpcyBkb2VzIG5vdCBqdXN0IGRvIF9hdHRhY2godHJ1ZSwgbnVsbCwgY2FsbGJhY2spIGJlY2F1c2UgdGhhdCB3b3VsZCBwdXQgdXNcclxuXHRcdFx0ICogaW50byB0aGUgJ2F0dGFjaGluZycgc3RhdGUgdW50aWwgd2UgcmVjZWl2ZSB0aGUgbmV3IGF0dGFjaGVkLCB3aGljaCBpc1xyXG5cdFx0XHQgKiBjb25jZXB0dWFsbHkgaW5jb3JyZWN0OiB3ZSBhcmUgc3RpbGwgYXR0YWNoZWQsIHdlIGp1c3QgaGF2ZSBhIHBlbmRpbmcgcmVxdWVzdCB0b1xyXG5cdFx0XHQgKiBjaGFuZ2Ugc29tZSBjaGFubmVsIHBhcmFtcy4gUGVyIFJUTDE3IGdvaW5nIGludG8gdGhlIGF0dGFjaGluZyBzdGF0ZSB3b3VsZCBtZWFuXHJcblx0XHRcdCAqIHJlamVjdGluZyBtZXNzYWdlcyB1bnRpbCB3ZSBoYXZlIGNvbmZpcm1hdGlvbiB0aGF0IHRoZSBvcHRpb25zIGhhdmUgY2hhbmdlZCxcclxuXHRcdFx0ICogd2hpY2ggd291bGQgdW5uZWNlc3NhcmlseSBsb3NlIG1lc3NhZ2UgY29udGludWl0eS4gKi9cclxuXHRcdFx0dGhpcy5hdHRhY2hJbXBsKCk7XHJcblx0XHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLm9uY2UoZnVuY3Rpb24oc3RhdGVDaGFuZ2UpIHtcclxuXHRcdFx0XHRzd2l0Y2godGhpcy5ldmVudCkge1xyXG5cdFx0XHRcdFx0Y2FzZSAndXBkYXRlJzpcclxuXHRcdFx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcclxuXHRcdFx0XHRcdFx0Y2FsbGJhY2sobnVsbCk7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbik7XHJcblx0XHRcdFx0XHRcdHJldHVybjtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH0pO1xyXG5cdFx0fSBlbHNlIHtcclxuXHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRmdW5jdGlvbiB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpIHtcclxuXHRcdGlmKG9wdGlvbnMgJiYgJ3BhcmFtcycgaW4gb3B0aW9ucyAmJiAhdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPYmplY3Qob3B0aW9ucy5wYXJhbXMpKSB7XHJcblx0XHRcdHJldHVybiBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdvcHRpb25zLnBhcmFtcyBtdXN0IGJlIGFuIG9iamVjdCcsIDQwMDAwLCA0MDApO1xyXG5cdFx0fVxyXG5cdFx0aWYob3B0aW9ucyAmJiAnbW9kZXMnIGluIG9wdGlvbnMpe1xyXG5cdFx0XHRpZighdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNBcnJheShvcHRpb25zLm1vZGVzKSl7XHJcblx0XHRcdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ29wdGlvbnMubW9kZXMgbXVzdCBiZSBhbiBhcnJheScsIDQwMDAwLCA0MDApO1xyXG5cdFx0XHR9XHJcblx0XHRcdGZvcih2YXIgaSA9IDA7IGkgPCBvcHRpb25zLm1vZGVzLmxlbmd0aDsgaSsrKXtcclxuXHRcdFx0XHR2YXIgY3VycmVudE1vZGUgPSBvcHRpb25zLm1vZGVzW2ldO1xyXG5cdFx0XHRcdGlmKCFjdXJyZW50TW9kZSB8fCB0eXBlb2YgY3VycmVudE1vZGUgIT09ICdzdHJpbmcnIHx8ICF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uY2hhbm5lbE1vZGVzLCBTdHJpbmcucHJvdG90eXBlLnRvVXBwZXJDYXNlLmNhbGwoY3VycmVudE1vZGUpKSl7XHJcblx0XHRcdFx0XHRyZXR1cm4gbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnSW52YWxpZCBjaGFubmVsIG1vZGU6ICcgKyBjdXJyZW50TW9kZSwgNDAwMDAsIDQwMCk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblx0fVxyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9zaG91bGRSZWF0dGFjaFRvU2V0T3B0aW9ucyA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRcdHJldHVybiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyB8fCB0aGlzLnN0YXRlID09PSAnYXR0YWNoaW5nJykgJiYgKG9wdGlvbnMucGFyYW1zIHx8IG9wdGlvbnMubW9kZXMpO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcclxuXHRcdFx0bWVzc2FnZXMgPSBhcmd1bWVudHNbMF0sXHJcblx0XHRcdGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ0NvdW50IC0gMV07XHJcblxyXG5cdFx0aWYodHlwZW9mKGNhbGxiYWNrKSAhPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRpZih0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdwdWJsaXNoJywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHRcdCsrYXJnQ291bnQ7XHJcblx0XHR9XHJcblx0XHRpZighdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XHJcblx0XHRcdGNhbGxiYWNrKHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGlmKGFyZ0NvdW50ID09IDIpIHtcclxuXHRcdFx0aWYodXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uaXNPYmplY3QobWVzc2FnZXMpKVxyXG5cdFx0XHRcdG1lc3NhZ2VzID0gW3R5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhtZXNzYWdlcyldO1xyXG5cdFx0XHRlbHNlIGlmKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkobWVzc2FnZXMpKVxyXG5cdFx0XHRcdG1lc3NhZ2VzID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzQXJyYXkobWVzc2FnZXMpO1xyXG5cdFx0XHRlbHNlXHJcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHRtZXNzYWdlcyA9IFt0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe25hbWU6IGFyZ3VtZW50c1swXSwgZGF0YTogYXJndW1lbnRzWzFdfSldO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHNlbGYgPSB0aGlzLFxyXG5cdFx0XHRtYXhNZXNzYWdlU2l6ZSA9IHRoaXMucmVhbHRpbWUub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcclxuXHRcdHR5cGVzX21lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZW5jb2RlQXJyYXkobWVzc2FnZXMsIHRoaXMuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRpZiAoZXJyKSB7XHJcblx0XHRcdFx0Y2FsbGJhY2soZXJyKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0LyogUlNMMWkgKi9cclxuXHRcdFx0dmFyIHNpemUgPSB0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmdldE1lc3NhZ2VzU2l6ZShtZXNzYWdlcyk7XHJcblx0XHRcdGlmKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xyXG5cdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ01heGltdW0gc2l6ZSBvZiBtZXNzYWdlcyB0aGF0IGNhbiBiZSBwdWJsaXNoZWQgYXQgb25jZSBleGNlZWRlZCAoIHdhcyAnICsgc2l6ZSArICcgYnl0ZXM7IGxpbWl0IGlzICcgKyBtYXhNZXNzYWdlU2l6ZSArICcgYnl0ZXMpJywgNDAwMDksIDQwMCkpO1xyXG5cdFx0XHRcdHJldHVybjtcclxuXHRcdFx0fVxyXG5cdFx0XHRzZWxmLl9wdWJsaXNoKG1lc3NhZ2VzLCBjYWxsYmFjayk7XHJcblx0XHR9KTtcclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24obWVzc2FnZXMsIGNhbGxiYWNrKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwucHVibGlzaCgpJywgJ21lc3NhZ2UgY291bnQgPSAnICsgbWVzc2FnZXMubGVuZ3RoKTtcclxuXHRcdHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XHJcblx0XHRzd2l0Y2goc3RhdGUpIHtcclxuXHRcdFx0Y2FzZSAnZmFpbGVkJzpcclxuXHRcdFx0Y2FzZSAnc3VzcGVuZGVkJzpcclxuXHRcdFx0XHRjYWxsYmFjayhlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhSZWFsdGltZUNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3Ioc3RhdGUpKSk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdzZW5kaW5nIG1lc3NhZ2U7IGNoYW5uZWwgc3RhdGUgaXMgJyArIHN0YXRlKTtcclxuXHRcdFx0XHR2YXIgbXNnID0gbmV3IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXSgpO1xyXG5cdFx0XHRcdG1zZy5hY3Rpb24gPSBhY3Rpb25zLk1FU1NBR0U7XHJcblx0XHRcdFx0bXNnLmNoYW5uZWwgPSB0aGlzLm5hbWU7XHJcblx0XHRcdFx0bXNnLm1lc3NhZ2VzID0gbWVzc2FnZXM7XHJcblx0XHRcdFx0dGhpcy5zZW5kTWVzc2FnZShtc2csIGNhbGxiYWNrKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbihtZXNzYWdlcykge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLm9uRXZlbnQoKScsICdyZWNlaXZlZCBtZXNzYWdlJyk7XHJcblx0XHR2YXIgc3Vic2NyaXB0aW9ucyA9IHRoaXMuc3Vic2NyaXB0aW9ucztcclxuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHR2YXIgbWVzc2FnZSA9IG1lc3NhZ2VzW2ldO1xyXG5cdFx0XHRzdWJzY3JpcHRpb25zLmVtaXQobWVzc2FnZS5uYW1lLCBtZXNzYWdlKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmF0dGFjaCA9IGZ1bmN0aW9uKGZsYWdzLCBjYWxsYmFjaykge1xyXG5cdFx0aWYodHlwZW9mKGZsYWdzKSA9PT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRjYWxsYmFjayA9IGZsYWdzO1xyXG5cdFx0XHRmbGFncyA9IG51bGw7XHJcblx0XHR9XHJcblx0XHRpZighY2FsbGJhY2spIHtcclxuXHRcdFx0aWYodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XHJcblx0XHRcdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnByb21pc2lmeSh0aGlzLCAnYXR0YWNoJywgYXJndW1lbnRzKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKGVycikge1xyXG5cdFx0XHRcdGlmKGVycikge1xyXG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaCgpJywgJ0NoYW5uZWwgYXR0YWNoIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHRcdGlmKGZsYWdzKSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5kZXByZWNhdGVkKCdjaGFubmVsLmF0dGFjaCgpIHdpdGggZmxhZ3MnLCAnY2hhbm5lbC5zZXRPcHRpb25zKCkgd2l0aCBjaGFubmVsT3B0aW9ucy5wYXJhbXMnKTtcclxuXHRcdFx0LyogSWYgZmxhZ3MgcmVxdWVzdGVkLCBhbHdheXMgZG8gYSByZS1hdHRhY2guIFRPRE8gb25seSBkbyB0aGlzIGlmXHJcblx0XHRcdCAqIGN1cnJlbnQgbW9kZSBkaWZmZXJzIGZyb20gcmVxdWVzdGVkIG1vZGUgKi9cclxuXHRcdFx0dGhpcy5fcmVxdWVzdGVkRmxhZ3MgPSBmbGFncztcclxuXHRcdH0gZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xyXG5cdFx0XHRjYWxsYmFjaygpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fYXR0YWNoKGZhbHNlLCBudWxsLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fYXR0YWNoID0gZnVuY3Rpb24oZm9yY2VSZWF0dGFjaCwgYXR0YWNoUmVhc29uLCBjYWxsYmFjaykge1xyXG5cdFx0aWYoIWNhbGxiYWNrKSB7XHJcblx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oZXJyKSB7XHJcblx0XHRcdFx0aWYgKGVycikge1xyXG5cdFx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLl9hdHRhY2goKScsICdDaGFubmVsIGF0dGFjaCBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9XHJcblx0XHR9XHJcblxyXG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcclxuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XHJcblx0XHRcdGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblxyXG5cdFx0aWYgKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hpbmcnIHx8IGZvcmNlUmVhdHRhY2gpIHtcclxuXHRcdFx0dGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGF0dGFjaFJlYXNvbik7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XHJcblx0XHRcdHN3aXRjaCh0aGlzLmV2ZW50KSB7XHJcblx0XHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxyXG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRcdGNhc2UgJ2RldGFjaGVkJzpcclxuXHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxyXG5cdFx0XHRcdGNhc2UgJ2ZhaWxlZCc6XHJcblx0XHRcdFx0XHRjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHwgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fCBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdVbmFibGUgdG8gYXR0YWNoOyByZWFzb24gdW5rbm93bjsgc3RhdGUgPSAnICsgdGhpcy5ldmVudCwgOTAwMDAsIDUwMCkpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcclxuXHRcdFx0XHRcdGNhbGxiYWNrKG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0F0dGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGRldGFjaCByZXF1ZXN0JywgOTAwMDAsIDQwOSkpO1xyXG5cdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdH1cclxuXHRcdH0pO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuYXR0YWNoSW1wbCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaEltcGwoKScsICdzZW5kaW5nIEFUVEFDSCBtZXNzYWdlJyk7XHJcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgdHJ1ZSk7XHJcblx0XHR2YXIgYXR0YWNoTXNnID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5BVFRBQ0gsIGNoYW5uZWw6IHRoaXMubmFtZSwgcGFyYW1zOiB0aGlzLmNoYW5uZWxPcHRpb25zLnBhcmFtc30pO1xyXG5cdFx0aWYodGhpcy5fcmVxdWVzdGVkRmxhZ3MpIHtcclxuXHRcdFx0YXR0YWNoTXNnLmVuY29kZU1vZGVzVG9GbGFncyh0aGlzLl9yZXF1ZXN0ZWRGbGFncyk7XHJcblx0XHR9IGVsc2UgaWYodGhpcy5jaGFubmVsT3B0aW9ucy5tb2Rlcykge1xyXG5cdFx0XHRhdHRhY2hNc2cuZW5jb2RlTW9kZXNUb0ZsYWdzKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFsbFRvVXBwZXJDYXNlKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpKTtcclxuXHRcdH1cclxuXHRcdGlmKHRoaXMuX2F0dGFjaFJlc3VtZSkge1xyXG5cdFx0XHRhdHRhY2hNc2cuc2V0RmxhZygnQVRUQUNIX1JFU1VNRScpO1xyXG5cdFx0fVxyXG5cdFx0aWYodGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xyXG5cdFx0XHRhdHRhY2hNc2cuY2hhbm5lbFNlcmlhbCA9IHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWw7XHJcblx0XHR9XHJcblx0XHR0aGlzLnNlbmRNZXNzYWdlKGF0dGFjaE1zZywgbm9vcCk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5kZXRhY2ggPSBmdW5jdGlvbihjYWxsYmFjaykge1xyXG5cdFx0aWYoIWNhbGxiYWNrKSB7XHJcblx0XHRcdGlmKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xyXG5cdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2RldGFjaCcsIGFyZ3VtZW50cyk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcclxuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XHJcblx0XHRcdGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2RldGFjaGVkJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxyXG5cdFx0XHRcdGNhbGxiYWNrKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ2ZhaWxlZCc6XHJcblx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnVW5hYmxlIHRvIGRldGFjaDsgY2hhbm5lbCBzdGF0ZSA9IGZhaWxlZCcsIDkwMDAxLCA0MDApKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0ZGVmYXVsdDpcclxuXHRcdFx0XHR0aGlzLnJlcXVlc3RTdGF0ZSgnZGV0YWNoaW5nJyk7XHJcblx0XHRcdGNhc2UgJ2RldGFjaGluZyc6XHJcblx0XHRcdFx0dGhpcy5vbmNlKGZ1bmN0aW9uKHN0YXRlQ2hhbmdlKSB7XHJcblx0XHRcdFx0XHRzd2l0Y2godGhpcy5ldmVudCkge1xyXG5cdFx0XHRcdFx0XHRjYXNlICdkZXRhY2hlZCc6XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2soKTtcclxuXHRcdFx0XHRcdFx0XHRicmVhaztcclxuXHRcdFx0XHRcdFx0Y2FzZSAnYXR0YWNoZWQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdzdXNwZW5kZWQnOlxyXG5cdFx0XHRcdFx0XHRjYXNlICdmYWlsZWQnOlxyXG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ1VuYWJsZSB0byBkZXRhY2g7IHJlYXNvbiB1bmtub3duOyBzdGF0ZSA9ICcgKyB0aGlzLmV2ZW50LCA5MDAwMCwgNTAwKSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHRcdGNhc2UgJ2F0dGFjaGluZyc6XHJcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnRGV0YWNoIHJlcXVlc3Qgc3VwZXJzZWRlZCBieSBhIHN1YnNlcXVlbnQgYXR0YWNoIHJlcXVlc3QnLCA5MDAwMCwgNDA5KSk7XHJcblx0XHRcdFx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdFx0XHR9XHJcblx0XHRcdFx0fSk7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5kZXRhY2hJbXBsID0gZnVuY3Rpb24oY2FsbGJhY2spIHtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5kZXRhY2goKScsICdzZW5kaW5nIERFVEFDSCBtZXNzYWdlJyk7XHJcblx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgdHJ1ZSk7XHJcblx0XHR2YXIgbXNnID0gcHJvdG9jb2xtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmZyb21WYWx1ZXMoe2FjdGlvbjogYWN0aW9ucy5ERVRBQ0gsIGNoYW5uZWw6IHRoaXMubmFtZX0pO1xyXG5cdFx0dGhpcy5zZW5kTWVzc2FnZShtc2csIChjYWxsYmFjayB8fCBub29wKSk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdWJzY3JpYmUgPSBmdW5jdGlvbigvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xyXG5cdFx0dmFyIGFyZ3MgPSBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmd1bWVudHMpO1xyXG5cdFx0dmFyIGV2ZW50ID0gYXJnc1swXTtcclxuXHRcdHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XHJcblx0XHR2YXIgY2FsbGJhY2sgPSBhcmdzWzJdO1xyXG5cclxuXHRcdGlmKCFjYWxsYmFjaykge1xyXG5cdFx0XHRpZih0aGlzLnJlYWx0aW1lLm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRyZXR1cm4gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvbWlzaWZ5KHRoaXMsICdzdWJzY3JpYmUnLCBbZXZlbnQsIGxpc3RlbmVyXSk7XHJcblx0XHRcdH1cclxuXHRcdFx0Y2FsbGJhY2sgPSBub29wO1xyXG5cdFx0fVxyXG5cclxuXHRcdGlmKHRoaXMuc3RhdGUgPT09ICdmYWlsZWQnKSB7XHJcblx0XHRcdGNhbGxiYWNrKGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKFJlYWx0aW1lQ2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcignZmFpbGVkJykpKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vbihldmVudCwgbGlzdGVuZXIpO1xyXG5cclxuXHRcdHJldHVybiB0aGlzLmF0dGFjaChjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uKC8qIFtldmVudF0sIGxpc3RlbmVyICovKSB7XHJcblx0XHR2YXIgYXJncyA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3VtZW50cyk7XHJcblx0XHR2YXIgZXZlbnQgPSBhcmdzWzBdO1xyXG5cdFx0dmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcclxuXHRcdHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnN5bmMgPSBmdW5jdGlvbigpIHtcclxuXHRcdC8qIGNoZWNrIHByZWNvbmRpdGlvbnMgKi9cclxuXHRcdHN3aXRjaCh0aGlzLnN0YXRlKSB7XHJcblx0XHRcdGNhc2UgJ2luaXRpYWxpemVkJzpcclxuXHRcdFx0Y2FzZSAnZGV0YWNoaW5nJzpcclxuXHRcdFx0Y2FzZSAnZGV0YWNoZWQnOlxyXG5cdFx0XHRcdHRocm93IG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oXCJVbmFibGUgdG8gc3luYyB0byBjaGFubmVsOyBub3QgYXR0YWNoZWRcIiwgNDAwMDApO1xyXG5cdFx0XHRkZWZhdWx0OlxyXG5cdFx0fVxyXG5cdFx0dmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcclxuXHRcdGlmKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XHJcblx0XHRcdHRocm93IGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Lyogc2VuZCBzeW5jIHJlcXVlc3QgKi9cclxuXHRcdHZhciBzeW5jTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHthY3Rpb246IGFjdGlvbnMuU1lOQywgY2hhbm5lbDogdGhpcy5uYW1lfSk7XHJcblx0XHRpZih0aGlzLnN5bmNDaGFubmVsU2VyaWFsKSB7XHJcblx0XHRcdHN5bmNNZXNzYWdlLmNoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsO1xyXG5cdFx0fVxyXG5cdFx0Y29ubmVjdGlvbk1hbmFnZXIuc2VuZChzeW5jTWVzc2FnZSk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kTWVzc2FnZSA9IGZ1bmN0aW9uKG1zZywgY2FsbGJhY2spIHtcclxuXHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc2VuZChtc2csIHRoaXMucmVhbHRpbWUub3B0aW9ucy5xdWV1ZU1lc3NhZ2VzLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kUHJlc2VuY2UgPSBmdW5jdGlvbihwcmVzZW5jZSwgY2FsbGJhY2spIHtcclxuXHRcdHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyh7XHJcblx0XHRcdGFjdGlvbjogYWN0aW9ucy5QUkVTRU5DRSxcclxuXHRcdFx0Y2hhbm5lbDogdGhpcy5uYW1lLFxyXG5cdFx0XHRwcmVzZW5jZTogKHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmlzQXJyYXkocHJlc2VuY2UpID9cclxuXHRcdFx0XHRwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlc0FycmF5KHByZXNlbmNlKSA6XHJcblx0XHRcdFx0W3ByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKHByZXNlbmNlKV0pXHJcblx0XHR9KTtcclxuXHRcdHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbk1lc3NhZ2UgPSBmdW5jdGlvbihtZXNzYWdlKSB7XHJcblx0XHR2YXIgc3luY0NoYW5uZWxTZXJpYWwsIGlzU3luYyA9IGZhbHNlO1xyXG5cdFx0c3dpdGNoKG1lc3NhZ2UuYWN0aW9uKSB7XHJcblx0XHRjYXNlIGFjdGlvbnMuQVRUQUNIRUQ6XHJcblx0XHRcdHRoaXMuX2F0dGFjaGVkTXNnSW5kaWNhdG9yID0gdHJ1ZTtcclxuXHRcdFx0dGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcclxuXHRcdFx0dGhpcy5fbW9kZSA9IG1lc3NhZ2UuZ2V0TW9kZSgpO1xyXG5cdFx0XHR0aGlzLnBhcmFtcyA9IG1lc3NhZ2UucGFyYW1zIHx8IHt9O1xyXG5cdFx0XHR2YXIgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XHJcblx0XHRcdHRoaXMubW9kZXMgPSAobW9kZXNGcm9tRmxhZ3MgJiYgdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL10uYWxsVG9Mb3dlckNhc2UobW9kZXNGcm9tRmxhZ3MpKSB8fCB1bmRlZmluZWQ7XHJcblx0XHRcdHZhciByZXN1bWVkID0gbWVzc2FnZS5oYXNGbGFnKCdSRVNVTUVEJyk7XHJcblx0XHRcdHZhciBoYXNQcmVzZW5jZSA9IG1lc3NhZ2UuaGFzRmxhZygnSEFTX1BSRVNFTkNFJyk7XHJcblx0XHRcdGlmKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcclxuXHRcdFx0XHQvKiBhdHRhY2hlZCBvcGVyYXRpb25zIHRvIGNoYW5nZSBvcHRpb25zIHNldCB0aGUgaW5wcm9ncmVzcyBtdXRleCwgYnV0IGxlYXZlXHJcblx0XHRcdFx0ICogY2hhbm5lbCBpbiB0aGUgYXR0YWNoZWQgc3RhdGUgKi9cclxuXHRcdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgZmFsc2UpO1xyXG5cdFx0XHRcdGlmKCFyZXN1bWVkKSB7XHJcblx0XHRcdFx0XHQvKiBPbiBhIGxvc3Mgb2YgY29udGludWl0eSwgdGhlIHByZXNlbmNlIHNldCBuZWVkcyB0byBiZSByZS1zeW5jZWQgKi9cclxuXHRcdFx0XHRcdHRoaXMucHJlc2VuY2Uub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHRcdHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlKHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIG1lc3NhZ2UuZXJyb3IpO1xyXG5cdFx0XHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XHJcblx0XHRcdFx0aWYoIXJlc3VtZWQgfHwgdGhpcy5jaGFubmVsT3B0aW9ucy51cGRhdGVPbkF0dGFjaGVkKSB7XHJcblx0XHRcdFx0XHR0aGlzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XHJcblx0XHRcdFx0fVxyXG5cdFx0XHR9IGVsc2UgaWYodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcclxuXHRcdFx0XHQvKiBSVEw1aTogcmUtc2VuZCBERVRBQ0ggYW5kIHJlbWFpbiBpbiB0aGUgJ2RldGFjaGluZycgc3RhdGUgKi9cclxuXHRcdFx0XHR0aGlzLmNoZWNrUGVuZGluZ1N0YXRlKCk7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnYXR0YWNoZWQnLCBtZXNzYWdlLmVycm9yLCByZXN1bWVkLCBoYXNQcmVzZW5jZSk7XHJcblx0XHRcdH1cclxuXHRcdFx0YnJlYWs7XHJcblxyXG5cdFx0Y2FzZSBhY3Rpb25zLkRFVEFDSEVEOlxyXG5cdFx0XHR2YXIgZXJyID0gbWVzc2FnZS5lcnJvciA/IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXS5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpIDogbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXSgnQ2hhbm5lbCBkZXRhY2hlZCcsIDkwMDAxLCA0MDQpO1xyXG5cdFx0XHRpZih0aGlzLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xyXG5cdFx0XHRcdHRoaXMubm90aWZ5U3RhdGUoJ2RldGFjaGVkJywgZXJyKTtcclxuXHRcdFx0fSBlbHNlIGlmKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hpbmcnKSB7XHJcblx0XHRcdFx0LyogT25seSByZXRyeSBpbW1lZGlhdGVseSBpZiB3ZSB3ZXJlIHByZXZpb3VzbHkgYXR0YWNoZWQuIElmIHdlIHdlcmVcclxuXHRcdFx0XHQgKiBhdHRhY2hpbmcsIGdvIGludG8gc3VzcGVuZGVkLCBmYWlsIG1lc3NhZ2VzLCBhbmQgd2FpdCBhIGZldyBzZWNvbmRzXHJcblx0XHRcdFx0ICogYmVmb3JlIHJldHJ5aW5nICovXHJcblx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnc3VzcGVuZGVkJywgZXJyKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgZXJyKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRjYXNlIGFjdGlvbnMuU1lOQzpcclxuXHRcdFx0Lyogc3luY3MgY2FuIGhhdmUgY2hhbm5lbFNlcmlhbHMsIGJ1dCBtaWdodCBub3QgaWYgdGhlIHN5bmMgaXMgb25lIHBhZ2UgbG9uZyAqL1xyXG5cdFx0XHRpc1N5bmMgPSB0cnVlO1xyXG5cdFx0XHRzeW5jQ2hhbm5lbFNlcmlhbCA9IHRoaXMuc3luY0NoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XHJcblx0XHRcdC8qIHN5bmNzIGNhbiBoYXBwZW4gb24gY2hhbm5lbHMgd2l0aCBubyBwcmVzZW5jZSBkYXRhIGFzIHBhcnQgb2YgY29ubmVjdGlvblxyXG5cdFx0XHQgKiByZXN1bWluZywgaW4gd2hpY2ggY2FzZSBwcm90b2NvbCBtZXNzYWdlIGhhcyBubyBwcmVzZW5jZSBwcm9wZXJ0eSAqL1xyXG5cdFx0XHRpZighbWVzc2FnZS5wcmVzZW5jZSkgYnJlYWs7XHJcblx0XHRjYXNlIGFjdGlvbnMuUFJFU0VOQ0U6XHJcblx0XHRcdHZhciBwcmVzZW5jZSA9IG1lc3NhZ2UucHJlc2VuY2UsXHJcblx0XHRcdFx0aWQgPSBtZXNzYWdlLmlkLFxyXG5cdFx0XHRcdGNvbm5lY3Rpb25JZCA9IG1lc3NhZ2UuY29ubmVjdGlvbklkLFxyXG5cdFx0XHRcdHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xyXG5cclxuXHRcdFx0dmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xyXG5cdFx0XHRmb3IodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2UubGVuZ3RoOyBpKyspIHtcclxuXHRcdFx0XHR0cnkge1xyXG5cdFx0XHRcdFx0dmFyIHByZXNlbmNlTXNnID0gcHJlc2VuY2VbaV07XHJcblx0XHRcdFx0XHRwcmVzZW5jZW1lc3NhZ2VbXCJhXCIgLyogZGVmYXVsdCAqL10uZGVjb2RlKHByZXNlbmNlTXNnLCBvcHRpb25zKTtcclxuXHRcdFx0XHR9IGNhdGNoIChlKSB7XHJcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkKSBwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQgPSBjb25uZWN0aW9uSWQ7XHJcblx0XHRcdFx0aWYoIXByZXNlbmNlTXNnLnRpbWVzdGFtcCkgcHJlc2VuY2VNc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xyXG5cdFx0XHRcdGlmKCFwcmVzZW5jZU1zZy5pZCkgcHJlc2VuY2VNc2cuaWQgPSBpZCArICc6JyArIGk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5wcmVzZW5jZS5zZXRQcmVzZW5jZShwcmVzZW5jZSwgaXNTeW5jLCBzeW5jQ2hhbm5lbFNlcmlhbCk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgYWN0aW9ucy5NRVNTQUdFOlxyXG5cclxuXHRcdFx0Ly9SVEwxN1xyXG5cdFx0XHRpZih0aGlzLnN0YXRlICE9PSAnYXR0YWNoZWQnKSB7XHJcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ01lc3NhZ2UgXCInICsgbWVzc2FnZS5pZCArICdcIiBza2lwcGVkIGFzIHRoaXMgY2hhbm5lbCBcIicgKyB0aGlzLm5hbWUgKyAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICsgdGhpcy5zdGF0ZSArICdcIikuJyk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblxyXG5cdFx0XHR2YXIgbWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLFxyXG5cdFx0XHRcdGZpcnN0TWVzc2FnZSA9IG1lc3NhZ2VzWzBdLFxyXG5cdFx0XHRcdGxhc3RNZXNzYWdlID0gbWVzc2FnZXNbbWVzc2FnZXMubGVuZ3RoIC0gMV0sXHJcblx0XHRcdFx0aWQgPSBtZXNzYWdlLmlkLFxyXG5cdFx0XHRcdGNvbm5lY3Rpb25JZCA9IG1lc3NhZ2UuY29ubmVjdGlvbklkLFxyXG5cdFx0XHRcdHRpbWVzdGFtcCA9IG1lc3NhZ2UudGltZXN0YW1wO1xyXG5cclxuXHRcdFx0aWYoZmlyc3RNZXNzYWdlLmV4dHJhcyAmJiBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhICYmIGZpcnN0TWVzc2FnZS5leHRyYXMuZGVsdGEuZnJvbSAhPT0gdGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkKSB7XHJcblx0XHRcdFx0dmFyIG1zZyA9ICdEZWx0YSBtZXNzYWdlIGRlY29kZSBmYWlsdXJlIC0gcHJldmlvdXMgbWVzc2FnZSBub3QgYXZhaWxhYmxlIGZvciBtZXNzYWdlIFwiJyArIG1lc3NhZ2UuaWQgKyAnXCIgb24gdGhpcyBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIi4nO1xyXG5cdFx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIG1zZyk7XHJcblx0XHRcdFx0dGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkobmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShtc2csIDQwMDE4LCA0MDApKTtcclxuXHRcdFx0XHRicmVhaztcclxuXHRcdFx0fVxyXG5cclxuXHRcdFx0Zm9yKHZhciBpID0gMDsgaSA8IG1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XHJcblx0XHRcdFx0dmFyIG1zZyA9IG1lc3NhZ2VzW2ldO1xyXG5cdFx0XHRcdHRyeSB7XHJcblx0XHRcdFx0XHR0eXBlc19tZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmRlY29kZShtc2csIHRoaXMuX2RlY29kaW5nQ29udGV4dCk7XHJcblx0XHRcdFx0fSBjYXRjaCAoZSkge1xyXG5cdFx0XHRcdFx0LyogZGVjcnlwdCBmYWlsZWQgLi4gdGhlIG1vc3QgbGlrZWx5IGNhdXNlIGlzIHRoYXQgd2UgaGF2ZSB0aGUgd3Jvbmcga2V5ICovXHJcblx0XHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xyXG5cdFx0XHRcdFx0c3dpdGNoKGUuY29kZSkge1xyXG5cdFx0XHRcdFx0XHRjYXNlIDQwMDE4OlxyXG5cdFx0XHRcdFx0XHRcdC8qIGRlY29kZSBmYWlsdXJlICovXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkoZSk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0XHRjYXNlIDQwMDE5OlxyXG5cdFx0XHRcdFx0XHRcdC8qIE5vIHZjZGlmZiBwbHVnaW4gcGFzc2VkIGluIC0gbm8gcG9pbnQgcmVjb3ZlcmluZywgZ2l2ZSB1cCAqL1xyXG5cdFx0XHRcdFx0XHRjYXNlIDQwMDIxOlxyXG5cdFx0XHRcdFx0XHRcdC8qIEJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBkZWx0YXMsIHNpbWlsYXJseSBubyBwb2ludCByZWNvdmVyaW5nICovXHJcblx0XHRcdFx0XHRcdFx0dGhpcy5ub3RpZnlTdGF0ZSgnZmFpbGVkJywgZSk7XHJcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHRcdFx0fVxyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRpZighbXNnLmNvbm5lY3Rpb25JZCkgbXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcclxuXHRcdFx0XHRpZighbXNnLnRpbWVzdGFtcCkgbXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcclxuXHRcdFx0XHRpZighbXNnLmlkKSBtc2cuaWQgPSBpZCArICc6JyArIGk7XHJcblx0XHRcdH1cclxuXHRcdFx0dGhpcy5fbGFzdFBheWxvYWQubWVzc2FnZUlkID0gbGFzdE1lc3NhZ2UuaWQ7XHJcblx0XHRcdHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XHJcblx0XHRcdHRoaXMub25FdmVudChtZXNzYWdlcyk7XHJcblx0XHRcdGJyZWFrO1xyXG5cclxuXHRcdGNhc2UgYWN0aW9ucy5FUlJPUjpcclxuXHRcdFx0LyogdGhlcmUgd2FzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciAqL1xyXG5cdFx0XHR2YXIgZXJyID0gbWVzc2FnZS5lcnJvcjtcclxuXHRcdFx0aWYoZXJyICYmIGVyci5jb2RlID09IDgwMDE2KSB7XHJcblx0XHRcdFx0LyogYXR0YWNoL2RldGFjaCBvcGVyYXRpb24gYXR0ZW1wdGVkIG9uIHN1cGVyc2VkZWQgdHJhbnNwb3J0IGhhbmRsZSAqL1xyXG5cdFx0XHRcdHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcclxuXHRcdFx0fSBlbHNlIHtcclxuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdmYWlsZWQnLCBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10uZnJvbVZhbHVlcyhlcnIpKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRicmVhaztcclxuXHJcblx0XHRkZWZhdWx0OlxyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnRmF0YWwgcHJvdG9jb2wgZXJyb3I6IHVucmVjb2duaXNlZCBhY3Rpb24gKCcgKyBtZXNzYWdlLmFjdGlvbiArICcpJyk7XHJcblx0XHRcdHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuYWJvcnQoY29ubmVjdGlvbmVycm9yW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnVua25vd25DaGFubmVsRXJyKTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9zdGFydERlY29kZUZhaWx1cmVSZWNvdmVyeSA9IGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0dmFyIHNlbGYgPSB0aGlzO1xyXG5cdFx0aWYoIXRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcclxuXHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgJ1N0YXJ0aW5nIGRlY29kZSBmYWlsdXJlIHJlY292ZXJ5IHByb2Nlc3MuJyk7XHJcblx0XHRcdHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSB0cnVlO1xyXG5cdFx0XHR0aGlzLl9hdHRhY2godHJ1ZSwgcmVhc29uLCBmdW5jdGlvbigpIHtcclxuXHRcdFx0XHRzZWxmLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gZmFsc2U7XHJcblx0XHRcdH0pO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUub25BdHRhY2hlZCA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uQXR0YWNoZWQnLCAnYWN0aXZhdGluZyBjaGFubmVsOyBuYW1lID0gJyArIHRoaXMubmFtZSk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5ub3RpZnlTdGF0ZSA9IGZ1bmN0aW9uKHN0YXRlLCByZWFzb24sIHJlc3VtZWQsIGhhc1ByZXNlbmNlKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwubm90aWZ5U3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBjdXJyZW50IHN0YXRlID0gJyArIHRoaXMuc3RhdGUgKyAnLCBub3RpZnlpbmcgc3RhdGUgJyArIHN0YXRlKTtcclxuXHRcdHRoaXMuY2xlYXJTdGF0ZVRpbWVyKCk7XHJcblxyXG5cdFx0aWYoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5wcmVzZW5jZS5hY3RPbkNoYW5uZWxTdGF0ZShzdGF0ZSwgaGFzUHJlc2VuY2UsIHJlYXNvbik7XHJcblx0XHRpZihzdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XHJcblx0XHRcdHRoaXMuc3RhcnRSZXRyeVRpbWVyKCk7XHJcblx0XHR9IGVsc2Uge1xyXG5cdFx0XHR0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcclxuXHRcdH1cclxuXHRcdGlmKHJlYXNvbikge1xyXG5cdFx0XHR0aGlzLmVycm9yUmVhc29uID0gcmVhc29uO1xyXG5cdFx0fVxyXG5cdFx0dmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2UodGhpcy5zdGF0ZSwgc3RhdGUsIHJlc3VtZWQsIHJlYXNvbik7XHJcblx0XHR2YXIgbG9nTGV2ZWwgPSBzdGF0ZSA9PT0gJ2ZhaWxlZCcgPyBsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX0VSUk9SIDogbG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NQUpPUjtcclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nTGV2ZWwsICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIicsIHN0YXRlICsgKHJlYXNvbiA/ICgnOyByZWFzb246ICcgKyByZWFzb24pIDogJycpKTtcclxuXHJcblx0XHQvKiBOb3RlOiB3ZSBkb24ndCBzZXQgaW5Qcm9ncmVzcyBmb3IgcGVuZGluZyBzdGF0ZXMgdW50aWwgdGhlIHJlcXVlc3QgaXMgYWN0dWFsbHkgaW4gcHJvZ3Jlc3MgKi9cclxuXHRcdGlmKHN0YXRlID09PSAnYXR0YWNoZWQnKSB7XHJcblx0XHRcdHRoaXMub25BdHRhY2hlZCgpO1xyXG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3luY09wLCBoYXNQcmVzZW5jZSk7XHJcblx0XHRcdHRoaXMuc2V0SW5Qcm9ncmVzcyhzdGF0ZWNoYW5nZU9wLCBmYWxzZSk7XHJcblx0XHR9IGVsc2UgaWYoc3RhdGUgPT09ICdkZXRhY2hlZCcgfHwgc3RhdGUgPT09ICdmYWlsZWQnIHx8IHN0YXRlID09PSAnc3VzcGVuZGVkJykge1xyXG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3RhdGVjaGFuZ2VPcCwgZmFsc2UpO1xyXG5cdFx0XHR0aGlzLnNldEluUHJvZ3Jlc3Moc3luY09wLCBmYWxzZSk7XHJcblx0XHR9XHJcblxyXG5cdFx0aWYoc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcclxuXHRcdFx0dGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcclxuXHRcdH0gZWxzZSBpZihzdGF0ZSA9PT0gJ2RldGFjaGluZycgfHwgc3RhdGUgPT09ICdmYWlsZWQnKSB7XHJcblx0XHRcdHRoaXMuX2F0dGFjaFJlc3VtZSA9IGZhbHNlO1xyXG5cdFx0fVxyXG5cclxuXHRcdHRoaXMuc3RhdGUgPSBzdGF0ZTtcclxuXHRcdHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XHJcblx0XHR0aGlzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5yZXF1ZXN0U3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgcmVhc29uKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwucmVxdWVzdFN0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgc3RhdGUgPSAnICsgc3RhdGUpO1xyXG5cdFx0dGhpcy5ub3RpZnlTdGF0ZShzdGF0ZSwgcmVhc29uKTtcclxuXHRcdC8qIHNlbmQgdGhlIGV2ZW50IGFuZCBhd2FpdCByZXNwb25zZSAqL1xyXG5cdFx0dGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2hlY2tQZW5kaW5nU3RhdGUgPSBmdW5jdGlvbigpIHtcclxuXHRcdC8qIGlmIGNhbid0IHNlbmQgZXZlbnRzLCBkbyBub3RoaW5nICovXHJcblx0XHR2YXIgY21TdGF0ZSA9IHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGU7XHJcblx0XHQvKiBBbGxvdyBhdHRhY2ggbWVzc2FnZXMgdG8gcXVldWUgdXAgd2hlbiBzeW5jaHJvbml6aW5nLCBzaW5jZSB0aGlzIHdpbGwgYmVcclxuXHRcdCAqIHRoZSBzdGF0ZSB3ZSdsbCBiZSBpbiB3aGVuIHVwZ3JhZGUgdHJhbnNwb3J0LmFjdGl2ZSB0cmlnZ2VycyBhIGNoZWNrcGVuZGluZ3N0YXRlICovXHJcblx0XHRpZighKGNtU3RhdGUuc2VuZEV2ZW50cyB8fCBjbVN0YXRlLmZvcmNlUXVldWVFdmVudHMpKSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZScsICdzZW5kRXZlbnRzIGlzIGZhbHNlOyBzdGF0ZSBpcyAnICsgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zdGF0ZSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUnLCAnbmFtZSA9ICcgKyB0aGlzLm5hbWUgKyAnLCBzdGF0ZSA9ICcgKyB0aGlzLnN0YXRlKTtcclxuXHRcdC8qIE9ubHkgc3RhcnQgdGhlIHN0YXRlIHRpbWVyIHJ1bm5pbmcgd2hlbiBhY3R1YWxseSBzZW5kaW5nIHRoZSBldmVudCAqL1xyXG5cdFx0c3dpdGNoKHRoaXMuc3RhdGUpIHtcclxuXHRcdFx0Y2FzZSAnYXR0YWNoaW5nJzpcclxuXHRcdFx0XHR0aGlzLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZygpO1xyXG5cdFx0XHRcdHRoaXMuYXR0YWNoSW1wbCgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxyXG5cdFx0XHRcdHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XHJcblx0XHRcdFx0dGhpcy5kZXRhY2hJbXBsKCk7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGNhc2UgJ2F0dGFjaGVkJzpcclxuXHRcdFx0XHQvKiByZXN1bWUgYW55IHN5bmMgb3BlcmF0aW9uIHRoYXQgd2FzIGluIHByb2dyZXNzICovXHJcblx0XHRcdFx0dGhpcy5zeW5jKCk7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS50aW1lb3V0UGVuZGluZ1N0YXRlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRzd2l0Y2godGhpcy5zdGF0ZSkge1xyXG5cdFx0XHRjYXNlICdhdHRhY2hpbmcnOlxyXG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDaGFubmVsIGF0dGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcclxuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdzdXNwZW5kZWQnLCBlcnIpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0XHRjYXNlICdkZXRhY2hpbmcnOlxyXG5cdFx0XHRcdHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKCdDaGFubmVsIGRldGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcclxuXHRcdFx0XHR0aGlzLm5vdGlmeVN0YXRlKCdhdHRhY2hlZCcsIGVycik7XHJcblx0XHRcdFx0YnJlYWs7XHJcblx0XHRcdGRlZmF1bHQ6XHJcblx0XHRcdFx0dGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xyXG5cdFx0XHRcdGJyZWFrO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRpZighdGhpcy5zdGF0ZVRpbWVyKSB7XHJcblx0XHRcdHRoaXMuc3RhdGVUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcblx0XHRcdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLnN0YXJ0U3RhdGVUaW1lcklmTm90UnVubmluZycsICd0aW1lciBleHBpcmVkJyk7XHJcblx0XHRcdFx0c2VsZi5zdGF0ZVRpbWVyID0gbnVsbDtcclxuXHRcdFx0XHRzZWxmLnRpbWVvdXRQZW5kaW5nU3RhdGUoKTtcclxuXHRcdFx0fSwgdGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2xlYXJTdGF0ZVRpbWVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc3RhdGVUaW1lciA9IHRoaXMuc3RhdGVUaW1lcjtcclxuXHRcdGlmKHN0YXRlVGltZXIpIHtcclxuXHRcdFx0Y2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xyXG5cdFx0XHR0aGlzLnN0YXRlVGltZXIgPSBudWxsO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3RhcnRSZXRyeVRpbWVyID0gZnVuY3Rpb24oKSB7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRpZih0aGlzLnJldHJ5VGltZXIpIHJldHVybjtcclxuXHJcblx0XHR0aGlzLnJldHJ5VGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG5cdFx0XHQvKiBJZiBjb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQsIGp1c3QgbGVhdmUgaW4gc3VzcGVuZGVkLCBhIHJlYXR0YWNoXHJcblx0XHRcdCAqIHdpbGwgYmUgdHJpZ2dlcmVkIG9uY2UgaXQgY29ubmVjdHMgYWdhaW4gKi9cclxuXHRcdFx0aWYoc2VsZi5zdGF0ZSA9PT0gJ3N1c3BlbmRlZCcgJiYgc2VsZi5jb25uZWN0aW9uTWFuYWdlci5zdGF0ZS5zZW5kRXZlbnRzKSB7XHJcblx0XHRcdFx0c2VsZi5yZXRyeVRpbWVyID0gbnVsbDtcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwgcmV0cnkgdGltZXIgZXhwaXJlZCcsICdhdHRlbXB0aW5nIGEgbmV3IGF0dGFjaCcpO1xyXG5cdFx0XHRcdHNlbGYucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcclxuXHRcdFx0fVxyXG5cdFx0fSwgdGhpcy5yZWFsdGltZS5vcHRpb25zLnRpbWVvdXRzLmNoYW5uZWxSZXRyeVRpbWVvdXQpO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuY2FuY2VsUmV0cnlUaW1lciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0aWYodGhpcy5yZXRyeVRpbWVyKSB7XHJcblx0XHRcdGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xyXG5cdFx0XHR0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XHJcblx0XHR9XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZXRJblByb2dyZXNzID0gZnVuY3Rpb24ob3BlcmF0aW9uLCB2YWx1ZSkge1xyXG5cdFx0dGhpcy5yZXN0LmNoYW5uZWxzLnNldEluUHJvZ3Jlc3ModGhpcywgb3BlcmF0aW9uLCB2YWx1ZSk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24ocGFyYW1zLCBjYWxsYmFjaykge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XHJcblx0XHQvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cclxuXHRcdGlmKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcclxuXHRcdFx0aWYodHlwZW9mKHBhcmFtcykgPT0gJ2Z1bmN0aW9uJykge1xyXG5cdFx0XHRcdGNhbGxiYWNrID0gcGFyYW1zO1xyXG5cdFx0XHRcdHBhcmFtcyA9IG51bGw7XHJcblx0XHRcdH0gZWxzZSB7XHJcblx0XHRcdFx0aWYodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcclxuXHRcdFx0XHRcdHJldHVybiB1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xyXG5cdFx0XHRcdH1cclxuXHRcdFx0XHRjYWxsYmFjayA9IG5vb3A7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHJcblx0XHRpZihwYXJhbXMgJiYgcGFyYW1zLnVudGlsQXR0YWNoKSB7XHJcblx0XHRcdGlmKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwib3B0aW9uIHVudGlsQXR0YWNoIHJlcXVpcmVzIHRoZSBjaGFubmVsIHRvIGJlIGF0dGFjaGVkXCIsIDQwMDAwLCA0MDApKTtcclxuXHRcdFx0XHRyZXR1cm47XHJcblx0XHRcdH1cclxuXHRcdFx0aWYoIXRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWwpIHtcclxuXHRcdFx0XHRjYWxsYmFjayhuZXcgZXJyb3JpbmZvW1wiYVwiIC8qIGRlZmF1bHQgKi9dKFwidW50aWxBdHRhY2ggd2FzIHNwZWNpZmllZCBhbmQgY2hhbm5lbCBpcyBhdHRhY2hlZCwgYnV0IGF0dGFjaFNlcmlhbCBpcyBub3QgZGVmaW5lZFwiLCA0MDAwMCwgNDAwKSk7XHJcblx0XHRcdFx0cmV0dXJuO1xyXG5cdFx0XHR9XHJcblx0XHRcdGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XHJcblx0XHRcdHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMucHJvcGVydGllcy5hdHRhY2hTZXJpYWw7XHJcblx0XHR9XHJcblxyXG5cdFx0Y2xpZW50X2NoYW5uZWwucHJvdG90eXBlLl9oaXN0b3J5LmNhbGwodGhpcywgcGFyYW1zLCBjYWxsYmFjayk7XHJcblx0fTtcclxuXHJcblx0UmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS53aGVuU3RhdGUgPSBmdW5jdGlvbihzdGF0ZSwgbGlzdGVuZXIpIHtcclxuXHRcdHJldHVybiBldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKHRoaXMsIHN0YXRlLCB0aGlzLnN0YXRlLCBsaXN0ZW5lcik7XHJcblx0fVxyXG5cclxuXHQvKiBAcmV0dXJucyBudWxsIChpZiBjYW4gc2FmZWx5IGJlIHJlbGVhc2VkKSB8IEVycm9ySW5mbyAoaWYgY2Fubm90KSAqL1xyXG5cdFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZ2V0UmVsZWFzZUVyciA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0dmFyIHMgPSB0aGlzLnN0YXRlO1xyXG5cdFx0aWYocyA9PT0gJ2luaXRpYWxpemVkJyB8fCBzID09PSAnZGV0YWNoZWQnIHx8IHMgPT09ICdmYWlsZWQnKSB7XHJcblx0XHRcdHJldHVybiBudWxsO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIG5ldyBlcnJvcmluZm9bXCJhXCIgLyogZGVmYXVsdCAqL10oJ0NhbiBvbmx5IHJlbGVhc2UgYSBjaGFubmVsIGluIGEgc3RhdGUgd2hlcmUgdGhlcmUgaXMgbm8gcG9zc2liaWxpdHkgb2YgZnVydGhlciB1cGRhdGVzIGZyb20gdGhlIHNlcnZlciBiZWluZyByZWNlaXZlZCAoaW5pdGlhbGl6ZWQsIGRldGFjaGVkLCBvciBmYWlsZWQpOyB3YXMgJyArIHMsIDkwMDAxLCA0MDApO1xyXG5cdH1cclxuXHJcblx0cmV0dXJuIFJlYWx0aW1lQ2hhbm5lbDtcclxufSkoKTtcclxuXHJcbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHJlYWx0aW1lY2hhbm5lbCA9IChyZWFsdGltZWNoYW5uZWxfUmVhbHRpbWVDaGFubmVsKTtcclxuXHJcbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9jb21tb24vbGliL3V0aWwvZXJyb3JyZXBvcnRlci5qc1xyXG52YXIgZXJyb3JyZXBvcnRlciA9IF9fd2VicGFja19yZXF1aXJlX18oMjMpO1xyXG5cclxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9jb21tb24vbGliL2NsaWVudC9yZWFsdGltZS5qc1xyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxudmFyIHJlYWx0aW1lX1JlYWx0aW1lID0gKGZ1bmN0aW9uKCkge1xyXG5cclxuXHRmdW5jdGlvbiBSZWFsdGltZShvcHRpb25zKSB7XHJcblx0XHRpZighKHRoaXMgaW5zdGFuY2VvZiBSZWFsdGltZSkpe1xyXG5cdFx0XHRyZXR1cm4gbmV3IFJlYWx0aW1lKG9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cclxuXHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19NSU5PUiwgJ1JlYWx0aW1lKCknLCAnJyk7XHJcblx0XHRjbGllbnRfcmVzdC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xyXG5cdFx0dGhpcy5jb25uZWN0aW9uID0gbmV3IGNvbm5lY3Rpb24odGhpcywgdGhpcy5vcHRpb25zKTtcclxuXHRcdHRoaXMuY2hhbm5lbHMgPSBuZXcgQ2hhbm5lbHModGhpcyk7XHJcblx0XHRpZihvcHRpb25zLmF1dG9Db25uZWN0ICE9PSBmYWxzZSlcclxuXHRcdFx0dGhpcy5jb25uZWN0KCk7XHJcblx0fVxyXG5cdHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmluaGVyaXRzKFJlYWx0aW1lLCBjbGllbnRfcmVzdCk7XHJcblxyXG5cdFJlYWx0aW1lLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24oKSB7XHJcblx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfTUlOT1IsICdSZWFsdGltZS5jb25uZWN0KCknLCAnJyk7XHJcblx0XHR0aGlzLmNvbm5lY3Rpb24uY29ubmVjdCgpO1xyXG5cdH07XHJcblxyXG5cdFJlYWx0aW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0bG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmxvZ0FjdGlvbihsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uTE9HX01JTk9SLCAnUmVhbHRpbWUuY2xvc2UoKScsICcnKTtcclxuXHRcdHRoaXMuY29ubmVjdGlvbi5jbG9zZSgpO1xyXG5cdH07XHJcblxyXG5cdGZ1bmN0aW9uIENoYW5uZWxzKHJlYWx0aW1lKSB7XHJcblx0XHRldmVudGVtaXR0ZXJbXCJhXCIgLyogZGVmYXVsdCAqL10uY2FsbCh0aGlzKTtcclxuXHRcdHRoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcclxuXHRcdHRoaXMuYWxsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcclxuXHRcdHRoaXMuaW5Qcm9ncmVzcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XHJcblx0XHR2YXIgc2VsZiA9IHRoaXM7XHJcblx0XHRyZWFsdGltZS5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd0cmFuc3BvcnQuYWN0aXZlJywgZnVuY3Rpb24oKSB7XHJcblx0XHRcdHNlbGYub25UcmFuc3BvcnRBY3RpdmUoKTtcclxuXHRcdH0pO1xyXG5cdH1cclxuXHR1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5pbmhlcml0cyhDaGFubmVscywgZXZlbnRlbWl0dGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dKTtcclxuXHJcblx0Q2hhbm5lbHMucHJvdG90eXBlLm9uQ2hhbm5lbE1lc3NhZ2UgPSBmdW5jdGlvbihtc2cpIHtcclxuXHRcdHZhciBjaGFubmVsTmFtZSA9IG1zZy5jaGFubmVsO1xyXG5cdFx0aWYoY2hhbm5lbE5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG5cdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgdW5zcGVjaWZpZWQgY2hhbm5lbCwgYWN0aW9uID0gJyArIG1zZy5hY3Rpb24pO1xyXG5cdFx0XHRyZXR1cm47XHJcblx0XHR9XHJcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcclxuXHRcdGlmKCFjaGFubmVsKSB7XHJcblx0XHRcdGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5sb2dBY3Rpb24obG9nZ2VyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCBmb3Igbm9uLWV4aXN0ZW50IGNoYW5uZWw6ICcgKyBjaGFubmVsTmFtZSk7XHJcblx0XHRcdHJldHVybjtcclxuXHRcdH1cclxuXHRcdGNoYW5uZWwub25NZXNzYWdlKG1zZyk7XHJcblx0fTtcclxuXHJcblx0LyogY2FsbGVkIHdoZW4gYSB0cmFuc3BvcnQgYmVjb21lcyBjb25uZWN0ZWQ7IHJlYXR0ZW1wdCBhdHRhY2gvZGV0YWNoXHJcblx0ICogZm9yIGNoYW5uZWxzIHRoYXQgYXJlIGF0dGFjaGluZyBvciBkZXRhY2hpbmcuXHJcblx0ICogTm90ZSB0aGF0IHRoaXMgZG9lcyBub3QgdXNlIGluUHJvZ3Jlc3MgYXMgaW5Qcm9ncmVzcyBpcyBvbmx5IGNoYW5uZWxzIHdoaWNoIGhhdmUgYWxyZWFkeSBtYWRlXHJcblx0KiBhdCBsZWFzdCBvbmUgYXR0ZW1wdCB0byBhdHRhY2gvZGV0YWNoICovXHJcblx0Q2hhbm5lbHMucHJvdG90eXBlLm9uVHJhbnNwb3J0QWN0aXZlID0gZnVuY3Rpb24oKSB7XHJcblx0XHRmb3IodmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuYWxsKSB7XHJcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbE5hbWVdO1xyXG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoaW5nJyB8fCBjaGFubmVsLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xyXG5cdFx0XHRcdGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcclxuXHRcdFx0fSBlbHNlIGlmKGNoYW5uZWwuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XHJcblx0XHRcdFx0Y2hhbm5lbC5hdHRhY2goKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZWF0dGFjaCA9IGZ1bmN0aW9uKHJlYXNvbikge1xyXG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcclxuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xyXG5cdFx0XHQvKiBOQiB0aGlzIHNob3VsZCBub3QgdHJpZ2dlciBmb3IgbWVyZWx5IGF0dGFjaGluZyBjaGFubmVscywgYXMgdGhleSB3aWxsXHJcblx0XHRcdCAqIGJlIHJlYXR0YWNoZWQgYW55d2F5IHRocm91Z2ggdGhlIG9uVHJhbnNwb3J0QWN0aXZlIGNoZWNrUGVuZGluZ1N0YXRlICovXHJcblx0XHRcdGlmKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcclxuXHRcdFx0XHRjaGFubmVsLnJlcXVlc3RTdGF0ZSgnYXR0YWNoaW5nJywgcmVhc29uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENoYW5uZWxzLnByb3RvdHlwZS5yZXNldEF0dGFjaGVkTXNnSW5kaWNhdG9ycyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcclxuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xyXG5cdFx0XHRpZihjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoZWQnKSB7XHJcblx0XHRcdGNoYW5uZWwuX2F0dGFjaGVkTXNnSW5kaWNhdG9yID0gZmFsc2U7XHJcblx0XHRcdH1cclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHRDaGFubmVscy5wcm90b3R5cGUuY2hlY2tBdHRhY2hlZE1zZ0luZGljYXRvcnMgPSBmdW5jdGlvbihjb25uZWN0aW9uSWQpIHtcclxuXHRcdGZvcih2YXIgY2hhbm5lbElkIGluIHRoaXMuYWxsKSB7XHJcblx0XHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcclxuXHRcdFx0aWYoY2hhbm5lbC5zdGF0ZSA9PT0gJ2F0dGFjaGVkJyAmJiBjaGFubmVsLl9hdHRhY2hlZE1zZ0luZGljYXRvciA9PT0gZmFsc2UpIHtcclxuXHRcdFx0XHR2YXIgbXNnID0gJzMwcyBhZnRlciBhIHJlc3VtZSwgZm91bmQgY2hhbm5lbCB3aGljaCBoYXMgbm90IHJlY2VpdmVkIGFuIGF0dGFjaGVkOyBjaGFubmVsSWQgPSAnICsgY2hhbm5lbElkICsgJzsgY29ubmVjdGlvbklkID0gJyArIGNvbm5lY3Rpb25JZDtcclxuXHRcdFx0XHRsb2dnZXJbXCJhXCIgLyogZGVmYXVsdCAqL10ubG9nQWN0aW9uKGxvZ2dlcltcImFcIiAvKiBkZWZhdWx0ICovXS5MT0dfRVJST1IsICdDaGFubmVscy5jaGVja0F0dGFjaGVkTXNnSW5kaWNhdG9ycygpJywgbXNnKTtcclxuXHRcdFx0XHRlcnJvcnJlcG9ydGVyW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnJlcG9ydCgnZXJyb3InLCBtc2csICdjaGFubmVsLW5vLWF0dGFjaGVkLWFmdGVyLXJlc3VtZScpO1xyXG5cdFx0XHRcdGNoYW5uZWwucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcclxuXHRcdFx0fTtcclxuXHRcdH1cclxuXHR9O1xyXG5cclxuXHQvKiBDb25uZWN0aW9uIGludGVycnVwdGlvbnMgKGllIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2lsbCBubyBsb25nZXIgcXVldWVcclxuXHQgKiBldmVudHMpIGltcGx5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBmb3IgYW55IGNoYW5uZWwgd2hpY2ggaXMgZWl0aGVyXHJcblx0ICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xyXG5cdENoYW5uZWxzLnByb3RvdHlwZS5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uID0gZnVuY3Rpb24oY29ubmVjdGlvblN0YXRlLCByZWFzb24pIHtcclxuXHRcdHZhciBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZSA9IHtcclxuXHRcdFx0J2Nsb3NpbmcnICA6ICdkZXRhY2hlZCcsXHJcblx0XHRcdCdjbG9zZWQnICAgOiAnZGV0YWNoZWQnLFxyXG5cdFx0XHQnZmFpbGVkJyAgIDogJ2ZhaWxlZCcsXHJcblx0XHRcdCdzdXNwZW5kZWQnOiAnc3VzcGVuZGVkJ1xyXG5cdFx0fTtcclxuXHRcdHZhciBmcm9tQ2hhbm5lbFN0YXRlcyA9IFsnYXR0YWNoaW5nJywgJ2F0dGFjaGVkJywgJ2RldGFjaGluZycsICdzdXNwZW5kZWQnXTtcclxuXHRcdHZhciB0b0NoYW5uZWxTdGF0ZSA9IGNvbm5lY3Rpb25TdGF0ZVRvQ2hhbm5lbFN0YXRlW2Nvbm5lY3Rpb25TdGF0ZV07XHJcblxyXG5cdFx0Zm9yKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcclxuXHRcdFx0dmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsSWRdO1xyXG5cdFx0XHRpZih1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5hcnJJbihmcm9tQ2hhbm5lbFN0YXRlcywgY2hhbm5lbC5zdGF0ZSkpIHtcclxuXHRcdFx0XHQgY2hhbm5lbC5ub3RpZnlTdGF0ZSh0b0NoYW5uZWxTdGF0ZSwgcmVhc29uKTtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbihuYW1lLCBjaGFubmVsT3B0aW9ucykge1xyXG5cdFx0bmFtZSA9IFN0cmluZyhuYW1lKTtcclxuXHRcdHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XHJcblx0XHRpZighY2hhbm5lbCkge1xyXG5cdFx0XHRjaGFubmVsID0gdGhpcy5hbGxbbmFtZV0gPSBuZXcgcmVhbHRpbWVjaGFubmVsKHRoaXMucmVhbHRpbWUsIG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcclxuXHRcdH0gZWxzZSBpZihjaGFubmVsT3B0aW9ucykge1xyXG5cdFx0XHRpZiAoY2hhbm5lbC5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpKSB7XHJcblx0XHRcdFx0dGhyb3cgbmV3IGVycm9yaW5mb1tcImFcIiAvKiBkZWZhdWx0ICovXShcIkNoYW5uZWxzLmdldCgpIGNhbm5vdCBiZSB1c2VkIHRvIHNldCBjaGFubmVsIG9wdGlvbnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgY2hhbm5lbCB0byByZWF0dGFjaC4gUGxlYXNlLCB1c2UgUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKSBpbnN0ZWFkLlwiLCA0MDAwMCwgNDAwKTtcclxuXHRcdFx0fVxyXG5cdFx0XHRjaGFubmVsLnNldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xyXG5cdFx0fVxyXG5cdFx0cmV0dXJuIGNoYW5uZWw7XHJcblx0fTtcclxuXHJcblx0LyogSW5jbHVkZWQgdG8gc3VwcG9ydCBjZXJ0YWluIG5pY2hlIHVzZS1jYXNlczsgbW9zdCB1c2VycyBzaG91bGQgaWdub3JlIHRoaXMuXHJcblx0ICogUGxlYXNlIGRvIG5vdCB1c2UgdGhpcyB1bmxlc3MgeW91IGtub3cgd2hhdCB5b3UncmUgZG9pbmcgKi9cclxuXHRDaGFubmVscy5wcm90b3R5cGUucmVsZWFzZSA9IGZ1bmN0aW9uKG5hbWUpIHtcclxuXHRcdG5hbWUgPSBTdHJpbmcobmFtZSk7XHJcblx0XHR2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xyXG5cdFx0aWYoIWNoYW5uZWwpIHtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dmFyIHJlbGVhc2VFcnIgPSBjaGFubmVsLmdldFJlbGVhc2VFcnIoKTtcclxuXHRcdGlmKHJlbGVhc2VFcnIpIHtcclxuXHRcdFx0dGhyb3cgcmVsZWFzZUVycjtcclxuXHRcdH1cclxuXHRcdGRlbGV0ZSB0aGlzLmFsbFtuYW1lXTtcclxuXHRcdGRlbGV0ZSB0aGlzLmluUHJvZ3Jlc3NbbmFtZV07XHJcblx0fTtcclxuXHJcblx0LyogUmVjb3JkcyBvcGVyYXRpb25zIGN1cnJlbnRseSBwZW5kaW5nIG9uIGEgdHJhbnNwb3J0OyB1c2VkIGJ5IGNvbm5lY3Rpb25NYW5hZ2VyIHRvIGRlY2lkZSB3aGVuXHJcblx0ICogaXQncyBzYWZlIHRvIHVwZ3JhZGUuIE5vdGUgdGhhdCBhIGNoYW5uZWwgbWlnaHQgYmUgaW4gdGhlIGF0dGFjaGluZyBzdGF0ZSB3aXRob3V0IGFueSBwZW5kaW5nXHJcblx0ICogb3BlcmF0aW9ucyAoZWcgaWYgYXR0YWNoZWQgd2hpbGUgdGhlIGNvbm5lY3Rpb24gc3RhdGUgaXMgY29ubmVjdGluZykgLSBzdWNoIGEgY2hhbm5lbCBtdXN0IG5vdFxyXG5cdCAqIGhvbGQgdXAgYW4gdXBncmFkZSwgc28gaXMgbm90IGNvbnNpZGVyZWQgaW5Qcm9ncmVzcy5cclxuXHQgKiBPcGVyYXRpb24gaXMgY3VycmVudGx5IG9uZSBvZiBlaXRoZXIgJ3N0YXRlY2hhbmdlJyBvciAnc3luYycgKi9cclxuXHRDaGFubmVscy5wcm90b3R5cGUuc2V0SW5Qcm9ncmVzcyA9IGZ1bmN0aW9uKGNoYW5uZWwsIG9wZXJhdGlvbiwgaW5Qcm9ncmVzcykge1xyXG5cdFx0dGhpcy5pblByb2dyZXNzW2NoYW5uZWwubmFtZV0gPSB0aGlzLmluUHJvZ3Jlc3NbY2hhbm5lbC5uYW1lXSB8fCB7fTtcclxuXHRcdHRoaXMuaW5Qcm9ncmVzc1tjaGFubmVsLm5hbWVdW29wZXJhdGlvbl0gPSBpblByb2dyZXNzO1xyXG5cdFx0aWYoIWluUHJvZ3Jlc3MgJiYgdGhpcy5oYXNOb3BlbmRpbmcoKSkge1xyXG5cdFx0XHR0aGlzLmVtaXQoJ25vcGVuZGluZycpO1xyXG5cdFx0fVxyXG5cdH07XHJcblxyXG5cdENoYW5uZWxzLnByb3RvdHlwZS5vbmNlTm9wZW5kaW5nID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcclxuXHRcdGlmKHRoaXMuaGFzTm9wZW5kaW5nKCkpIHtcclxuXHRcdFx0bGlzdGVuZXIoKTtcclxuXHRcdFx0cmV0dXJuO1xyXG5cdFx0fVxyXG5cdFx0dGhpcy5vbmNlKCdub3BlbmRpbmcnLCBsaXN0ZW5lcik7XHJcblx0fTtcclxuXHJcblx0Q2hhbm5lbHMucHJvdG90eXBlLmhhc05vcGVuZGluZyA9IGZ1bmN0aW9uKCkge1xyXG5cdFx0cmV0dXJuIHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLmFyckV2ZXJ5KHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dLnZhbHVlc0FycmF5KHRoaXMuaW5Qcm9ncmVzcywgdHJ1ZSksIGZ1bmN0aW9uKG9wZXJhdGlvbnMpIHtcclxuXHRcdFx0cmV0dXJuICF1dGlsc1tcImFcIiAvKiBkZWZhdWx0ICovXS5jb250YWluc1ZhbHVlKG9wZXJhdGlvbnMsIHRydWUpO1xyXG5cdFx0fSk7XHJcblx0fTtcclxuXHJcblx0cmV0dXJuIFJlYWx0aW1lO1xyXG59KSgpO1xyXG5cclxucmVhbHRpbWVfUmVhbHRpbWUuUHJvbWlzZSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcclxuXHRvcHRpb25zID0gZGVmYXVsdHNbXCJhXCIgLyogZGVmYXVsdCAqL10ub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcclxuXHRvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcclxuXHRyZXR1cm4gbmV3IHJlYWx0aW1lX1JlYWx0aW1lKG9wdGlvbnMpO1xyXG59O1xyXG5cclxucmVhbHRpbWVfUmVhbHRpbWUuQ2FsbGJhY2tzID0gcmVhbHRpbWVfUmVhbHRpbWU7XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBjbGllbnRfcmVhbHRpbWUgPSAocmVhbHRpbWVfUmVhbHRpbWUpO1xyXG5cclxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL2Jyb3dzZXIvbGliL3V0aWwvbXNncGFjay5qc1xyXG52YXIgdXRpbF9tc2dwYWNrID0gX193ZWJwYWNrX3JlcXVpcmVfXygyNCk7XHJcblxyXG4vLyBDT05DQVRFTkFURUQgTU9EVUxFOiAuL2NvbW1vbi9saWIvaW5kZXguanNcclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5cclxuXHJcblxyXG5jbGllbnRfcmVzdC5VdGlscyA9IHV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xyXG5jbGllbnRfcmVzdC5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xyXG5jbGllbnRfcmVzdC5DcnlwdG8gPSB1dGlsX2NyeXB0b1tcImFcIiAvKiBkZWZhdWx0ICovXTtcclxuY2xpZW50X3Jlc3QuRGVmYXVsdHMgPSBkZWZhdWx0c1tcImFcIiAvKiBkZWZhdWx0ICovXTtcclxuY2xpZW50X3Jlc3QuSHR0cCA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL107XHJcbmNsaWVudF9yZXN0LlJlc291cmNlID0gY2xpZW50X3Jlc291cmNlO1xyXG5jbGllbnRfcmVzdC5NZXNzYWdlID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcclxuY2xpZW50X3Jlc3QuUHJlc2VuY2VNZXNzYWdlID0gcHJlc2VuY2VtZXNzYWdlW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xyXG5cclxuY2xpZW50X3JlYWx0aW1lLlV0aWxzID0gdXRpbHNbXCJhXCIgLyogZGVmYXVsdCAqL107XHJcbmNsaWVudF9yZWFsdGltZS5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xyXG5jbGllbnRfcmVhbHRpbWUuQ3J5cHRvID0gdXRpbF9jcnlwdG9bXCJhXCIgLyogZGVmYXVsdCAqL107XHJcbmNsaWVudF9yZWFsdGltZS5EZWZhdWx0cyA9IGRlZmF1bHRzW1wiYVwiIC8qIGRlZmF1bHQgKi9dO1xyXG5jbGllbnRfcmVhbHRpbWUuSHR0cCA9IGh0dHBbXCJhXCIgLyogZGVmYXVsdCAqL107XHJcbmNsaWVudF9yZWFsdGltZS5NZXNzYWdlID0gdHlwZXNfbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcclxuY2xpZW50X3JlYWx0aW1lLlByZXNlbmNlTWVzc2FnZSA9IHByZXNlbmNlbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcclxuY2xpZW50X3JlYWx0aW1lLlByb3RvY29sTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZVtcImFcIiAvKiBkZWZhdWx0ICovXTtcclxuY2xpZW50X3JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyID0gY29ubmVjdGlvbm1hbmFnZXJbXCJhXCIgLyogZGVmYXVsdCAqL107XHJcblxyXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciBsaWIgPSBfX3dlYnBhY2tfZXhwb3J0c19fW1wiZGVmYXVsdFwiXSA9ICh7XHJcbiAgUmVzdDogY2xpZW50X3Jlc3QsXHJcbiAgUmVhbHRpbWU6IGNsaWVudF9yZWFsdGltZSxcclxuICBtc2dwYWNrOiB1dGlsX21zZ3BhY2tbXCJhXCIgLyogZGVmYXVsdCAqL11cclxufSk7XHJcblxyXG5cclxuLyoqKi8gfSlcclxuLyoqKioqKi8gXSlbXCJkZWZhdWx0XCJdO1xyXG59KTsiLCJcInVzZSBzdHJpY3RcIjtcclxuZnVuY3Rpb24gcHJvbWlzaWZ5T3B0aW9ucyhvcHRpb25zKSB7XHJcbiAgaWYodHlwZW9mIG9wdGlvbnMgPT0gJ3N0cmluZycpIHtcclxuICAgIG9wdGlvbnMgPSAob3B0aW9ucy5pbmRleE9mKCc6JykgPT0gLTEpID8ge3Rva2VuOiBvcHRpb25zfSA6IHtrZXk6IG9wdGlvbnN9O1xyXG4gIH1cclxuICBvcHRpb25zLnByb21pc2VzID0gdHJ1ZTtcclxuICByZXR1cm4gb3B0aW9ucztcclxufVxyXG5cclxuLyogUGxlYXNlIG5vdGUgdGhhdCB0aGUgZmlsZSBpbXBvcnRlZCBiZWxvdyBpcyBvbmx5IGdlbmVyYXRlZCBhZnRlciBydW5uaW5nIFxyXG4gKiB0aGUgYnVpbGQgdGFzay4gKi9cclxudmFyIEFibHkgPSByZXF1aXJlKCcuL2Jyb3dzZXIvc3RhdGljL2FibHktbm9kZScpO1xyXG5cclxudmFyIFJlc3RQcm9taXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgQWJseS5SZXN0KHByb21pc2lmeU9wdGlvbnMob3B0aW9ucykpO1xyXG59XHJcbk9iamVjdC5hc3NpZ24oUmVzdFByb21pc2UsIEFibHkuUmVzdCk7XHJcblxyXG52YXIgUmVhbHRpbWVQcm9taXNlID0gZnVuY3Rpb24ob3B0aW9ucykge1xyXG4gIHJldHVybiBuZXcgQWJseS5SZWFsdGltZShwcm9taXNpZnlPcHRpb25zKG9wdGlvbnMpKTtcclxufVxyXG5PYmplY3QuYXNzaWduKFJlYWx0aW1lUHJvbWlzZSwgQWJseS5SZWFsdGltZSk7XHJcblxyXG5tb2R1bGUuZXhwb3J0cyA9IHtcclxuICBSZXN0OiBSZXN0UHJvbWlzZSxcclxuICBSZWFsdGltZTogUmVhbHRpbWVQcm9taXNlXHJcbn07XHJcbiIsIid1c2Ugc3RyaWN0J1xyXG5cclxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxyXG5leHBvcnRzLnRvQnl0ZUFycmF5ID0gdG9CeXRlQXJyYXlcclxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxyXG5cclxudmFyIGxvb2t1cCA9IFtdXHJcbnZhciByZXZMb29rdXAgPSBbXVxyXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XHJcblxyXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xyXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gIGxvb2t1cFtpXSA9IGNvZGVbaV1cclxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcclxufVxyXG5cclxuLy8gU3VwcG9ydCBkZWNvZGluZyBVUkwtc2FmZSBiYXNlNjQgc3RyaW5ncywgYXMgTm9kZS5qcyBkb2VzLlxyXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXHJcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcclxuXHJcbmZ1bmN0aW9uIGdldExlbnMgKGI2NCkge1xyXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXHJcblxyXG4gIGlmIChsZW4gJSA0ID4gMCkge1xyXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcclxuICB9XHJcblxyXG4gIC8vIFRyaW0gb2ZmIGV4dHJhIGJ5dGVzIGFmdGVyIHBsYWNlaG9sZGVyIGJ5dGVzIGFyZSBmb3VuZFxyXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxyXG4gIHZhciB2YWxpZExlbiA9IGI2NC5pbmRleE9mKCc9JylcclxuICBpZiAodmFsaWRMZW4gPT09IC0xKSB2YWxpZExlbiA9IGxlblxyXG5cclxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gdmFsaWRMZW4gPT09IGxlblxyXG4gICAgPyAwXHJcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxyXG5cclxuICByZXR1cm4gW3ZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW5dXHJcbn1cclxuXHJcbi8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxyXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcclxuICB2YXIgbGVucyA9IGdldExlbnMoYjY0KVxyXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cclxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxyXG4gIHJldHVybiAoKHZhbGlkTGVuICsgcGxhY2VIb2xkZXJzTGVuKSAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0xlblxyXG59XHJcblxyXG5mdW5jdGlvbiBfYnl0ZUxlbmd0aCAoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSB7XHJcbiAgcmV0dXJuICgodmFsaWRMZW4gKyBwbGFjZUhvbGRlcnNMZW4pICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzTGVuXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcclxuICB2YXIgdG1wXHJcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcclxuICB2YXIgdmFsaWRMZW4gPSBsZW5zWzBdXHJcbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cclxuXHJcbiAgdmFyIGFyciA9IG5ldyBBcnIoX2J5dGVMZW5ndGgoYjY0LCB2YWxpZExlbiwgcGxhY2VIb2xkZXJzTGVuKSlcclxuXHJcbiAgdmFyIGN1ckJ5dGUgPSAwXHJcblxyXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcclxuICB2YXIgbGVuID0gcGxhY2VIb2xkZXJzTGVuID4gMFxyXG4gICAgPyB2YWxpZExlbiAtIDRcclxuICAgIDogdmFsaWRMZW5cclxuXHJcbiAgdmFyIGlcclxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcclxuICAgIHRtcCA9XHJcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8XHJcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxyXG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfFxyXG4gICAgICByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxyXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcclxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcclxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxyXG4gIH1cclxuXHJcbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMikge1xyXG4gICAgdG1wID1cclxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfFxyXG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcclxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxyXG4gIH1cclxuXHJcbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xyXG4gICAgdG1wID1cclxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHxcclxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcclxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXHJcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXHJcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcclxuICB9XHJcblxyXG4gIHJldHVybiBhcnJcclxufVxyXG5cclxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcclxuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICtcclxuICAgIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArXHJcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXHJcbiAgICBsb29rdXBbbnVtICYgMHgzRl1cclxufVxyXG5cclxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XHJcbiAgdmFyIHRtcFxyXG4gIHZhciBvdXRwdXQgPSBbXVxyXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XHJcbiAgICB0bXAgPVxyXG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXHJcbiAgICAgICgodWludDhbaSArIDFdIDw8IDgpICYgMHhGRjAwKSArXHJcbiAgICAgICh1aW50OFtpICsgMl0gJiAweEZGKVxyXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXHJcbiAgfVxyXG4gIHJldHVybiBvdXRwdXQuam9pbignJylcclxufVxyXG5cclxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcclxuICB2YXIgdG1wXHJcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxyXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xyXG4gIHZhciBwYXJ0cyA9IFtdXHJcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXHJcblxyXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XHJcbiAgICBwYXJ0cy5wdXNoKGVuY29kZUNodW5rKHVpbnQ4LCBpLCAoaSArIG1heENodW5rTGVuZ3RoKSA+IGxlbjIgPyBsZW4yIDogKGkgKyBtYXhDaHVua0xlbmd0aCkpKVxyXG4gIH1cclxuXHJcbiAgLy8gcGFkIHRoZSBlbmQgd2l0aCB6ZXJvcywgYnV0IG1ha2Ugc3VyZSB0byBub3QgZm9yZ2V0IHRoZSBleHRyYSBieXRlc1xyXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XHJcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxyXG4gICAgcGFydHMucHVzaChcclxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXHJcbiAgICAgIGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl0gK1xyXG4gICAgICAnPT0nXHJcbiAgICApXHJcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XHJcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyB1aW50OFtsZW4gLSAxXVxyXG4gICAgcGFydHMucHVzaChcclxuICAgICAgbG9va3VwW3RtcCA+PiAxMF0gK1xyXG4gICAgICBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdICtcclxuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXHJcbiAgICAgICc9J1xyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXHJcbn1cclxuIiwiLyohXHJcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxyXG4gKlxyXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxyXG4gKiBAbGljZW5zZSAgTUlUXHJcbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xyXG5cclxuJ3VzZSBzdHJpY3QnXHJcblxyXG52YXIgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcclxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcclxudmFyIGN1c3RvbUluc3BlY3RTeW1ib2wgPVxyXG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuZm9yID09PSAnZnVuY3Rpb24nKVxyXG4gICAgPyBTeW1ib2wuZm9yKCdub2RlanMudXRpbC5pbnNwZWN0LmN1c3RvbScpXHJcbiAgICA6IG51bGxcclxuXHJcbmV4cG9ydHMuQnVmZmVyID0gQnVmZmVyXHJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXHJcblxyXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxyXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcclxuXHJcbi8qKlxyXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxyXG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxyXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcclxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcclxuICpcclxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxyXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXHJcbiAqXHJcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxyXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXHJcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcclxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXHJcbiAqL1xyXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcclxuXHJcbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xyXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xyXG4gIClcclxufVxyXG5cclxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xyXG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cclxuICB0cnkge1xyXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXHJcbiAgICB2YXIgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XHJcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YocHJvdG8sIFVpbnQ4QXJyYXkucHJvdG90eXBlKVxyXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXHJcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxyXG4gIH0gY2F0Y2ggKGUpIHtcclxuICAgIHJldHVybiBmYWxzZVxyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XHJcbiAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICByZXR1cm4gdGhpcy5idWZmZXJcclxuICB9XHJcbn0pXHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcclxuICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcclxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcclxuICB9XHJcbn0pXHJcblxyXG5mdW5jdGlvbiBjcmVhdGVCdWZmZXIgKGxlbmd0aCkge1xyXG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcclxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXHJcbiAgfVxyXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXHJcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcclxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxyXG4gIHJldHVybiBidWZcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXHJcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcclxuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcclxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cclxuICpcclxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcclxuICAvLyBDb21tb24gY2FzZS5cclxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcclxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgICAnVGhlIFwic3RyaW5nXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIHN0cmluZy4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXHJcbiAgICAgIClcclxuICAgIH1cclxuICAgIHJldHVybiBhbGxvY1Vuc2FmZShhcmcpXHJcbiAgfVxyXG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxyXG59XHJcblxyXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cclxuXHJcbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgcmV0dXJuIGZyb21TdHJpbmcodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQpXHJcbiAgfVxyXG5cclxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xyXG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2UodmFsdWUpXHJcbiAgfVxyXG5cclxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xyXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XHJcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgQXJyYXlCdWZmZXIpKSkge1xyXG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxyXG4gIH1cclxuXHJcbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcclxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxyXG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIFNoYXJlZEFycmF5QnVmZmVyKSkpKSB7XHJcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXHJcbiAgfVxyXG5cclxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mICYmIHZhbHVlLnZhbHVlT2YoKVxyXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXHJcbiAgfVxyXG5cclxuICB2YXIgYiA9IGZyb21PYmplY3QodmFsdWUpXHJcbiAgaWYgKGIpIHJldHVybiBiXHJcblxyXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxyXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKFxyXG4gICAgICB2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFxyXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xyXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxyXG4gIClcclxufVxyXG5cclxuLyoqXHJcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXHJcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxyXG4gKiBCdWZmZXIuZnJvbShzdHJbLCBlbmNvZGluZ10pXHJcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxyXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXHJcbiAqIEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyWywgYnl0ZU9mZnNldFssIGxlbmd0aF1dKVxyXG4gKiovXHJcbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcclxuICByZXR1cm4gZnJvbSh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxyXG59XHJcblxyXG4vLyBOb3RlOiBDaGFuZ2UgcHJvdG90eXBlICphZnRlciogQnVmZmVyLmZyb20gaXMgZGVmaW5lZCB0byB3b3JrYXJvdW5kIENocm9tZSBidWc6XHJcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XHJcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcclxuT2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlciwgVWludDhBcnJheSlcclxuXHJcbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcclxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XHJcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcclxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XHJcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIHNpemUgKyAnXCIgaXMgaW52YWxpZCBmb3Igb3B0aW9uIFwic2l6ZVwiJylcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xyXG4gIGFzc2VydFNpemUoc2l6ZSlcclxuICBpZiAoc2l6ZSA8PSAwKSB7XHJcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXHJcbiAgfVxyXG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcclxuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXHJcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXHJcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXHJcbiAgICByZXR1cm4gdHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJ1xyXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxyXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXHJcbiAgfVxyXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcclxufVxyXG5cclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cclxuICogYWxsb2Moc2l6ZVssIGZpbGxbLCBlbmNvZGluZ11dKVxyXG4gKiovXHJcbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xyXG4gIHJldHVybiBhbGxvYyhzaXplLCBmaWxsLCBlbmNvZGluZylcclxufVxyXG5cclxuZnVuY3Rpb24gYWxsb2NVbnNhZmUgKHNpemUpIHtcclxuICBhc3NlcnRTaXplKHNpemUpXHJcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcclxufVxyXG5cclxuLyoqXHJcbiAqIEVxdWl2YWxlbnQgdG8gQnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXHJcbiAqICovXHJcbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXHJcbn1cclxuLyoqXHJcbiAqIEVxdWl2YWxlbnQgdG8gU2xvd0J1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxyXG4gKi9cclxuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XHJcbiAgcmV0dXJuIGFsbG9jVW5zYWZlKHNpemUpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyb21TdHJpbmcgKHN0cmluZywgZW5jb2RpbmcpIHtcclxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcclxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXHJcbiAgfVxyXG5cclxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxyXG4gIH1cclxuXHJcbiAgdmFyIGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXHJcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXHJcblxyXG4gIHZhciBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcclxuXHJcbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XHJcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcclxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXHJcbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcclxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXHJcbiAgfVxyXG5cclxuICByZXR1cm4gYnVmXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XHJcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxyXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcclxuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XHJcbiAgfVxyXG4gIHJldHVybiBidWZcclxufVxyXG5cclxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XHJcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XHJcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxyXG4gIH1cclxuXHJcbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcclxuICB9XHJcblxyXG4gIHZhciBidWZcclxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcclxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcclxuICB9IGVsc2Uge1xyXG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcclxuICB9XHJcblxyXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXHJcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcclxuXHJcbiAgcmV0dXJuIGJ1ZlxyXG59XHJcblxyXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcclxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcclxuICAgIHZhciBsZW4gPSBjaGVja2VkKG9iai5sZW5ndGgpIHwgMFxyXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXHJcblxyXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIGJ1ZlxyXG4gICAgfVxyXG5cclxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxyXG4gICAgcmV0dXJuIGJ1ZlxyXG4gIH1cclxuXHJcbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xyXG4gICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXHJcbiAgICB9XHJcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXHJcbiAgfVxyXG5cclxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XHJcbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmouZGF0YSlcclxuICB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xyXG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxyXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxyXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XHJcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXHJcbiAgfVxyXG4gIHJldHVybiBsZW5ndGggfCAwXHJcbn1cclxuXHJcbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xyXG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxyXG4gICAgbGVuZ3RoID0gMFxyXG4gIH1cclxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXHJcbn1cclxuXHJcbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XHJcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxyXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxyXG59XHJcblxyXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcclxuICBpZiAoaXNJbnN0YW5jZShhLCBVaW50OEFycmF5KSkgYSA9IEJ1ZmZlci5mcm9tKGEsIGEub2Zmc2V0LCBhLmJ5dGVMZW5ndGgpXHJcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxyXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXHJcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXHJcblxyXG4gIHZhciB4ID0gYS5sZW5ndGhcclxuICB2YXIgeSA9IGIubGVuZ3RoXHJcblxyXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xyXG4gICAgICB4ID0gYVtpXVxyXG4gICAgICB5ID0gYltpXVxyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcclxuICBpZiAoeSA8IHgpIHJldHVybiAxXHJcbiAgcmV0dXJuIDBcclxufVxyXG5cclxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xyXG4gIHN3aXRjaCAoU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpKSB7XHJcbiAgICBjYXNlICdoZXgnOlxyXG4gICAgY2FzZSAndXRmOCc6XHJcbiAgICBjYXNlICd1dGYtOCc6XHJcbiAgICBjYXNlICdhc2NpaSc6XHJcbiAgICBjYXNlICdsYXRpbjEnOlxyXG4gICAgY2FzZSAnYmluYXJ5JzpcclxuICAgIGNhc2UgJ2Jhc2U2NCc6XHJcbiAgICBjYXNlICd1Y3MyJzpcclxuICAgIGNhc2UgJ3Vjcy0yJzpcclxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxyXG4gICAgY2FzZSAndXRmLTE2bGUnOlxyXG4gICAgICByZXR1cm4gdHJ1ZVxyXG4gICAgZGVmYXVsdDpcclxuICAgICAgcmV0dXJuIGZhbHNlXHJcbiAgfVxyXG59XHJcblxyXG5CdWZmZXIuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0IChsaXN0LCBsZW5ndGgpIHtcclxuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXHJcbiAgfVxyXG5cclxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcclxuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcclxuICB9XHJcblxyXG4gIHZhciBpXHJcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICBsZW5ndGggPSAwXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxyXG4gIHZhciBwb3MgPSAwXHJcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgIHZhciBidWYgPSBsaXN0W2ldXHJcbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XHJcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcclxuICAgIH1cclxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcclxuICAgIH1cclxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxyXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcclxuICB9XHJcbiAgcmV0dXJuIGJ1ZmZlclxyXG59XHJcblxyXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XHJcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XHJcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxyXG4gIH1cclxuICBpZiAoQXJyYXlCdWZmZXIuaXNWaWV3KHN0cmluZykgfHwgaXNJbnN0YW5jZShzdHJpbmcsIEFycmF5QnVmZmVyKSkge1xyXG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXHJcbiAgfVxyXG4gIGlmICh0eXBlb2Ygc3RyaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcclxuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBzdHJpbmdcclxuICAgIClcclxuICB9XHJcblxyXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXHJcbiAgdmFyIG11c3RNYXRjaCA9IChhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gPT09IHRydWUpXHJcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxyXG5cclxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cclxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxyXG4gIGZvciAoOzspIHtcclxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcclxuICAgICAgY2FzZSAnYXNjaWknOlxyXG4gICAgICBjYXNlICdsYXRpbjEnOlxyXG4gICAgICBjYXNlICdiaW5hcnknOlxyXG4gICAgICAgIHJldHVybiBsZW5cclxuICAgICAgY2FzZSAndXRmOCc6XHJcbiAgICAgIGNhc2UgJ3V0Zi04JzpcclxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcclxuICAgICAgY2FzZSAndWNzMic6XHJcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcclxuICAgICAgY2FzZSAndXRmMTZsZSc6XHJcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcclxuICAgICAgICByZXR1cm4gbGVuICogMlxyXG4gICAgICBjYXNlICdoZXgnOlxyXG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcclxuICAgICAgY2FzZSAnYmFzZTY0JzpcclxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkge1xyXG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcclxuICAgICAgICB9XHJcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcclxuXHJcbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcclxuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxyXG5cclxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcclxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxyXG5cclxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcclxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXHJcbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcclxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cclxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcclxuICAgIHN0YXJ0ID0gMFxyXG4gIH1cclxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXHJcbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcclxuICAgIHJldHVybiAnJ1xyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XHJcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCA8PSAwKSB7XHJcbiAgICByZXR1cm4gJydcclxuICB9XHJcblxyXG4gIC8vIEZvcmNlIGNvZXJzaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXHJcbiAgZW5kID4+Pj0gMFxyXG4gIHN0YXJ0ID4+Pj0gMFxyXG5cclxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XHJcbiAgICByZXR1cm4gJydcclxuICB9XHJcblxyXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXHJcblxyXG4gIHdoaWxlICh0cnVlKSB7XHJcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XHJcbiAgICAgIGNhc2UgJ2hleCc6XHJcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXHJcblxyXG4gICAgICBjYXNlICd1dGY4JzpcclxuICAgICAgY2FzZSAndXRmLTgnOlxyXG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcclxuXHJcbiAgICAgIGNhc2UgJ2FzY2lpJzpcclxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxyXG5cclxuICAgICAgY2FzZSAnbGF0aW4xJzpcclxuICAgICAgY2FzZSAnYmluYXJ5JzpcclxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcclxuXHJcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XHJcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXHJcblxyXG4gICAgICBjYXNlICd1Y3MyJzpcclxuICAgICAgY2FzZSAndWNzLTInOlxyXG4gICAgICBjYXNlICd1dGYxNmxlJzpcclxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxyXG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXHJcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxyXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXHJcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XHJcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXHJcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxyXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcclxuXHJcbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcclxuICB2YXIgaSA9IGJbbl1cclxuICBiW25dID0gYlttXVxyXG4gIGJbbV0gPSBpXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2ID0gZnVuY3Rpb24gc3dhcDE2ICgpIHtcclxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcclxuICBpZiAobGVuICUgMiAhPT0gMCkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xyXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcclxuICB9XHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xyXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxyXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XHJcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XHJcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxyXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXHJcbiAgfVxyXG4gIHJldHVybiB0aGlzXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcclxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcclxuICBpZiAobGVuICUgOCAhPT0gMCkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcclxuICB9XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xyXG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcclxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyA2KVxyXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXHJcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcclxuICB9XHJcbiAgcmV0dXJuIHRoaXNcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcclxuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcclxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcclxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXHJcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXHJcblxyXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xyXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcclxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcclxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XHJcbiAgdmFyIHN0ciA9ICcnXHJcbiAgdmFyIG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcclxuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXHJcbiAgaWYgKHRoaXMubGVuZ3RoID4gbWF4KSBzdHIgKz0gJyAuLi4gJ1xyXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXHJcbn1cclxuaWYgKGN1c3RvbUluc3BlY3RTeW1ib2wpIHtcclxuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XHJcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xyXG4gICAgdGFyZ2V0ID0gQnVmZmVyLmZyb20odGFyZ2V0LCB0YXJnZXQub2Zmc2V0LCB0YXJnZXQuYnl0ZUxlbmd0aClcclxuICB9XHJcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xyXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcclxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xyXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXHJcbiAgICApXHJcbiAgfVxyXG5cclxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgc3RhcnQgPSAwXHJcbiAgfVxyXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcclxuICB9XHJcbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICB0aGlzU3RhcnQgPSAwXHJcbiAgfVxyXG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcclxuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxyXG4gIH1cclxuXHJcbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XHJcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcclxuICB9XHJcblxyXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcclxuICAgIHJldHVybiAwXHJcbiAgfVxyXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xyXG4gICAgcmV0dXJuIC0xXHJcbiAgfVxyXG4gIGlmIChzdGFydCA+PSBlbmQpIHtcclxuICAgIHJldHVybiAxXHJcbiAgfVxyXG5cclxuICBzdGFydCA+Pj49IDBcclxuICBlbmQgPj4+PSAwXHJcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxyXG4gIHRoaXNFbmQgPj4+PSAwXHJcblxyXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXHJcblxyXG4gIHZhciB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxyXG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcclxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcclxuXHJcbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXHJcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xyXG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XHJcbiAgICAgIHggPSB0aGlzQ29weVtpXVxyXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxyXG4gICAgICBicmVha1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcclxuICBpZiAoeSA8IHgpIHJldHVybiAxXHJcbiAgcmV0dXJuIDBcclxufVxyXG5cclxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxyXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxyXG4vL1xyXG4vLyBBcmd1bWVudHM6XHJcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXHJcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXHJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xyXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxyXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcclxuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcclxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXHJcblxyXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XHJcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xyXG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XHJcbiAgICBieXRlT2Zmc2V0ID0gMFxyXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcclxuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXHJcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcclxuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxyXG4gIH1cclxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cclxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcclxuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFwiZm9vXCIsIGV0Yywgc2VhcmNoIHdob2xlIGJ1ZmZlclxyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXHJcbiAgfVxyXG5cclxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XHJcbiAgaWYgKGJ5dGVPZmZzZXQgPj0gYnVmZmVyLmxlbmd0aCkge1xyXG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXHJcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxyXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IDApIHtcclxuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXHJcbiAgICBlbHNlIHJldHVybiAtMVxyXG4gIH1cclxuXHJcbiAgLy8gTm9ybWFsaXplIHZhbFxyXG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xyXG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcclxuICB9XHJcblxyXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXHJcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XHJcbiAgICAvLyBTcGVjaWFsIGNhc2U6IGxvb2tpbmcgZm9yIGVtcHR5IHN0cmluZy9idWZmZXIgYWx3YXlzIGZhaWxzXHJcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICByZXR1cm4gLTFcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xyXG4gICAgdmFsID0gdmFsICYgMHhGRiAvLyBTZWFyY2ggZm9yIGEgYnl0ZSB2YWx1ZSBbMC0yNTVdXHJcbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaWYgKGRpcikge1xyXG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5pbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcclxuICB9XHJcblxyXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcclxuICB2YXIgaW5kZXhTaXplID0gMVxyXG4gIHZhciBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXHJcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcclxuXHJcbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcclxuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXHJcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxyXG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcclxuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XHJcbiAgICAgICAgcmV0dXJuIC0xXHJcbiAgICAgIH1cclxuICAgICAgaW5kZXhTaXplID0gMlxyXG4gICAgICBhcnJMZW5ndGggLz0gMlxyXG4gICAgICB2YWxMZW5ndGggLz0gMlxyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xyXG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gYnVmW2ldXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgdmFyIGlcclxuICBpZiAoZGlyKSB7XHJcbiAgICB2YXIgZm91bmRJbmRleCA9IC0xXHJcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcclxuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xyXG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcclxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XHJcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcclxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcclxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xyXG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcclxuICAgICAgICAgIGZvdW5kID0gZmFsc2VcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiAtMVxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcclxuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XHJcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xyXG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcclxufVxyXG5cclxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcclxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxyXG4gIGlmICghbGVuZ3RoKSB7XHJcbiAgICBsZW5ndGggPSByZW1haW5pbmdcclxuICB9IGVsc2Uge1xyXG4gICAgbGVuZ3RoID0gTnVtYmVyKGxlbmd0aClcclxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcclxuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxyXG5cclxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xyXG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxyXG4gIH1cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxyXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXHJcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcclxuICB9XHJcbiAgcmV0dXJuIGlcclxufVxyXG5cclxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxyXG59XHJcblxyXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcclxufVxyXG5cclxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcclxufVxyXG5cclxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xyXG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcclxufVxyXG5cclxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XHJcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcclxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcclxuICAgIGVuY29kaW5nID0gJ3V0ZjgnXHJcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxyXG4gICAgb2Zmc2V0ID0gMFxyXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxyXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcclxuICAgIGVuY29kaW5nID0gb2Zmc2V0XHJcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxyXG4gICAgb2Zmc2V0ID0gMFxyXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXHJcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XHJcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XHJcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxyXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXHJcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcclxuICAgIClcclxuICB9XHJcblxyXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxyXG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xyXG5cclxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcclxuICB9XHJcblxyXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXHJcblxyXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXHJcbiAgZm9yICg7Oykge1xyXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xyXG4gICAgICBjYXNlICdoZXgnOlxyXG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxyXG5cclxuICAgICAgY2FzZSAndXRmOCc6XHJcbiAgICAgIGNhc2UgJ3V0Zi04JzpcclxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXHJcblxyXG4gICAgICBjYXNlICdhc2NpaSc6XHJcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcclxuXHJcbiAgICAgIGNhc2UgJ2xhdGluMSc6XHJcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XHJcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXHJcblxyXG4gICAgICBjYXNlICdiYXNlNjQnOlxyXG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXHJcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXHJcblxyXG4gICAgICBjYXNlICd1Y3MyJzpcclxuICAgICAgY2FzZSAndWNzLTInOlxyXG4gICAgICBjYXNlICd1dGYxNmxlJzpcclxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxyXG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcclxuXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXHJcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxyXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xyXG4gIHJldHVybiB7XHJcbiAgICB0eXBlOiAnQnVmZmVyJyxcclxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xyXG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcclxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXHJcbiAgfSBlbHNlIHtcclxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xyXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcclxuICB2YXIgcmVzID0gW11cclxuXHJcbiAgdmFyIGkgPSBzdGFydFxyXG4gIHdoaWxlIChpIDwgZW5kKSB7XHJcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXHJcbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxyXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XHJcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xyXG4gICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxyXG4gICAgICAgICAgOiAxXHJcblxyXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xyXG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XHJcblxyXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcclxuICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xyXG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cclxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XHJcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxyXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcclxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cclxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cclxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xyXG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcclxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xyXG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxyXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxyXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cclxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XHJcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxyXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcclxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcclxuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxyXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXHJcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxyXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxyXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcclxuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcclxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcclxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxyXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxyXG4gICAgfVxyXG5cclxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcclxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXHJcbn1cclxuXHJcbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxyXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXHJcbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcclxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXHJcblxyXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcclxuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcclxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XHJcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcclxuICB9XHJcblxyXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cclxuICB2YXIgcmVzID0gJydcclxuICB2YXIgaSA9IDBcclxuICB3aGlsZSAoaSA8IGxlbikge1xyXG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXHJcbiAgICAgIFN0cmluZyxcclxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxyXG4gICAgKVxyXG4gIH1cclxuICByZXR1cm4gcmVzXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xyXG4gIHZhciByZXQgPSAnJ1xyXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcclxuXHJcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcclxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXHJcbiAgfVxyXG4gIHJldHVybiByZXRcclxufVxyXG5cclxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xyXG4gIHZhciByZXQgPSAnJ1xyXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcclxuXHJcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcclxuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcclxuICB9XHJcbiAgcmV0dXJuIHJldFxyXG59XHJcblxyXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XHJcbiAgdmFyIGxlbiA9IGJ1Zi5sZW5ndGhcclxuXHJcbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxyXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cclxuXHJcbiAgdmFyIG91dCA9ICcnXHJcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcclxuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cclxuICB9XHJcbiAgcmV0dXJuIG91dFxyXG59XHJcblxyXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xyXG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxyXG4gIHZhciByZXMgPSAnJ1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcclxuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXHJcbiAgfVxyXG4gIHJldHVybiByZXNcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XHJcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXHJcbiAgc3RhcnQgPSB+fnN0YXJ0XHJcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxyXG5cclxuICBpZiAoc3RhcnQgPCAwKSB7XHJcbiAgICBzdGFydCArPSBsZW5cclxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxyXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcclxuICAgIHN0YXJ0ID0gbGVuXHJcbiAgfVxyXG5cclxuICBpZiAoZW5kIDwgMCkge1xyXG4gICAgZW5kICs9IGxlblxyXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcclxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xyXG4gICAgZW5kID0gbGVuXHJcbiAgfVxyXG5cclxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XHJcblxyXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXHJcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcclxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YobmV3QnVmLCBCdWZmZXIucHJvdG90eXBlKVxyXG5cclxuICByZXR1cm4gbmV3QnVmXHJcbn1cclxuXHJcbi8qXHJcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxyXG4gKi9cclxuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcclxuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxyXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcclxuXHJcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxyXG4gIHZhciBtdWwgPSAxXHJcbiAgdmFyIGkgPSAwXHJcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcclxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXHJcbiAgfVxyXG5cclxuICByZXR1cm4gdmFsXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIHtcclxuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXHJcbiAgfVxyXG5cclxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXHJcbiAgdmFyIG11bCA9IDFcclxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcclxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcclxuICB9XHJcblxyXG4gIHJldHVybiB2YWxcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxyXG4gIHJldHVybiB0aGlzW29mZnNldF1cclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxyXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXHJcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcclxuXHJcbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XHJcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcclxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXHJcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXHJcblxyXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXHJcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcclxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcclxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxyXG5cclxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXHJcbiAgdmFyIG11bCA9IDFcclxuICB2YXIgaSA9IDBcclxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xyXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcclxuICB9XHJcbiAgbXVsICo9IDB4ODBcclxuXHJcbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcclxuXHJcbiAgcmV0dXJuIHZhbFxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcclxuXHJcbiAgdmFyIGkgPSBieXRlTGVuZ3RoXHJcbiAgdmFyIG11bCA9IDFcclxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXHJcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XHJcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXHJcbiAgfVxyXG4gIG11bCAqPSAweDgwXHJcblxyXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXHJcblxyXG4gIHJldHVybiB2YWxcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcclxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXHJcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXHJcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXHJcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxyXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxyXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcclxuXHJcbiAgcmV0dXJuICh0aGlzW29mZnNldF0pIHxcclxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcclxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XHJcbiAgICAodGhpc1tvZmZzZXQgKyAzXSA8PCAyNClcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcclxuXHJcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcclxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XHJcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XHJcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcclxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXHJcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxyXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxyXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcclxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxyXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcclxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcclxuICB2YWx1ZSA9ICt2YWx1ZVxyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxyXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXHJcbiAgfVxyXG5cclxuICB2YXIgbXVsID0gMVxyXG4gIHZhciBpID0gMFxyXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxyXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XHJcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcclxuICB9XHJcblxyXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcclxuICB2YWx1ZSA9ICt2YWx1ZVxyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxyXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXHJcbiAgfVxyXG5cclxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXHJcbiAgdmFyIG11bCA9IDFcclxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXHJcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XHJcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcclxuICB9XHJcblxyXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgdmFsdWUgPSArdmFsdWVcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxyXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXHJcbiAgcmV0dXJuIG9mZnNldCArIDFcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICB2YWx1ZSA9ICt2YWx1ZVxyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcclxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxyXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXHJcbiAgcmV0dXJuIG9mZnNldCArIDJcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICB2YWx1ZSA9ICt2YWx1ZVxyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcclxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXHJcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXHJcbiAgcmV0dXJuIG9mZnNldCArIDJcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICB2YWx1ZSA9ICt2YWx1ZVxyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXHJcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXHJcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXHJcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcclxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxyXG4gIHJldHVybiBvZmZzZXQgKyA0XHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgdmFsdWUgPSArdmFsdWVcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxyXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXHJcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXHJcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcclxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcclxuICByZXR1cm4gb2Zmc2V0ICsgNFxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xyXG4gIHZhbHVlID0gK3ZhbHVlXHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkge1xyXG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXHJcblxyXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXHJcbiAgfVxyXG5cclxuICB2YXIgaSA9IDBcclxuICB2YXIgbXVsID0gMVxyXG4gIHZhciBzdWIgPSAwXHJcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXHJcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcclxuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XHJcbiAgICAgIHN1YiA9IDFcclxuICAgIH1cclxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcclxuICB9XHJcblxyXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XHJcbiAgdmFsdWUgPSArdmFsdWVcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcclxuXHJcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcclxuICB9XHJcblxyXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcclxuICB2YXIgbXVsID0gMVxyXG4gIHZhciBzdWIgPSAwXHJcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxyXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xyXG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcclxuICAgICAgc3ViID0gMVxyXG4gICAgfVxyXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgdmFsdWUgPSArdmFsdWVcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcclxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcclxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxyXG4gIHJldHVybiBvZmZzZXQgKyAxXHJcbn1cclxuXHJcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xyXG4gIHZhbHVlID0gK3ZhbHVlXHJcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXHJcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxyXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXHJcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcclxuICByZXR1cm4gb2Zmc2V0ICsgMlxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICB2YWx1ZSA9ICt2YWx1ZVxyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcclxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXHJcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXHJcbiAgcmV0dXJuIG9mZnNldCArIDJcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgdmFsdWUgPSArdmFsdWVcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcclxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxyXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXHJcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXHJcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXHJcbiAgcmV0dXJuIG9mZnNldCArIDRcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgdmFsdWUgPSArdmFsdWVcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcclxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcclxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxyXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxyXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXHJcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXHJcbiAgcmV0dXJuIG9mZnNldCArIDRcclxufVxyXG5cclxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcclxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXHJcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcclxuICB2YWx1ZSA9ICt2YWx1ZVxyXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxyXG4gIGlmICghbm9Bc3NlcnQpIHtcclxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxyXG4gIH1cclxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcclxuICByZXR1cm4gb2Zmc2V0ICsgNFxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XHJcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxyXG59XHJcblxyXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XHJcbiAgdmFsdWUgPSArdmFsdWVcclxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcclxuICBpZiAoIW5vQXNzZXJ0KSB7XHJcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxyXG4gIH1cclxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcclxuICByZXR1cm4gb2Zmc2V0ICsgOFxyXG59XHJcblxyXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xyXG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcclxufVxyXG5cclxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcclxuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxyXG59XHJcblxyXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXHJcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcclxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCBzaG91bGQgYmUgYSBCdWZmZXInKVxyXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxyXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcclxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXHJcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXHJcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XHJcblxyXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxyXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxyXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxyXG5cclxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXHJcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xyXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxyXG4gIH1cclxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcclxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcclxuXHJcbiAgLy8gQXJlIHdlIG9vYj9cclxuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXHJcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XHJcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxyXG4gIH1cclxuXHJcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XHJcblxyXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcclxuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcclxuICAgIHRoaXMuY29weVdpdGhpbih0YXJnZXRTdGFydCwgc3RhcnQsIGVuZClcclxuICB9IGVsc2UgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XHJcbiAgICAvLyBkZXNjZW5kaW5nIGNvcHkgZnJvbSBlbmRcclxuICAgIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID49IDA7IC0taSkge1xyXG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxyXG4gICAgfVxyXG4gIH0gZWxzZSB7XHJcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcclxuICAgICAgdGFyZ2V0LFxyXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxyXG4gICAgICB0YXJnZXRTdGFydFxyXG4gICAgKVxyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGxlblxyXG59XHJcblxyXG4vLyBVc2FnZTpcclxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXHJcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxyXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcclxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xyXG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XHJcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XHJcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XHJcbiAgICAgIHN0YXJ0ID0gMFxyXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxyXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xyXG4gICAgICBlbmNvZGluZyA9IGVuZFxyXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxyXG4gICAgfVxyXG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcclxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxyXG4gICAgfVxyXG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcclxuICAgICAgdmFyIGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxyXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcclxuICAgICAgICAgIGVuY29kaW5nID09PSAnbGF0aW4xJykge1xyXG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXHJcbiAgICAgICAgdmFsID0gY29kZVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xyXG4gICAgdmFsID0gdmFsICYgMjU1XHJcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcclxuICAgIHZhbCA9IE51bWJlcih2YWwpXHJcbiAgfVxyXG5cclxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cclxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcclxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxyXG4gIH1cclxuXHJcbiAgaWYgKGVuZCA8PSBzdGFydCkge1xyXG4gICAgcmV0dXJuIHRoaXNcclxuICB9XHJcblxyXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcclxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXHJcblxyXG4gIGlmICghdmFsKSB2YWwgPSAwXHJcblxyXG4gIHZhciBpXHJcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XHJcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XHJcbiAgICAgIHRoaXNbaV0gPSB2YWxcclxuICAgIH1cclxuICB9IGVsc2Uge1xyXG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcclxuICAgICAgPyB2YWxcclxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxyXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxyXG4gICAgaWYgKGxlbiA9PT0gMCkge1xyXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcclxuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcclxuICAgIH1cclxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XHJcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpc1xyXG59XHJcblxyXG4vLyBIRUxQRVIgRlVOQ1RJT05TXHJcbi8vID09PT09PT09PT09PT09PT1cclxuXHJcbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcclxuXHJcbmZ1bmN0aW9uIGJhc2U2NGNsZWFuIChzdHIpIHtcclxuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXHJcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cclxuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcclxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxyXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcclxuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xyXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxyXG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xyXG4gICAgc3RyID0gc3RyICsgJz0nXHJcbiAgfVxyXG4gIHJldHVybiBzdHJcclxufVxyXG5cclxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcclxuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XHJcbiAgdmFyIGNvZGVQb2ludFxyXG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXHJcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXHJcbiAgdmFyIGJ5dGVzID0gW11cclxuXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xyXG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcclxuXHJcbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XHJcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xyXG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxyXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcclxuICAgICAgICAvLyBubyBsZWFkIHlldFxyXG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcclxuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcclxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcclxuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcclxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxyXG4gICAgICAgICAgY29udGludWVcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcclxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XHJcblxyXG4gICAgICAgIGNvbnRpbnVlXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcclxuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xyXG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxyXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcclxuICAgICAgICBjb250aW51ZVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXHJcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcclxuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxyXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcclxuICAgIH1cclxuXHJcbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxyXG5cclxuICAgIC8vIGVuY29kZSB1dGY4XHJcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xyXG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcclxuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXHJcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XHJcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xyXG4gICAgICBieXRlcy5wdXNoKFxyXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxyXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXHJcbiAgICAgIClcclxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xyXG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcclxuICAgICAgYnl0ZXMucHVzaChcclxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcclxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXHJcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcclxuICAgICAgKVxyXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xyXG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcclxuICAgICAgYnl0ZXMucHVzaChcclxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXHJcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxyXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcclxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxyXG4gICAgICApXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYnl0ZXNcclxufVxyXG5cclxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcclxuICB2YXIgYnl0ZUFycmF5ID0gW11cclxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xyXG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXHJcbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXHJcbiAgfVxyXG4gIHJldHVybiBieXRlQXJyYXlcclxufVxyXG5cclxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcclxuICB2YXIgYywgaGksIGxvXHJcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcclxuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xyXG5cclxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxyXG4gICAgaGkgPSBjID4+IDhcclxuICAgIGxvID0gYyAlIDI1NlxyXG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXHJcbiAgICBieXRlQXJyYXkucHVzaChoaSlcclxuICB9XHJcblxyXG4gIHJldHVybiBieXRlQXJyYXlcclxufVxyXG5cclxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XHJcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxyXG59XHJcblxyXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcclxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XHJcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXHJcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cclxuICB9XHJcbiAgcmV0dXJuIGlcclxufVxyXG5cclxuLy8gQXJyYXlCdWZmZXIgb3IgVWludDhBcnJheSBvYmplY3RzIGZyb20gb3RoZXIgY29udGV4dHMgKGkuZS4gaWZyYW1lcykgZG8gbm90IHBhc3NcclxuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXHJcbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxyXG5mdW5jdGlvbiBpc0luc3RhbmNlIChvYmosIHR5cGUpIHtcclxuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxyXG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcclxuICAgICAgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09IHR5cGUubmFtZSlcclxufVxyXG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XHJcbiAgLy8gRm9yIElFMTEgc3VwcG9ydFxyXG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxyXG59XHJcblxyXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxyXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcclxudmFyIGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xyXG4gIHZhciBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xyXG4gIHZhciB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgKytpKSB7XHJcbiAgICB2YXIgaTE2ID0gaSAqIDE2XHJcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyArK2opIHtcclxuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiB0YWJsZVxyXG59KSgpXHJcbiIsIi8qISBpZWVlNzU0LiBCU0QtMy1DbGF1c2UgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXHJcbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XHJcbiAgdmFyIGUsIG1cclxuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXHJcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcclxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcclxuICB2YXIgbkJpdHMgPSAtN1xyXG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcclxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcclxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxyXG5cclxuICBpICs9IGRcclxuXHJcbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcclxuICBzID4+PSAoLW5CaXRzKVxyXG4gIG5CaXRzICs9IGVMZW5cclxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XHJcblxyXG4gIG0gPSBlICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXHJcbiAgZSA+Pj0gKC1uQml0cylcclxuICBuQml0cyArPSBtTGVuXHJcbiAgZm9yICg7IG5CaXRzID4gMDsgbSA9IChtICogMjU2KSArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxyXG5cclxuICBpZiAoZSA9PT0gMCkge1xyXG4gICAgZSA9IDEgLSBlQmlhc1xyXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xyXG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXHJcbiAgfSBlbHNlIHtcclxuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcclxuICAgIGUgPSBlIC0gZUJpYXNcclxuICB9XHJcbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcclxufVxyXG5cclxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xyXG4gIHZhciBlLCBtLCBjXHJcbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxyXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXHJcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXHJcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxyXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcclxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcclxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxyXG5cclxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxyXG5cclxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xyXG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXHJcbiAgICBlID0gZU1heFxyXG4gIH0gZWxzZSB7XHJcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcclxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcclxuICAgICAgZS0tXHJcbiAgICAgIGMgKj0gMlxyXG4gICAgfVxyXG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XHJcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcclxuICAgICAgZSsrXHJcbiAgICAgIGMgLz0gMlxyXG4gICAgfVxyXG5cclxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xyXG4gICAgICBtID0gMFxyXG4gICAgICBlID0gZU1heFxyXG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xyXG4gICAgICBtID0gKCh2YWx1ZSAqIGMpIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxyXG4gICAgICBlID0gZSArIGVCaWFzXHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBtID0gdmFsdWUgKiBNYXRoLnBvdygyLCBlQmlhcyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcclxuICAgICAgZSA9IDBcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XHJcblxyXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cclxuICBlTGVuICs9IG1MZW5cclxuICBmb3IgKDsgZUxlbiA+IDA7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IGUgJiAweGZmLCBpICs9IGQsIGUgLz0gMjU2LCBlTGVuIC09IDgpIHt9XHJcblxyXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxyXG59XHJcbiIsInZhciBhcGkgPSByZXF1aXJlKFwiIS4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzXCIpO1xuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL2Nzcy1sb2FkZXIvY2pzLmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzNdLm9uZU9mWzJdLnVzZVsxXSEuLi8uLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3Bvc3Rjc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMl0hLi9jaGF0Q29tcG9uZW50cy5tb2R1bGUuY3NzXCIpO1xuXG4gICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG4gICAgICAgICAgICB9XG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuaW5zZXJ0ID0gZnVuY3Rpb24oZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXHJcbiAgICAgICAgICAgICAgICAvLyB0aGlzIGNvZGUgc2hvdWxkIGZhaWwuXHJcbiAgICAgICAgICAgICAgICB2YXIgYW5jaG9yRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyNfX25leHRfY3NzX19ET19OT1RfVVNFX18nKTtcclxuICAgICAgICAgICAgICAgIHZhciBwYXJlbnROb2RlID0gYW5jaG9yRWxlbWVudC5wYXJlbnROb2RlLy8gTm9ybWFsbHkgPGhlYWQ+XHJcbiAgICAgICAgICAgICAgICA7XHJcbiAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcclxuICAgICAgICAgICAgICAgIC8vIGFuY2hvci4gQnkgaW5zZXJ0aW5nIGJlZm9yZSBhbmQgbm90IGFmdGVyLCB3ZSBkbyBub3RcclxuICAgICAgICAgICAgICAgIC8vIG5lZWQgdG8gdHJhY2sgdGhlIGxhc3QgaW5zZXJ0ZWQgZWxlbWVudC5cclxuICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9O1xub3B0aW9ucy5zaW5nbGV0b24gPSBmYWxzZTtcblxudmFyIHVwZGF0ZSA9IGFwaShjb250ZW50LCBvcHRpb25zKTtcblxuXG5pZiAobW9kdWxlLmhvdCkge1xuICBpZiAoIWNvbnRlbnQubG9jYWxzIHx8IG1vZHVsZS5ob3QuaW52YWxpZGF0ZSkge1xuICAgIHZhciBpc0VxdWFsTG9jYWxzID0gZnVuY3Rpb24gaXNFcXVhbExvY2FscyhhLCBiLCBpc05hbWVkRXhwb3J0KSB7XHJcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgbGV0IHA7XHJcbiAgICBmb3IocCBpbiBhKXtcclxuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChhW3BdICE9PSBiW3BdKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBmb3IocCBpbiBiKXtcclxuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSAnZGVmYXVsdCcpIHtcclxuICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghYVtwXSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn07XG4gICAgdmFyIG9sZExvY2FscyA9IGNvbnRlbnQubG9jYWxzO1xuXG4gICAgbW9kdWxlLmhvdC5hY2NlcHQoXG4gICAgICBcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzJdIS4vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiLFxuICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9jc3MtbG9hZGVyL2Nqcy5qcz8/cnVsZVNldFsxXS5ydWxlc1szXS5vbmVPZlsyXS51c2VbMV0hLi4vLi4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9wb3N0Y3NzLWxvYWRlci9janMuanM/P3J1bGVTZXRbMV0ucnVsZXNbM10ub25lT2ZbMl0udXNlWzJdIS4vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiLCIvLyBJbXBvcnRzXG52YXIgX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fID0gcmVxdWlyZShcIi4uLy4uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvY3NzLWxvYWRlci9hcGkuanNcIik7XG52YXIgX19fQ1NTX0xPQURFUl9FWFBPUlRfX18gPSBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18odHJ1ZSk7XG4vLyBNb2R1bGVcbl9fX0NTU19MT0FERVJfRVhQT1JUX19fLnB1c2goW21vZHVsZS5pZCwgXCIuY2hhdENvbXBvbmVudHNfY2hhdEhvbGRlcl9fMkUxQVgge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtcm93czogMWZyIDEwMHB4O1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfY2hhdFRleHRfXzNNUkVzIHtcXHJcXG4gIGRpc3BsYXk6IC1tb3otYm94O1xcclxcbiAgZGlzcGxheTogZmxleDtcXHJcXG4gIC1tb3otYm94LW9yaWVudDogdmVydGljYWw7XFxyXFxuICAtbW96LWJveC1kaXJlY3Rpb246IG5vcm1hbDtcXHJcXG4gICAgICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXHJcXG4gIC1tb3otYm94LWFsaWduOiBzdGFydDtcXHJcXG4gICAgICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxyXFxuICBncmlkLWdhcDogMWVtO1xcclxcbiAgZ2FwOiAxZW07XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBoZWlnaHQ6IC13ZWJraXQtY2FsYygxMDB2aCAtIDQwcHggLSAxMDBweCAtIDEwMHB4IC0gMTAwcHgpO1xcclxcbiAgaGVpZ2h0OiBjYWxjKDEwMHZoIC0gNDBweCAtIDEwMHB4IC0gMTAwcHggLSAxMDBweCk7XFxyXFxuICBvdmVyZmxvdy15OiBhdXRvO1xcclxcbn1cXHJcXG5cXHJcXG4uY2hhdENvbXBvbmVudHNfZm9ybV9fM3JGSUsge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDEwMHB4O1xcclxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlZWU7XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c190ZXh0YXJlYV9fMlV1THkge1xcclxcbiAgcGFkZGluZzogMWVtO1xcclxcbiAgYm9yZGVyOiAwO1xcclxcbiAgZm9udC1mYW1pbHk6IC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgU2Vnb2UgVUksIFJvYm90bywgT3h5Z2VuLFxcclxcbiAgICBVYnVudHUsIENhbnRhcmVsbCwgRmlyYSBTYW5zLCBEcm9pZCBTYW5zLCBIZWx2ZXRpY2EgTmV1ZSwgc2Fucy1zZXJpZjtcXHJcXG4gIGZvbnQtc2l6ZTogMS4yZW07XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c19idXR0b25fXzNlWnlNIHtcXHJcXG4gIGJvcmRlcjogMDtcXHJcXG4gIGNvbG9yOiB3aGl0ZTtcXHJcXG4gIGZvbnQtd2VpZ2h0OiBib2xkO1xcclxcbiAgZm9udC1zaXplOiAxLjRlbTtcXHJcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQobGluZWFyLCBsZWZ0IHRvcCwgcmlnaHQgdG9wLCBmcm9tKCMzNjM3OTUpLCB0bygjMDA1Yzk3KSk7XFxyXFxuICBiYWNrZ3JvdW5kOiAtd2Via2l0LWxpbmVhci1ncmFkaWVudChsZWZ0LCAjMzYzNzk1LCAjMDA1Yzk3KTtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgIzM2Mzc5NSwgIzAwNWM5Nyk7XFxyXFxufVxcclxcblxcclxcbi5jaGF0Q29tcG9uZW50c19idXR0b25fXzNlWnlNOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtZ3JhZGllbnQoXFxyXFxuICAgIGxpbmVhcixcXHJcXG4gICAgbGVmdCB0b3AsIHJpZ2h0IHRvcCxcXHJcXG4gICAgZnJvbShyZ2JhKDU0LCA1NSwgMTQ5LCAxKSksXFxyXFxuICAgIGNvbG9yLXN0b3AoNjIlLCByZ2JhKDAsIDkyLCAxNTEsIDEpKSxcXHJcXG4gICAgdG8ocmdiYSgwLCAxMjUsIDIwNSwgMSkpXFxyXFxuICApO1xcclxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1saW5lYXItZ3JhZGllbnQoXFxyXFxuICAgIGxlZnQsXFxyXFxuICAgIHJnYmEoNTQsIDU1LCAxNDksIDEpIDAlLFxcclxcbiAgICByZ2JhKDAsIDkyLCAxNTEsIDEpIDYyJSxcXHJcXG4gICAgcmdiYSgwLCAxMjUsIDIwNSwgMSkgMTAwJVxcclxcbiAgKTtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXHJcXG4gICAgOTBkZWcsXFxyXFxuICAgIHJnYmEoNTQsIDU1LCAxNDksIDEpIDAlLFxcclxcbiAgICByZ2JhKDAsIDkyLCAxNTEsIDEpIDYyJSxcXHJcXG4gICAgcmdiYSgwLCAxMjUsIDIwNSwgMSkgMTAwJVxcclxcbiAgKTtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX2J1dHRvbl9fM2VaeU06ZGlzYWJsZWQsXFxyXFxuLmNoYXRDb21wb25lbnRzX2J1dHRvbl9fM2VaeU06aG92ZXI6ZGlzYWJsZWQge1xcclxcbiAgYmFja2dyb3VuZDogLXdlYmtpdC1ncmFkaWVudChsaW5lYXIsIGxlZnQgdG9wLCByaWdodCB0b3AsIGZyb20oIzM2Mzc5NSksIHRvKCMwMDVjOTcpKTtcXHJcXG4gIGJhY2tncm91bmQ6IC13ZWJraXQtbGluZWFyLWdyYWRpZW50KGxlZnQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbiAgYmFja2dyb3VuZDogbGluZWFyLWdyYWRpZW50KHRvIHJpZ2h0LCAjMzYzNzk1LCAjMDA1Yzk3KTtcXHJcXG4gIG9wYWNpdHk6IDAuNTtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRDb21wb25lbnRzX21lc3NhZ2VfXzFkbm9CIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWY1Zjg7XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgLW1vei1ib3gtZmxleDogMDtcXHJcXG4gICAgICAgZmxleC1ncm93OiAwO1xcclxcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXHJcXG59XFxyXFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL2NvbXBvbmVudHMvY2hhdHJvb20vY2hhdENvbXBvbmVudHMubW9kdWxlLmNzc1wiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiQUFBQTtFQUNFLGFBQWE7RUFDYiw2QkFBNkI7QUFDL0I7O0FBRUE7RUFDRSxpQkFBYTtFQUFiLGFBQWE7RUFDYix5QkFBc0I7RUFBdEIsMEJBQXNCO09BQXRCLHNCQUFzQjtFQUN0QixxQkFBdUI7T0FBdkIsdUJBQXVCO0VBQ3ZCLGFBQVE7RUFBUixRQUFRO0VBQ1IsWUFBWTtFQUNaLDBEQUFrRDtFQUFsRCxrREFBa0Q7RUFDbEQsZ0JBQWdCO0FBQ2xCOztBQUVBO0VBQ0UsYUFBYTtFQUNiLGdDQUFnQztFQUNoQywwQkFBMEI7QUFDNUI7O0FBRUE7RUFDRSxZQUFZO0VBQ1osU0FBUztFQUNUO3dFQUNzRTtFQUN0RSxnQkFBZ0I7QUFDbEI7O0FBRUE7RUFDRSxTQUFTO0VBQ1QsWUFBWTtFQUNaLGlCQUFpQjtFQUNqQixnQkFBZ0I7RUFDaEIscUZBQXVEO0VBQXZELDJEQUF1RDtFQUF2RCx1REFBdUQ7QUFDekQ7O0FBRUE7RUFDRTs7Ozs7O0dBS0M7RUFMRDs7Ozs7R0FLQztFQUxEOzs7OztHQUtDO0FBQ0g7O0FBRUE7O0VBRUUscUZBQXVEO0VBQXZELDJEQUF1RDtFQUF2RCx1REFBdUQ7RUFDdkQsWUFBWTtBQUNkOztBQUVBO0VBQ0UseUJBQXlCO0VBQ3pCLFlBQVk7RUFDWixtQkFBbUI7RUFDbkIsZ0JBQVk7T0FBWixZQUFZO0VBQ1osNEJBQTRCO0FBQzlCXCIsXCJzb3VyY2VzQ29udGVudFwiOltcIi5jaGF0SG9sZGVyIHtcXHJcXG4gIGRpc3BsYXk6IGdyaWQ7XFxyXFxuICBncmlkLXRlbXBsYXRlLXJvd3M6IDFmciAxMDBweDtcXHJcXG59XFxyXFxuXFxyXFxuLmNoYXRUZXh0IHtcXHJcXG4gIGRpc3BsYXk6IGZsZXg7XFxyXFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcclxcbiAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XFxyXFxuICBnYXA6IDFlbTtcXHJcXG4gIHBhZGRpbmc6IDFlbTtcXHJcXG4gIGhlaWdodDogY2FsYygxMDB2aCAtIDQwcHggLSAxMDBweCAtIDEwMHB4IC0gMTAwcHgpO1xcclxcbiAgb3ZlcmZsb3cteTogYXV0bztcXHJcXG59XFxyXFxuXFxyXFxuLmZvcm0ge1xcclxcbiAgZGlzcGxheTogZ3JpZDtcXHJcXG4gIGdyaWQtdGVtcGxhdGUtY29sdW1uczogMWZyIDEwMHB4O1xcclxcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICNlZWU7XFxyXFxufVxcclxcblxcclxcbi50ZXh0YXJlYSB7XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBmb250LWZhbWlseTogLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCBTZWdvZSBVSSwgUm9ib3RvLCBPeHlnZW4sXFxyXFxuICAgIFVidW50dSwgQ2FudGFyZWxsLCBGaXJhIFNhbnMsIERyb2lkIFNhbnMsIEhlbHZldGljYSBOZXVlLCBzYW5zLXNlcmlmO1xcclxcbiAgZm9udC1zaXplOiAxLjJlbTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbiB7XFxyXFxuICBib3JkZXI6IDA7XFxyXFxuICBjb2xvcjogd2hpdGU7XFxyXFxuICBmb250LXdlaWdodDogYm9sZDtcXHJcXG4gIGZvbnQtc2l6ZTogMS40ZW07XFxyXFxuICBiYWNrZ3JvdW5kOiBsaW5lYXItZ3JhZGllbnQodG8gcmlnaHQsICMzNjM3OTUsICMwMDVjOTcpO1xcclxcbn1cXHJcXG5cXHJcXG4uYnV0dG9uOmhvdmVyIHtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudChcXHJcXG4gICAgOTBkZWcsXFxyXFxuICAgIHJnYmEoNTQsIDU1LCAxNDksIDEpIDAlLFxcclxcbiAgICByZ2JhKDAsIDkyLCAxNTEsIDEpIDYyJSxcXHJcXG4gICAgcmdiYSgwLCAxMjUsIDIwNSwgMSkgMTAwJVxcclxcbiAgKTtcXHJcXG59XFxyXFxuXFxyXFxuLmJ1dHRvbjpkaXNhYmxlZCxcXHJcXG4uYnV0dG9uOmhvdmVyOmRpc2FibGVkIHtcXHJcXG4gIGJhY2tncm91bmQ6IGxpbmVhci1ncmFkaWVudCh0byByaWdodCwgIzM2Mzc5NSwgIzAwNWM5Nyk7XFxyXFxuICBvcGFjaXR5OiAwLjU7XFxyXFxufVxcclxcblxcclxcbi5tZXNzYWdlIHtcXHJcXG4gIGJhY2tncm91bmQtY29sb3I6ICNlZWY1Zjg7XFxyXFxuICBwYWRkaW5nOiAxZW07XFxyXFxuICBib3JkZXItcmFkaXVzOiAxMHB4O1xcclxcbiAgZmxleC1ncm93OiAwO1xcclxcbiAgYm9yZGVyLWJvdHRvbS1sZWZ0LXJhZGl1czogMDtcXHJcXG59XFxyXFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5sb2NhbHMgPSB7XG5cdFwiY2hhdEhvbGRlclwiOiBcImNoYXRDb21wb25lbnRzX2NoYXRIb2xkZXJfXzJFMUFYXCIsXG5cdFwiY2hhdFRleHRcIjogXCJjaGF0Q29tcG9uZW50c19jaGF0VGV4dF9fM01SRXNcIixcblx0XCJmb3JtXCI6IFwiY2hhdENvbXBvbmVudHNfZm9ybV9fM3JGSUtcIixcblx0XCJ0ZXh0YXJlYVwiOiBcImNoYXRDb21wb25lbnRzX3RleHRhcmVhX18yVXVMeVwiLFxuXHRcImJ1dHRvblwiOiBcImNoYXRDb21wb25lbnRzX2J1dHRvbl9fM2VaeU1cIixcblx0XCJtZXNzYWdlXCI6IFwiY2hhdENvbXBvbmVudHNfbWVzc2FnZV9fMWRub0JcIlxufTtcbm1vZHVsZS5leHBvcnRzID0gX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xyXG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xyXG5cclxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIHtcclxuICAgIGFycjJbaV0gPSBhcnJbaV07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gYXJyMjtcclxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcclxuICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gYXJyO1xyXG59IiwiaW1wb3J0IGFycmF5TGlrZVRvQXJyYXkgZnJvbSBcIi4vYXJyYXlMaWtlVG9BcnJheS5qc1wiO1xyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB7XHJcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcclxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xyXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xyXG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xyXG4gIHZhciBfaSA9IGFyciA9PSBudWxsID8gbnVsbCA6IHR5cGVvZiBTeW1ib2wgIT09IFwidW5kZWZpbmVkXCIgJiYgYXJyW1N5bWJvbC5pdGVyYXRvcl0gfHwgYXJyW1wiQEBpdGVyYXRvclwiXTtcclxuXHJcbiAgaWYgKF9pID09IG51bGwpIHJldHVybjtcclxuICB2YXIgX2FyciA9IFtdO1xyXG4gIHZhciBfbiA9IHRydWU7XHJcbiAgdmFyIF9kID0gZmFsc2U7XHJcblxyXG4gIHZhciBfcywgX2U7XHJcblxyXG4gIHRyeSB7XHJcbiAgICBmb3IgKF9pID0gX2kuY2FsbChhcnIpOyAhKF9uID0gKF9zID0gX2kubmV4dCgpKS5kb25lKTsgX24gPSB0cnVlKSB7XHJcbiAgICAgIF9hcnIucHVzaChfcy52YWx1ZSk7XHJcblxyXG4gICAgICBpZiAoaSAmJiBfYXJyLmxlbmd0aCA9PT0gaSkgYnJlYWs7XHJcbiAgICB9XHJcbiAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICBfZCA9IHRydWU7XHJcbiAgICBfZSA9IGVycjtcclxuICB9IGZpbmFsbHkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFfbiAmJiBfaVtcInJldHVyblwiXSAhPSBudWxsKSBfaVtcInJldHVyblwiXSgpO1xyXG4gICAgfSBmaW5hbGx5IHtcclxuICAgICAgaWYgKF9kKSB0aHJvdyBfZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiBfYXJyO1xyXG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcclxuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIGRlc3RydWN0dXJlIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xyXG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xyXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIGF0dGVtcHQgdG8gc3ByZWFkIG5vbi1pdGVyYWJsZSBpbnN0YW5jZS5cXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXCIpO1xyXG59IiwiaW1wb3J0IGFycmF5V2l0aEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aEhvbGVzLmpzXCI7XHJcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXlMaW1pdCBmcm9tIFwiLi9pdGVyYWJsZVRvQXJyYXlMaW1pdC5qc1wiO1xyXG5pbXBvcnQgdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkuanNcIjtcclxuaW1wb3J0IG5vbkl0ZXJhYmxlUmVzdCBmcm9tIFwiLi9ub25JdGVyYWJsZVJlc3QuanNcIjtcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XHJcbiAgcmV0dXJuIGFycmF5V2l0aEhvbGVzKGFycikgfHwgaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IG5vbkl0ZXJhYmxlUmVzdCgpO1xyXG59IiwiaW1wb3J0IGFycmF5V2l0aG91dEhvbGVzIGZyb20gXCIuL2FycmF5V2l0aG91dEhvbGVzLmpzXCI7XHJcbmltcG9ydCBpdGVyYWJsZVRvQXJyYXkgZnJvbSBcIi4vaXRlcmFibGVUb0FycmF5LmpzXCI7XHJcbmltcG9ydCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSBmcm9tIFwiLi91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheS5qc1wiO1xyXG5pbXBvcnQgbm9uSXRlcmFibGVTcHJlYWQgZnJvbSBcIi4vbm9uSXRlcmFibGVTcHJlYWQuanNcIjtcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xyXG4gIHJldHVybiBhcnJheVdpdGhvdXRIb2xlcyhhcnIpIHx8IGl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IHVuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgbm9uSXRlcmFibGVTcHJlYWQoKTtcclxufSIsImltcG9ydCBhcnJheUxpa2VUb0FycmF5IGZyb20gXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIjtcclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KG8sIG1pbkxlbikge1xyXG4gIGlmICghbykgcmV0dXJuO1xyXG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcclxuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XHJcbiAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcclxuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcclxuICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcclxufSJdLCJuYW1lcyI6WyJBYmx5IiwidXNlRWZmZWN0IiwiYWJseSIsIlJlYWx0aW1lIiwiUHJvbWlzZSIsImF1dGhVcmwiLCJ1c2VDaGFubmVsIiwiY2hhbm5lbE5hbWUiLCJjYWxsYmFja09uTWVzc2FnZSIsImNoYW5uZWwiLCJjaGFubmVscyIsImdldCIsIm9uTW91bnQiLCJzdWJzY3JpYmUiLCJtc2ciLCJvblVuTW91bnQiLCJ1bnN1YnNjcmliZSIsInVzZUVmZmVjdEhvb2siLCJSZWFjdCIsInVzZVN0YXRlIiwic3R5bGVzIiwiQ2hhdENvbXBvbmVudCIsImlucHV0Qm94IiwibWVzc2FnZUVuZCIsIm1lc3NhZ2VUZXh0Iiwic2V0TWVzc2FnZVRleHQiLCJyZWNlaXZlZE1lc3NhZ2VzIiwic2V0TWVzc2FnZXMiLCJtZXNzYWdlVGV4dElzRW1wdHkiLCJ0cmltIiwibGVuZ3RoIiwibWVzc2FnZSIsImhpc3RvcnkiLCJzbGljZSIsInNlbmRDaGF0TWVzc2FnZSIsInB1Ymxpc2giLCJuYW1lIiwiZGF0YSIsImZvY3VzIiwiaGFuZGxlRm9ybVN1Ym1pc3Npb24iLCJldmVudCIsInByZXZlbnREZWZhdWx0IiwiaGFuZGxlS2V5UHJlc3MiLCJjaGFyQ29kZSIsIm1lc3NhZ2VzIiwibWFwIiwiaW5kZXgiLCJhdXRob3IiLCJjb25uZWN0aW9uSWQiLCJjb25uZWN0aW9uIiwiaWQiLCJtaWxsaXNlY29uZHMiLCJEYXRlIiwidGltZVN0YW1wIiwidG9EYXRlU3RyaW5nIiwic2Nyb2xsSW50b1ZpZXciLCJiZWhhdmlvdXIiLCJjaGF0SG9sZGVyIiwiY2hhdFRleHQiLCJlbGVtZW50IiwiZm9ybSIsImUiLCJ0YXJnZXQiLCJ2YWx1ZSIsInRleHRhcmVhIiwiYnV0dG9uIl0sInNvdXJjZVJvb3QiOiIifQ==